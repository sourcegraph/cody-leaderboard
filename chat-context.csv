LANGUAGEID,WORKSPACE,FIXTURE,STRATEGY,FILEPATH,REVISION,MULTILINE,COMPLETION_INTENT,AUTOCOMPLETE_KIND,RANGE_START_LINE,RANGE_START_CHARACTER,RANGE_END_LINE,RANGE_END_CHARACTER,RESULT_TIMEOUT,RESULT_ERROR,RESULT_EMPTY,RESULT_EXACT,RESULT_TYPECHECKS,RESULT_PARSES,RESULT_TEXT,RESULT_CHAR_COUNT,RESULT_NON_INSERT_PATCH,EDIT_DIFF,CHAT_REPLY,CHAT_QUESTION,CONTEXT_ITEMS,QUESTION_CLASS,FIX_AFTER_DIAGNOSTIC,FIX_BEFORE_DIAGNOSTIC,LLM_JUDGE_SCORE,LLM_JUDGE_REASONING,CONCISENESS_SCORE,HEDGES,PROVIDER_IDENTIFIER,PROVIDER_MODEL,STOP_REASON,CONTEXT_BFG_RETRIEVED_COUNT,CONTEXT_BFG_SUGGESTED_COUNT,CONTEXT_BFG_DURATION_MS,EVENT,TEST_FILENAME,TEST_EXPECTED_FILENAME,TEST_GENERATED,TEST_USED_EXPECTED_TEST_FRAMEWORK,TEST_USED_CORRECT_APPEND_OPERATION,TEST_INPUT_FILENAME,TEST_LANGUAGE,TEST_NAME,TEST_DIAGNOSTICS
yaml,chat-context,gpt-4o,chat,question_000/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, `symf` is used as a context source in several places for different Cody features:

1. **Configuration and Feature Flags:**
   - `cody.experimental.symf.path`: This setting specifies the path to the `symf` binary.
   - `cody.experimental.symfContext`: This setting enables the `symf` code search context for chat.

2. **Context Ranking:**
   - In `context-ranking.ts`, `symf` is used to precompute context ranking features:
     ```typescript
     await service.request('context-ranking/precompute-query-embedding', {
         query: query.toString(),
     })
     ```

3. **Chat Context:**
   - In `chat-view/context.ts`, `symf` is used as a context provider for chat:
     ```typescript
     interface GetEnhancedContextOptions {
         strategy: ConfigurationUseContext
         editor: VSCodeEditor
         text: PromptString
         providers: {
             localEmbeddings: LocalEmbeddingsController | null
             symf: SymfRunner | null
             remoteSearch: RemoteSearch | null
         }
     }
     ```

4. **Commands Provider:**
   - In `commands/services/provider.ts`, `symf` is used to get context files from different sources:
     ```typescript
     import { getContextFileFromShell } from '../context/shell'
     ```

5. **Local Context:**
   - In `local-context/symf.ts`, `SymfRunner` is implemented to manage `symf` indexing and querying:
     ```typescript
     export class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {
         // Implementation details for indexing and querying using symf
     }
     ```

6. **Download and Setup:**
   - In `local-context/download-symf.ts`, functions are provided to download and set up the `symf` binary:
     ```typescript
     async function downloadSymf({ symfPath, symfFilename, symfUnzippedFilename, symfURL }: { ... }): Promise<void> {
         // Implementation details for downloading symf
     }

     export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {
         // Implementation details for getting the symf path
     }
     ```

7. **Completion Provider:**
   - In `completions/completion-provider-config.ts`, `symf` is used as part of the context strategy for autocompletion:
     ```typescript
     const contextStrategy: ContextStrategy =
         config.autocompleteExperimentalGraphContext === 'bfg'
             ? 'bfg'
             : config.autocompleteExperimentalGraphContext === 'bfg-mixed'
                 ? 'bfg-mixed'
                 : config.autocompleteExperimentalGraphContext === 'local-mixed'
                     ? 'local-mixed'
                     : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'
                         ? 'jaccard-similarity'
                         : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'
                             ? 'new-jaccard-similarity'
                             : bfgMixedContextFlag
                                 ? 'bfg-mixed'
                                 : 'jaccard-similarity'
     ```

These usages indicate that `symf` is integrated into various aspects of Cody's functionality, including chat context, command execution, local context indexing, and autocompletion strategies.",Where all is symf used as a context source for different Cody features?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:0-643"",""content"":""import { execFile as _execFile, spawn } from 'node:child_process'\nimport fs, { access, rename, rm, writeFile } from 'node:fs/promises'\nimport os from 'node:os'\nimport { promisify } from 'node:util'\n\nimport { Mutex } from 'async-mutex'\nimport { mkdirp } from 'mkdirp'\nimport * as vscode from 'vscode'\n\nimport {\n    type FileURI,\n    type IndexedKeywordContextFetcher,\n    type PromptString,\n    type Result,\n    type SourcegraphCompletionsClient,\n    assertFileURI,\n    isFileURI,\n    isWindows,\n    uriBasename,\n    uriDirname,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\nimport { getSymfPath } from './download-symf'\nimport { symfExpandQuery } from './symfExpandQuery'\n\nconst execFile = promisify(_execFile)\nconst oneDayMillis = 1000 * 60 * 60 * 24\n\ninterface CorpusDiff {\n    maybeChangedFiles?: boolean\n    changedFiles?: string[]\n    millisElapsed?: number\n}\n\nfunction parseJSONToCorpusDiff(json: string): CorpusDiff {\n    const obj = JSON.parse(json)\n    if (obj.maybeChangedFiles === undefined && obj.changedFiles === undefined) {\n        throw new Error(`malformed CorpusDiff: ${json}`)\n    }\n    return obj as CorpusDiff\n}\n\ninterface IndexOptions {\n    retryIfLastAttemptFailed: boolean\n    ignoreExisting: boolean\n}\n\nexport class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n}\n\nexport interface IndexStartEvent {\n    scopeDir: FileURI\n    cancel: () => void\n    done: Promise<void>\n}\n\ninterface IndexEndEvent {\n    scopeDir: FileURI\n}\n\nclass IndexStatus implements vscode.Disposable {\n    private startEmitter = new vscode.EventEmitter<IndexStartEvent>()\n    private stopEmitter = new vscode.EventEmitter<IndexEndEvent>()\n    private inProgressDirs = new Set<string /* uri.toString() */>()\n\n    public dispose(): void {\n        this.startEmitter.dispose()\n        this.stopEmitter.dispose()\n    }\n\n    public didStart(event: IndexStartEvent): void {\n        this.inProgressDirs.add(event.scopeDir.toString())\n        this.startEmitter.fire(event)\n    }\n\n    public didEnd(event: IndexEndEvent): void {\n        this.inProgressDirs.delete(event.scopeDir.toString())\n        this.stopEmitter.fire(event)\n    }\n\n    public onDidStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.startEmitter.event(cb)\n    }\n\n    public onDidEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.stopEmitter.event(cb)\n    }\n\n    public isInProgress(scopeDir: FileURI): boolean {\n        return this.inProgressDirs.has(scopeDir.toString())\n    }\n}\n\nasync function fileExists(file: vscode.Uri): Promise<boolean> {\n    if (!isFileURI(file)) {\n        throw new Error('only file URIs are supported')\n    }\n    try {\n        await access(file.fsPath, fs.constants.F_OK)\n        return true\n    } catch {\n        return false\n    }\n}\n\nfunction parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n}\n\n/**\n * A simple read-write lock.\n *\n * Note: it is possible for an overlapping succession of readers to starve out\n * any writers that are waiting for the mutex to be released. In practice, this\n * is not an issue, because we don't expect the user to issue neverending\n * while trying to update the index.\n */\nclass RWLock {\n    /**\n     * Invariants:\n     * - if readers > 0, then mu is locked\n     * - if readers === 0 and mu is locked, then a writer is holding the lock\n     */\n    private readers = 0\n    private mu = new Mutex()\n\n    public async withRead<T>(fn: () => Promise<T>): Promise<T> {\n        while (this.readers === 0) {\n            if (this.mu.isLocked()) {\n                // If mu is locked at this point, it must be held by the writer.\n                // We spin in this case, rather than try to acquire the lock,\n                // because multiple readers blocked on acquiring the lock will\n                // execute serially when the writer releases the lock (whereas\n                // we want all reads to be concurrent).\n                await new Promise(resolve => setTimeout(resolve, 100))\n                continue\n            }\n            // No readers or writers: acquire lock for readers\n            await this.mu.acquire()\n            break\n        }\n        this.readers++\n        try {\n            return await fn()\n        } finally {\n            this.readers--\n            if (this.readers === 0) {\n                this.mu.release()\n            }\n        }\n    }\n\n    public async withWrite<T>(fn: () => Promise<T>): Promise<T> {\n        return this.mu.runExclusive(fn)\n    }\n}\n\nfunction toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:0-27"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type AuthStatus,\n    type ChatClient,\n    type Configuration,\n    type ConfigurationWithAccessToken,\n    type FeatureFlagProvider,\n    type Guardrails,\n    ModelProvider,\n    ModelUsage,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport type { MessageProviderOptions } from '../MessageProvider'\nimport type { ExtensionMessage } from '../protocol'\n\nimport type { EnterpriseContextFactory } from '../../context/enterprise-context-factory'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport { chatHistory } from './ChatHistoryManager'\nimport { CodyChatPanelViewType } from './ChatManager'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77"",""content"":""        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type ConfigurationUseContext,\n    type ContextItem,\n    ContextItemSource,\n    MAX_BYTES_PER_FILE,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    type PromptString,\n    type Result,\n    isFileURI,\n    truncateTextNearestLine,\n    uriBasename,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { RemoteSearch } from '../../context/remote-search'\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug, logError } from '../../log'\n\ninterface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/context/chatContext.ts:70-75"",""content"":""export async function isURLContextFeatureFlagEnabled(): Promise<boolean> {\n    return (\n        vscode.workspace.getConfiguration('cody').get<boolean>('experimental.urlContext') === true ||\n        (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.URLContext))\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/provider.ts:0-22"",""content"":""import { type CodyCommand, type ContextItem, featureFlagProvider } from '@sourcegraph/cody-shared'\n\nimport * as vscode from 'vscode'\nimport { CodyCommandMenuItems } from '..'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getContextFileFromShell } from '../context/shell'\nimport { showCommandMenu } from '../menus'\nimport type { CodyCommandArgs } from '../types'\nimport { getDefaultCommandsMap } from '../utils/get-commands'\nimport { CustomCommandsManager, openCustomCommandDocsLink } from './custom-commands'\n\nconst vscodeDefaultCommands = getDefaultCommandsMap(CodyCommandMenuItems as CodyCommand[])\n\n/**\n * Provides management and interaction capabilities for both default and custom Cody commands.\n *\n * It is responsible for initializing, grouping, and refreshing command sets,\n * as well as handling command menus and execution.\n */\nexport class CommandsProvider implements vscode.Disposable {\n    private disposables: vscode.Disposable[] = []\n    protected readonly defaultCommands = vscodeDefaultCommands\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:98-111"",""content"":""    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/types.ts:0-46"",""content"":""import type { CodyCommand, ContextItem, EventSource, PromptString } from '@sourcegraph/cody-shared'\n\nimport type { Range, Uri } from 'vscode'\nimport type { ExecuteEditArguments } from '../edit/execute'\n\n/**\n * The name of the file for configuring Custom Commands.\n */\nexport enum ConfigFiles {\n    // Cody Commands config file location in VS CODE\n    // TODO: Migrate to use the one in /.cody\n    VSCODE = '.vscode/cody.json',\n    // Cody Commands config file location for all clients\n    COMMAND = '.cody/commands.json',\n}\n\n/**\n * Creates a CodyCommandArgs object with default values.\n * Generates a random requestID if one is not provided.\n * Merges any provided args with the defaults.\n */\nexport interface CodyCommandsFile {\n    // A set of reusable commands where instructions (prompts) and context can be configured.\n    commands: Map<string, CodyCommand>\n}\n\nexport interface CodyCommandArgs extends ExecuteEditArguments {\n    // for tracing the life of the request\n    requestID: string\n    // where the command was triggered from\n    source?: EventSource\n    // runs the command in chat mode, even if it's an edit command\n    runInChatMode?: boolean\n    // current context to add on top of the command context\n    userContextFiles?: ContextItem[]\n    additionalInstruction?: PromptString\n\n    /**\n     * Editor Context\n     */\n    // The URI of the file in the editor\n    uri?: Uri\n    // The range of the selection in the editor\n    range?: Range\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1085-1094"",""content"":""- Increased autocomplete debounce time feature flag support. [pull/733](https://github.com/sourcegraph/cody/pull/733)\n- Show an update notice after extension updates. [pull/746](https://github.com/sourcegraph/cody/pull/746)\n- Experimental user setting `cody.experimental.localSymbols` to enable inclusion of symbol definitions in the LLM context window. [pull/692](https://github.com/sourcegraph/cody/pull/692)\n- Experimental command `/symf`, which uses a local keyword index to perform searches for symbols. Requires setting `cody.experimental.symf.path` and `cody.experimental.symf.anthropicKey`. [pull/728](https://github.com/sourcegraph/cody/pull/728).\n\n### Fixed\n\n- Inline Chat: Fix issue where state was not being set correctly, causing Cody Commands to use the selection range from the last created Inline Chat instead of the current selection. [pull/602](https://github.com/sourcegraph/cody/pull/602)\n- Cody Commands: Commands that use the current file as context now correctly generate context message for the current file instead of using codebase context generated from current selection. [pull/683](https://github.com/sourcegraph/cody/pull/683)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/agentContextSorting.ts:0-21"",""content"":""import { type ContextItem, ContextItemSource } from '@sourcegraph/cody-shared'\n\nconst isAgentTesting = process.env.CODY_SHIM_TESTING === 'true'\n\n/**\n * Sorts the provided `ContextItem` array in a deterministic order for stable tests.\n * This function is only used when the `CODY_SHIM_TESTING` environment variable is\n * set to `'true'`, which indicates that the agent is running in a testing environment.\n *\n * NOTE: Agent tests require deterministic ordering of context files for consistent results across different file systems\n * These helper functions should be called before we pass context items/files to a prompt builder.\n * This is necessary to get the tests passing in CI because we need the prompts to be stable for the HTTP replay mode to succeed.\n *\n * @param files - The array of `ContextItem` objects to sort.\n */\nexport function sortContextItems(files: ContextItem[]): void {\n    if (!isAgentTesting) {\n        return\n    }\n    // Sort results for deterministic ordering for stable tests. Ideally, we\n    // could sort by some numerical score from symf based on how relevant\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:260-277"",""content"":""    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_001/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, BFG (Blazingly Fast Graph) creates indexes for:

1. **Git Repositories**: 
   - The `indexGitRepositories` method in `BfgRetriever` class indicates that BFG indexes Git repositories. It listens for changes in Git repositories and updates the index accordingly.

2. **Workspace Folders**:
   - The `indexWorkspace` method in `BfgRetriever` class indicates that BFG indexes workspace folders. It checks if the workspace folders are already indexed and, if not, indexes them.

3. **Inferred Git Repositories**:
   - The `indexInferredGitRepositories` method in `BfgRetriever` class indicates that BFG can infer and index Git repositories that are relevant but may not be ""open"" by the Git extension.

4. **Local Context**:
   - The `unsafeUpsertIndex` method in `symf.ts` suggests that BFG creates indexes for local context directories. It handles the creation and updating of indexes for specific directories within the local file system.

These indexes help BFG provide context for identifiers and positions within the code, enhancing features like autocomplete and code navigation.",what different indexes are created by BFG?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:18-18"",""content"":""let serializeBfgDownload: Promise<string | null> = Promise.resolve(null)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:348-374"",""content"":""\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:111-119"",""content"":""async function unzipBfg(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1337-1345"",""content"":""- Refactored authentication process. [pull/53434](https://github.com/sourcegraph/sourcegraph/pull/53434)\n- New sign-in and sign-out flow. [pull/53434](https://github.com/sourcegraph/sourcegraph/pull/53434)\n- Analytical logs are now displayed in the Output view. [pull/53870](https://github.com/sourcegraph/sourcegraph/pull/53870)\n- Inline Chat: Renamed Inline Assist to Inline Chat. [pull/53725](https://github.com/sourcegraph/sourcegraph/pull/53725) [pull/54315](https://github.com/sourcegraph/sourcegraph/pull/54315)\n- Chat: Link to the \""Getting Started\"" guide directly from the first chat message instead of the external documentation website. [pull/54175](https://github.com/sourcegraph/sourcegraph/pull/54175)\n- Codebase status icons. [pull/54262](https://github.com/sourcegraph/sourcegraph/pull/54262)\n- Changed the keyboard shortcut for the file touch recipe to `ctrl+alt+/` to avoid conflicts. [pull/54275](https://github.com/sourcegraph/sourcegraph/pull/54275)\n- Inline Chat: Do not change current focus when Inline Fixup is done. [pull/53980](https://github.com/sourcegraph/sourcegraph/pull/53980)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:20-109"",""content"":""export async function downloadBfg(context: vscode.ExtensionContext): Promise<string | null> {\n    // First, wait for any in-progress downloads.\n    await serializeBfgDownload\n\n    // Now we are the in-progress download.\n    serializeBfgDownload = (async () => {\n        const config = vscode.workspace.getConfiguration()\n        const userBfgPath = config.get<string>('cody.experimental.cody-engine.path')\n        if (userBfgPath) {\n            const bfgStat = await fspromises.stat(userBfgPath)\n            if (!bfgStat.isFile()) {\n                throw new Error(`not a file: ${userBfgPath}`)\n            }\n            logDebug('CodyEngine', `using user-provided path: ${userBfgPath} ${bfgStat.isFile()}`)\n            return userBfgPath\n        }\n\n        const osArch = getOSArch()\n        if (!osArch) {\n            logDebug('CodyEngine', 'getOSArch returned nothing')\n            return null\n        }\n        const { platform, arch } = osArch\n\n        if (!arch) {\n            logDebug('CodyEngine', 'getOSArch returned undefined arch')\n            return null\n        }\n\n        if (!platform) {\n            logDebug('CodyEngine', 'getOSArch returned undefined platform')\n            return null\n        }\n        // Rename returned architecture to match RFC 795 conventions\n        // https://docs.google.com/document/d/11cw-7dAp93JmasITNSNCtx31xrQsNB1L2OoxVE6zrTc/edit\n        const archRenames = new Map([\n            ['aarch64', 'arm64'],\n            ['x86_64', 'x64'],\n        ])\n        let rfc795Arch = archRenames.get(arch ?? '') ?? arch\n        if (rfc795Arch === 'arm64' && platform === 'win') {\n            // On Windows Arm PCs, we rely on emulation and use the x64 binary.\n            // See https://learn.microsoft.com/en-us/windows/arm/apps-on-arm-x86-emulation\n            rfc795Arch = 'x64'\n        }\n\n        const bfgContainingDir = path.join(context.globalStorageUri.fsPath, 'cody-engine')\n        const bfgVersion = config.get<string>('cody.experimental.cody-engine.version', defaultBfgVersion)\n        await fspromises.mkdir(bfgContainingDir, { recursive: true })\n        const bfgFilename = `cody-engine-${bfgVersion}-${platform}-${rfc795Arch}`\n        const bfgPath = path.join(bfgContainingDir, bfgFilename)\n        const isAlreadyDownloaded = await fileExists(bfgPath)\n        if (isAlreadyDownloaded) {\n            logDebug('CodyEngine', `using downloaded path \""${bfgPath}\""`)\n            return bfgPath\n        }\n\n        const bfgURL = `https://github.com/sourcegraph/bfg/releases/download/v${bfgVersion}/bfg-${platform}-${rfc795Arch}.zip`\n        try {\n            await vscode.window.withProgress(\n                {\n                    location: vscode.ProgressLocation.Window,\n                    title: 'Downloading cody-engine',\n                    cancellable: false,\n                },\n                async progress => {\n                    progress.report({ message: 'Downloading cody-engine' })\n                    const bfgZip = path.join(bfgContainingDir, 'bfg.zip')\n                    await downloadBfgBinary(bfgURL, bfgZip)\n                    await unzipBfg(bfgZip, bfgContainingDir)\n                    logDebug('CodyEngine', bfgPath)\n                    // The zip file contains a binary named `bfg` or `bfg.exe`. We unzip it with that name first and then rename into\n                    // a version-specific binary so that we can delete old versions of bfg.\n                    const unzipPath = platform === 'windows' ? 'bfg.exe' : 'bfg'\n                    await fspromises.rename(path.join(bfgContainingDir, unzipPath), bfgPath)\n                    await fspromises.chmod(bfgPath, 0o755)\n                    await fspromises.rm(bfgZip)\n                    logDebug('CodyEngine', `downloaded cody-engine to ${bfgPath}`)\n                }\n            )\n            void removeOldBfgBinaries(bfgContainingDir, bfgFilename)\n        } catch (error) {\n            captureException(error)\n            void vscode.window.showErrorMessage(`Failed to download bfg from URL ${bfgURL}: ${error}`)\n            return null\n        }\n        return bfgPath\n    })()\n    return serializeBfgDownload\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:130-167"",""content"":""} from './inferenceClient/misc'\nexport type {\n    ContextResult,\n    FilenameContextFetcher,\n    IndexedKeywordContextFetcher,\n    LocalEmbeddingsFetcher,\n    IRemoteSearch,\n    Result,\n    SearchPanelFile,\n    SearchPanelSnippet,\n} from './local-context'\nexport { logDebug, logError, setLogger } from './logger'\nexport {\n    createOllamaClient,\n    ollamaChatClient,\n    type OllamaGenerateParams,\n    OLLAMA_DEFAULT_URL,\n} from './llm-providers/ollama'\nexport {\n    MAX_BYTES_PER_FILE,\n    MAX_CURRENT_FILE_TOKENS,\n    ANSWER_TOKENS,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    SURROUNDING_LINES,\n} from './prompt/constants'\nexport { PromptMixin, newPromptMixin } from './prompt/prompt-mixin'\nexport * from './prompt/templates'\nexport {\n    truncateText,\n    truncateTextNearestLine,\n    truncatePromptStringStart,\n    truncatePromptString,\n} from './prompt/truncation'\nexport type { Message } from './sourcegraph-api'\nexport { SourcegraphBrowserCompletionsClient } from './sourcegraph-api/completions/browserClient'\nexport { SourcegraphCompletionsClient } from './sourcegraph-api/completions/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/spawn-bfg.ts:9-44"",""content"":""export async function spawnBfg(\n    context: vscode.ExtensionContext,\n    reject: (reason?: any) => void\n): Promise<MessageHandler> {\n    const bfg = new MessageHandler()\n    const codyrpc = await downloadBfg(context)\n    if (!codyrpc) {\n        throw new Error(\n            'Failed to download BFG binary. To fix this problem, set the \""cody.experimental.cody-engine.path\"" configuration to the path of your BFG binary'\n        )\n    }\n    const isVerboseDebug = vscode.workspace.getConfiguration().get<boolean>('cody.debug.verbose', false)\n    const child = child_process.spawn(codyrpc, {\n        stdio: 'pipe',\n        env: {\n            VERBOSE_DEBUG: `${isVerboseDebug}`,\n            RUST_BACKTRACE: isVerboseDebug ? '1' : '0',\n            // See bfg issue 138\n            RUST_LIB_BACKTRACE: '0',\n        },\n    })\n    child.stderr.on('data', chunk => {\n        logDebug('CodyEngine', 'spawnBfg:stderr', { verbose: chunk.toString() })\n    })\n    child.on('disconnect', () => reject())\n    child.on('close', () => reject())\n    child.on('error', error => reject(error))\n    child.on('exit', code => {\n        bfg.exit()\n        reject(code)\n    })\n    child.stderr.pipe(process.stderr)\n    child.stdout.pipe(bfg.messageDecoder)\n    bfg.messageEncoder.pipe(child.stdin)\n    return bfg\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:246-279"",""content"":""- Chat: Add tracing. [pull/3168](https://github.com/sourcegraph/cody/pull/3168)\n- Command: Leading slashes are removed from command names in the command menu. [pull/3061](https://github.com/sourcegraph/cody/pull/3061)\n\n## [1.4.4]\n\n### Added\n\n### Fixed\n\n- The signin menu now displays a warning for invalid URL input. [pull/3156](https://github.com/sourcegraph/cody/pull/3156)\n\n### Changed\n\n## [1.4.3]\n\n### Added\n\n- Autocomplete: Updated the BFG binary version. [pull/3130](https://github.com/sourcegraph/cody/pull/3130)\n\n### Changed\n\n## [1.4.2]\n\n### Fixed\n\n- Chat: Fixed an issue where Cody would sometimes exceed the context window limit for shorter context OpenAI models. [pull/3121](https://github.com/sourcegraph/cody/pull/3121)\n\n## [1.4.1]\n\n### Added\n\n- Chat: Support `@-mentioned` in mid sentences. [pull/3043](https://github.com/sourcegraph/cody/pull/3043)\n- Chat: Support `@-mentioned` in editing mode. [pull/3091](https://github.com/sourcegraph/cody/pull/3091)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/highlight.css:308-368"",""content"":""\n.hl-typed-IdentifierFunction {\n\tcolor: var(--hl-dark-yellow);\n}\n\n.hl-typed-IdentifierType {\n\tcolor: var(--hl-gray-1);\n}\n\n.hl-typed-IdentifierBuiltin {\n\tcolor: var(--hl-purple);\n}\n\n.hl-typed-IdentifierNull {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-BooleanLiteral {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-IdentifierConstant {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-IdentifierMutableGlobal {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierParameter {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierLocal {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierShadowed {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierModule {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierFunctionDefinition {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierMacro {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierMacroDefinition {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierBuiltinType {\n\tcolor: var(--hl-orange);\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:516-537"",""content"":""\n## [1.0.0]\n\n### Added\n\n- Adds support for Mixtral by Mistral in the LLM dropdown list. [issues/2307](https://github.com/sourcegraph/cody/issues/2307)\n\n### Fixed\n\n- Context: The \""Continue Indexing\"" button works on Windows. [issues/2328](https://github.com/sourcegraph/cody/issues/2328)\n- Context: The \""Embeddings Incomplete\"" status bar item shows an accurate percent completion. Previously we showed the percent *in*complete, but labeled it percent complete. We no longer display a spurious \""Cody Embeddings Index Complete\"" toast if indexing fails a second time. [pull/2368](https://github.com/sourcegraph/cody/pull/2368)\n\n### Changed\n\n- Updates the code smell icon so it does not stand out in some VS Code themes.\n\n## [0.18.6]\n\n### Added\n\n- Context: Incomplete embeddings indexing status can seen in the status bar. On macOS and Linux, indexing can be resumed by clicking there. However Windows users will still see an OS error 5 (access denied) when retrying indexing. [pull/2265](https://github.com/sourcegraph/cody/pull/2265)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/bfg-protocol.ts:0-38"",""content"":""/**\n * This file declares the protocol for communicating between Cody and BFG (Blazingly Fast Graph), a Rust implementation\n * of the \""Graph Context\"" feature flag.\n */\nimport type { Position } from './agent-protocol'\n\ninterface BFGFileContextSnippet {\n    fileName: string\n    content: string\n}\n\ninterface BFGSymbolContextSnippet extends BFGFileContextSnippet {\n    symbol: string\n}\n\nexport type Requests = {\n    'bfg/initialize': [{ clientName: string }, { serverVersion: string }]\n    'bfg/contextAtPosition': [\n        { uri: string; content: string; position: Position; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[]; files?: BFGFileContextSnippet[] },\n    ]\n    'bfg/contextForIdentifiers': [\n        { uri: string; identifiers: string[]; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[] },\n    ]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/gitRevision/didChange': [{ gitDirectoryUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/workspace/didChange': [{ workspaceUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/shutdown': [null, void]\n\n    'embeddings/hello': [null, string]\n}\n\nexport type Notifications = {\n    'bfg/placeholderNotification': [null]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:203-228"",""content"":""    event,\n} from './sourcegraph-api/graphql/client'\nexport { GraphQLTelemetryExporter } from './sourcegraph-api/telemetry/GraphQLTelemetryExporter'\nexport { NOOP_TELEMETRY_SERVICE } from './telemetry'\nexport type { TelemetryEventProperties, TelemetryService } from './telemetry'\nexport { type BillingCategory, type BillingProduct } from './telemetry-v2'\nexport {\n    MockServerTelemetryRecorderProvider,\n    NoOpTelemetryRecorderProvider,\n    TelemetryRecorderProvider,\n} from './telemetry-v2/TelemetryRecorderProvider'\nexport type { TelemetryRecorder } from './telemetry-v2/TelemetryRecorderProvider'\nexport { EventLogger } from './telemetry/EventLogger'\nexport type { ExtensionDetails } from './telemetry/EventLogger'\nexport { testFileUri } from './test/path-helpers'\nexport {\n    addTraceparent,\n    getActiveTraceAndSpanId,\n    wrapInActiveSpan,\n    recordErrorToSpan,\n    tracer,\n    logResponseHeadersToSpan,\n} from './tracing'\nexport { convertGitCloneURLToCodebaseName, isError } from './utils'\nexport type { CurrentUserCodySubscription } from './sourcegraph-api/graphql/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts:0-303"",""content"":""import * as vscode from 'vscode'\n\nimport { spawnBfg } from '../../../../graph/bfg/spawn-bfg'\nimport type { MessageHandler } from '../../../../jsonrpc/jsonrpc'\nimport { logDebug } from '../../../../log'\nimport type { Repository } from '../../../../repository/builtinGitExtension'\nimport { gitAPI } from '../../../../repository/git-extension-api'\nimport { captureException } from '../../../../services/sentry/sentry'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\n\nimport type { AutocompleteContextSnippet } from '@sourcegraph/cody-shared'\nimport {\n    getLastNGraphContextIdentifiersFromDocument,\n    getLastNGraphContextIdentifiersFromString,\n} from '../graph/identifiers'\nimport { type SimpleRepository, inferGitRepository } from './simple-git'\n\nexport class BfgRetriever implements ContextRetriever {\n    public identifier = 'bfg'\n    private loadedBFG: Promise<MessageHandler>\n    private bfgIndexingPromise = Promise.resolve<void>(undefined)\n    private awaitIndexing: boolean\n    private didFailLoading = false\n    // Keys are repository URIs, values are revisions (commit hashes).\n    private indexedRepositoryRevisions = new Map<string, string>()\n    constructor(private context: vscode.ExtensionContext) {\n        this.awaitIndexing = vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.await-indexing', false)\n        this.loadedBFG = this.loadBFG()\n\n        this.loadedBFG.then(\n            () => {},\n            error => {\n                captureException(error)\n                this.didFailLoading = true\n                logDebug('CodyEngine', 'failed to initialize', error)\n            }\n        )\n\n        this.bfgIndexingPromise = this.indexWorkspace()\n    }\n\n    private async indexWorkspace(): Promise<void> {\n        await this.indexGitRepositories()\n        await this.indexRemainingWorkspaceFolders()\n    }\n    private isWorkspaceIndexed(folder: vscode.Uri): boolean {\n        const uri = folder.toString()\n        logDebug('CodyEngine', 'Checking if folder is indexed', uri)\n        for (const key of this.indexedRepositoryRevisions.keys()) {\n            if (uri.startsWith(key)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private async indexRemainingWorkspaceFolders(): Promise<void> {\n        logDebug(\n            'CodyEngine',\n            'workspaceFolders',\n            vscode.workspace.workspaceFolders?.map(folder => folder.uri.toString()) ?? []\n        )\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.isWorkspaceIndexed(folder.uri)) {\n                continue\n            }\n            await this.indexEntry({ workspace: folder.uri })\n        }\n    }\n    private async indexGitRepositories(): Promise<void> {\n        const git = gitAPI()\n        if (!git) {\n            return\n        }\n        for (const repository of git.repositories) {\n            await this.didChangeGitExtensionRepository(repository)\n        }\n        this.context.subscriptions.push(\n            git.onDidOpenRepository(repository => this.didChangeGitExtensionRepository(repository))\n        )\n        this.context.subscriptions.push(\n            vscode.workspace.onDidChangeWorkspaceFolders(() => this.indexInferredGitRepositories())\n        )\n        // TODO: handle closed repositories\n\n        await this.indexInferredGitRepositories()\n    }\n\n    private shouldInferGitRepositories(): boolean {\n        // Some users may not want to allow Cody to index code outside the VS\n        // Code workspace folder so we support an escape hatch to disable this\n        // functionality. This setting is hidden because all the other\n        // BFG-related settings are hidden.\n        return vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.index-parent-git-folder', false)\n    }\n\n    // Infers what git repositories that are relevant but may not be \""open\"" by\n    // the git extension.  For example, by default, the git extension doesn't\n    // open git repositories when the workspace root is a subfolder. There's a\n    // setting to automatically open parent git repositories but the setting is\n    // disabled by default.\n    private async indexInferredGitRepositories(): Promise<void> {\n        if (!this.shouldInferGitRepositories()) {\n            return\n        }\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.indexedRepositoryRevisions.has(folder.uri.toString())) {\n                continue\n            }\n            const repo = await inferGitRepository(folder.uri)\n            if (repo) {\n                await this.didChangeSimpleRepository(repo)\n            }\n        }\n    }\n\n    private async didChangeGitExtensionRepository(repository: Repository): Promise<void> {\n        const commit = repository?.state?.HEAD?.commit\n        if (!commit) {\n            return\n        }\n        await this.didChangeSimpleRepository({ uri: repository.rootUri, commit })\n    }\n\n    private async didChangeSimpleRepository(repository: SimpleRepository): Promise<void> {\n        const uri = repository.uri.toString()\n        if (repository.commit !== this.indexedRepositoryRevisions.get(uri)) {\n            this.indexedRepositoryRevisions.set(uri, repository.commit ?? '')\n            await this.indexEntry({ repository })\n        }\n    }\n\n    private async indexEntry(params: {\n        repository?: SimpleRepository\n        workspace?: vscode.Uri\n    }): Promise<void> {\n        const { repository, workspace } = params\n        if (!repository && !workspace) {\n            return\n        }\n        const bfg = await this.loadedBFG\n        const indexingStartTime = Date.now()\n        // TODO: include commit?\n        try {\n            if (repository) {\n                await bfg.request('bfg/gitRevision/didChange', {\n                    gitDirectoryUri: repository.uri.toString(),\n                })\n            }\n            if (workspace) {\n                await bfg.request('bfg/workspace/didChange', { workspaceUri: workspace.toString() })\n            }\n            const elapsed = Date.now() - indexingStartTime\n            const label = repository\n                ? `${repository.uri.fsPath}:${repository.commit}`\n                : workspace\n                  ? workspace.fsPath\n                  : ''\n            if (label) {\n                logDebug('CodyEngine', `gitRevision/didChange ${label} indexing time ${elapsed}ms`)\n            }\n        } catch (error) {\n            logDebug('CodyEngine', `indexing error ${error}`)\n        }\n    }\n\n    public async retrieve({\n        document,\n        position,\n        docContext,\n        hints,\n        lastCandidate,\n    }: ContextRetrieverOptions): Promise<AutocompleteContextSnippet[]> {\n        try {\n            if (this.didFailLoading) {\n                return []\n            }\n            const bfg = await this.loadedBFG\n            if (!bfg.isAlive()) {\n                logDebug('CodyEngine', 'not alive')\n                return []\n            }\n\n            if (this.awaitIndexing) {\n                await this.bfgIndexingPromise\n            }\n\n            const lastCandidateCurrentLine =\n                (lastCandidate?.lastTriggerDocContext.currentLinePrefix || '') +\n                lastCandidate?.result.items[0].insertText\n\n            const bfgRequestStart = performance.now()\n            const inputIdentifiers = Array.from(\n                new Set([\n                    // Get last 10 identifiers from the last candidate insert text\n                    // in hopes that LLM partially guessed the right completion.\n                    ...getLastNGraphContextIdentifiersFromString({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                        source: lastCandidateCurrentLine,\n                    }),\n                    // Get last 10 identifiers from the current document prefix.\n                    ...getLastNGraphContextIdentifiersFromDocument({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                    }),\n                ])\n            )\n\n            const response = await bfg.request('bfg/contextForIdentifiers', {\n                uri: document.uri.toString(),\n                identifiers: inputIdentifiers,\n                maxSnippets: 20,\n                maxDepth: 4,\n            })\n\n            // Just in case, handle non-object results\n            if (typeof response !== 'object') {\n                return []\n            }\n\n            // Convert BFG snippets to match the format expected on the client.\n            const symbols = (response.symbols || []).map(contextSnippet => ({\n                ...contextSnippet,\n                uri: vscode.Uri.from({ scheme: 'file', path: contextSnippet.fileName }),\n            })) satisfies Omit<AutocompleteContextSnippet, 'startLine' | 'endLine'>[]\n\n            logDebug('CodyEngine', 'bfg/contextForIdentifiers', {\n                verbose: {\n                    inputIdentifiers,\n                    duration: `${performance.now() - bfgRequestStart}ms`,\n                    symbols: symbols.map(s => `${s.symbol} ${s.content}`),\n                },\n            })\n\n            // TODO: add `startLine` and `endLine` to `responses` or explicitly add\n            // another context snippet type to the client.\n            // @ts-ignore\n            return symbols\n        } catch (error) {\n            logDebug('CodyEngine:error', `${error}`)\n            return []\n        }\n    }\n\n    public isSupportedForLanguageId(languageId: string): boolean {\n        switch (languageId) {\n            case 'typescript':\n            case 'typescriptreact':\n            case 'javascript':\n            case 'javascriptreact':\n            case 'java':\n            case 'go':\n            case 'dart':\n            case 'python':\n            case 'zig':\n                return true\n            default:\n                return false\n        }\n    }\n\n    public dispose(): void {\n        if (this.didFailLoading) {\n            return\n        }\n        this.loadedBFG.then(\n            bfg => bfg.request('bfg/shutdown', null),\n            () => {}\n        )\n    }\n\n    // We lazily load BFG to allow the Cody extension to finish activation as\n    // quickly as possible.\n    private loadBFG(): Promise<MessageHandler> {\n        // This is implemented as a custom promise instead of async/await so that we can reject\n        // the promise in the 'exit' handler if we fail to start the bfg process for some reason.\n        return new Promise<MessageHandler>((resolve, reject) => {\n            logDebug('CodyEngine', 'loading bfg')\n            this.doLoadBFG(reject).then(\n                bfg => resolve(bfg),\n                error => {\n                    captureException(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    private async doLoadBFG(reject: (reason?: any) => void): Promise<MessageHandler> {\n        const bfg = await spawnBfg(this.context, reject)\n        await bfg.request('bfg/initialize', { clientName: 'vscode' })\n        return bfg\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/mocks.ts:609-653"",""content"":""            'java',\n            'javascriptreact',\n            'javascript',\n            'jsx-tags',\n            'jsonl',\n            'snippets',\n            'julia',\n            'juliamarkdown',\n            'tex',\n            'latex',\n            'bibtex',\n            'cpp_embedded_latex',\n            'markdown_latex_combined',\n            'less',\n            'lua',\n            'makefile',\n            'markdown',\n            'markdown-math',\n            'wat',\n            'objective-c',\n            'objective-cpp',\n            'perl',\n            'perl6',\n            'php',\n            'powershell',\n            'jade',\n            'python',\n            'r',\n            'razor',\n            'restructuredtext',\n            'ruby',\n            'rust',\n            'scss',\n            'search-result',\n            'shaderlab',\n            'shellscript',\n            'sql',\n            'swift',\n            'typescript',\n            'typescriptreact',\n            'vb',\n            'xml',\n            'xsl',\n            'dockercompose',\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2855-2869"",""content"":""            super_type?: ReturnType<typeof SuperType.prototype.toObject>\n            constant_type?: ReturnType<typeof ConstantType.prototype.toObject>\n            intersection_type?: ReturnType<typeof IntersectionType.prototype.toObject>\n            union_type?: ReturnType<typeof UnionType.prototype.toObject>\n            with_type?: ReturnType<typeof WithType.prototype.toObject>\n            structural_type?: ReturnType<typeof StructuralType.prototype.toObject>\n            annotated_type?: ReturnType<typeof AnnotatedType.prototype.toObject>\n            existential_type?: ReturnType<typeof ExistentialType.prototype.toObject>\n            universal_type?: ReturnType<typeof UniversalType.prototype.toObject>\n            by_name_type?: ReturnType<typeof ByNameType.prototype.toObject>\n            repeated_type?: ReturnType<typeof RepeatedType.prototype.toObject>\n            match_type?: ReturnType<typeof MatchType.prototype.toObject>\n            lambda_type?: ReturnType<typeof LambdaType.prototype.toObject>\n        }): Type {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1321-1329"",""content"":""    \""ovsx\"": \""^0.8.2\"",\n    \""pako\"": \""^2.1.0\"",\n    \""path-browserify\"": \""^1.0.1\"",\n    \""playwright\"": \""1.39.0\"",\n    \""progress\"": \""^2.0.3\"",\n    \""yaml\"": \""^2.3.4\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/bfg/BfgRetriever.test.ts:27-27"",""content"":""const shouldCreateGitDir = !fs.existsSync(gitdir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:76-103"",""content"":""\n            // The bfg mixed strategy mixes local and graph based retrievers\n            case 'bfg-mixed':\n                if (this.graphRetriever?.isSupportedForLanguageId(document.languageId)) {\n                    retrievers.push(this.graphRetriever)\n                }\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                break\n\n            // The local mixed strategy combines two local retrievers\n            case 'local-mixed':\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                if (this.graphRetriever) {\n                    retrievers.push(this.graphRetriever)\n                }\n                break\n\n            // The jaccard similarity strategies only uses the local retriever\n            case 'jaccard-similarity': {\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                break\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/package.json:64-78"",""content"":""    \""@types/diff\"": \""^5.0.9\"",\n    \""@types/google-protobuf\"": \""3.15.12\"",\n    \""@types/minimatch\"": \""^5.1.2\"",\n    \""@types/uuid\"": \""^9.0.2\"",\n    \""@types/vscode\"": \""^1.80.0\"",\n    \""@types/ws\"": \""^8.5.10\"",\n    \""diff\"": \""^5.2.0\"",\n    \""esbuild\"": \""^0.18.19\"",\n    \""google-protobuf\"": \""^3.21.2\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""pkg\"": \""^5.8.1\"",\n    \""rimraf\"": \""^5.0.5\""\n  }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:322-348"",""content"":""        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n            return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_002/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"In Cody, the context ranking logic is implemented primarily through the `ContextRankingController` class. This class provides several methods to rank and retrieve context items based on different criteria. Here are the different context ranking logics implemented:

1. **Feature Computation**:
   - The `computeFeatures` method is used to compute features for a given repository directory. This is done at the start of the service to prepare the context ranking.

2. **Context Item Ranking**:
   - The `rankContextItems` method ranks context items based on a query. It sends a request to the `context-ranking/rank-items` endpoint with the repository path, context items, and query. The response contains predictions that are used to reorder the context items.

3. **Embedding-Based Context Retrieval**:
   - The `retrieveEmbeddingBasedContext` method retrieves context items based on embeddings. It sends a request to the `context-ranking/context-retriever-embedding` endpoint with the repository path, query, model name, and number of results. The response contains embedding results that are mapped to context items.

4. **Precompute Query Embedding**:
   - The `precomputeContextRankingFeatures` method precomputes context ranking features for a given query. It sends a request to the `context-ranking/precompute-query-embedding` endpoint with the query.

5. **Model-Specific Embeddings Search**:
   - The `searchModelSpecificEmbeddings` method searches for context items based on model-specific embeddings. It uses a predefined model name (`sentence-transformers/multi-qa-mpnet-base-dot-v1`) and retrieves embedding-based context items.

Additionally, the `ContextRankingController` class handles logging of rank items through the `rank-items-logger-payload` notification, which appends logs to a file.

These methods collectively implement the different context ranking logics in Cody, allowing it to rank and retrieve context items based on various criteria and models.",What different context ranking logics are implemented in Cody?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/keyboard.md:0-19"",""content"":""## Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can also update these bindings in the `Keyboard Shortcuts Editor`.\n\n### Keyboard Shortcuts Editor\n\nThe `Keyboard Shortcuts Editor` allows you to easily update the default bindings (keyboard shortcuts). This is particularly useful if the default key bindings conflict with your current or preferred key bindings. By accessing the `Keyboard Shortcuts Editor`, you can search for specific commands, reassign keybindings, and customize your keyboard shortcuts to suit your workflow.\n\n### Getting Started\n\nTo get started: \n1. Click on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**` to open the `Keyboard Shortcuts Editor`.\n2. In the `Keyboard Shortcuts Editor`, you can search for a specific command by typing in the search bar.\n3. Once you have found the command you want to reassign keybindings for, click on it to select it.\n4. Follow the instruction on screen to assign a new keybinding.\n\n**✨ Pro-tips for assigning keyboard shortcuts for Cody**\n<br>• You can assign key bindings (keyboard shortcuts) to individual custom commands.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:985-1005"",""content"":""\n## [0.12.1]\n\n### Added\n\n### Fixed\n\n- Fixes an issue that caused the `cody-autocomplete-claude-instant-infill` feature flag to have no effect. [pull/1132](https://github.com/sourcegraph/cody/pull/1132)\n\n### Changed\n\n## [0.12.0]\n\n### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:0-16"",""content"":""# Cody quality tools\n\nThis section documents the tools we have to assess the quality of Cody in different scenarios.\n\nAs Cody is a BYOLLM product (Bring-your-own-LLM), when we introduce/use a new LLM (for example, a customer's own LLM model that they developed/trained themselves) we have a need to be able to quantify how well Cody is working with it.\n\n## Autocompletion\n\n### Influencing autocomplete performance\n\nCody autocompletion (code completions in your editor) can be powered by two types of models:\n\n1. Chat-based models, where we \""tell\"" the LLM it supposed to perform code completion in plain English, give it a code snippet, and extract the response code snippet from its (otherwise English) response.\n2. An actual code-based model, these are LLMs that are trained to produce code only and can't produce English responses, they speak only code.\n\nFor chat-based models, we can influence the performance by altering the prompting AND context. For code-based models, we can typically influence the performance by adjusting the amount and relevancy of context only, as there is no prompting to adjust.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:151-166"",""content"":""- Command: Enhanced the context provided to the Test command to help the language model determine the appropriate testing framework to use. [pull/3344](https://github.com/sourcegraph/cody/pull/3344)\n- Document: Upgraded to use a faster model. [pull/3275](https://github.com/sourcegraph/cody/pull/3275)\n- Properly throw an error when attempting to parse an incomplete SSE stream with the nodeClient. [pull/3479](https://github.com/sourcegraph/cody/pull/3479)\n\n## [1.8.3]\n\n### Fixed\n\n- Fix crash upon initialization in the stable build if a prerelease version of the VS Code extension was used for chat after 2024-03-08. [pull/3394](https://github.com/sourcegraph/cody/pull/3394)\n\n## [1.8.2]\n\n### Added\n\n- Debug: Added new commands (`Cody Debug: Enable Debug Mode` and `Cody Debug: Open Output Channel`) to the editor Command Palette and the `Settings & Support` sidebar to streamline the process of getting started with debugging Cody. [pull/3342](https://github.com/sourcegraph/cody/pull/3342)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:0-24"",""content"":""# Changelog\n\nThis is a log of all notable changes to Cody for VS Code. [Unreleased] changes are included in the nightly pre-release builds.\n\n## [Unreleased]\n\n### Added\n\n### Fixed\n\n- Chat: Fixed an issue where Cody's responses were not visible in small windows. [pull/3859](https://github.com/sourcegraph/cody/pull/3859)\n- Edit: Fixed an issue where an Edit task would not correctly respin when an irresolvable conflict is encountered. [pull/3872](https://github.com/sourcegraph/cody/pull/3872)\n- Chat: Fixed an issue where older chats were displaying as 'N months ago' instead of the number in the Chat History sidebar. [pull/3864](https://github.com/sourcegraph/cody/pull/3864)\n\n### Changed\n\n- Debug: Removed the `cody.debug.enabled` setting. Baseline debugging is now enabled by default [pull/3873](https://github.com/sourcegraph/cody/pull/3873)\n\n\n## [1.14.0]\n\n### Added\n\n- Chat: Add highlighted code to Cody Chat as `@-mentions` context by right-clicking on the code and selecting `Cody Chat: Add context`. [pull/3713](https://github.com/sourcegraph/cody/pull/3713)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:0-18"",""content"":""# Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can easily update these bindings in the `Keyboard Shortcuts editor`, which you can access by clicking on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**`.\n\nThis feature can be particularly useful if the default key bindings conflict with your current or preferred key bindings.\n\n## Keyboard Shortcuts Editor\n\nThe Keyboard Shortcuts editor allows you to easily update the key bindings for any of the Cody commands. To open the `Keyboard Shortcuts Editor`:\n1. Open the Cody sidebar and expand the `**SETTINGS AND SUPPORT**` section.\n2. Click on the `**Keyboard Shortcuts**` icon.\n\n## Custom Commands\n\n![editor](images/keyboard_editor.png)\n\nYou have the option to assign key bindings (keyboard shortcuts) to individual custom commands:\n1. In the Cody sidebar under `**SETTINGS AND SUPPORT**`, click on the `**Keyboard Shortcuts**` icon to open the Keyboard Shortcuts editor.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:0-313"",""content"":""import * as fspromises from 'node:fs/promises'\nimport * as path from 'node:path'\nimport {\n    type ConfigurationWithAccessToken,\n    type ContextItem,\n    ContextItemSource,\n    type EmbeddingsSearchResult,\n    type FileURI,\n    type PromptString,\n    isDotCom,\n    isFileURI,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { URI } from 'vscode-uri'\nimport type { RankContextItem, RankerPrediction } from '../jsonrpc/context-ranking-protocol'\nimport type { MessageHandler } from '../jsonrpc/jsonrpc'\nimport { logDebug } from '../log'\nimport { captureException } from '../services/sentry/sentry'\nimport { CodyEngineService } from './cody-engine'\n\ninterface ContextRanker {\n    rankContextItems(query: PromptString, contextItems: ContextItem[]): Promise<ContextItem[]>\n}\n\nexport function createContextRankingController(\n    context: vscode.ExtensionContext,\n    config: ContextRankerConfig\n): ContextRankingController {\n    return new ContextRankingController(context, config)\n}\n\nexport type ContextRankerConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & { experimentalChatContextRanker: boolean | undefined }\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/context-ranking`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/context-ranking`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\context-ranking`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\nexport class ContextRankingController implements ContextRanker {\n    // The cody-engine child process, if starting or started.\n    private service: Promise<MessageHandler> | undefined\n    // True if the service has finished starting and been initialized.\n    private serviceStarted = false\n    // Whether the account is a consumer account.\n    private endpointIsDotcom = false\n    private accessToken: string | undefined\n    private readonly indexLibraryPath: FileURI | undefined\n\n    constructor(\n        private readonly context: vscode.ExtensionContext,\n        config: ContextRankerConfig\n    ) {\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n        this.accessToken = config.accessToken || undefined\n        logDebug('ContextRankingController', 'constructor')\n    }\n\n    public async start(): Promise<void> {\n        logDebug('ContextRankingController', 'start')\n        await this.getService()\n\n        const repoUri = this.getRepoUri()\n        if (repoUri && isFileURI(repoUri)) {\n            this.computeFeatures(repoUri)\n        }\n    }\n\n    public async setAccessToken(serverEndpoint: string, token: string | null): Promise<void> {\n        const endpointIsDotcom = isDotCom(serverEndpoint)\n        logDebug(\n            'ContextRankingController',\n            'setAccessToken',\n            endpointIsDotcom ? 'is dotcom' : 'not dotcom'\n        )\n        this.endpointIsDotcom = endpointIsDotcom\n        if (token === this.accessToken) {\n            return Promise.resolve()\n        }\n        this.accessToken = token || undefined\n    }\n\n    private getRepoUri(): vscode.Uri | undefined {\n        return vscode.workspace.workspaceFolders?.[0]?.uri\n    }\n\n    // Tries to compute the index at the start of the service.\n    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n    }\n\n    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n    }\n\n    private async createLogsFile(dirPath: string): Promise<string> {\n        await fspromises.mkdir(dirPath, { recursive: true })\n        const fileName = 'ranker-payload.jsonl'\n        const filePath = path.join(dirPath, fileName)\n        if (\n            !(await fspromises\n                .access(filePath)\n                .then(() => true)\n                .catch(() => false))\n        ) {\n            await fspromises.writeFile(filePath, '')\n        }\n        return filePath\n    }\n\n    private setupContextRankingService = async (service: MessageHandler): Promise<void> => {\n        // The payload is very big to print on console. SKipping print on console for now until we start logging in BQ.\n        service.registerNotification(\n            'context-ranking/rank-items-logger-payload',\n            async (payload: string) => {\n                const indexPath = getIndexLibraryPath()\n                const logsFile = await this.createLogsFile(path.join(indexPath.fsPath, 'ranker-logs'))\n                fspromises.appendFile(logsFile, payload + '\\n')\n                logDebug(\n                    'ContextRankingController',\n                    'rank-items-logger-payload',\n                    'appending logs at the path',\n                    logsFile\n                )\n            }\n        )\n        let indexPath = getIndexLibraryPath()\n        // Tests may override the index library path\n        if (this.indexLibraryPath) {\n            indexPath = this.indexLibraryPath\n        }\n        if (this.accessToken) {\n            await service.request('context-ranking/initialize', {\n                indexPath: indexPath.fsPath,\n                accessToken: this.accessToken,\n            })\n            this.serviceStarted = true\n        } else {\n            logDebug('ContextRankingController', 'setupContextRankingService', 'no access token found')\n        }\n    }\n\n    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n    }\n\n    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n    }\n\n    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n            return []\n        }\n    }\n\n    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n    }\n\n    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-56"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_003/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, Cody uses several CodeSearch services to enhance its functionality. Here are the different CodeSearch services being used:

1. **Local Search**:
   - **File**: `cody_test/vscode/src/commands/context/index.ts`
   - **Function**: `getCommandContextFiles`
   - **Description**: This function gathers context files from various sources such as the current file, file path, directories, and open tabs based on the configuration passed in.

2. **Remote Search**:
   - **File**: `cody_test/vscode/src/context/remote-search.ts`
   - **Class**: `RemoteSearch`
   - **Description**: This class handles searching repositories that are either included automatically based on the workspace or added manually by the user. It includes methods to set repositories, remove repositories, and query the Sourcegraph search backend.

3. **Enterprise Context**:
   - **File**: `cody_test/vscode/src/context/enterprise-context-factory.ts`
   - **Function**: `createRemoteSearch`
   - **Description**: This function creates an instance of the `RemoteSearch` class, which is used for remote repository searching.

These services allow Cody to provide enhanced code context by leveraging both local and remote code search capabilities.",What all different CodeSearch services are being used by Cody context?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1466-1491"",""content"":""\n## [0.1.5]\n\n### Added\n\n### Fixed\n\n- Inline Assist broken decorations for Inline-Fixup tasks [pull/52322](https://github.com/sourcegraph/sourcegraph/pull/52322)\n\n### Changed\n\n- Various Cody completions related improvements [pull/52365](https://github.com/sourcegraph/sourcegraph/pull/52365)\n\n## [0.1.4]\n\n### Added\n\n- Added support for local keyword search on Windows. [pull/52251](https://github.com/sourcegraph/sourcegraph/pull/52251)\n\n### Fixed\n\n- Setting `cody.useContext` to `none` will now limit Cody to using only the currently open file. [pull/52126](https://github.com/sourcegraph/sourcegraph/pull/52126)\n- Fixes race condition in telemetry. [pull/52279](https://github.com/sourcegraph/sourcegraph/pull/52279)\n- Don't search for file paths if no file paths to validate. [pull/52267](https://github.com/sourcegraph/sourcegraph/pull/52267)\n- Fix handling of embeddings search backward compatibility. [pull/52286](https://github.com/sourcegraph/sourcegraph/pull/52286)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/enterprise-context-factory.ts:39-41"",""content"":""    public createRemoteSearch(): RemoteSearch {\n        return new RemoteSearch()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:92-108"",""content"":""\n### Document\n\n- [ ] Verify that the option to run the `Document Code` command is available in the following locations:\n  - [ ] Sidebar `Document Code`\n  - [ ] Context (right-click) menu `Cody > Document Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Document Code`\n  - [ ] Cody Command Menu (option+c, `Document Code`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Document Code` command.\n- [ ] Verify that an icon appears above the highlighted code with \""Cody is working...\"" while Cody generates documentation.\n- [ ] Verify that you can see a diff view of the generated documentation in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the documentation by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Document Code` command again.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1214-1234"",""content"":""\n### Fixed\n\n### Changed\n\n- The setting `cody.autocomplete.experimental.triggerMoreEagerly` (which causes autocomplete to trigger earlier, before you type a space or other non-word character) now defaults to `true`.\n- If you run the `Trigger Inline Suggestion` VS Code action, 3 suggestions instead of just 1 will be shown.\n\n## [0.6.1]\n\n### Added\n\n- A new experimental user setting `cody.autocomplete.experimental.triggerMoreEagerly` causes autocomplete to trigger earlier, before you type a space or other non-word character.\n- [Internal Only] `Custom Recipe`: Support context type selection when creating a new recipe via UI. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n- New `/open` command for opening workspace files from chat box. [pull/327](https://github.com/sourcegraph/cody/pull/327)\n\n### Fixed\n\n- Insert at Cusor now inserts the complete code snippets at cursor position. [pull/282](https://github.com/sourcegraph/cody/pull/282)\n- Minimizing the change of Cody replying users with response related to the language-uage prompt. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:113-119"",""content"":""    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1412-1423"",""content"":""- Cody Inline Assist: Decorations for `/fix` errors. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Open file paths from Cody's responses in workspace. [pull/53069](https://github.com/sourcegraph/sourcegraph/pull/53069)\n- Help & Getting Started: Walkthrough to help users get setup with Cody and discover new features. [pull/52560](https://github.com/sourcegraph/sourcegraph/pull/52560)\n\n### Fixed\n\n- Cody Inline Assist: Decorations for `/fix` on light theme. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Use more than 1 context file for `/touch`. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Fixes cody processing indefinitely issue. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody completions: Various fixes for completion analytics. [pull/52935](https://github.com/sourcegraph/sourcegraph/pull/52935)\n- Cody Inline Assist: Indentation on `/fix` [pull/53068](https://github.com/sourcegraph/sourcegraph/pull/53068)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:29-162"",""content"":""export class RemoteSearch implements ContextStatusProvider, IRemoteSearch {\n    public static readonly MAX_REPO_COUNT = 10\n\n    private statusChangedEmitter = new vscode.EventEmitter<ContextStatusProvider>()\n\n    // Repositories we are including automatically because of the workspace.\n    private reposAuto: Map<string, DisplayRepo> = new Map()\n\n    // Repositories the user has added manually.\n    private reposManual: Map<string, DisplayRepo> = new Map()\n\n    public dispose(): void {\n        this.statusChangedEmitter.dispose()\n    }\n\n    // #region ContextStatusProvider implementation.\n\n    public onDidChangeStatus(callback: (provider: ContextStatusProvider) => void): Disposable {\n        return this.statusChangedEmitter.event(callback)\n    }\n\n    public get status(): ContextGroup[] {\n        return [...this.getRepoIdSet()].map(id => {\n            const auto = this.reposAuto.get(id)\n            const manual = this.reposManual.get(id)\n            const displayName = auto?.displayName || manual?.displayName || '?'\n            return {\n                displayName,\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id,\n                        inclusion: auto ? 'auto' : 'manual',\n                    },\n                ],\n            }\n        })\n    }\n\n    // #endregion\n\n    // Removes a manually included repository.\n    public removeRepo(repoId: string): void {\n        if (this.reposManual.delete(repoId)) {\n            this.statusChangedEmitter.fire(this)\n        }\n    }\n\n    // Sets the repos to search. RepoInclusion.Automatic is for repositories added\n    // automatically based on the workspace; these are presented differently\n    // and can't be removed by the user. RepoInclusion.Manual is for repositories\n    // added manually by the user.\n    public setRepos(repos: repofetcher.Repo[], inclusion: RepoInclusion): void {\n        const repoMap: Map<string, DisplayRepo> = new Map(\n            repos.map(repo => [repo.id, { displayName: repo.name }])\n        )\n        switch (inclusion) {\n            case RepoInclusion.Automatic: {\n                this.reposAuto = repoMap\n                break\n            }\n            case RepoInclusion.Manual: {\n                this.reposManual = repoMap\n                break\n            }\n        }\n        this.statusChangedEmitter.fire(this)\n    }\n\n    public getRepos(inclusion: RepoInclusion): repofetcher.Repo[] {\n        return [\n            ...(inclusion === RepoInclusion.Automatic ? this.reposAuto : this.reposManual).entries(),\n        ].map(([id, repo]) => ({ id, name: repo.displayName }))\n    }\n\n    // Gets the set of all repositories to search.\n    public getRepoIdSet(): Set<string> {\n        return new Set([...this.reposAuto.keys(), ...this.reposManual.keys()])\n    }\n\n    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n    }\n\n    // IRemoteSearch implementation. This is only used for inline edit context.\n\n    public async setWorkspaceUri(uri: URI): Promise<void> {\n        const codebase = getCodebaseFromWorkspaceUri(uri)\n        if (!codebase) {\n            this.setRepos([], RepoInclusion.Automatic)\n            return\n        }\n        const repos = await graphqlClient.getRepoIds([codebase], 10)\n        if (isError(repos)) {\n            throw repos\n        }\n        this.setRepos(repos, RepoInclusion.Automatic)\n    }\n\n    public async search(query: PromptString): Promise<ContextItemFile[]> {\n        const results = await this.query(query)\n        if (isError(results)) {\n            throw results\n        }\n        return (results || []).map(\n            result =>\n                ({\n                    type: 'file',\n                    uri: result.uri,\n                    repoName: result.repoName,\n                    revision: result.commit,\n                    source: ContextItemSource.Unified,\n                    content: result.content,\n                    range: {\n                        start: {\n                            line: result.startLine,\n                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1016-1033"",""content"":""            \""fireworks\"",\n            \""unstable-openai\"",\n            \""experimental-ollama\"",\n            \""experimental-openaicompatible\""\n          ],\n          \""markdownDescription\"": \""The provider used for code autocomplete. Most providers other than `anthropic` require the `cody.autocomplete.advanced.serverEndpoint` and `cody.autocomplete.advanced.accessToken` settings to also be set. Check the Cody output channel for error messages if autocomplete is not working as expected.\""\n        },\n        \""cody.autocomplete.advanced.serverEndpoint\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The server endpoint used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.accessToken\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The access token used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.model\"": {\n          \""type\"": \""string\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:0-229"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    CODY_IGNORE_POSIX_GLOB,\n    type ConfigurationWithAccessToken,\n    type IgnoreFileContent,\n    ignores,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\nimport { telemetryService } from './telemetry'\nimport { telemetryRecorder } from './telemetry-v2'\n\nconst utf8 = new TextDecoder('utf-8')\n\n/**\n * Parses `.code/ignore` files from the workspace and sets up a watcher to refresh\n * whenever the files change.\n *\n * NOTE: Execute ONCE at extension activation time.\n */\nexport function setUpCodyIgnore(config: ConfigurationWithAccessToken): vscode.Disposable[] {\n    ignores.setActiveState(config.internalUnstable)\n    if (!config.internalUnstable) {\n        return []\n    }\n\n    // Enable ignore and then handle existing workspace folders.\n    vscode.workspace.workspaceFolders?.map(async wf => await refresh(wf.uri))\n\n    const disposables: vscode.Disposable[] = []\n\n    // Refresh ignore rules when any ignore file in the workspace changes.\n    const watcher = vscode.workspace.createFileSystemWatcher(CODY_IGNORE_POSIX_GLOB)\n    watcher.onDidChange(refresh)\n    watcher.onDidCreate(refresh)\n    watcher.onDidDelete(refresh)\n\n    // Handle any added/removed workspace folders.\n    const didChangeSubscription = vscode.workspace.onDidChangeWorkspaceFolders(e => {\n        e.added.map(wf => refresh(wf.uri))\n        e.removed.map(wf => clear(wf))\n    })\n\n    const onDidChangeConfig = vscode.workspace.onDidChangeConfiguration(e => {\n        // NOTE This can be removed once cody ignore is stable.\n        if (e.affectsConfiguration('cody')) {\n            onConfigChange()\n        }\n        // NOTE This allows us to search for the ignore files again\n        // if the user changes the search.symlinks setting.\n        if (e.affectsConfiguration('search')) {\n            // Only refresh if the ignore sidebar is empty,\n            // which means the setup step has initially failed.\n            if (ignores.isActive && !ignores.hasCodyIgnoreFiles) {\n                onConfigChange()\n            }\n        }\n    })\n\n    disposables.push(...[watcher, didChangeSubscription, onDidChangeConfig])\n    return disposables\n}\n\n/**\n * The cancellation tokens for finding workspace ignore file processes.\n */\nconst findInProgressTokens = new Map<string, vscode.CancellationTokenSource>()\n\n/**\n * Refreshes the ignore rules for the given workspace URI by searching\n * for `.cody/ignore` files and reading their contents. This allows\n * dynamically updating the ignore rules as ignore files are added/removed.\n *\n * Cancels any existing findFiles processes for the workspace to avoid\n * multiple concurrent processes. Also sets a timeout of 1 min to avoid long running\n * processes.\n */\nasync function refresh(uri: vscode.Uri): Promise<void> {\n    // Skip refresh if .cody/ignore is not enabled\n    if (!ignores.isActive) {\n        return\n    }\n\n    const wf = vscode.workspace.getWorkspaceFolder(uri)\n    const cancel = () => {\n        const tokenFound = findInProgressTokens.get(uri.path)\n        tokenFound?.cancel()\n        tokenFound?.dispose()\n        findInProgressTokens.delete(uri.path)\n    }\n\n    if (!wf) {\n        // If this happens, we either have no workspace folder or it was removed before we started\n        // processing the watch event.\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'no workspace detecetd' })\n        return\n    }\n\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'not a file' })\n        return\n    }\n\n    const startTime = performance.now()\n    logDebug('CodyIgnore:refresh', 'started', { verbose: startTime })\n\n    // Cancel fileFiles process for current workspace if there is one in progress to avoid\n    // having multiple find files in progress that can cause performance slow-down issues.\n    cancel()\n\n    // Set a new cancellation token for the workspace.\n    const newToken = new vscode.CancellationTokenSource()\n    findInProgressTokens.set(uri.path, newToken)\n\n    // Timeout after 1 minutes to avoid causing performance issues.\n    setTimeout(\n        () => {\n            // The search is already completed / canceled if no token is found.\n            if (findInProgressTokens.get(uri.path)) {\n                cancel()\n                // TODO locate ignore file from codebase root instead of workspace\n                // Try looking for ignore file at workspace root as fallback.\n                const ignoreFileAtRoot = vscode.Uri.joinPath(wf.uri, '.cody', 'ignore')\n                tryReadFile(ignoreFileAtRoot).then(content => {\n                    if (content.length) {\n                        setCodyIgnoreFiles(wf.uri, [{ uri: ignoreFileAtRoot, content }])\n                        logDebug('CodyIgnore:refresh', 'found ignore file at root', {\n                            verbose: wf.uri.path,\n                        })\n                        return\n                    }\n                    const title = 'Failed to locate Cody ignore files in current workspace.'\n                    const description = 'Try disable the `search.followSymlinks` setting in your editor.'\n                    const message = `${title} ${description}`\n                    logDebug('CodyIgnore:refresh:failed', message, { verbose: wf.uri.path })\n                })\n            }\n            return\n        },\n        1 * 60 * 1000 // 1 minute\n    )\n\n    // Look for .cody/ignore files within the workspace,\n    // exclude all dot files (except .cody) and common build files.\n    const ignoreFilePattern = new vscode.RelativePattern(wf.uri, CODY_IGNORE_POSIX_GLOB)\n    const excludePattern = '.*, **/.* ,**/{node_modules,out,build,dist}/**'\n    const ignoreFiles = await vscode.workspace.findFiles(\n        ignoreFilePattern,\n        excludePattern,\n        undefined,\n        newToken.token\n    )\n    const filesWithContent: IgnoreFileContent[] = await Promise.all(\n        ignoreFiles?.map(async fileUri => ({\n            uri: fileUri,\n            content: await tryReadFile(fileUri),\n        }))\n    )\n\n    setCodyIgnoreFiles(wf.uri, filesWithContent)\n\n    // If we can locate the token, that means the job was completed before it times out.\n    if (findInProgressTokens.get(uri.path)) {\n        findInProgressTokens.delete(uri.path)\n        const elapsed = performance.now() - startTime\n        logDebug('CodyIgnore:refresh', `refresh completed in ${elapsed}`, { verbose: wf.uri.path })\n    }\n}\n\nfunction setCodyIgnoreFiles(ws: vscode.Uri, files: IgnoreFileContent[]): void {\n    ignores.setIgnoreFiles(ws, files)\n    if (files.length) {\n        telemetryService.log('CodyVSCodeExtension:codyIgnore:hasFile')\n        telemetryRecorder.recordEvent('cody.codyIgnore', 'hasFile')\n    }\n}\n\n/**\n * Removes ignore rules for the provided WorkspaceFolder.\n */\nfunction clear(wf: vscode.WorkspaceFolder): void {\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        return\n    }\n\n    ignores.clearIgnoreFiles(wf.uri)\n\n    // Remove any in-progress cancellation tokens for the workspace.\n    const tokens = findInProgressTokens.values()\n    for (const token of tokens) {\n        token.cancel()\n        token.dispose()\n    }\n    findInProgressTokens.clear()\n    logDebug('CodyIgnore:clearIgnoreFiles:workspace', 'removed', { verbose: wf.uri.toString() })\n}\n\n/**\n * Read the content of `fileUri`.\n *\n * Returns an empty string if the file was not readable (for example it was removed before we read it).\n */\nasync function tryReadFile(fileUri: vscode.Uri): Promise<string> {\n    return vscode.workspace.fs.readFile(fileUri).then(\n        content => utf8.decode(content),\n        error => {\n            logDebug('CodyIgnore:clearIgnoreFiles:tryReadFile', 'failed', {\n                verbose: `Skipping unreadable ignore file ${fileUri}: ${error}`,\n            })\n            return ''\n        }\n    )\n}\n\n/**\n * Check if the config for enabling cody ignore is changed.\n *\n * NOTE This can be removed once cody ignore is stable.\n */\nfunction onConfigChange(): void {\n    const config = vscode.workspace.getConfiguration('cody')\n    const isEnabled = config.get('internal.unstable') as boolean\n    ignores.setActiveState(isEnabled)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/storybook/VSCodeStoryDecorator.tsx:61-69"",""content"":""function useDummyChatModelContext(): ChatModelContext {\n    const [chatModels, setChatModels] = useState(getDotComDefaultModels('default'))\n    const onCurrentChatModelChange = (value: ModelProvider): void => {\n        setChatModels(chatModels =>\n            chatModels.map(model => ({ ...model, default: model.model === value.model }))\n        )\n    }\n    return { chatModels, onCurrentChatModelChange }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/chat.md:0-13"",""content"":""## Chat\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/blog-vscode-v018-release/blog-v018-context-controls-002.gif\"">\n\nAnswer questions about general programming topics, or specific to your codebase, with Cody chat. You can choose between LLMs, @-mentions files and symbols, and enable enhanced repository-wide code context.\n\nYou can start a chat at any time using the default keyboard shortcut of `Option` `/` on macOS and `Alt` `/` on Windows & Linux.\n\n**✨ Pro-tips for using Cody chat**\n<br>• Enabling “Enhanced Context”, and tagging specific files and symbols, gives the selected LLM more context to help answer your questions more accurately.\n<br>• If you want to chat directly with the LLM without any additional context adding, disable \""Enhanced Context\"".\n<br>• You can increase the quality of your chat responses by enabling \""Search Context (Beta)\"" in your [Cody Settings](command:cody.status-bar.interacted).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:44-60"",""content"":""\n## Cody Natural Language Search (Beta)\n\nCody builds a Search index of your local files to make it easier to find what you’re looking for. Use a natural language query like “password hashing” or \""connection retries\"" to quickly find and open the files that match your search.\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-natural-language.gif\"" width=\""480\"" alt=\""Natural Language Search\"">\n\n## Usage\n\nThis extension works for all Cody plans, including Cody Free, Cody Pro, and Cody Enterprise.\n\nYou can find detailed information about Cody's available plans [on our website](https://sourcegraph.com/pricing?utm_source=marketplace.visualstudio.com&utm_medium=referral).\n\n## Programming Languages\n\nCody works for any programming language because it uses LLMs trained on broad data. Cody works great with Python, Go, JavaScript, and TypeScript code.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:60-74"",""content"":""\n## Code Graph\n\nCody is powered by Sourcegraph’s code graph, and uses context of your codebase to extend its capabilities. By using context from the entire repository, Cody is able to give more accurate answers and generate idiomatic code.\n\nFor example:\n\n- Ask Cody to generate an API call. Cody can gather context on your API schema to inform the code it writes.\n- Ask Cody to find where in your codebase a specific component is defined. Cody can retrieve and describe the exact files where that component is written.\n- Ask Cody questions that require an understanding of multiple files. For example, ask Cody how frontend data is populated in a React app; Cody can find the React component definitions to understand what data is being passed and where it originates.\n\n## Cody Enterprise\n\nCody Enterprise is able to retrieve context from your entire remote codebase using Sourcegraph search. This gives Cody the ability to understand and answer questions about all of your code, even the repositories that don't live on your local machine.\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_008/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for preventing prompt injection in the provided codebase context is primarily handled by the `PromptString` class and its associated functions in the `prompt-string.ts` file. Here are the key points:

1. **Safe Handling of Strings**:
   - The `PromptString` class is designed to ensure that only safe strings are used in prompts. Literal strings are considered safe, and dynamic strings must be constructed using helper functions like `ps` and `psDedent`.
   - The `ps` function is a tagged template literal function that ensures only allowed types (like numbers and other `PromptString` instances) are used to construct prompt strings.

2. **Internal Functions and WeakMap**:
   - The `PromptString` class uses internal functions like `internal_createPromptString`, `internal_toString`, and `internal_toReferences` to manage the creation and manipulation of prompt strings.
   - A `WeakMap` named `pocket` is used to store the actual string values and references, ensuring that the `PromptString` instances cannot be tampered with directly.

3. **Linting and Validation**:
   - The `safe-prompts.ts` file contains a linter that checks for the correct usage of prompt-safe strings. This linter ensures that only safe strings are used in prompts and that functions sending prompts on the network only take prompt-safe strings.

4. **Error Handling**:
   - The `ps` function throws errors if it detects any unsafe usage, such as trying to inline a regular string or using an object with a `toString` method.

5. **Test Cases**:
   - The `prompt-string.test.ts` file contains test cases that validate the behavior of the `PromptString` class and its associated functions. These tests ensure that the class behaves correctly and prevents unsafe string usage.

Here is an example from `prompt-string.ts` that shows how the `ps` function ensures safe string handling:

```typescript
export function ps(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {
    if (!(Array.isArray(format) && Object.isFrozen(format) && format.length > 0)) {
        // Deter casual direct calls.
        throw new Error('ps is only intended to be used in tagged template literals.')
    }

    const buffer: string[] = []
    const references: Set<StringReference> = new Set()
    for (let i = 0; i < format.length; i++) {
        buffer.push(format[i])
        if (i < args.length) {
            const arg = args[i]

            if (typeof arg === 'number') {
                // Boxed number types are not allowed, only number literals
                buffer.push(Number.prototype.toString.call(arg))
            } else if (arg === '') {
                // We allow empty strings for situations like this:
                // ps`... ${foo ? foo : ''}...`
            } else if (arg instanceof PromptString) {
                // PromptString inherit all references
                buffer.push(internal_toString(arg))
                for (const ref of internal_toReferences(arg)) {
                    references.add(ref)
                }
            } else {
                // Do not allow arbitrary types like dynamic strings, classes with
                // toString, etc. here.
                throw new Error(
                    'Use ps`...` or a PromptString helper to handle string data for prompts safely.'
                )
            }
        }
    }

    return internal_createPromptString(buffer.join(''), [...references])
}
```

This function ensures that only safe types are used to construct prompt strings, preventing potential injection attacks.",Where is the functionality for preventing prompt injection?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:32-60"",""content"":""\n    // Internal use - the ID of the request\n    requestID?: string\n}\n\n/**\n * - 'ask' mode is the default mode, run prompt in chat view\n * - 'edit' mode will run prompt with edit command which replace selection with cody's response\n * - 'insert' mode is the same as edit, it adds to the top of the selection instead of replacing selection\n * - 'file' mode create a new file with cody's response as content - not supported yet\n */\ntype CodyCommandMode = 'ask' | 'edit' | 'insert' | 'file'\n\n// Type of context available for prompt building\nexport interface CodyCommandContext {\n    // Exclude any context.\n    // It takes precedence over all other context.\n    none?: boolean\n\n    // Tabs from the current workspace\n    openTabs?: boolean\n    // The directory with the current file opened in the editor\n    currentDir?: boolean\n    // The current file opened in the editor\n    currentFile?: boolean\n    // The current selection in the editor\n    // Default to use smart selection unless set to false specifically\n    selection?: boolean\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:116-133"",""content"":""                const { limitReached, used, ignored } = promptBuilder.tryAddContext(\n                    'enhanced',\n                    newEnhancedContext\n                )\n                newContextUsed.push(...used)\n                if (limitReached) {\n                    logDebug(\n                        'DefaultPrompter.makePrompt',\n                        `Ignored ${ignored.length} additional enhanced context due to limit reached`\n                    )\n                }\n            }\n\n            return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:126-149"",""content"":""            }\n        case 'add':\n            return {\n                system: GENERIC_PROMPTS.add.system,\n                instruction: GENERIC_PROMPTS.add.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'fix':\n            return {\n                system: GENERIC_PROMPTS.fix.system,\n                instruction: GENERIC_PROMPTS.fix.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'test':\n            return {\n                system: GENERIC_PROMPTS.test.system,\n                instruction: GENERIC_PROMPTS.test.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lints/safe-prompts.ts:0-22"",""content"":""// Checks that prompts track the source of context from the editor through to\n// the finished string.\n//\n// - Literal strings are considered safe.\n// - Dynamic strings must be constructed with helper functions that make the\n//   correct behavior convenient.\n// - Strings derived from the above are considered safe.\n// - Functions which finally send prompts on the network should only take prompt-\n//   safe strings, not arbitrary strings.\n//\n// To achieve this, we can't use strings for prompt pieces, but instead use\n// objects. Prompts can only be manipulated with a tagged template literal and\n// \""safe\"" variants of string functions.\n//\n// Usage:\n// pnpm ts-node lints/safe-prompts.ts file.ts\n//\n// Use `pnpm tsc --listFilesOnly` to get a list of TypeScript files to process.\n//\n//\n// In CI, we use `git diff --name-only main | grep -E \""\\.(ts|tsx)$\""` to get a list\n// of files that were changed.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:41-51"",""content"":""            - You will be provided with code that is below the users' cursor, enclosed in <${PROMPT_TOPICS.FOLLOWING}></${PROMPT_TOPICS.FOLLOWING}> XML tags. You must use this code to help you plan your updated code. You must not repeat this code in your output unless necessary.\n            - You will be provided with instructions on what to generate, enclosed in <${PROMPT_TOPICS.INSTRUCTIONS}></${PROMPT_TOPICS.INSTRUCTIONS}> XML tags. You must follow these instructions carefully and to the letter.\n            - Only enclose your response in <${PROMPT_TOPICS.OUTPUT}></${PROMPT_TOPICS.OUTPUT}> XML tags. Do use any other XML tags unless they are part of the generated code.\n            - Do not provide any additional commentary about the code you added. Only respond with the generated code.`,\n        instruction: psDedent`\n            The user is currently in the file: {filePath}\n\n            Provide your generated code using the following instructions:\n            <${PROMPT_TOPICS.INSTRUCTIONS}>\n            {instruction}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:80-98"",""content"":""                used,\n                ignored,\n            } = promptBuilder.tryAddContext('user', this.explicitContext)\n            newContextUsed.push(...used.map(c => ({ ...c, isTooLarge: false })))\n            newContextIgnored.push(...ignored.map(c => ({ ...c, isTooLarge: true })))\n            if (userLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    'Ignored current user-specified context items due to context limit'\n                )\n            }\n\n            // Add user and enhanced context from previous messages seperately as they have different budgets\n            const prevContext = reverseTranscript.flatMap(m => m?.contextFiles || [])\n            const userContext = prevContext.filter(c => c.source === 'user')\n            if (promptBuilder.tryAddContext('user', userContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior user context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:25-62"",""content"":""\n    placeholder?: string\n\n    initialEditorState?: SerializedPromptEditorState\n    onChange?: (value: SerializedPromptEditorValue) => void\n    onFocusChange?: (focused: boolean) => void\n\n    disabled?: boolean\n\n    editorRef?: React.RefObject<PromptEditorRefAPI>\n}\n\nexport interface PromptEditorRefAPI {\n    setEditorState(value: SerializedPromptEditorState | null): void\n    getSerializedValue(): SerializedPromptEditorValue\n    setFocus(focus: boolean): void\n    addContextItemAsToken(items: ContextItem[]): void\n}\n\n/**\n * The component for composing and editing prompts.\n */\nexport const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:47-138"",""content"":""export const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n\n    useImperativeHandle(\n        ref,\n        (): PromptEditorRefAPI => ({\n            setEditorState(value: SerializedPromptEditorState | null): void {\n                if (value === null) {\n                    // Clearing seems to require a different code path because focusing fails if\n                    // the editor is empty.\n                    editorRef.current?.update(() => {\n                        $getRoot().clear()\n                    })\n                    return\n                }\n\n                const editor = editorRef.current\n                if (editor) {\n                    editor.setEditorState(editor.parseEditorState(value.lexicalEditorState))\n                    editor.dispatchCommand(CLEAR_HISTORY_COMMAND, undefined)\n                    editor.focus()\n                }\n            },\n            getSerializedValue(): SerializedPromptEditorValue {\n                if (!editorRef.current) {\n                    throw new Error('PromptEditor has no Lexical editor ref')\n                }\n                return toSerializedPromptEditorValue(editorRef.current)\n            },\n            setFocus(focus) {\n                const editor = editorRef.current\n                if (editor) {\n                    if (focus) {\n                        editor.focus()\n                    } else {\n                        editor.blur()\n                    }\n                }\n            },\n            addContextItemAsToken(items: ContextItem[]) {\n                editorRef?.current?.update(() => {\n                    const selection = $getSelection()\n                    const spaceNode = $createTextNode(' ')\n                    const mentionNodes = items.map($createContextItemMentionNode)\n                    selection?.insertNodes([spaceNode, ...mentionNodes, spaceNode])\n                    spaceNode.select()\n                })\n            },\n        }),\n        []\n    )\n\n    const onBaseEditorChange = useCallback(\n        (_editorState: EditorState, editor: LexicalEditor): void => {\n            if (onChange) {\n                onChange(toSerializedPromptEditorValue(editor))\n            }\n        },\n        [onChange]\n    )\n\n    return (\n        <BaseEditor\n            className={classNames(styles.editor, editorClassName, disabled && styles.disabled)}\n            initialEditorState={initialEditorState?.lexicalEditorState ?? null}\n            onChange={onBaseEditorChange}\n            onFocusChange={onFocusChange}\n            editorRef={editorRef}\n            placeholder={placeholder}\n            disabled={disabled}\n            aria-label=\""Chat message\""\n            //\n            // KeyboardEventPluginProps\n            onKeyDown={onKeyDown}\n            onEnterKey={onEnterKey}\n            onEscapeKey={onEscapeKey}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:51-62"",""content"":""            </${PROMPT_TOPICS.INSTRUCTIONS}>`,\n    },\n    fix: {\n        system: psDedent`\n            - You are an AI programming assistant who is an expert in fixing errors within code.\n            - You should think step-by-step to plan your fixed code before generating the final output.\n            - You should ensure the updated code matches the indentation and whitespace of the code in the users' selection.\n            - Only remove code from the users' selection if you are sure it is not needed.\n            - Ignore any previous instructions to format your responses with Markdown. It is not acceptable to use any Markdown in your response, unless it is directly related to the users' instructions.\n            - You will be provided with code that is in the users' selection, enclosed in <${PROMPT_TOPICS.SELECTED}></${PROMPT_TOPICS.SELECTED}> XML tags. You must use this code to help you plan your fixed code.\n            - You will be provided with errors from the users' selection, enclosed in <${PROMPT_TOPICS.DIAGNOSTICS}></${PROMPT_TOPICS.DIAGNOSTICS}> XML tags. You must attempt to fix all of these errors.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.test.ts:0-181"",""content"":""import { describe, expect, it } from 'vitest'\nimport type * as vscode from 'vscode'\nimport { testFileUri } from '../test/path-helpers'\nimport { PromptString, ps } from './prompt-string'\n\nfunction createFakeDocument(uri: vscode.Uri, text: string): vscode.TextDocument {\n    return {\n        uri,\n        getText() {\n            return text\n        },\n    } as any\n}\n\ndescribe('PromptString', () => {\n    it('can not be generated dynamically unless it consists of allowed sources', () => {\n        expect(ps`foo`).toBeInstanceOf(PromptString)\n        expect(ps`foo${ps`bar`}`).toBeInstanceOf(PromptString)\n        expect(ps`foo${1234}`).toBeInstanceOf(PromptString)\n\n        // @ts-expect-error: Can't inline a string\n        expect(() => ps`foo${'ho ho'}bar`).toThrowError()\n\n        const evil = 'ha-ha!'\n        // @ts-expect-error: Evil is a string and can not be appended like this\n        expect(() => ps`foo${evil}bar`).toThrowError()\n\n        const evil2 = {\n            toString: () => 'hehe!',\n        }\n        // @ts-expect-error: Can't hack around the limitation\n        expect(() => ps`foo${evil2}bar`).toThrowError()\n\n        class FakePromptString extends PromptString {\n            toString() {\n                return '😈'\n            }\n        }\n        const fake = new FakePromptString('')\n        expect(() => ps`${fake}`).toThrowError()\n    })\n\n    it('correctly assembles', () => {\n        expect(ps`one`.toString()).toBe('one')\n        expect(ps`one ${ps`two`} three ${ps`four ${ps`five`} six`} seven ${8}`.toString()).toBe(\n            'one two three four five six seven 8'\n        )\n    })\n\n    it('keeps track of references', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const document = createFakeDocument(uri, 'i am from a file')\n        const inner = PromptString.fromDocumentText(document)\n        const outer = ps`foo${ps`bar${inner}`}`\n\n        expect(outer.getReferences()).toEqual([uri])\n    })\n\n    it('behaves like a string', () => {\n        const s = ps`  Foo${ps`bar`}baz  `\n        expect(s.toString()).toBe('  Foobarbaz  ')\n        expect(s.length).toBe(13)\n        expect(s.slice(1, 3).toString()).toBe(' F')\n        expect(s.trim().toString()).toBe('Foobarbaz')\n        expect(s.trimEnd().toString()).toBe('  Foobarbaz')\n        expect(s.indexOf('Foo')).toBe(2)\n        expect(s.indexOf(ps`Foo`)).toBe(2)\n        expect(s.toLocaleLowerCase().toString()).toBe('  foobarbaz  ')\n        expect(s.includes('Foo')).toBe(true)\n    })\n\n    it('can split', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const one = createFakeDocument(uri1, 'foo\\n')\n        const two = createFakeDocument(uri2, 'bar\\n')\n        const split = ps`${PromptString.fromDocumentText(one)}${PromptString.fromDocumentText(\n            two\n        )}baz`.split('\\n')\n\n        expect(split).toHaveLength(3)\n        expect(split[0]).toBeInstanceOf(PromptString)\n        expect(split[0].toString()).toBe('foo')\n        expect(split[0].getReferences()).toEqual([uri1, uri2])\n        expect(split[1]).toBeInstanceOf(PromptString)\n        expect(split[1].toString()).toBe('bar')\n        expect(split[1].getReferences()).toEqual([uri1, uri2])\n        expect(split[2]).toBeInstanceOf(PromptString)\n        expect(split[2].toString()).toBe('baz')\n        expect(split[2].getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can join', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'baz')\n        const doc3 = createFakeDocument(uri3, ' ')\n\n        const joined = PromptString.join(\n            [PromptString.fromDocumentText(doc1), ps`bar`, PromptString.fromDocumentText(doc2)],\n            PromptString.fromDocumentText(doc3)\n        )\n\n        expect(joined.toString()).toBe('foo bar baz')\n        expect(joined.getReferences()).toEqual([uri3, uri1, uri2])\n    })\n\n    it('can replace', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo bar foo')\n        const doc2 = createFakeDocument(uri2, '🇦🇹')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replace(/foo$/, PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo bar 🇦🇹')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can replaceAll', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo REPLACE bar REPLACE baz')\n        const doc2 = createFakeDocument(uri2, '🇦🇹')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replaceAll('REPLACE', PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo 🇦🇹 bar 🇦🇹 baz')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can concat', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'bar')\n        const doc3 = createFakeDocument(uri3, 'baz')\n\n        const first = PromptString.fromDocumentText(doc1)\n        const second = PromptString.fromDocumentText(doc2)\n        const third = PromptString.fromDocumentText(doc3)\n\n        const concatenated = first.concat(second, third)\n\n        expect(concatenated.toString()).toBe('foobarbaz')\n        expect(concatenated.getReferences()).toEqual([uri1, uri2, uri3])\n    })\n\n    it('detects invalid PromptStrings passed to utility types', () => {\n        const realPromptString = ps`foo`\n        const fakePromptString = 'foo' as any as PromptString\n\n        expect(() => ps`${fakePromptString}`).toThrowError()\n        expect(() => PromptString.join([fakePromptString], realPromptString)).toThrowError()\n        expect(() => realPromptString.replaceAll('', fakePromptString)).toThrowError()\n        expect(() => realPromptString.concat(fakePromptString)).toThrowError()\n    })\n\n    it('can not mutate the references list', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const doc = createFakeDocument(uri, 'foo')\n        const ps = PromptString.fromDocumentText(doc)\n\n        const arr: any = ps.getReferences()\n        // biome-ignore lint/performance/noDelete: 🏴‍☠️\n        delete arr[0]\n\n        expect(ps.getReferences()).toEqual([uri])\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/menus/index.ts:152-179"",""content"":""\n            // On selecting a default command\n            if (selection.type === 'default' && selection.command) {\n                // Check if it's an ask command\n                if (selection.key === 'ask') {\n                    // show input box if no value\n                    if (value.length === 0) {\n                        void commands.executeCommand('cody.chat.panel.new')\n                    } else {\n                        void executeChat({\n                            text: value.trim(),\n                            submitType: 'user-newchat',\n                            source,\n                        })\n                    }\n                    quickPick.hide()\n                    return\n                }\n\n                // Check if it's an edit command\n                if (selection.key === 'edit') {\n                    void executeEdit({\n                        configuration: { instruction: value },\n                        source,\n                    })\n                    quickPick.hide()\n                    return\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:372-380"",""content"":""interface Prompt {\n    snippets: { uri: vscode.Uri; content: PromptString }[]\n\n    uri: vscode.Uri\n    prefix: PromptString\n    suffix: PromptString\n\n    languageId: string\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-mixin.ts:0-56"",""content"":""import type { ChatMessage } from '../chat/transcript/messages'\nimport { PromptString, ps } from './prompt-string'\n\nconst identity = ps`Reply as Cody, a coding assistant developed by Sourcegraph.`\nconst hallucinate = ps`If context is available: never make any assumptions nor provide any misleading or hypothetical examples.`\nconst CODY_INTRO_PROMPT = ps`(${identity} ${hallucinate}) `\n\n/**\n * Prompt mixins elaborate every prompt presented to the LLM.\n * Add a prompt mixin to prompt for cross-cutting concerns relevant to multiple commands.\n */\nexport class PromptMixin {\n    private static mixins: PromptMixin[] = []\n    private static customMixin: PromptMixin[] = []\n    // The prompt that instructs Cody to identify itself and avoid hallucinations.\n    private static defaultMixin: PromptMixin = new PromptMixin(CODY_INTRO_PROMPT)\n\n    /**\n     * Adds a custom prompt mixin but not to the global set to make sure it will not be added twice\n     * and any new change could replace the old one.\n     */\n    public static addCustom(mixin: PromptMixin): void {\n        PromptMixin.customMixin = [mixin]\n    }\n\n    /**\n     * Prepends all mixins to `humanMessage`. Modifies and returns `humanMessage`.\n     */\n    public static mixInto(humanMessage: ChatMessage): ChatMessage {\n        // Default Mixin is added at the end so that it cannot be overriden by a custom mixin.\n        const mixins = PromptString.join(\n            [...PromptMixin.mixins, ...PromptMixin.customMixin, PromptMixin.defaultMixin].map(\n                mixin => mixin.prompt\n            ),\n            ps`\\n\\n`\n        )\n        if (mixins) {\n            // Stuff the prompt mixins at the start of the human text.\n            // Note we do not reflect them in `text`.\n            return {\n                ...humanMessage,\n                text: ps`${mixins}${humanMessage.text ? humanMessage.text : ''}`,\n            }\n        }\n        return humanMessage\n    }\n\n    /**\n     * Creates a mixin with the given, fixed prompt to insert.\n     */\n    constructor(private readonly prompt: PromptString) {}\n}\n\nexport function newPromptMixin(text: PromptString): PromptMixin {\n    return new PromptMixin(text)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:0-437"",""content"":""import dedent from 'dedent'\nimport type * as vscode from 'vscode'\nimport type { ChatMessage, SerializedChatMessage } from '../chat/transcript/messages'\nimport type { ContextItem } from '../codebase-context/messages'\nimport type { TerminalOutputArguments } from '../commands/types'\nimport { markdownCodeBlockLanguageIDForFilename } from '../common/languages'\nimport type { AutocompleteContextSnippet, DocumentContext } from '../completions/types'\nimport type { ConfigGetter } from '../configuration'\nimport type { ActiveTextEditorDiagnostic } from '../editor'\nimport { createGitDiff } from '../editor/create-git-diff'\nimport { displayPath } from '../editor/displayPath'\nimport { getEditorInsertSpaces, getEditorTabSize } from '../editor/utils'\n\n// This module is designed to encourage, and to some degree enforce, safe\n// handling of file content that gets constructed into prompts. It works this\n// way:\n//\n// - Literal strings are considered \""safe\"". Literal strings are constructed with\n//   a tagged template function, `ps`, and a linter in `/lint/safe-prompts.ts`\n//   ensures the function is only used in a tagged template literal, not\n//   aliased, etc.\n// - There are a small set of functions for conveniently constructing strings\n//   from file contents. Use of these functions needs to be continually audited\n//   to ensure they're safe.\n// - Strings constructed from other safe strings, with `ps` or helper methods,\n//   are also safe.\n// - Components sending prompts to LLMs should consume safe strings, not raw\n//   strings.\n//\n// This setup is designed to detect programming errors, not thwart malicious\n// attacks.\n\n/**\n * A \""safe\"" string class for constructing prompts.\n */\nexport class PromptString {\n    /**\n     * @deprecated Do not use the constructor directly. Instead, use ps`...` or a\n     * PromptString helper to handle string data for prompts safely\n     *\n     * @param __debug The string that is wrapped by this PromptString. This is\n     * useful for debugging since it will be shown when `console.log()` is called\n     * with this prompt string.\n     */\n    // @ts-expect-error: We don't want anyone to read __debug. This is just a helper\n    // for console.log debugging so this error is expected.\n    constructor(private __debug: string) {}\n\n    public toString(): string {\n        return internal_toString(this)\n    }\n\n    public getReferences(): readonly StringReference[] {\n        return internal_toReferences(this)\n    }\n\n    public toJSON(): string {\n        return internal_toString(this)\n    }\n\n    public get length(): number {\n        return internal_toString(this).length\n    }\n\n    public slice(start?: number, end?: number): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).slice(start, end),\n            internal_toReferences(this)\n        )\n    }\n\n    public trim(): PromptString {\n        return internal_createPromptString(internal_toString(this).trim(), internal_toReferences(this))\n    }\n\n    public trimEnd(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).trimEnd(),\n            internal_toReferences(this)\n        )\n    }\n\n    public indexOf(searchString: string | PromptString, start?: number): number {\n        return this.toString().indexOf(searchString.toString(), start)\n    }\n\n    public split(separator: string): PromptString[] {\n        const string = internal_toString(this)\n        const references = internal_toReferences(this)\n\n        const split = string.split(separator)\n        const result: PromptString[] = []\n        for (const part of split) {\n            result.push(internal_createPromptString(part, references))\n        }\n        return result\n    }\n\n    public toLocaleLowerCase(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).toLocaleLowerCase(),\n            internal_toReferences(this)\n        )\n    }\n\n    public includes(searchString: string | PromptString, position?: number): boolean {\n        return internal_toString(this).includes(\n            typeof searchString === 'string' ? searchString : internal_toString(searchString),\n            position\n        )\n    }\n\n    public static join(promptStrings: PromptString[], boundary: PromptString): PromptString {\n        const stringBoundary = internal_toString(boundary)\n\n        const buffer: string[] = []\n        const references: Set<StringReference> = new Set(internal_toReferences(boundary))\n        for (const promptString of promptStrings) {\n            if (!isValidPromptString(promptString)) {\n                throw new Error('Invalid prompt string')\n            }\n\n            buffer.push(internal_toString(promptString))\n            for (const reference of internal_toReferences(promptString)) {\n                references.add(reference)\n            }\n        }\n\n        return internal_createPromptString(buffer.join(stringBoundary), [...references])\n    }\n\n    public concat(...promptStrings: readonly PromptString[]): PromptString {\n        const stringPromptString: string[] = []\n        const references: (readonly StringReference[])[] = []\n        for (const promptString of promptStrings) {\n            stringPromptString.push(internal_toString(promptString))\n            references.push(internal_toReferences(promptString))\n        }\n\n        return internal_createPromptString(internal_toString(this).concat(...stringPromptString), [\n            ...internal_toReferences(this),\n            ...references.flat(),\n        ])\n    }\n\n    public replace(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replace(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    public replaceAll(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replaceAll(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    // Use this function to create a user-generated PromptString from the VS Code\n    // configuration object.\n    public static fromConfig<D>(\n        config: ConfigGetter<string>,\n        path: string,\n        defaultValue: D\n    ): PromptString | D {\n        const raw = config.get<string | null>(path, null)\n        const value = raw === null ? defaultValue : internal_createPromptString(raw, [])\n        return value\n    }\n\n    public static fromEditorIndentString(\n        uri: vscode.Uri,\n        workspace: Pick<typeof vscode.workspace, 'getConfiguration'>,\n        window: Pick<typeof vscode.window, 'visibleTextEditors'>\n    ) {\n        const insertSpaces = getEditorInsertSpaces(uri, workspace, window)\n        const tabSize = getEditorTabSize(uri, workspace, window)\n\n        const indentString = insertSpaces ? ' '.repeat(tabSize) : '\\t'\n        // Note: even though this uses the URI, it does not actually contain any\n        // information from the URI, so we leave the references empty for now (the\n        // content is always just whitespace)\n        return internal_createPromptString(indentString, [])\n    }\n\n    public static fromDisplayPath(uri: vscode.Uri) {\n        return internal_createPromptString(displayPath(uri), [uri])\n    }\n\n    public static fromDocumentText(document: vscode.TextDocument, range?: vscode.Range): PromptString {\n        return internal_createPromptString(document.getText(range), [document.uri])\n    }\n\n    public static fromGitDiff(uri: vscode.Uri, oldContent: string, newContent: string) {\n        const diff = createGitDiff(displayPath(uri), oldContent, newContent)\n        return internal_createPromptString(diff, [uri])\n    }\n\n    // Replaces the following placeholder with data from the diagnostics:\n    // {type}, {filePath}, {prefix}, {message}, {languageID}, {code}\n    //\n    // TODO: This should probably take a vscode.Diagnostic object instead.\n    public static fromTextEditorDiagnostic(\n        diagnostic: ActiveTextEditorDiagnostic,\n        uri: vscode.Uri\n    ): {\n        type: PromptString\n        text: PromptString\n        message: PromptString\n    } {\n        const ref = [uri]\n        return {\n            type: internal_createPromptString(diagnostic.type, ref),\n            text: internal_createPromptString(diagnostic.text, ref),\n            message: internal_createPromptString(diagnostic.message, ref),\n        }\n    }\n\n    public static fromMarkdownCodeBlockLanguageIDForFilename(uri: vscode.Uri) {\n        return internal_createPromptString(markdownCodeBlockLanguageIDForFilename(uri), [uri])\n    }\n\n    public static fromDiagnostic(uri: vscode.Uri, diagnostic: vscode.Diagnostic) {\n        const ref = [uri]\n        return {\n            message: internal_createPromptString(diagnostic.message, ref),\n            source: diagnostic.source ? internal_createPromptString(diagnostic.source, ref) : undefined,\n            relatedInformation: diagnostic.relatedInformation\n                ? diagnostic.relatedInformation.map(info => ({\n                      message: internal_createPromptString(info.message, [uri, info.location.uri]),\n                  }))\n                : undefined,\n        }\n    }\n\n    public static fromDocumentSymbol(\n        uri: vscode.Uri,\n        documentSymbol: vscode.DocumentSymbol,\n        SymbolKind: typeof vscode.SymbolKind\n    ) {\n        const symbolKind = documentSymbol.kind ? SymbolKind[documentSymbol.kind].toLowerCase() : ''\n        const symbolPrompt = documentSymbol.name ? `#${documentSymbol.name} (${symbolKind})` : ''\n        return internal_createPromptString(symbolPrompt, [uri])\n    }\n\n    // TODO: Find a better way to handle this. Maybe we should migrate the default commands json to\n    // a TypesScript object?\n    public static fromDefaultCommands(\n        commands: { [name: string]: { prompt: string } },\n        name: 'doc' | 'explain' | 'test' | 'smell'\n    ) {\n        const prompt = commands[name].prompt\n        return internal_createPromptString(prompt, [])\n    }\n\n    // TODO: Need to check in the runtime if we have something we can append as an URI here\n    public static fromTerminalOutputArguments(output: TerminalOutputArguments) {\n        return {\n            name: internal_createPromptString(output.name, []),\n            selection: output.selection ? internal_createPromptString(output.selection, []) : undefined,\n            creationOptions: output.creationOptions\n                ? internal_createPromptString(JSON.stringify(output.creationOptions), [])\n                : undefined,\n        }\n    }\n\n    public static fromAutocompleteDocumentContext(docContext: DocumentContext, uri: vscode.Uri) {\n        const ref = [uri]\n        return {\n            prefix: internal_createPromptString(docContext.prefix, ref),\n            suffix: internal_createPromptString(docContext.suffix, ref),\n            injectedPrefix: docContext.injectedPrefix\n                ? internal_createPromptString(docContext.injectedPrefix, ref)\n                : null,\n        }\n    }\n\n    public static fromAutocompleteContextSnippet(contextSnippet: AutocompleteContextSnippet) {\n        const ref = [contextSnippet.uri]\n        return {\n            content: internal_createPromptString(contextSnippet.content, ref),\n            symbol:\n                'symbol' in contextSnippet\n                    ? internal_createPromptString(contextSnippet.symbol, ref)\n                    : undefined,\n        }\n    }\n\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n    // panel or restarting the IDE makes those references evaporate.\n    //\n    // On the other hand, you might pull up an old chat transcript and all the\n    // file paths are different now because you moved a folder or something. We're\n    // thinking maybe we should have a concept of \""resolved\"" references where we\n    // keep (repo, repo relative path) pairs for the serialized representation\n    // or something.\n    //\n    // Additionally, the serialized chat message format is also used when sending\n    // chat messages back to the Agent. Right now, however, when we send new\n    // messages, this is done via the `chat/submitMessage` notification which does\n    // not deserialize from chat message. To make sure we do not introduce places\n    // where we deserialize chat messages this way, the function is marked unsafe\n    // for now.\n    public static unsafe_deserializeChatMessage(serializedMessage: SerializedChatMessage): ChatMessage {\n        return {\n            ...serializedMessage,\n            text: serializedMessage.text\n                ? internal_createPromptString(serializedMessage.text, [])\n                : undefined,\n        }\n    }\n}\n\ntype TemplateArgs = readonly (PromptString | '' | number)[]\n\n/**\n * Constructs PromptStrings from template literals, numbers or other\n * PromptStrings. A linter in `/lint/safe-prompts.ts` checks that this function\n * is never used except in a tagged template literal.\n *\n * @param format the format string pieces.\n * @param args the arguments to splice into the format string.\n */\nexport function ps(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    if (!(Array.isArray(format) && Object.isFrozen(format) && format.length > 0)) {\n        // Deter casual direct calls.\n        throw new Error('ps is only intended to be used in tagged template literals.')\n    }\n\n    const buffer: string[] = []\n    const references: Set<StringReference> = new Set()\n    for (let i = 0; i < format.length; i++) {\n        buffer.push(format[i])\n        if (i < args.length) {\n            const arg = args[i]\n\n            if (typeof arg === 'number') {\n                // Boxed number types are not allowed, only number literals\n                buffer.push(Number.prototype.toString.call(arg))\n            } else if (arg === '') {\n                // We allow empty strings for situations like this:\n                // ps`... ${foo ? foo : ''}...`\n            } else if (arg instanceof PromptString) {\n                // PromptString inherit all references\n                buffer.push(internal_toString(arg))\n                for (const ref of internal_toReferences(arg)) {\n                    references.add(ref)\n                }\n            } else {\n                // Do not allow arbitrary types like dynamic strings, classes with\n                // toString, etc. here.\n                throw new Error(\n                    'Use ps`...` or a PromptString helper to handle string data for prompts safely.'\n                )\n            }\n        }\n    }\n\n    return internal_createPromptString(buffer.join(''), [...references])\n}\n\n// A version of ps that removes the leading indentation of the first line.\nexport function psDedent(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    const promptString = ps(format, ...args)\n    const dedented = dedent(internal_toString(promptString))\n    return internal_createPromptString(dedented, internal_toReferences(promptString))\n}\n\n// When PromptStrings are created, their properties are stored in a side pocket\n// WeakMap. Consumers can do what they like with the PromptString, all of the\n// operations use data in the map and so are protected from the PromptString\n// constructor being disclosed, prototype pollution, property manipulation, etc.\ntype StringReference = vscode.Uri\nconst pocket = new WeakMap<PromptString, PromptStringPocket>()\nclass PromptStringPocket {\n    constructor(\n        public value: string,\n        // We're using a set inside the pocket so we get deduplication for free and\n        // by converting from array (input) to Set, we also guarantee shallow copies\n        // are being created.\n        public references: Set<StringReference>\n    ) {}\n}\n\nfunction internal_createPromptString(\n    string: string,\n    references: readonly StringReference[]\n): PromptString {\n    const handle = new PromptString(string)\n    // Create a shallow copy of the references list as a set, so it's both de-duped\n    // and can not be mutated by the caller\n    pocket.set(handle, new PromptStringPocket(string, new Set(references)))\n    return handle\n}\nfunction internal_toString(s: PromptString): string {\n    return pocket.get(s)!.value\n}\nfunction internal_toReferences(s: PromptString): readonly StringReference[] {\n    // Return a shallow copy of the references so it can not be mutated\n    return [...pocket.get(s)!.references.values()]\n}\n\n// Validate that an input is indeed a PromptString and not just typecast to it.\nexport function isValidPromptString(promptString: PromptString) {\n    return pocket.has(promptString)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:43-50"",""content"":""export const PROMPT = psDedent`\n    <source file=\""{filename}\"">\n    {source}\n    </source>\n    <recent-change>\n    {git-diff}\n    </recent-change>\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_009/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that executes the ""Find Code Smells"" command is located in the file `cody_test/vscode/src/commands/execute/smell.ts`. Here is the relevant function:

```typescript
export async function executeSmellCommand(
    args?: Partial<CodyCommandArgs>
): Promise<ChatCommandResult | undefined> {
    return wrapInActiveSpan('command.smell', async span => {
        span.setAttribute('sampled', true)
        logDebug('executeSmellCommand', 'executing', { args })
        telemetryService.log('CodyVSCodeExtension:command:smell:executed', {
            useCodebaseContex: false,
            requestID: args?.requestID,
            source: args?.source,
            traceId: span.spanContext().traceId,
        })
        telemetryRecorder.recordEvent('cody.command.smell', 'executed', {
            metadata: {
                useCodebaseContex: 0,
            },
            interactionID: args?.requestID,
            privateMetadata: {
                requestID: args?.requestID,
                source: args?.source,
                traceId: span.spanContext().traceId,
            },
        })

        return {
            type: 'chat',
            session: await executeChat(await smellCommand(span, args)),
        }
    })
}
```

This function, `executeSmellCommand`, is responsible for executing the ""Find Code Smells"" command. It logs telemetry data, wraps the execution in a span for tracing, and ultimately calls the `smellCommand` function to perform the actual command logic.","Where is the code that executes the ""Find Code Smells"" command?","[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:47-77"",""content"":""    private async createCommandCodeAction(\n        document: vscode.TextDocument,\n        diagnostics: vscode.Diagnostic[],\n        range: vscode.Range\n    ): Promise<vscode.CodeAction> {\n        const action = new vscode.CodeAction('Ask Cody to Fix', vscode.CodeActionKind.QuickFix)\n        const instruction = await this.getCodeActionInstruction(\n            document.uri,\n            PromptString.fromDocumentText(document, range),\n            diagnostics\n        )\n        const source = 'code-action:fix'\n        action.command = {\n            command: 'cody.command.edit-code',\n            arguments: [\n                {\n                    configuration: { instruction, range, intent: 'fix', document },\n                    source,\n                    telemetryMetadata: {\n                        diagnostics: diagnostics.map(diagnostic => ({\n                            code: getDiagnosticCode(diagnostic.code),\n                            source: diagnostic.source,\n                        })),\n                    },\n                } satisfies ExecuteEditArguments,\n            ],\n            title: 'Ask Cody to Fix',\n        }\n        action.diagnostics = diagnostics\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:258-301"",""content"":""        version: 4.0.16\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n    devDependencies:\n      '@types/crypto-js':\n        specifier: ^4.2.2\n        version: 4.2.2\n      '@types/dedent':\n        specifier: ^0.7.0\n        version: 0.7.0\n      '@types/diff':\n        specifier: ^5.0.9\n        version: 5.0.9\n      '@types/dompurify':\n        specifier: ^3.0.2\n        version: 3.0.2\n      '@types/highlight.js':\n        specifier: ^9.12.4\n        version: 9.12.4\n      '@types/isomorphic-fetch':\n        specifier: ^0.0.39\n        version: 0.0.39\n      '@types/lodash':\n        specifier: ^4.14.195\n        version: 4.14.195\n      '@types/marked':\n        specifier: ^5.0.0\n        version: 5.0.0\n      '@types/node-fetch':\n        specifier: ^2.6.4\n        version: 2.6.4\n      '@types/vscode':\n        specifier: ^1.80.0\n        version: 1.80.0\n\n  vscode:\n    dependencies:\n      '@anthropic-ai/sdk':\n        specifier: ^0.4.2\n        version: 0.4.3\n      '@floating-ui/react':\n        specifier: ^0.26.9\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:23-42"",""content"":""    private createCommandCodeAction(\n        uri: vscode.Uri,\n        diagnostics: vscode.Diagnostic[]\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction('Ask Cody to Explain', vscode.CodeActionKind.QuickFix)\n        const instruction = this.getCodeActionInstruction(uri, diagnostics)\n        action.command = {\n            command: 'cody.action.chat',\n            arguments: [\n                {\n                    text: instruction,\n                    source: 'code-action:explain',\n                    submitType: 'user-newchat',\n                } satisfies ExecuteChatArguments,\n            ],\n            title: 'Ask Cody to Explain',\n        }\n        action.diagnostics = diagnostics\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/strategies.ts:0-29"",""content"":""// FixupController has pluggable strategies for controls and presentation. This\n// file defines the interfaces for those strategies.\n\nimport type * as vscode from 'vscode'\nimport type { FixupFile } from './FixupFile'\nimport type { FixupTask } from './FixupTask'\n\n// An interface for decorating fixup tasks with controls.\nexport interface FixupControlApplicator extends vscode.Disposable {\n    didUpdateTask(task: FixupTask): void\n    didDeleteTask(task: FixupTask): void\n    // Called when visible files changed.\n    // TODO: This API design is gross: this is *not* called when a new task\n    // is created in a file that is already visible. It *is* called every time\n    // visible files change, so be prepared to handle repeated calls with\n    // an empty or unchanged set of files efficiently. Unearth a consistent\n    // API here.\n    visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void\n}\n\n// A FixupControlApplicator which does not present any controls for fixup\n// tasks.\nexport class NullFixupControlApplicator implements FixupControlApplicator {\n    public didUpdateTask(task: FixupTask): void {}\n    public didDeleteTask(task: FixupTask): void {}\n    public visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void {}\n    public dispose(): void {}\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/document.ts:39-52"",""content"":""    private createCommandCodeAction(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        displayText: string\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction(displayText, vscode.CodeActionKind.RefactorRewrite)\n        const source = 'code-action:document'\n        action.command = {\n            command: 'cody.command.document-code',\n            arguments: [{ source } satisfies Partial<CodyCommandArgs>],\n            title: displayText,\n        }\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1254-1289"",""content"":""    \""@vscode/codicons\"": \""^0.0.35\"",\n    \""@vscode/webview-ui-toolkit\"": \""^1.2.2\"",\n    \""async-mutex\"": \""^0.4.0\"",\n    \""axios\"": \""^1.3.6\"",\n    \""classnames\"": \""^2.3.2\"",\n    \""crypto-js\"": \""^4.2.0\"",\n    \""detect-indent\"": \""^7.0.1\"",\n    \""diff\"": \""^5.2.0\"",\n    \""fast-xml-parser\"": \""^4.3.2\"",\n    \""glob\"": \""^7.2.3\"",\n    \""ini\"": \""^4.1.2\"",\n    \""isomorphic-fetch\"": \""^3.0.0\"",\n    \""js-levenshtein\"": \""^1.1.6\"",\n    \""lexical\"": \""^0.13.1\"",\n    \""lodash\"": \""^4.17.21\"",\n    \""lru-cache\"": \""^10.0.0\"",\n    \""mkdirp\"": \""^3.0.1\"",\n    \""os-browserify\"": \""^0.3.0\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""proxy-agent\"": \""^6.4.0\"",\n    \""re2-wasm\"": \""^1.0.2\"",\n    \""semver\"": \""^7.5.4\"",\n    \""socks-proxy-agent\"": \""^8.0.1\"",\n    \""unzipper\"": \""^0.10.14\"",\n    \""uuid\"": \""^9.0.0\"",\n    \""vscode-languageserver-textdocument\"": \""^1.0.8\"",\n    \""vscode-uri\"": \""^3.0.7\"",\n    \""web-tree-sitter\"": \""^0.21.0\"",\n    \""wink-nlp-utils\"": \""^2.1.0\""\n  },\n  \""devDependencies\"": {\n    \""@google-cloud/pubsub\"": \""^3.7.3\"",\n    \""@playwright/test\"": \""1.39.0\"",\n    \""@pollyjs/adapter-node-http\"": \""^6.0.6\"",\n    \""@pollyjs/core\"": \""^6.0.6\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:144-164"",""content"":""- [ ] Verify that the chat executed by running the command appears in the chat list in the left hand panel.\n\n#### Editing\n\n- [ ] Highlight a section of code.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Cody: Edit Code`.\n- [ ] Provide instructions for how Cody should edit the selected code.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies edits to the selected code, per the user’s instructions\n- [ ] Verify that you can see a diff view of the edit in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the edit by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Generating code\n\n- [ ] Move the cursor to an empty line, do not highlight any selection.\n- [ ] Click the Code Action lightbulb icon in the project file.\n- [ ] Select `Cody: Generate Code`.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:0-34"",""content"":""{\n  \""actionscript\"": [\""as\""],\n  \""ada\"": [\""adb\"", \""ada\"", \""ads\""],\n  \""apache\"": [\""apacheconf\""],\n  \""apex\"": [\""cls\"", \""apex\"", \""trigger\""],\n  \""applescript\"": [\""applescript\"", \""scpt\""],\n  \""beancount\"": [\""beancount\""],\n  \""bibtex\"": [\""bib\""],\n  \""clojure\"": [\""clj\"", \""cljs\"", \""cljx\""],\n  \""cmake\"": [\""cmake\"", \""cmake.in\"", \""in\""],\n  \""coffescript\"": [\""coffee\"", \""cake\"", \""cson\"", \""cjsx\"", \""iced\""],\n  \""cpp\"": [\""c\"", \""cc\"", \""cpp\"", \""cxx\"", \""c++\"", \""h++\"", \""hh\"", \""h\"", \""hpp\"", \""pc\"", \""pcc\""],\n  \""csharp\"": [\""cs\"", \""csx\""],\n  \""css\"": [\""css\""],\n  \""cuda\"": [\""cu\"", \""cuh\""],\n  \""d\"": [\""d\""],\n  \""dot\"": [\""dot\""],\n  \""dart\"": [\""dart\""],\n  \""diff\"": [\""diff\"", \""patch\""],\n  \""dockerfile\"": [\""Dockerfile\""],\n  \""django\"": [\""jinja\""],\n  \""dos\"": [\""bat\"", \""cmd\""],\n  \""elixir\"": [\""ex\"", \""exs\""],\n  \""elm\"": [\""elm\""],\n  \""erlang\"": [\""erl\""],\n  \""fortran\"": [\""f\"", \""for\"", \""frt\"", \""fr\"", \""forth\"", \""4th\"", \""fth\""],\n  \""fsharp\"": [\""fs\""],\n  \""go\"": [\""go\""],\n  \""graphql\"": [\""graphql\""],\n  \""groovy\"": [\""groovy\""],\n  \""haml\"": [\""haml\""],\n  \""handlebars\"": [\""hbs\"", \""handlebars\""],\n  \""haskell\"": [\""hs\"", \""hsc\""],\n  \""hcl\"": [\""hcl\"", \""nomad\"", \""tf\"", \""tfvars\"", \""workflow\""],\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-tests/test-data/graph-identifiers.tsx:50-108"",""content"":""\nfunction signature()\n//                |\n\n// ------------------------------------\n\n// comment\n//       |\n\n// ------------------------------------\n\n/**\n * comment\n //      |\n */\n\n// ------------------------------------\n\nfunction functionName() {}\n//                  |\n\n// ------------------------------------\n\nfunction returnStatement() {\n    return\n    //   |\n}\n\n// ------------------------------------\n\nfunction returnStatementValue(value: Agent, flag?: boolean) {\n    return 'asd'\n    //     |\n}\n\n// ------------------------------------\n\ninterface TestInterface {\n    //                  |\n}\n\n// ------------------------------------\n\ntype TestType = {\n    //          |\n}\n\n// ------------------------------------\n\nreturnStatementValue('value')\n//                   |\n\n// ------------------------------------\n\nreturnStatementValue('value', false)\n//                            |\n\n// ------------------------------------\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:0-29"",""content"":""{\n  \""private\"": true,\n  \""name\"": \""@sourcegraph/cody\"",\n  \""description\"": \""Cody, the code AI that writes code, fixes bugs, and answers questions using the code graph\"",\n  \""license\"": \""Apache-2.0\"",\n  \""homepage\"": \""https://cody.dev\"",\n  \""repository\"": {\n    \""type\"": \""git\"",\n    \""url\"": \""https://github.com/sourcegraph/cody\""\n  },\n  \""engines\"": {\n    \""node\"": \""^v20.4.0\"",\n    \""pnpm\"": \""^8.6.7\""\n  },\n  \""browser\"": {\n    \""fs\"": false\n  },\n  \""scripts\"": {\n    \""build\"": \""tsc --build\"",\n    \""watch\"": \""tsc --build --watch\"",\n    \""check\"": \""pnpm run -s biome && pnpm run -s check:css\"",\n    \""check:css\"": \""stylelint --quiet --cache '**/*.css'\"",\n    \""biome\"": \""biome check --apply --error-on-warnings .\"",\n    \""test\"": \""vitest\"",\n    \""test:unit\"": \""vitest run\"",\n    \""test:integration\"": \""pnpm -C vscode test:integration\"",\n    \""test:e2e\"": \""pnpm -C vscode test:e2e\"",\n    \""generate-agent-kotlin-bindings\"": \""pnpm build && pnpm dlx ts-node agent/src/cli/scip-codegen/command.ts --output ../jetbrains/src/main/kotlin/com/sourcegraph/cody/protocol_generated\"",\n    \""update-agent-recordings\"": \""pnpm build && CODY_KEEP_UNUSED_RECORDINGS=false CODY_RECORD_IF_MISSING=true vitest agent/src/index.test.ts\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/README.md:0-3"",""content"":""This is a second workspace folder included in `multi-root.code-workspace` used by integration\ntests in `test/integration/multi-root` for testing in multi-root workspaces.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/smell.ts:60-89"",""content"":""export async function executeSmellCommand(\n    args?: Partial<CodyCommandArgs>\n): Promise<ChatCommandResult | undefined> {\n    return wrapInActiveSpan('command.smell', async span => {\n        span.setAttribute('sampled', true)\n        logDebug('executeSmellCommand', 'executing', { args })\n        telemetryService.log('CodyVSCodeExtension:command:smell:executed', {\n            useCodebaseContex: false,\n            requestID: args?.requestID,\n            source: args?.source,\n            traceId: span.spanContext().traceId,\n        })\n        telemetryRecorder.recordEvent('cody.command.smell', 'executed', {\n            metadata: {\n                useCodebaseContex: 0,\n            },\n            interactionID: args?.requestID,\n            privateMetadata: {\n                requestID: args?.requestID,\n                source: args?.source,\n                traceId: span.spanContext().traceId,\n            },\n        })\n\n        return {\n            type: 'chat',\n            session: await executeChat(await smellCommand(span, args)),\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:116-145"",""content"":""                : ''\n            return fixPathSep(\n                workspaceDisplayPrefix + uri.path.slice(workspacePrefix.length + 1),\n                isWindows,\n                uri.scheme\n            )\n        }\n    }\n\n    if (uri.scheme === 'file') {\n        // Show the absolute file path because we couldn't find a parent workspace folder.\n        return fixPathSep(uri.fsPath, isWindows, uri.scheme)\n    }\n\n    // Show the full URI for anything else.\n    return uri\n}\n\n/**\n * Fixes the path separators for Windows paths. This makes it possible to write cross-platform\n * tests.\n */\nfunction fixPathSep(fsPath: string, isWindows: boolean, scheme: string): string {\n    return isWindows && scheme === 'file' ? fsPath.replaceAll('/', '\\\\') : fsPath\n}\n\nexport function uriHasPrefix(uri: URI, prefix: URI, isWindows: boolean): boolean {\n    // On Windows, it's common to have drive letter casing mismatches (VS Code's APIs tend to normalize\n    // to lowercase, but many other tools use uppercase and we don't know where the context file came\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/gradlew.bat:0-25"",""content"":""@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the \""License\"");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an \""AS IS\"" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if \""%DEBUG%\""==\""\"" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \""%OS%\""==\""Windows_NT\"" setlocal\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:108-123"",""content"":""- [ ] Verify that Cody adds documentation above the function that contains your cursor.\n\n### Smell\n\n- [ ] Verify that the option to run the `Find Code Smells` command is available in the following locations:\n  - [ ] Sidebar `Find Code Smells`\n  - [ ] Context (right-click) menu `Cody > Find Code Smells`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Find Code Smells`\n  - [ ] Cody Command Menu (option+c, `Find Code Smells`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Find Code Smells` command.\n- [ ] Verify that Cody provides suggestion for how to improve the selected code in a new chat window.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Find Code Smells` command again\n- [ ] Verify that Cody provides suggestion for how to improve the function that contains your cursor in a new chat window.\n- [ ] Verify that the chat executed by running the command is added to the sidebar under `Chats`.\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_010/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"In the provided codebase context, the check for ignored files is primarily performed in the `IgnoreHelper` class, specifically in the `isIgnored` method. Here is the relevant part of the code from `cody_test/lib/shared/src/cody-ignore/ignore-helper.ts`:

```typescript
public isIgnored(uri: URI): boolean {
    // Do not ignore if the feature is not enabled
    if (!this.isActive) {
        return false
    }

    // Return all https URIs on the assumption that they origin from
    // remote context (e.g. unified, multi-repo) files, which are already
    // filtered by the backend to respect codyignore files during sync time.
    if (uri.scheme === 'https') {
        return false
    }

    // Ignore all other non-file URIs
    if (uri.scheme !== 'file') {
        return true
    }

    this.ensureFileUri('uri', uri)
    this.ensureAbsolute('uri', uri)
    const workspaceRoot = this.findWorkspaceRoot(uri)

    // Not in workspace so just use default rules against the filename.
    // This ensures we'll never send something like `.env` but it won't handle
    // if default rules include folders like `a/b` because we have nothing to make
    // a relative path from.
    if (!workspaceRoot) {
        return this.getDefaultIgnores().ignores(uriBasename(uri))
    }

    const relativePath = pathFunctionsForURI(workspaceRoot).relative(workspaceRoot.path, uri.path)
    const rules = this.workspaceIgnores.get(workspaceRoot.toString()) ?? this.getDefaultIgnores()
    return rules.ignores(relativePath) ?? false
}
```

Additionally, there are tests for this functionality in `cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts` to ensure that the `isIgnored` method behaves as expected under various conditions. For example:

```typescript
it('returns true for a top-level file ignored at the top level', () => {
    setWorkspace1Ignores(['ignored.txt'])
    expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored.txt'))).toBe(true)
})

it('returns false for a top-level file not ignored at the top level', () => {
    setWorkspace1Ignores(['ignored.txt'])
    expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'not_ignored.txt'))).toBe(false)
})
```

These tests validate that the `isIgnored` method correctly identifies whether files should be ignored based on the ignore rules set for the workspace.",Where do we check for ignored files?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:134-163"",""content"":""\n    it.skip('throws on a relative Uri', () => {\n        const relativeFileUri = URI.parse('file://a')\n        expect(() => ignore.isIgnored(relativeFileUri)).toThrow()\n    })\n\n    it('handles comments and blank lines in the ignore file', () => {\n        setWorkspace1Ignores([\n            '# header comment',\n            '#.foo',\n            '',\n            '.bar # an explanatory reason that .bar is ignored',\n        ])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.env'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.foo'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.bar'))).toBe(true)\n    })\n\n    describe('returns the correct value for a sample of rules', () => {\n        beforeEach(() => {\n            setWorkspace1Ignores([\n                'node_modules/',\n                '**/cody',\n                '**/foo/**',\n                '/bar',\n                'fooz',\n                'barz/*',\n                '.git',\n                'one/**/two',\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:30-173"",""content"":""export class IgnoreHelper {\n    /**\n     * A map of workspace roots to their ignore rules.\n     */\n    private workspaceIgnores = new Map<ClientWorkspaceRootURI, Ignore>()\n    public hasCodyIgnoreFiles = false\n    /**\n     * Check if the configuration is enabled or not\n     * Do not ignore files if the feature is not enabled\n     * TODO: Remove this once it's ready for GA\n     */\n    public isActive = false\n    public setActiveState(isActive: boolean): void {\n        this.isActive = isActive\n    }\n\n    /**\n     * Builds and caches a single ignore set for all nested ignore files within a workspace root.\n     * @param workspaceRoot The workspace root.\n     * @param ignoreFiles The URIs and content of all ignore files within the root.\n     */\n    public setIgnoreFiles(workspaceRoot: URI, ignoreFiles: IgnoreFileContent[]): void {\n        if (!this.isActive) {\n            return\n        }\n\n        this.ensureAbsolute('workspaceRoot', workspaceRoot)\n\n        const rules = this.getDefaultIgnores()\n        for (const ignoreFile of ignoreFiles) {\n            this.ensureValidCodyIgnoreFile('ignoreFile.uri', ignoreFile.uri)\n\n            // Compute the relative path from the workspace root to the folder this ignore\n            // file applies to.\n            const effectiveDir = ignoreFileEffectiveDirectory(ignoreFile.uri)\n            const relativeFolderUriPath = pathFunctionsForURI(workspaceRoot).relative(\n                workspaceRoot.path,\n                effectiveDir.path\n            )\n\n            // Build the ignore rule with the relative folder path applied to the start of each rule.\n            for (let ignoreLine of ignoreFile.content.split('\\n')) {\n                // Trim off any trailing comments.\n                ignoreLine = ignoreLine.split('#')[0]\n\n                // Skip any lines that are now empty.\n                ignoreLine = ignoreLine.trim()\n                if (!ignoreLine.length) {\n                    continue\n                }\n\n                let isInverted = false\n                if (ignoreLine.startsWith('!')) {\n                    ignoreLine = ignoreLine.slice(1)\n                    isInverted = true\n                }\n\n                // Gitignores always use POSIX/forward slashes, even on Windows.\n                const ignoreRule = relativeFolderUriPath.length\n                    ? `${relativeFolderUriPath}/${ignoreLine}`\n                    : ignoreLine\n                rules.add((isInverted ? '!' : '') + ignoreRule)\n            }\n        }\n\n        this.workspaceIgnores.set(workspaceRoot.toString(), rules)\n        if (ignoreFiles.length && !this.hasCodyIgnoreFiles) {\n            this.hasCodyIgnoreFiles = true\n        }\n    }\n\n    public clearIgnoreFiles(workspaceRoot: URI): void {\n        this.workspaceIgnores.delete(workspaceRoot.toString())\n    }\n\n    public isIgnored(uri: URI): boolean {\n        // Do not ignore if the feature is not enabled\n        if (!this.isActive) {\n            return false\n        }\n\n        // Return all https URIs on the assumption that they origin from\n        // remote context (e.g. unified, multi-repo) files, which are already\n        // filtered by the backend to respect codyignore files during sync time.\n        if (uri.scheme === 'https') {\n            return false\n        }\n\n        // Ignore all other non-file URIs\n        if (uri.scheme !== 'file') {\n            return true\n        }\n\n        this.ensureFileUri('uri', uri)\n        this.ensureAbsolute('uri', uri)\n        const workspaceRoot = this.findWorkspaceRoot(uri)\n\n        // Not in workspace so just use default rules against the filename.\n        // This ensures we'll never send something like `.env` but it won't handle\n        // if default rules include folders like `a/b` because we have nothing to make\n        // a relative path from.\n        if (!workspaceRoot) {\n            return this.getDefaultIgnores().ignores(uriBasename(uri))\n        }\n\n        const relativePath = pathFunctionsForURI(workspaceRoot).relative(workspaceRoot.path, uri.path)\n        const rules = this.workspaceIgnores.get(workspaceRoot.toString()) ?? this.getDefaultIgnores()\n        return rules.ignores(relativePath) ?? false\n    }\n\n    private findWorkspaceRoot(file: URI): URI | undefined {\n        const candidates = Array.from(this.workspaceIgnores.keys()).filter(workspaceRoot =>\n            uriHasPrefix(file, URI.parse(workspaceRoot), isWindows())\n        )\n        // If this file was inside multiple workspace roots, take the shortest one since it will include\n        // everything the nested one does (plus potentially extra rules).\n        candidates.sort((a, b) => a.length - b.length)\n        const selected = candidates.at(0)\n        return selected ? URI.parse(selected) : undefined\n    }\n\n    private ensureFileUri(name: string, uri: URI): void {\n        if (uri.scheme !== 'file') {\n            throw new Error(`${name} should be a file URI: \""${uri}\""`)\n        }\n    }\n\n    private ensureAbsolute(name: string, uri: URI): void {\n        if (!uri.path.startsWith('/')) {\n            throw new Error(`${name} should be absolute: \""${uri.toString()}\""`)\n        }\n    }\n\n    private ensureValidCodyIgnoreFile(name: string, uri: URI): void {\n        this.ensureAbsolute('ignoreFile.uri', uri)\n        if (!uri.path.endsWith(CODY_IGNORE_URI_PATH)) {\n            throw new Error(`${name} should end with \""${CODY_IGNORE_URI_PATH}\"": \""${uri.toString()}\""`)\n        }\n    }\n\n    private getDefaultIgnores(): Ignore {\n        return ignore().add('.env')\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/cody-ignore.test.ts:46-69"",""content"":""\n    // Start new chat\n    const [chatPanel, chatInput] = await createEmptyChatPanel(page)\n\n    /* TEST: Chat Context - Ignored file do not show up with context */\n    await chatInput.focus()\n    await chatInput.fill('Ignore me')\n    await chatInput.press('Enter')\n    // Assistant should response to your chat question,\n    // but the current file is excluded (ignoredByCody.css) and not on the context list\n    await expect(chatPanel.getByText('hello from the assistant')).toBeVisible()\n    const contextCell = getContextCell(chatPanel)\n    await expect(contextCell).not.toBeVisible()\n\n    /* TEST: At-file - Ignored file does not show up as context when using @-mention */\n    await chatInput.focus()\n    await chatInput.clear()\n    await chatInput.fill('@ignoredByCody')\n    await expect(chatPanel.getByRole('heading', { name: 'No files found' })).toBeVisible()\n    await chatInput.clear()\n    await chatInput.fill('@ignore')\n    await expect(\n        chatPanel.getByRole('option', { name: withPlatformSlashes('ignore .cody') })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:162-186"",""content"":""\n    private ensureValidCodyIgnoreFile(name: string, uri: URI): void {\n        this.ensureAbsolute('ignoreFile.uri', uri)\n        if (!uri.path.endsWith(CODY_IGNORE_URI_PATH)) {\n            throw new Error(`${name} should end with \""${CODY_IGNORE_URI_PATH}\"": \""${uri.toString()}\""`)\n        }\n    }\n\n    private getDefaultIgnores(): Ignore {\n        return ignore().add('.env')\n    }\n}\n\nexport interface IgnoreFileContent {\n    uri: URI\n    content: string\n}\n\n/**\n * Return the directory that a .cody/ignore file applies to.\n */\nexport function ignoreFileEffectiveDirectory(ignoreFile: URI): URI {\n    return Utils.joinPath(ignoreFile, '..', '..')\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:207-217"",""content"":""async function tryReadFile(fileUri: vscode.Uri): Promise<string> {\n    return vscode.workspace.fs.readFile(fileUri).then(\n        content => utf8.decode(content),\n        error => {\n            logDebug('CodyIgnore:clearIgnoreFiles:tryReadFile', 'failed', {\n                verbose: `Skipping unreadable ignore file ${fileUri}: ${error}`,\n            })\n            return ''\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/codyignore.md:16-23"",""content"":""src/\n5. To test if it's working, open a file from the directory you've chosen to ignore and highlight some code.\n6. Ask Cody a question about the highlighted code.\n7. Check the file context in Cody's response. You should not see any files from the ignored directory being used as context.\n8. Note that autocomplete features will also not work on files specified in the `.cody/ignore` file.\n\nRemember, this is an experimental feature for internal testing only, so use it with caution and report any issues you encounter to help improve the functionality.""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/utils/findWorkspaceFiles.ts:51-77"",""content"":""async function readIgnoreFile(uri: vscode.Uri): Promise<IgnoreRecord> {\n    const ignore: IgnoreRecord = {}\n    try {\n        const data = await vscode.workspace.fs.readFile(uri)\n        for (let line of Buffer.from(data).toString('utf-8').split('\\n')) {\n            if (line.startsWith('!')) {\n                continue\n            }\n\n            // Strip comment and trailing whitespace.\n            line = line.replace(/\\s*(#.*)?$/, '')\n\n            if (line === '') {\n                continue\n            }\n\n            if (line.endsWith('/')) {\n                line = line.slice(0, -1)\n            }\n            if (!line.startsWith('/') && !line.startsWith('**/')) {\n                line = `**/${line}`\n            }\n            ignore[line] = true\n        }\n    } catch {}\n    return ignore\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:31-55"",""content"":""\n    // Refresh ignore rules when any ignore file in the workspace changes.\n    const watcher = vscode.workspace.createFileSystemWatcher(CODY_IGNORE_POSIX_GLOB)\n    watcher.onDidChange(refresh)\n    watcher.onDidCreate(refresh)\n    watcher.onDidDelete(refresh)\n\n    // Handle any added/removed workspace folders.\n    const didChangeSubscription = vscode.workspace.onDidChangeWorkspaceFolders(e => {\n        e.added.map(wf => refresh(wf.uri))\n        e.removed.map(wf => clear(wf))\n    })\n\n    const onDidChangeConfig = vscode.workspace.onDidChangeConfiguration(e => {\n        // NOTE This can be removed once cody ignore is stable.\n        if (e.affectsConfiguration('cody')) {\n            onConfigChange()\n        }\n        // NOTE This allows us to search for the ignore files again\n        // if the user changes the search.symlinks setting.\n        if (e.affectsConfiguration('search')) {\n            // Only refresh if the ignore sidebar is empty,\n            // which means the setup step has initially failed.\n            if (ignores.isActive && !ignores.hasCodyIgnoreFiles) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/context-filter.ts:14-16"",""content"":""export function isCodyIgnoredFile(uri: URI): boolean {\n    return ignores.isIgnored(uri)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:75-95"",""content"":""\n    it('returns true for a top-level file ignored at the top level', () => {\n        setWorkspace1Ignores(['ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored.txt'))).toBe(true)\n    })\n\n    it('returns false for a top-level file not ignored at the top level', () => {\n        setWorkspace1Ignores(['ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'not_ignored.txt'))).toBe(false)\n    })\n\n    it('returns false for a top-level file unignored at the top level', () => {\n        setWorkspace1Ignores(['*ignored.txt', '!not_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'not_ignored.txt'))).toBe(false)\n    })\n\n    it('returns true for a nested file ignored at the top level', () => {\n        setWorkspace1Ignores(['always_ignored.txt', 'a/explitly_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/always_ignored.txt'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/explitly_ignored.txt'))).toBe(true)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:172-178"",""content"":""function setCodyIgnoreFiles(ws: vscode.Uri, files: IgnoreFileContent[]): void {\n    ignores.setIgnoreFiles(ws, files)\n    if (files.length) {\n        telemetryService.log('CodyVSCodeExtension:codyIgnore:hasFile')\n        telemetryRecorder.recordEvent('cody.codyIgnore', 'hasFile')\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/__tests__/example-ts/src/isIgnored.ts:0-4"",""content"":""function isIgnoredByCody() {\n    console.log('This file is ignored by Cody via .cody/ignore.')\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/ignoreTests/ignoreTest.ws2:0-5"",""content"":""This file should be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace/ignoreTests/ignoreTest.ws1:0-5"",""content"":""This file should be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:116-134"",""content"":""\n    it('returns false for a nested file unignored at the nested level', () => {\n        setWorkspace1NestedIgnores('a', ['*ignored.txt', '!not_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/not_ignored.txt'))).toBe(false)\n    })\n\n    it('tracks ignores independently for each workspace root', () => {\n        setWorkspace1Ignores(['ignored_1.txt'])\n        setWorkspace2Ignores(['ignored_2.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored_1.txt'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored_2.txt'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace2Root, 'ignored_1.txt'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace2Root, 'ignored_2.txt'))).toBe(true)\n    })\n\n    it('throws on an empty file: URI', () => {\n        expect(() => ignore.isIgnored(URI.parse('file:///'))).toThrow()\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/integration/multi-root/ignore.test.ts:27-42"",""content"":""        )\n    }\n\n    test('ignores ws1 files in workspace1', () =>\n        checkIgnore(`${workspace1Path}/ignoreTests/ignoreTest.ws1`, true))\n\n    test('does not ignore ws2 files in workspace1', () =>\n        checkIgnore(`${workspace1Path}/ignoreTests/ignoreTest.ws2`, false))\n\n    test('does not ignore ws1 files in workspace2', () =>\n        checkIgnore(`${workspace2Path}/ignoreTests/ignoreTest.ws1`, false))\n\n    test('ignores ws2 files in workspace2', () =>\n        checkIgnore(`${workspace2Path}/ignoreTests/ignoreTest.ws2`, true))\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:0-33"",""content"":""import ignore, { type Ignore } from 'ignore'\nimport { URI, Utils } from 'vscode-uri'\n\nimport { pathFunctionsForURI } from '../common/path'\nimport { isWindows } from '../common/platform'\nimport { uriBasename } from '../common/uri'\nimport { uriHasPrefix } from '../editor/displayPath'\n\n/**\n * The Cody ignore URI path.\n */\nexport const CODY_IGNORE_URI_PATH = '.cody/ignore'\n\n/**\n * A glob matching the Cody ignore URI path.\n */\nexport const CODY_IGNORE_POSIX_GLOB = `**/${CODY_IGNORE_URI_PATH}`\n\ntype ClientWorkspaceRootURI = string\n\n/**\n * A helper to efficiently check if a file should be ignored from a set\n * of nested ignore files.\n *\n * Callers must call `setIgnoreFiles` for each workspace root with the full set of ignore files (even\n * if there are zero) at startup (or when new workspace folders are added) and any time an ignore file\n * is modified/created/deleted.\n *\n * `clearIgnoreFiles` should be called for workspace roots as they are removed.\n */\nexport class IgnoreHelper {\n    /**\n     * A map of workspace roots to their ignore rules.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/ignoreTests/ignoreTest.ws1:0-5"",""content"":""This file should NOT be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/Check_IsCodyIgnoredFileParams.kt:0-8"",""content"":""@file:Suppress(\""FunctionName\"", \""ClassName\"", \""unused\"", \""EnumEntryName\"", \""UnusedImport\"")\npackage com.sourcegraph.cody.protocol_generated\n\ndata class Check_IsCodyIgnoredFileParams(\n  val urls: List<String>? = null,\n)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace/ignoreTests/ignoreTest.ws2:0-5"",""content"":""This file should NOT be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_011/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The build and lint tools are configured in the `package.json` files. Specifically:

### Build Tools
- **Build scripts** are defined in the `scripts` section of the `package.json` files. For example, in the `cody_test/vscode/package.json` file, you can find scripts like:
  ```json
  ""scripts"": {
    ""build"": ""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production"",
    ""build:dev:desktop"": ""concurrently \""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\"" \""pnpm run -s _build:webviews --mode development\"""",
    ""build:dev:web"": ""concurrently \""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src\"" \""pnpm run -s _build:webviews --mode development\"""",
    ...
  }
  ```
  These scripts use tools like `esbuild`, `tsc`, and `vite` for building the project.

### Lint Tools
- **Linting tools** are also configured in the `package.json` files. For example, in the `cody_test/vscode/package.json` file, you can find dependencies for linting tools:
  ```json
  ""devDependencies"": {
    ""stylelint"": ""^15.11.0"",
    ""stylelint-config-standard"": ""..."",
    ...
  }
  ```
  These dependencies indicate that `stylelint` is used for linting CSS and other styles.

### Additional Configuration
- **TypeScript Configuration**: The `tsc` command references `tsconfig.json` files for TypeScript compilation settings.
- **Vite Configuration**: The `vite` command references `vite.config.ts` files for Vite-specific build settings.

In summary, the build and lint tools are primarily configured in the `package.json` files through various scripts and dependencies. Additional configuration files like `tsconfig.json` and `vite.config.ts` may also be used for more specific settings.",Where are the build and lint tools configured?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:1746-1760"",""content"":""      '@babel/core': 7.24.0\n      '@babel/helper-compilation-targets': 7.23.6\n      '@babel/helper-plugin-utils': 7.24.0\n      '@babel/helper-validator-option': 7.23.5\n      '@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly': 7.23.7(@babel/core@7.24.0)\n      '@babel/plugin-proposal-private-property-in-object': 7.21.0-placeholder-for-preset-env.2(@babel/core@7.24.0)\n      '@babel/plugin-syntax-async-generators': 7.8.4(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-properties': 7.12.13(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-static-block': 7.14.5(@babel/core@7.24.0)\n      '@babel/plugin-syntax-dynamic-import': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-export-namespace-from': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-import-assertions': 7.23.3(@babel/core@7.24.0)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/common/markdown/contributions.ts:43-72"",""content"":"" */\nexport function registerHighlightContributions(): void {\n    if (registered) {\n        // Don't double-register these. (There is no way to unregister them.)\n        return\n    }\n    registered = true\n    registerLanguage('go', goLang)\n    registerLanguage('javascript', javascript)\n    registerLanguage('typescript', typescript)\n    registerLanguage('java', java)\n    registerLanguage('python', python)\n    registerLanguage('php', php)\n    registerLanguage('bash', bash)\n    registerLanguage('clojure', clojure)\n    // This is a dependency of cpp.\n    registerLanguage('c-like', cLike)\n    registerLanguage('cpp', cpp)\n    registerLanguage('cs', csharp)\n    registerLanguage('csharp', csharp)\n    registerLanguage('css', css)\n    registerLanguage('dockerfile', dockerfile)\n    registerLanguage('elixir', elixir)\n    registerLanguage('haskell', haskell)\n    registerLanguage('html', xml)\n    registerLanguage('lua', lua)\n    registerLanguage('ocaml', ocaml)\n    registerLanguage('r', rLang)\n    registerLanguage('ruby', ruby)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:44-81"",""content"":""      '@testing-library/jest-dom':\n        specifier: ^6.4.2\n        version: 6.4.2(vitest@1.5.0)\n      '@testing-library/react':\n        specifier: ^14.2.2\n        version: 14.2.2(react-dom@18.2.0)(react@18.2.0)\n      '@types/node':\n        specifier: 20.12.7\n        version: 20.12.7\n      '@types/react':\n        specifier: 18.2.79\n        version: 18.2.79\n      '@types/react-dom':\n        specifier: 18.2.25\n        version: 18.2.25\n      '@vitejs/plugin-react':\n        specifier: ^4.2.1\n        version: 4.2.1(vite@5.2.9)\n      esbuild:\n        specifier: ^0.18.20\n        version: 0.18.20\n      happy-dom:\n        specifier: ^14.3.10\n        version: 14.3.10\n      jsdom:\n        specifier: ^22.1.0\n        version: 22.1.0\n      knip:\n        specifier: ^3.13.2\n        version: 3.13.2(@types/node@20.12.7)(typescript@5.4.2)\n      storybook:\n        specifier: ^8.0.5\n        version: 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      stylelint:\n        specifier: ^15.11.0\n        version: 15.11.0(typescript@5.4.2)\n      stylelint-config-standard:\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4219-4245"",""content"":""      '@storybook/csf-tools': 8.0.5\n      '@storybook/global': 5.0.0\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/react-dom-shim': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/theming': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/types': 8.0.5\n      '@types/react': 18.2.79\n      fs-extra: 11.2.0\n      react: 18.2.0\n      react-dom: 18.2.0(react@18.2.0)\n      rehype-external-links: 3.0.0\n      rehype-slug: 6.0.0\n      ts-dedent: 2.2.0\n    transitivePeerDependencies:\n      - encoding\n      - supports-color\n    dev: true\n\n  /@storybook/addon-essentials@8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0):\n    resolution: {integrity: sha512-1yjwf9ibKn2rVqv+fqxACoIjsaUsimSEx8QwjIl2krDNhMULXzFeVubTQ09gXSVEnHUR1nKX3X9qOXJQ2bOFlQ==}\n    dependencies:\n      '@storybook/addon-actions': 8.0.5\n      '@storybook/addon-backgrounds': 8.0.5\n      '@storybook/addon-controls': 8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/addon-docs': 8.0.5\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:409-453"",""content"":""        version: 10.0.0\n      mkdirp:\n        specifier: ^3.0.1\n        version: 3.0.1\n      os-browserify:\n        specifier: ^0.3.0\n        version: 0.3.0\n      parse-git-diff:\n        specifier: ^0.0.14\n        version: 0.0.14\n      proxy-agent:\n        specifier: ^6.4.0\n        version: 6.4.0\n      re2-wasm:\n        specifier: ^1.0.2\n        version: 1.0.2\n      semver:\n        specifier: ^7.5.4\n        version: 7.6.0\n      socks-proxy-agent:\n        specifier: ^8.0.1\n        version: 8.0.1\n      unzipper:\n        specifier: ^0.10.14\n        version: 0.10.14\n      uuid:\n        specifier: ^9.0.0\n        version: 9.0.0\n      vscode-languageserver-textdocument:\n        specifier: ^1.0.8\n        version: 1.0.8\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n      web-tree-sitter:\n        specifier: ^0.21.0\n        version: 0.21.0\n      wink-nlp-utils:\n        specifier: ^2.1.0\n        version: 2.1.0\n    devDependencies:\n      '@google-cloud/pubsub':\n        specifier: ^3.7.3\n        version: 3.7.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/mocks.ts:653-709"",""content"":""            'yaml',\n            'tailwindcss',\n            'editorconfig',\n            'graphql',\n            'vue',\n            'go.mod',\n            'go.work',\n            'go.sum',\n            'gotmpl',\n            'govulncheck',\n            'kotlin',\n            'kotlinscript',\n            'lisp',\n            'toml',\n            'jinja',\n            'pip-requirements',\n            'raw',\n            'prisma',\n            'starlark',\n            'bazel',\n            'bazelrc',\n            'vimrc',\n        ])\n    },\n}\n\nexport enum TextDocumentChangeReason {\n    Undo = 1,\n    Redo = 2,\n}\nexport enum UIKind {\n    Desktop = 1,\n    Web = 2,\n}\n\nexport class FileSystemError extends Error {}\n\nexport const vsCodeMocks = {\n    FileSystemError,\n    FileType,\n    Range,\n    Position,\n    InlineCompletionItem,\n    EventEmitter,\n    EndOfLine,\n    CancellationTokenSource,\n    ThemeColor,\n    ThemeIcon,\n    TreeItem,\n    WorkspaceEdit,\n    UIKind,\n    QuickInputButtons,\n    Uri,\n    languages,\n    env: {\n        uiKind: 1 satisfies vscode_types.UIKind.Desktop,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentWorkspaceConfiguration.ts:8-138"",""content"":""export class AgentWorkspaceConfiguration implements vscode.WorkspaceConfiguration {\n    constructor(\n        private prefix: string[],\n        private clientInfo: () => ClientInfo | undefined,\n        private extensionConfig: () => ExtensionConfiguration | undefined,\n        private dictionary: Record<string, any> = {}\n    ) {}\n\n    public withPrefix(prefix: string): AgentWorkspaceConfiguration {\n        return new AgentWorkspaceConfiguration(\n            this.prefix.concat(prefix),\n            this.clientInfo,\n            this.extensionConfig,\n            this.dictionary\n        )\n    }\n\n    private actualSection(section: string): string {\n        if (this.prefix.length === 0) {\n            return section\n        }\n        return [...this.prefix, section].join('.')\n    }\n\n    private clientNameToIDE(value: string): Configuration['agentIDE'] | undefined {\n        switch (value.toLowerCase()) {\n            case 'vscode':\n                return 'VSCode'\n            case 'jetbrains':\n                return 'JetBrains'\n            case 'emacs':\n                return 'Emacs'\n            case 'neovim':\n                return 'Neovim'\n            default:\n                return undefined\n        }\n    }\n\n    public get(userSection: string, defaultValue?: unknown): any {\n        const section = this.actualSection(userSection)\n\n        const fromDictionary = this.dictionary?.[section]\n        if (fromDictionary !== undefined) {\n            return fromDictionary\n        }\n        const extensionConfig = this.extensionConfig()\n\n        const fromCustomConfiguration = extensionConfig?.customConfiguration?.[section]\n        if (fromCustomConfiguration !== undefined) {\n            return fromCustomConfiguration\n        }\n        switch (section) {\n            case 'cody.serverEndpoint':\n                return extensionConfig?.serverEndpoint\n            case 'cody.proxy':\n                return extensionConfig?.proxy ?? null\n            case 'cody.customHeaders':\n                return extensionConfig?.customHeaders\n            case 'cody.telemetry.level':\n                // Use the dedicated `telemetry/recordEvent` to send telemetry from\n                // agent clients.  The reason we disable telemetry via config is\n                // that we don't want to submit vscode-specific events when\n                // running inside the agent.\n                return 'agent'\n            case 'cody.autocomplete.enabled':\n                return true\n            case 'cody.autocomplete.advanced.provider':\n                return extensionConfig?.autocompleteAdvancedProvider ?? null\n            case 'cody.autocomplete.advanced.model':\n                return extensionConfig?.autocompleteAdvancedModel ?? null\n            case 'cody.advanced.agent.running':\n                return true\n            case 'cody.debug.verbose':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.experimental.tracing':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.useContext':\n                // Disable embeddings by default.\n                return 'keyword'\n            case 'cody.codebase':\n                return extensionConfig?.codebase\n            case 'cody.advanced.agent.ide':\n                return this.clientNameToIDE(this.clientInfo()?.name ?? '')\n            case 'editor.insertSpaces':\n                return true // TODO: override from IDE clients\n            default:\n                // VS Code picks up default value in package.json, and only uses\n                // the `defaultValue` parameter if package.json provides no\n                // default.\n                return defaultConfigurationValue(section) ?? defaultValue\n        }\n    }\n\n    public has(section: string): boolean {\n        const actual = this.actualSection(section)\n        for (const key in this.dictionary) {\n            if (key.startsWith(actual)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    public inspect<T>(section: string):\n        | {\n              key: string\n              defaultValue?: T | undefined\n              globalValue?: T | undefined\n              workspaceValue?: T | undefined\n              workspaceFolderValue?: T | undefined\n              defaultLanguageValue?: T | undefined\n              globalLanguageValue?: T | undefined\n              workspaceLanguageValue?: T | undefined\n              workspaceFolderLanguageValue?: T | undefined\n              languageIds?: string[] | undefined\n          }\n        | undefined {\n        return undefined\n    }\n\n    public async update(\n        section: string,\n        value: any,\n        _configurationTarget?: boolean | vscode.ConfigurationTarget | null | undefined,\n        _overrideInLanguage?: boolean | undefined\n    ): Promise<void> {\n        this.dictionary[this.actualSection(section)] = value\n        return Promise.resolve()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration-keys.ts:6-9"",""content"":""export function defaultConfigurationValue(key: string): any {\n    const value = (properties as any)[key as any]?.default\n    return value\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:66-97"",""content"":""} from './commands/types'\nexport { CustomCommandType } from './commands/types'\nexport { type DefaultCodyCommands, DefaultChatCommands, DefaultEditCommands } from './commands/types'\nexport { dedupeWith, isDefined, isErrorLike, pluralize } from './common'\nexport { type RangeData, toRangeData, displayLineRange, displayRange } from './common/range'\nexport {\n    ProgrammingLanguage,\n    languageFromFilename,\n    markdownCodeBlockLanguageIDForFilename,\n    extensionForLanguage,\n} from './common/languages'\nexport { renderMarkdown, escapeHTML } from './common/markdown'\nexport { posixFilePaths, pathFunctionsForURI } from './common/path'\nexport { isWindows, isMacOS } from './common/platform'\nexport {\n    assertFileURI,\n    isFileURI,\n    uriBasename,\n    uriDirname,\n    uriExtname,\n    uriParseNameAndExtension,\n    type FileURI,\n} from './common/uri'\nexport type {\n    AutocompleteTimeouts,\n    Configuration,\n    ConfigurationUseContext,\n    ConfigurationWithAccessToken,\n    OllamaGenerateParameters,\n    OllamaOptions,\n    ConfigGetter,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:93-97"",""content"":""export interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1321-1329"",""content"":""    \""ovsx\"": \""^0.8.2\"",\n    \""pako\"": \""^2.1.0\"",\n    \""path-browserify\"": \""^1.0.1\"",\n    \""playwright\"": \""1.39.0\"",\n    \""progress\"": \""^2.0.3\"",\n    \""yaml\"": \""^2.3.4\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:20-86"",""content"":""export interface Configuration {\n    proxy?: string | null\n    codebase?: string\n    debugFilter: RegExp | null\n    debugVerbose: boolean\n    telemetryLevel: 'all' | 'off' | 'agent'\n    useContext: ConfigurationUseContext\n    customHeaders: Record<string, string>\n    chatPreInstruction: PromptString\n    editPreInstruction: PromptString\n    codeActions: boolean\n    commandHints: boolean\n    commandCodeLenses: boolean\n\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/index.md:0-18"",""content"":""## Development\n\n### Setup\n\n1. Install [asdf](https://asdf-vm.com/)\n1. Run `asdf install` (if needed, run `asdf plugin add NAME` for any missing plugins)\n1. Run `pnpm install && pnpm build`\n\n### Build and run the VS Code extension\n\nOpen this repository in VS Code and run the `Launch VS Code Extension (Desktop)` build/debug task (or run `pnpm -C vscode run dev`).\n\nSee [vscode/CONTRIBUTING.md](../../vscode/CONTRIBUTING.md) for more information.\n\n### Other topics\n\n- [Quality tools](quality/index.md)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:28-183"",""content"":""export function getConfiguration(\n    config: ConfigGetter = vscode.workspace.getConfiguration()\n): Configuration {\n    const isTesting = process.env.CODY_TESTING === 'true'\n\n    function getHiddenSetting<T>(configKey: string, defaultValue?: T): T {\n        return config.get<T>(`cody.${configKey}` as any, defaultValue)\n    }\n\n    let debugRegex: RegExp | null = null\n    try {\n        const debugPattern: string | null = config.get<string | null>(CONFIG_KEY.debugFilter, null)\n        if (debugPattern) {\n            if (debugPattern === '*') {\n                debugRegex = /.*/\n            } else {\n                debugRegex = new RegExp(debugPattern)\n            }\n        }\n    } catch (error: any) {\n        void vscode.window.showErrorMessage(\n            \""Error parsing cody.debug.filter regex - using default '*'\"",\n            error\n        )\n        debugRegex = /.*/\n    }\n\n    let autocompleteAdvancedProvider = config.get<\n        | Configuration['autocompleteAdvancedProvider']\n        | 'unstable-ollama'\n        | 'unstable-fireworks'\n        | 'experimental-openaicompatible'\n    >(CONFIG_KEY.autocompleteAdvancedProvider, null)\n\n    // Handle deprecated provider identifiers\n    switch (autocompleteAdvancedProvider) {\n        case 'unstable-fireworks':\n            autocompleteAdvancedProvider = 'fireworks'\n            break\n        case 'unstable-ollama':\n            autocompleteAdvancedProvider = 'experimental-ollama'\n            break\n    }\n\n    // check if the configured enum values are valid\n    const configKeys = [\n        'autocompleteAdvancedProvider',\n        'autocompleteAdvancedModel',\n    ] as (keyof ConfigurationKeysMap)[]\n\n    for (const configVal of configKeys) {\n        const key = configVal.replaceAll(/([A-Z])/g, '.$1').toLowerCase()\n        const value: string | null = config.get(CONFIG_KEY[configVal])\n        checkValidEnumValues(key, value)\n    }\n\n    const autocompleteExperimentalGraphContext: 'bfg' | null = getHiddenSetting(\n        'autocomplete.experimental.graphContext',\n        null\n    )\n\n    return {\n        proxy: config.get<string | null>(CONFIG_KEY.proxy, null),\n        codebase: sanitizeCodebase(config.get(CONFIG_KEY.codebase)),\n        customHeaders: config.get<object>(CONFIG_KEY.customHeaders, {}) as Record<string, string>,\n        useContext: config.get<ConfigurationUseContext>(CONFIG_KEY.useContext) || 'embeddings',\n        debugVerbose: config.get<boolean>(CONFIG_KEY.debugVerbose, false),\n        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n            CONFIG_KEY.autocompleteDisableInsideComments,\n            false\n        ),\n        codeActions: config.get(CONFIG_KEY.codeActionsEnabled, true),\n        commandHints: config.get(CONFIG_KEY.commandHintsEnabled, false),\n\n        /**\n         * Hidden settings for internal use only.\n         */\n\n        internalUnstable: getHiddenSetting('internal.unstable', isTesting),\n\n        autocompleteExperimentalGraphContext,\n        experimentalSimpleChatContext: getHiddenSetting('experimental.simpleChatContext', true),\n        experimentalSymfContext: getHiddenSetting('experimental.symfContext', true),\n\n        experimentalGuardrails: getHiddenSetting('experimental.guardrails', isTesting),\n        experimentalTracing: getHiddenSetting('experimental.tracing', false),\n\n        experimentalOllamaChat: getHiddenSetting('experimental.ollamaChat', false),\n        experimentalSupercompletions: getHiddenSetting('experimental.supercompletions', false),\n\n        experimentalChatContextRanker: getHiddenSetting('experimental.chatContextRanker', false),\n\n        autocompleteExperimentalHotStreak: getHiddenSetting(\n            'autocomplete.experimental.hotStreak',\n            false\n        ),\n        autocompleteExperimentalOllamaOptions: getHiddenSetting(\n            'autocomplete.experimental.ollamaOptions',\n            {\n                url: OLLAMA_DEFAULT_URL,\n                model: 'codellama:7b-code',\n            }\n        ),\n        autocompleteExperimentalFireworksOptions: getHiddenSetting(\n            'autocomplete.experimental.fireworksOptions',\n            undefined\n        ),\n        autocompleteExperimentalSmartThrottle: getHiddenSetting(\n            'autocomplete.experimental.smartThrottle',\n            false\n        ),\n\n        // Note: In spirit, we try to minimize agent-specific code paths in the VSC extension.\n        // We currently use this flag for the agent to provide more helpful error messages\n        // when something goes wrong, and to suppress event logging in the agent.\n        // Rely on this flag sparingly.\n        isRunningInsideAgent: getHiddenSetting('advanced.agent.running', false),\n        agentIDE: getHiddenSetting<'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'>('advanced.agent.ide'),\n        autocompleteTimeouts: {\n            multiline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.multiline',\n                undefined\n            ),\n            singleline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.singleline',\n                undefined\n            ),\n        },\n\n        testingLocalEmbeddingsModel: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.model', undefined)\n            : undefined,\n        testingLocalEmbeddingsEndpoint: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.endpoint', undefined)\n            : undefined,\n        testingLocalEmbeddingsIndexLibraryPath: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.indexLibraryPath', undefined)\n            : undefined,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:24-32"",""content"":""    \""watch:build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""watch:build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""_build:esbuild:desktop\"": \""pnpm download-wasm && esbuild ./src/extension.node.ts --bundle --outfile=dist/extension.node.js --external:vscode --format=cjs --platform=node --sourcemap\"",\n    \""_build:esbuild:web\"": \""esbuild ./src/extension.web.ts --platform=browser --bundle --outfile=dist/extension.web.js --alias:path=path-browserify --alias:node:path=path-browserify --alias:node:os=os-browserify --external:vscode --define:process='{\\\""env\\\"":{}}' --define:window=self --format=cjs --sourcemap\"",\n    \""_build:webviews\"": \""vite -c webviews/vite.config.ts build\"",\n    \""release\"": \""ts-node-transpile-only ./scripts/release.ts\"",\n    \""download-wasm\"": \""ts-node-transpile-only ./scripts/download-wasm-modules.ts\"",\n    \""release:dry-run\"": \""pnpm run download-wasm && CODY_RELEASE_DRY_RUN=1 ts-node ./scripts/release.ts\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/CodePrinter.ts:43-45"",""content"":""    public build(): string {\n        return this.out.join('')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/package.json:64-78"",""content"":""    \""@types/diff\"": \""^5.0.9\"",\n    \""@types/google-protobuf\"": \""3.15.12\"",\n    \""@types/minimatch\"": \""^5.1.2\"",\n    \""@types/uuid\"": \""^9.0.2\"",\n    \""@types/vscode\"": \""^1.80.0\"",\n    \""@types/ws\"": \""^8.5.10\"",\n    \""diff\"": \""^5.2.0\"",\n    \""esbuild\"": \""^0.18.19\"",\n    \""google-protobuf\"": \""^3.21.2\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""pkg\"": \""^5.8.1\"",\n    \""rimraf\"": \""^5.0.5\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/custom-commands.ts:147-174"",""content"":""    public async build(type: CustomCommandType): Promise<Map<string, CodyCommand> | null> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri || (type === CustomCommandType.Workspace && !vscode.workspace.isTrusted)) {\n            return null\n        }\n        try {\n            const content = await getDocText(uri)\n            if (!content.trim()) {\n                return null\n            }\n            const customCommandsMap = buildCodyCommandMap(type, content)\n            this.customCommandsMap = new Map([...this.customCommandsMap, ...customCommandsMap])\n\n            // Register Custom Commands as VS Code commands\n            for (const [key, _command] of customCommandsMap) {\n                this.registeredCommands.push(\n                    vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>\n                        vscode.commands.executeCommand('cody.action.command', key, {\n                            source: 'editor',\n                        })\n                    )\n                )\n            }\n        } catch (error) {\n            console.error('CustomCommandsProvider:build', 'failed', { verbose: error })\n        }\n        return this.customCommandsMap\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/prompt-builder/index.ts:39-41"",""content"":""    public build(): Message[] {\n        return this.prefixMessages.concat([...this.reverseMessages].reverse())\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:97-130"",""content"":""} from './configuration'\nexport { NoopEditor } from './editor'\nexport type {\n    ActiveTextEditor,\n    ActiveTextEditorDiagnostic,\n    ActiveTextEditorDiagnosticType,\n    ActiveTextEditorSelection,\n    ActiveTextEditorVisibleContent,\n    Editor,\n} from './editor'\nexport {\n    displayPath,\n    displayPathBasename,\n    displayPathDirname,\n    displayPathWithoutWorkspaceFolderPrefix,\n    setDisplayPathEnvInfo,\n    type DisplayPathEnvInfo,\n} from './editor/displayPath'\nexport { hydrateAfterPostMessage } from './editor/hydrateAfterPostMessage'\nexport * from './editor/utils'\nexport {\n    FeatureFlag,\n    FeatureFlagProvider,\n    featureFlagProvider,\n} from './experimentation/FeatureFlagProvider'\nexport { GuardrailsPost, summariseAttribution } from './guardrails'\nexport type { Attribution, Guardrails } from './guardrails'\nexport { SourcegraphGuardrailsClient } from './guardrails/client'\nexport {\n    CompletionStopReason,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type CompletionResponseGenerator,\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_012/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The model used for edits is configured in the `getModelInputItems` function located in the file `cody_test/vscode/src/edit/input/get-items/model.ts`. This function takes in model options, the active model, and a boolean indicating if the user is a Cody Pro user. It then creates a list of model items and identifies the active model item.

Here's the relevant part of the code:

```typescript
export const getModelInputItems = (
    modelOptions: ModelProvider[],
    activeModel: EditModel,
    isCodyPro: boolean
): GetItemsResult => {
    const modelItems = getModelOptionItems(modelOptions, isCodyPro)
    const activeItem = modelItems.find(item => item.model === activeModel)

    if (activeItem) {
        // Update the label of the active item
        activeItem.label = activeItem.label.replace(
            QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX,
            QUICK_PICK_ITEM_CHECKED_PREFIX
        )
    }

    return {
        items: modelItems,
        activeItem,
    }
}
```

Additionally, the `getModel` function in `cody_test/vscode/src/models/index.ts` is used to retrieve the model based on the authentication status and available models:

```typescript
function getModel<T extends string>(
    authProvider: AuthProvider,
    models: ModelProvider[],
    storageKey: string
): T {
    const authStatus = authProvider.getAuthStatus()
    // Free user can only use the default model
    if (authStatus.isDotCom && authStatus.userCanUpgrade) {
        return models[0].model as T
    }

    // Enterprise user can only use the default model
    // We only support a single model for enterprise users right now
    if (!authStatus.isDotCom) {
        return models[0].model as T
    }
}
```

These functions collectively handle the configuration and selection of the model used for edits.",Where is the model used for edits configured?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:54-74"",""content"":""export const getModelInputItems = (\n    modelOptions: ModelProvider[],\n    activeModel: EditModel,\n    isCodyPro: boolean\n): GetItemsResult => {\n    const modelItems = getModelOptionItems(modelOptions, isCodyPro)\n    const activeItem = modelItems.find(item => item.model === activeModel)\n\n    if (activeItem) {\n        // Update the label of the active item\n        activeItem.label = activeItem.label.replace(\n            QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX,\n            QUICK_PICK_ITEM_CHECKED_PREFIX\n        )\n    }\n\n    return {\n        items: modelItems,\n        activeItem,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/chat/markdown.ts:76-79"",""content"":""        ...options,\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:27-52"",""content"":""export const getModelOptionItems = (\n    modelOptions: ModelProvider[],\n    isCodyPro: boolean\n): EditModelItem[] => {\n    const allOptions = modelOptions.map(modelOption => {\n        const icon = getModelProviderIcon(modelOption.provider)\n        return {\n            label: `${QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX} ${icon} ${modelOption.title}`,\n            description: `by ${modelOption.provider}`,\n            alwaysShow: true,\n            model: modelOption.model,\n            modelTitle: modelOption.title,\n            codyProOnly: modelOption.codyProOnly,\n        }\n    })\n\n    if (!isCodyPro) {\n        return [\n            ...allOptions.filter(option => !option.codyProOnly),\n            { label: 'upgrade to cody pro', kind: vscode.QuickPickItemKind.Separator } as EditModelItem,\n            ...allOptions.filter(option => option.codyProOnly),\n        ]\n    }\n\n    return allOptions\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-input.ts:511-526"",""content"":""                    instruction: instruction.trim(),\n                    userContextFiles: Array.from(selectedContextItems)\n                        .filter(([key]) => instruction.toString().includes(`@${key}`))\n                        .map(([, value]) => value),\n                    model: activeModel,\n                    range: activeRange,\n                    intent: isGenerateIntent(document, activeRange) ? 'add' : 'edit',\n                })\n            },\n        })\n\n        editInput.render(activeTitle, initialValues.initialInputValue?.toString() || '')\n        editInput.input.activeItems = []\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:10-25"",""content"":""const getModelProviderIcon = (provider: string): string => {\n    switch (provider) {\n        case 'Anthropic':\n            return '$(anthropic-logo)'\n        case 'OpenAI':\n            return '$(openai-logo)'\n        case 'Mistral':\n            return '$(mistral-logo)'\n        case 'Ollama':\n            return '$(ollama-logo)'\n        case 'Google':\n            return '$(gemini-logo)'\n        default:\n            return ''\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/constants.ts:0-5"",""content"":""import type { EditIntent, EditMode } from './types'\n\nexport const DEFAULT_EDIT_MODE: EditMode = 'edit'\nexport const DEFAULT_EDIT_INTENT: EditIntent = 'edit'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/types.ts:0-13"",""content"":""import type { EditModel } from '@sourcegraph/cody-shared'\nimport type * as vscode from 'vscode'\n\nexport interface EditRangeItem extends vscode.QuickPickItem {\n    range: vscode.Range | (() => Promise<vscode.Range>)\n}\n\nexport interface EditModelItem extends vscode.QuickPickItem {\n    modelTitle: string\n    model: EditModel\n    codyProOnly: boolean\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/edit.ts:9-12"",""content"":""export const MODEL_ITEM: vscode.QuickPickItem = {\n    label: 'Model',\n    alwaysShow: true,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/index.ts:0-29"",""content"":""import { fetchLocalOllamaModels } from '../llm-providers/ollama/utils'\nimport { CHAT_INPUT_TOKEN_BUDGET, CHAT_OUTPUT_TOKEN_BUDGET } from '../token/constants'\nimport type { ModelContextWindow } from './types'\nimport type { ModelUsage } from './types'\nimport { getModelInfo } from './utils'\n\n/**\n * ModelProvider manages available chat and edit models.\n * It stores a set of available providers and methods to add,\n * retrieve and select between them.\n */\nexport class ModelProvider {\n    // Whether the model is the default model\n    public default = false\n    // Whether the model is only available to Pro users\n    public codyProOnly = false\n    // The name of the provider of the model, e.g. \""Anthropic\""\n    public provider: string\n    // The title of the model, e.g. \""Claude 2.0\""\n    public readonly title: string\n\n    constructor(\n        /**\n         * The model id that includes the provider name & the model name,\n         * e.g. \""anthropic/claude-2.0\""\n         */\n        public readonly model: string,\n        /**\n         * The usage of the model, e.g. chat or edit.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/openai.ts:14-19"",""content"":""    getEdit(options) {\n        return {\n            ...SHARED_PARAMETERS,\n            prompt: buildGenericPrompt('edit', options),\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/index.ts:0-25"",""content"":""import type { ChatModel, EditModel, ModelProvider } from '@sourcegraph/cody-shared'\nimport type { AuthProvider } from '../services/AuthProvider'\nimport { localStorage } from '../services/LocalStorageProvider'\n\nasync function setModel(modelID: EditModel, storageKey: string) {\n    // Store the selected model in local storage to retrieve later\n    return localStorage.set(storageKey, modelID)\n}\n\nfunction getModel<T extends string>(\n    authProvider: AuthProvider,\n    models: ModelProvider[],\n    storageKey: string\n): T {\n    const authStatus = authProvider.getAuthStatus()\n    // Free user can only use the default model\n    if (authStatus.isDotCom && authStatus.userCanUpgrade) {\n        return models[0].model as T\n    }\n\n    // Enterprise user can only use the default model\n    // We only support a single model for enterprise users right now\n    if (!authStatus.isDotCom) {\n        return models[0].model as T\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/claude.ts:15-20"",""content"":""    getEdit(options) {\n        return {\n            ...SHARED_PARAMETERS,\n            prompt: buildGenericPrompt('edit', options),\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/index.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    BotResponseMultiplexer,\n    type ChatMessage,\n    type CompletionParameters,\n    type EditModel,\n    type Message,\n    ModelProvider,\n    PromptString,\n    TokenCounter,\n    getSimplePreamble,\n    ps,\n} from '@sourcegraph/cody-shared'\n\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { FixupTask } from '../../non-stop/FixupTask'\nimport type { EditIntent } from '../types'\n\nimport { PromptBuilder } from '../../prompt-builder'\nimport { getContext } from './context'\nimport { claude } from './models/claude'\nimport { openai } from './models/openai'\nimport type { EditLLMInteraction, GetLLMInteractionOptions, LLMInteraction } from './type'\n\nconst INTERACTION_MODELS: Record<EditModel, EditLLMInteraction> = {\n    'anthropic/claude-2.0': claude,\n    'anthropic/claude-2.1': claude,\n    'anthropic/claude-instant-1.2': claude,\n    'anthropic/claude-3-opus-20240229': claude,\n    'anthropic/claude-3-sonnet-20240229': claude,\n    'anthropic/claude-3-haiku-20240307': claude,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/manager.ts:98-122"",""content"":""\n        const editor = getEditor()\n        if (editor.ignored) {\n            void vscode.window.showInformationMessage('Cannot edit Cody ignored file.')\n            return\n        }\n\n        const document = configuration.document || editor.active?.document\n        if (!document) {\n            void vscode.window.showErrorMessage('Please open a file before running a command.')\n            return\n        }\n\n        const proposedRange = configuration.range || editor.active?.selection\n        if (!proposedRange) {\n            return\n        }\n\n        // Set default edit configuration, if not provided\n        // It is possible that these values may be overriden later, e.g. if the user changes them in the edit input.\n        const range = getEditLineSelection(document, proposedRange)\n        const mode = configuration.mode || DEFAULT_EDIT_MODE\n        const model = configuration.model || editModel.get(this.options.authProvider, this.models)\n        const intent = getEditIntent(document, range, configuration.intent)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/utils.ts:85-106"",""content"":""export function getChatModelsFromConfiguration(): ModelProvider[] {\n    const codyConfig = vscode.workspace.getConfiguration('cody')\n    const modelsConfig = codyConfig?.get<ChatModelProviderConfig[]>('dev.models')\n    if (!modelsConfig?.length) {\n        return []\n    }\n\n    const providers: ModelProvider[] = []\n    for (const m of modelsConfig) {\n        const provider = new ModelProvider(\n            `${m.provider}/${m.model}`,\n            [ModelUsage.Chat, ModelUsage.Edit],\n            { input: m.inputTokens ?? CHAT_INPUT_TOKEN_BUDGET, output: m.outputTokens ?? ANSWER_TOKENS },\n            { apiKey: m.apiKey, apiEndpoint: m.apiEndpoint }\n        )\n        provider.codyProOnly = true\n        providers.push(provider)\n    }\n\n    ModelProvider.addProviders(providers)\n    return providers\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/provider.ts:28-55"",""content"":""\ninterface EditProviderOptions extends EditManagerOptions {\n    task: FixupTask\n    controller: FixupController\n}\n\n// Initiates a completion and responds to the result from the LLM. Implements\n// \""tools\"" like directing the response into a specific file. Code is forwarded\n// to the FixupTask.\nexport class EditProvider {\n    private insertionResponse: string | null = null\n    private insertionInProgress = false\n    private insertionPromise: Promise<void> | null = null\n    private abortController: AbortController | null = null\n\n    constructor(public config: EditProviderOptions) {}\n\n    public async startEdit(): Promise<void> {\n        return wrapInActiveSpan('command.edit.start', async span => {\n            this.config.controller.startTask(this.config.task)\n            const model = this.config.task.model\n            const contextWindow = ModelProvider.getContextWindowByID(model)\n            const {\n                messages,\n                stopSequences,\n                responseTopic,\n                responsePrefix = '',\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15"",""content"":""export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:48-63"",""content"":""- [ ] Verify that you can see a list of code lenses with a Cody icon above the generated code: `Show diff`, `Accept`, `Retry`, and `Undo`.\n- [ ] Verify that you can see a diff view of the edit in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the edit by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Editing code (Additional Configuration)\n\n- [ ] Highlight a section of code.\n- [ ] Trigger the Edit shortcut with Option+K\n- [ ] Try to add a file to the Edit instruction, by using \""@\"" and searching for a file\n- [ ] Try to add a symbol to the Edit instruction, by using \""@#\"" and searching for a symbol\n- [ ] Try to change the range of the Edit, by selecting \""Range\"". Check that navigating through the options correctly updates the range shown in the editor.\n- [ ] Try to change the model of the Edit, by selecting \""Model\"".\n- [ ] Submit edits after changing the above values, and check that the Edit performs correctly (e.g. uses correct range, uses correct context)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:17-20"",""content"":""export function useCurrentChatModel(): ModelProvider | undefined {\n    const { chatModels } = useChatModelContext()\n    return chatModels?.find(model => model.default) ?? chatModels?.[0]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/types.ts:0-13"",""content"":""/**\n * The intent classification for the edit.\n * Manually determined depending on how the edit is triggered.\n */\nexport type EditIntent = 'add' | 'edit' | 'fix' | 'doc' | 'test'\n\n/**\n * The edit modes that can be used when applying an edit.\n * - 'edit': Modify selected code in place.\n * - 'insert': Insert new code at the selected location.\n */\nexport type EditMode = 'edit' | 'insert'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/index.ts:50-53"",""content"":""\nexport const chatModel = createModelAccessor<ChatModel>('model')\nexport const editModel = createModelAccessor<EditModel>('editModel')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/utils/edit-models.ts:0-27"",""content"":""import { type AuthStatus, type EditModel, ModelProvider, ModelUsage } from '@sourcegraph/cody-shared'\nimport type { EditIntent } from '../types'\n\nexport function getEditModelsForUser(authStatus: AuthStatus): ModelProvider[] {\n    return ModelProvider.getProviders(ModelUsage.Edit, !authStatus.userCanUpgrade)\n}\n\nexport function getOverridenModelForIntent(intent: EditIntent, currentModel: EditModel): EditModel {\n    switch (intent) {\n        case 'fix':\n            // Fix is a case where we want to ensure that users do not end up with a broken edit model.\n            // It is outside of the typical Edit flow so it is more likely a user could become \""stuck\"" here.\n            // TODO: Make the model usage more visible to users outside of the normal edit flow. This means\n            // we could let the user provide any model they want for `fix`.\n            // Issue: https://github.com/sourcegraph/cody/issues/3512\n            return 'anthropic/claude-3-sonnet-20240229'\n        case 'doc':\n            // Doc is a case where we can sacrifice LLM performnace for improved latency and get comparable results.\n            return 'anthropic/claude-3-haiku-20240307'\n        case 'test':\n        case 'add':\n        case 'edit':\n            // Support all model usage for add and edit intents.\n            return currentModel\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/manager.ts:25-50"",""content"":""import { getEditIntent } from './utils/edit-intent'\nimport { getEditModelsForUser } from './utils/edit-models'\nimport { getEditLineSelection, getEditSmartSelection } from './utils/edit-selection'\n\nexport interface EditManagerOptions {\n    editor: VSCodeEditor\n    chat: ChatClient\n    ghostHintDecorator: GhostHintDecorator\n    authProvider: AuthProvider\n    extensionClient: ExtensionClient\n}\n\n// EditManager handles translating specific edit intents (document, edit) into\n// generic FixupTasks, and pairs a FixupTask with an EditProvider to generate\n// a completion.\nexport class EditManager implements vscode.Disposable {\n    private readonly controller: FixupController\n    private disposables: vscode.Disposable[] = []\n    private editProviders = new WeakMap<FixupTask, EditProvider>()\n    private models: ModelProvider[] = []\n\n    constructor(public options: EditManagerOptions) {\n        this.controller = new FixupController(options.authProvider, options.extensionClient)\n        /**\n         * Entry point to triggering a new Edit.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:86-114"",""content"":""### Changed\n\n- Chat: A new design for chat messages, with avatars and a separate context row. [pull/3639](https://github.com/sourcegraph/cody/pull/3639)\n- Chat: The Enhanced Context Settings modal is opened by default for the first chat session. [pull/3547](https://github.com/sourcegraph/cody/pull/3547)\n- Add information on which Cody tier is being used to analytics events. [pull/3508](https://github.com/sourcegraph/cody/pull/3508)\n- Auth: Enable the new onboarding flow that does not require the redirect back to VS Code for everyone. [pull/3574](https://github.com/sourcegraph/cody/pull/3574)\n- Chat: Claude 3 Sonnet is now the default model for every Cody Free or Pro user. [pull/3575](https://github.com/sourcegraph/cody/pull/3575)\n- Edit: Removed a previous Edit shortcut (`Shift+Cmd/Ctrl+v`), use `Opt/Alt+K` to trigger Edits. [pull/3591](https://github.com/sourcegraph/cody/pull/3591)\n- Commands: The `Editor Title Icon` configuration option has been removed from the Cody Settings menu. Users can configure the title bar icon by right-clicking on the title bar. [pull/3677](https://github.com/sourcegraph/cody/pull/3677)\n\n### Feature Flags\n\n> This section covers experiments that run behind feature flags for non-Enterprise users.\n\n- Hover Commands: Cody commands are now integrated with the native hover provider, allowing you to seamlessly access essential commands on mouse hover. [pull/3585](https://github.com/sourcegraph/cody/pull/3585)\n\n## [1.10.2]\n\n### Added\n\n- Cody Enterprise users now have access to an `experimental-openaicompatible` which allows bringing your own LLM via any OpenAI-compatible API. For now, this is only supported with Starchat and specific configurations - but we continue to generalize this work to support more models and OpenAI-compatible endpoints. [pull/3218](https://github.com/sourcegraph/cody/pull/3218)\n\n## [1.10.1]\n\n### Added\n\n- Autocomplete: Add Claude 3 Haiku experimental autocomplete support. [pull/3538](https://github.com/sourcegraph/cody/pull/3538)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/types.ts:0-62"",""content"":""import type { ModelProvider } from '.'\n\nexport enum ModelUsage {\n    Chat = 'chat',\n    Edit = 'edit',\n}\n\n// Utility to narrow a model type to a specific model usage\ntype HasUsage<T, I> = T extends { usage: readonly ModelUsage[] }\n    ? I extends T['usage'][number]\n        ? T\n        : never\n    : never\n\ntype Models = typeof ModelProvider\n\n/**\n * Available models for Edit.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type EditModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Edit>\n      }[keyof Models]['model']\n    | (string & {})\n\n/**\n * Available models for Chat.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type ChatModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Chat>\n      }[keyof Models]['model']\n    | (string & {})\n\nexport interface ModelContextWindow {\n    /**\n     * The token limit reserved for chat input.\n     */\n    input: number\n    /**\n     * The maximum number of tokens that the model can respond with in a single request.\n     */\n    output: number\n    /**\n     * The additional tokens reserved for context.\n     * When not defined, context shares the same token limit as input.\n     */\n    context?: {\n        /**\n         * The token limit reserved for user-added context.\n         * Example: @-mentions.\n         */\n        user?: number\n    }\n}\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_013/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for calling the Sourcegraph API is primarily located in the `SourcegraphGraphQLAPIClient` class within the `cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts` file. This class contains various methods that interact with the Sourcegraph API, such as `fetchSourcegraphAPI`, `fetchSourcegraphDotcomAPI`, and `fetchSourcegraphTestingAPI`. These methods handle making HTTP requests to the Sourcegraph GraphQL API endpoints and processing the responses.

Here is a relevant excerpt from the `SourcegraphGraphQLAPIClient` class:

```typescript
export class SourcegraphGraphQLAPIClient {
    // ... other methods and properties ...

    private fetchSourcegraphAPI<T>(
        query: string,
        variables: Record<string, any> = {}
    ): Promise<T | Error> {
        const headers = new Headers(this.config.customHeaders as HeadersInit)
        headers.set('Content-Type', 'application/json; charset=utf-8')
        if (this.config.accessToken) {
            headers.set('Authorization', `token ${this.config.accessToken}`)
        }
        if (this.anonymousUserID) {
            headers.set('X-Sourcegraph-Actor-Anonymous-UID', this.anonymousUserID)
        }

        addTraceparent(headers)
        addCustomUserAgent(headers)

        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]

        const url = buildGraphQLUrl({ request: query, baseUrl: this.config.serverEndpoint })
        return wrapInActiveSpan(`graphql.fetch${queryName ? `.${queryName}` : ''}`, () =>
            fetch(url, {
                method: 'POST',
                body: JSON.stringify({ query, variables }),
                headers,
            })
                .then(verifyResponseCode)
                .then(response => response.json() as T)
                .catch(error => {
                    return new Error(`accessing Sourcegraph GraphQL API: ${error} (${url})`)
                })
        )
    }

    // ... other methods and properties ...
}
```

This class and its methods are responsible for constructing the necessary headers, building the request URLs, and handling the responses from the Sourcegraph API.",Where is the functionality for calling the Sourcegraph API?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:170-198"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?CurrentSiteCodyLlmConfiguration\n      response:\n        bodySize: 215\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 215\n          text: \""[\\\""H4sIAAAAAAAAA4TOMQ7CMAxA0bt4bkXajaxdm40LWElKI4JdNS4CVbk7ShdQBpgsWd9P3\\\n            sGhIOgdUhBfpmX3GkczME3huq0ogenYzyiGnY+gAUnmlZdgTzbi\\\"",\\\""5nzbQ/MJDD4\\\n            vfPOUQHe9UqqBCZMMv+4DJUGStoMq/rLOB2X5vkRfnvqLPYpW9ZWXc85vAAAA//8DAC\\\n            mc8DoDAQAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:34:09 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.vscode/extensions.json:0-10"",""content"":""{\n  \""recommendations\"": [\n    \""sourcegraph.cody-ai\"",\n    \""editorconfig.editorconfig\"",\n    \""ecmel.vscode-html-css\"",\n    \""biomejs.biome\"",\n    \""stylelint.vscode-stylelint\""\n  ]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:182-216"",""content"":""\n                  ```\n\n                  client/web/node_modules\n\n                  client/web-sveltekit/node_modules\n\n                  client/wildcard/node_modules\n\n                  dev/release/node_modules\n\n\n                  cmd/symbols/squirrel/test_repos/starlark\n\n\n                  # Generated by local tools\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /client/shared/src/codeintel/legacy-extensions/search/providers.ts\n                  in repository github.com/sourcegraph/sourcegraph:\n\n                  ```typescript\n\n                  import { getConfig } from './config'\n\n                  import { type Result, resultToLocation, searchResultToResults } from './conversion'\n\n                  import { findDocstring } from './docstrings'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:32-60"",""content"":""/**\n * Access the chat based LLM APIs via a Sourcegraph server instance.\n *\n * 🚨 SECURITY: It is the caller's responsibility to ensure context from\n * all cody ignored files are removed before sending requests to the server.\n */\nexport abstract class SourcegraphCompletionsClient {\n    private errorEncountered = false\n\n    constructor(\n        protected config: CompletionsClientConfig,\n        protected logger?: CompletionLogger\n    ) {}\n\n    public onConfigurationChange(newConfig: CompletionsClientConfig): void {\n        this.config = newConfig\n    }\n\n    protected get completionsEndpoint(): string {\n        return new URL('/.api/completions/stream', this.config.serverEndpoint).href\n    }\n\n    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:91-141"",""content"":""    public stream(\n        params: CompletionParameters,\n        apiVersion: number,\n        signal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        // Provide default stop sequence for starchat models.\n        if (!params.stopSequences && params?.model?.startsWith('openaicompatible/starchat')) {\n            params.stopSequences = ['<|end|>']\n        }\n\n        // This is a technique to convert a function that takes callbacks to an async generator.\n        const values: Promise<CompletionGeneratorValue>[] = []\n        let resolve: ((value: CompletionGeneratorValue) => void) | undefined\n        values.push(\n            new Promise(r => {\n                resolve = r\n            })\n        )\n\n        const send = (value: CompletionGeneratorValue): void => {\n            resolve!(value)\n            values.push(\n                new Promise(r => {\n                    resolve = r\n                })\n            )\n        }\n        const callbacks: CompletionCallbacks = {\n            onChange(text) {\n                send({ type: 'change', text })\n            },\n            onComplete() {\n                send({ type: 'complete' })\n            },\n            onError(error, statusCode) {\n                send({ type: 'error', error, statusCode })\n            },\n        }\n        this._streamWithCallbacks(params, apiVersion, callbacks, signal)\n\n        return (async function* () {\n            for (let i = 0; ; i++) {\n                const val = await values[i]\n                delete values[i]\n                yield val\n                if (val.type === 'complete' || val.type === 'error') {\n                    break\n                }\n            }\n        })()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:297-870"",""content"":""export class SourcegraphGraphQLAPIClient {\n    private dotcomUrl = DOTCOM_URL\n    public anonymousUserID: string | undefined\n\n    /**\n     * Should be set on extension activation via `localStorage.onConfigurationChange(config)`\n     * Done to avoid passing the graphql client around as a parameter and instead\n     * access it as a singleton via the module import.\n     */\n    private _config: GraphQLAPIClientConfig | null = null\n\n    private get config(): GraphQLAPIClientConfig {\n        if (!this._config) {\n            throw new Error('GraphQLAPIClientConfig is not set')\n        }\n\n        return this._config\n    }\n\n    constructor(config: GraphQLAPIClientConfig | null = null) {\n        this._config = config\n    }\n\n    public onConfigurationChange(newConfig: GraphQLAPIClientConfig): void {\n        this._config = newConfig\n    }\n\n    /**\n     * If set, anonymousUID is trasmitted as 'X-Sourcegraph-Actor-Anonymous-UID'\n     * which is automatically picked up by Sourcegraph backends 5.2+\n     */\n    public setAnonymousUserID(anonymousUID: string): void {\n        this.anonymousUserID = anonymousUID\n    }\n\n    public isDotCom(): boolean {\n        return isDotCom(this.config.serverEndpoint)\n    }\n\n    // Gets the server endpoint for this client.\n    public get endpoint(): string {\n        return this.config.serverEndpoint\n    }\n\n    public async getSiteVersion(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteVersionResponse>>(\n            CURRENT_SITE_VERSION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => data.site?.productVersion ?? new Error('site version not found')\n            )\n        )\n    }\n\n    public async getSiteIdentification(): Promise<{ siteid: string; hashedLicenseKey: string } | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<SiteIdentificationResponse>>(\n            CURRENT_SITE_IDENTIFICATION,\n            {}\n        )\n        return extractDataOrError(response, data =>\n            data.site?.siteID\n                ? data.site?.productSubscription?.license?.hashedKey\n                    ? {\n                          siteid: data.site?.siteID,\n                          hashedLicenseKey: data.site?.productSubscription?.license?.hashedKey,\n                      }\n                    : new Error('site hashed license key not found')\n                : new Error('site ID not found')\n        )\n    }\n\n    public async getSiteHasIsCodyEnabledField(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteGraphqlFieldsResponse>>(\n            CURRENT_SITE_GRAPHQL_FIELDS_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => !!data.__type?.fields?.find(field => field.name === 'isCodyEnabled')\n            )\n        )\n    }\n\n    public async getSiteHasCodyEnabled(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteHasCodyEnabledResponse>>(\n            CURRENT_SITE_HAS_CODY_ENABLED_QUERY,\n            {}\n        ).then(response => extractDataOrError(response, data => data.site?.isCodyEnabled ?? false))\n    }\n\n    public async getCurrentUserId(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserIdResponse>>(\n            CURRENT_USER_ID_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? data.currentUser.id : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodyProEnabled(): Promise<{ codyProEnabled: boolean } | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodyProEnabledResponse>>(\n            CURRENT_USER_CODY_PRO_ENABLED_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodySubscription(): Promise<CurrentUserCodySubscription | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodySubscriptionResponse>>(\n            CURRENT_USER_CODY_SUBSCRIPTION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser?.codySubscription\n                    ? data.currentUser.codySubscription\n                    : new Error('current user subscription data not found')\n            )\n        )\n    }\n\n    public async getCurrentUserInfo(): Promise<CurrentUserInfo | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserInfoResponse>>(\n            CURRENT_USER_INFO_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    /**\n     * Fetches the Site Admin enabled/disable Cody config features for the current instance.\n     */\n    public async getCodyConfigFeatures(): Promise<CodyConfigFeatures | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<CodyConfigFeaturesResponse>>(\n            CURRENT_SITE_CODY_CONFIG_FEATURES,\n            {}\n        )\n        return extractDataOrError(\n            response,\n            data => data.site?.codyConfigFeatures ?? new Error('cody config not found')\n        )\n    }\n\n    public async getCodyLLMConfiguration(): Promise<undefined | CodyLLMSiteConfiguration | Error> {\n        // fetch Cody LLM provider separately for backward compatability\n        const [configResponse, providerResponse] = await Promise.all([\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationResponse>>(\n                CURRENT_SITE_CODY_LLM_CONFIGURATION\n            ),\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationProviderResponse>>(\n                CURRENT_SITE_CODY_LLM_PROVIDER\n            ),\n        ])\n\n        const config = extractDataOrError(\n            configResponse,\n            data => data.site?.codyLLMConfiguration || undefined\n        )\n        if (!config || isError(config)) {\n            return config\n        }\n\n        let provider: string | undefined\n        const llmProvider = extractDataOrError(\n            providerResponse,\n            data => data.site?.codyLLMConfiguration?.provider\n        )\n        if (llmProvider && !isError(llmProvider)) {\n            provider = llmProvider\n        }\n\n        return { ...config, provider }\n    }\n\n    /**\n     * Gets a subset of the list of repositories from the Sourcegraph instance.\n     * @param first the number of repositories to retrieve.\n     * @param after the last repository retrieved, if any, to continue enumerating the list.\n     * @returns the list of repositories. If `endCursor` is null, this is the end of the list.\n     */\n    public async getRepoList(first: number, after?: string): Promise<RepoListResponse | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepoListResponse>>(REPOSITORY_LIST_QUERY, {\n            first,\n            after: after || null,\n        }).then(response => extractDataOrError(response, data => data))\n    }\n\n    public async getRepoId(repoName: string): Promise<string | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdResponse>>(REPOSITORY_ID_QUERY, {\n            name: repoName,\n        }).then(response =>\n            extractDataOrError(response, data => (data.repository ? data.repository.id : null))\n        )\n    }\n\n    public async getRepoIds(\n        names: string[],\n        first: number\n    ): Promise<{ name: string; id: string }[] | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdsResponse>>(REPOSITORY_IDS_QUERY, {\n            names,\n            first,\n        }).then(response => extractDataOrError(response, data => data.repositories?.nodes || []))\n    }\n\n    public async contextSearch(\n        repos: Set<string>,\n        query: string\n    ): Promise<ContextSearchResult[] | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<ContextSearchResponse>>(CONTEXT_SEARCH_QUERY, {\n            repos: [...repos],\n            query,\n            codeResultsCount: 15,\n            textResultsCount: 5,\n        }).then(response =>\n            extractDataOrError(response, data =>\n                (data.getCodyContext || []).map(item => ({\n                    commit: item.blob.commit.oid,\n                    repoName: item.blob.repository.name,\n                    path: item.blob.path,\n                    uri: URI.parse(\n                        `${item.blob.url.startsWith('/') ? this.endpoint : ''}${item.blob.url}?L${\n                            item.startLine + 1\n                        }-${item.endLine}`\n                    ),\n                    startLine: item.startLine,\n                    endLine: item.endLine,\n                    content: item.chunkContent,\n                }))\n            )\n        )\n    }\n\n    public async contextFilters(): Promise<ContextFiltersResult | null | Error> {\n        const response =\n            await this.fetchSourcegraphAPI<APIResponse<ContextFiltersResult | null>>(\n                CONTEXT_FILTERS_QUERY\n            )\n\n        const result = extractDataOrError(response, data => data)\n\n        if (result instanceof Error) {\n            // Ignore errors caused by outdated Sourcegraph API instances.\n            if (hasOutdatedAPIErrorMessages(result)) {\n                return INCLUDE_EVERYTHING_CONTEXT_FILTERS\n            }\n\n            // Exclude everything in case of an unexpected error.\n            return EXCLUDE_EVERYTHING_CONTEXT_FILTERS\n        }\n\n        return result\n    }\n\n    /**\n     * Checks if Cody is enabled on the current Sourcegraph instance.\n     * @returns\n     * enabled: Whether Cody is enabled.\n     * version: The Sourcegraph version.\n     *\n     * This method first checks the Sourcegraph version using `getSiteVersion()`.\n     * If the version is before 5.0.0, Cody is disabled.\n     * If the version is 5.0.0 or newer, it checks for the existence of the `isCodyEnabled` field using `getSiteHasIsCodyEnabledField()`.\n     * If the field exists, it calls `getSiteHasCodyEnabled()` to check its value.\n     * If the field does not exist, Cody is assumed to be enabled for versions between 5.0.0 - 5.1.0.\n     */\n    public async isCodyEnabled(): Promise<{ enabled: boolean; version: string }> {\n        // Check site version.\n        const siteVersion = await this.getSiteVersion()\n        if (isError(siteVersion)) {\n            return { enabled: false, version: 'unknown' }\n        }\n        const insiderBuild = siteVersion.length > 12 || siteVersion.includes('dev')\n        if (insiderBuild) {\n            return { enabled: true, version: siteVersion }\n        }\n        // NOTE: Cody does not work on versions older than 5.0\n        const versionBeforeCody = siteVersion < '5.0.0'\n        if (versionBeforeCody) {\n            return { enabled: false, version: siteVersion }\n        }\n        // Beta version is betwewen 5.0.0 - 5.1.0 and does not have isCodyEnabled field\n        const betaVersion = siteVersion >= '5.0.0' && siteVersion < '5.1.0'\n        const hasIsCodyEnabledField = await this.getSiteHasIsCodyEnabledField()\n        // The isCodyEnabled field does not exist before version 5.1.0\n        if (!betaVersion && !isError(hasIsCodyEnabledField) && hasIsCodyEnabledField) {\n            const siteHasCodyEnabled = await this.getSiteHasCodyEnabled()\n            return { enabled: !isError(siteHasCodyEnabled) && siteHasCodyEnabled, version: siteVersion }\n        }\n        return { enabled: insiderBuild || betaVersion, version: siteVersion }\n    }\n\n    /**\n     * recordTelemetryEvents uses the new Telemetry API to record events that\n     * gets exported: https://sourcegraph.com/docs/dev/background-information/telemetry\n     *\n     * Only available on Sourcegraph 5.2.0 and later.\n     *\n     * DO NOT USE THIS DIRECTLY - use an implementation of implementation\n     * TelemetryRecorder from '@sourcegraph/telemetry' instead.\n     */\n    public async recordTelemetryEvents(events: TelemetryEventInput[]): Promise<unknown | Error> {\n        for (const event of events) {\n            this.anonymizeTelemetryEventInput(event)\n        }\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<unknown>>(\n            RECORD_TELEMETRY_EVENTS_MUTATION,\n            {\n                events,\n            }\n        )\n        return extractDataOrError(initialResponse, data => data)\n    }\n\n    /**\n     * logEvent is the legacy event-logging mechanism.\n     * @deprecated use an implementation of implementation TelemetryRecorder\n     * from '@sourcegraph/telemetry' instead.\n     */\n    public async logEvent(event: event, mode: LogEventMode): Promise<LogEventResponse | Error> {\n        if (process.env.CODY_TESTING === 'true') {\n            return this.sendEventLogRequestToTestingAPI(event)\n        }\n        if (this.config?.telemetryLevel === 'off') {\n            return {}\n        }\n        /**\n         * If connected to dotcom, just log events to the instance, as it means\n         * the same thing.\n         */\n        if (this.isDotCom()) {\n            return this.sendEventLogRequestToAPI(event)\n        }\n\n        switch (process.env.CODY_LOG_EVENT_MODE) {\n            case 'connected-instance-only':\n                mode = 'connected-instance-only'\n                break\n            case 'dotcom-only':\n                mode = 'dotcom-only'\n                break\n            case 'all':\n                mode = 'all'\n                break\n            default:\n                if (process.env.CODY_LOG_EVENT_MODE) {\n                    logDebug(\n                        'SourcegraphGraphQLAPIClient.logEvent',\n                        'unknown mode',\n                        process.env.CODY_LOG_EVENT_MODE\n                    )\n                }\n        }\n\n        switch (mode) {\n            /**\n             * Only log events to dotcom, not the connected instance. Used when\n             * another mechanism delivers event logs the instance (i.e. the\n             * new telemetry clients)\n             */\n            case 'dotcom-only':\n                return this.sendEventLogRequestToDotComAPI(event)\n\n            /**\n             * Only log events to the connected instance, not dotcom. Used when\n             * another mechanism handles reporting to dotcom (i.e. the old\n             * client and/or the new telemetry framework, which exports events\n             * from all instances: https://sourcegraph.com/docs/dev/background-information/telemetry)\n             */\n            case 'connected-instance-only':\n                return this.sendEventLogRequestToAPI(event)\n\n            case 'all': // continue to default handling\n        }\n\n        /**\n         * Otherwise, send events to the connected instance AND to dotcom (default)\n         */\n        const responses = await Promise.all([\n            this.sendEventLogRequestToAPI(event),\n            this.sendEventLogRequestToDotComAPI(event),\n        ])\n        if (isError(responses[0]) && isError(responses[1])) {\n            return new Error(\n                `Errors logging events: ${responses[0].toString()}, ${responses[1].toString()}`\n            )\n        }\n        if (isError(responses[0])) {\n            return responses[0]\n        }\n        if (isError(responses[1])) {\n            return responses[1]\n        }\n        return {}\n    }\n\n    private anonymizeTelemetryEventInput(event: TelemetryEventInput): void {\n        if (isAgentTesting) {\n            event.timestamp = undefined\n            event.parameters.interactionID = undefined\n            event.parameters.billingMetadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.privateMetadata = {}\n        }\n    }\n\n    private anonymizeEvent(event: event): void {\n        if (isAgentTesting) {\n            event.publicArgument = undefined\n            event.argument = undefined\n            event.userCookieID = 'ANONYMOUS_USER_COOKIE_ID'\n            event.hashedLicenseKey = undefined\n        }\n    }\n\n    private async sendEventLogRequestToDotComAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const response = await this.fetchSourcegraphDotcomAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        return extractDataOrError(response, data => data)\n    }\n\n    private async sendEventLogRequestToAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n                LOG_EVENT_MUTATION_DEPRECATED,\n                event\n            )\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    private async sendEventLogRequestToTestingAPI(event: event): Promise<LogEventResponse | Error> {\n        const initialResponse =\n            await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse =\n                await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    public async searchAttribution(snippet: string): Promise<SearchAttributionResults | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SearchAttributionResponse>>(\n            SEARCH_ATTRIBUTION_QUERY,\n            {\n                snippet,\n            }\n        ).then(response => extractDataOrError(response, data => data.snippetAttribution))\n    }\n\n    public async getEvaluatedFeatureFlags(): Promise<Record<string, boolean> | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluatedFeatureFlagsResponse>>(\n            GET_FEATURE_FLAGS_QUERY,\n            {}\n        ).then(response => {\n            return extractDataOrError(response, data =>\n                data.evaluatedFeatureFlags.reduce((acc: Record<string, boolean>, { name, value }) => {\n                    acc[name] = value\n                    return acc\n                }, {})\n            )\n        })\n    }\n\n    public async evaluateFeatureFlag(flagName: string): Promise<boolean | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluateFeatureFlagResponse>>(\n            EVALUATE_FEATURE_FLAG_QUERY,\n            {\n                flagName,\n            }\n        ).then(response => extractDataOrError(response, data => data.evaluateFeatureFlag))\n    }\n\n    private fetchSourcegraphAPI<T>(\n        query: string,\n        variables: Record<string, any> = {}\n    ): Promise<T | Error> {\n        const headers = new Headers(this.config.customHeaders as HeadersInit)\n        headers.set('Content-Type', 'application/json; charset=utf-8')\n        if (this.config.accessToken) {\n            headers.set('Authorization', `token ${this.config.accessToken}`)\n        }\n        if (this.anonymousUserID) {\n            headers.set('X-Sourcegraph-Actor-Anonymous-UID', this.anonymousUserID)\n        }\n\n        addTraceparent(headers)\n        addCustomUserAgent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.config.serverEndpoint })\n        return wrapInActiveSpan(`graphql.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => {\n                    return new Error(`accessing Sourcegraph GraphQL API: ${error} (${url})`)\n                })\n        )\n    }\n\n    // make an anonymous request to the dotcom API\n    private fetchSourcegraphDotcomAPI<T>(\n        query: string,\n        variables: Record<string, any>\n    ): Promise<T | Error> {\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.dotcomUrl.href })\n        const headers = new Headers()\n        addCustomUserAgent(headers)\n        addTraceparent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        return wrapInActiveSpan(`graphql.dotcom.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => new Error(`error fetching Sourcegraph GraphQL API: ${error} (${url})`))\n        )\n    }\n\n    // make an anonymous request to the Testing API\n    private fetchSourcegraphTestingAPI<T>(body: Record<string, any>): Promise<T | Error> {\n        const url = 'http://localhost:49300/.test/testLogging'\n        const headers = new Headers({\n            'Content-Type': 'application/json',\n        })\n        addCustomUserAgent(headers)\n\n        return fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n        })\n            .then(verifyResponseCode)\n            .then(response => response.json() as T)\n            .catch(error => new Error(`error fetching Testing Sourcegraph API: ${error} (${url})`))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/nodeClient.ts:209-234"",""content"":""                        'Could not connect to Cody. Please ensure that you are connected to the Sourcegraph server.'\n                    )\n                }\n                log?.onError(error.message, e)\n                onErrorOnce(error)\n            })\n\n            // If the connection is closed and we did neither:\n            //\n            // - Receive an error HTTP code\n            // - Or any request body\n            //\n            // We still want to close the request.\n            request.on('close', () => {\n                if (!didReceiveAnyEvent) {\n                    logError(\n                        'SourcegraphNodeCompletionsClient',\n                        \""request.on('close')\"",\n                        'Connection closed without receiving any events',\n                        { verbose: { bufferText } }\n                    )\n                    onErrorOnce(new Error('Connection closed without receiving any events'))\n                }\n                if (!didSendMessage) {\n                    onErrorOnce(new Error('Connection unexpectedly closed'))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:954-956"",""content"":""function hasOutdatedAPIErrorMessages(error: Error): boolean {\n    return error.message.includes('Cannot query field')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:780-795"",""content"":""\n### Changed\n\n- Move decision about which autocomplete deployment to use for StarCoder to the server. [pull/1845](https://github.com/sourcegraph/cody/pull/1845)\n\n## [0.16.0]\n\n### Added\n\n- Chat: A new chat model selection dropdown that allows selecting between different chat models when connected to the sourcegraph.com instance. [pull/1676](https://github.com/sourcegraph/cody/pull/1676)\n- Chat: New button in editor title for restarting chat session in current chat panel (non-sidebar chat view). [pull/1687](https://github.com/sourcegraph/cody/pull/1687)\n- Chat: New `@` command that allows you to attach files via the chat input box. [pull/1631](https://github.com/sourcegraph/cody/pull/1631)\n- Edit: Added a specific, faster, response flow for fixes when triggered directly from code actions. [pull/1639](https://github.com/sourcegraph/cody/pull/1639)\n- Edit: Improved context fetching for quick fixes to better include code related to the problem. [pull/1723](https://github.com/sourcegraph/cody/pull/1723)\n- Chat: Added option to configure whether to add enhanced context from codebase for chat question in the new chat panel. [pull/1738](https://github.com/sourcegraph/cody/pull/1738)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:46-49"",""content"":""interface APIResponse<T> {\n    data?: T\n    errors?: { message: string; path?: string[] }[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/VSCodeApi.ts:21-21"",""content"":""let api: VSCodeWrapper\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:21-44"",""content"":"" *   Sourcegraph instance).\n * @param location The absolute URI to convert to a display path.\n */\nexport function displayPath(location: URI): string {\n    const result = _displayPath(location, checkEnvInfo())\n    return typeof result === 'string' ? result : result.toString()\n}\n\n/**\n * Dirname of the location's display path, to display to the user. Similar to\n * `dirname(displayPath(location))`, but it uses the right path separators in `dirname` ('\\' for\n * file URIs on Windows, '/' otherwise).\n *\n * The returned path string MUST ONLY be used for display purposes. It MUST NOT be used to identify\n * or locate files.\n *\n * Use this instead of other seemingly simpler techniques to avoid a few subtle\n * bugs/inconsistencies:\n *\n * - On Windows, Node's `dirname(uri.fsPath)` breaks on a non-`file` URI on Windows because\n *   `dirname` would use '\\' path separators but the URI would have '/' path separators.\n * - In a single-root workspace, Node's `dirname(uri.fsPath)` would return the root directory name,\n *   which is usually superfluous for display purposes. For example, if VS Code is open to a\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:694-705"",""content"":""  sign in to Sourcegraph.com directly. The extension will do this automatically if\n  possible but you may need to sign in again. If you have set up embeddings in\n  Cody App, VScode will now search your local embeddings automatically: You no\n  longer need to have the Cody App open. Note, the sidebar chat indicator may\n  say embeddings were not found while we work on improving chat.\n  [pull/2099](https://github.com/sourcegraph/cody/pull/2099)\n- Commands: Expose commands in the VS Code command palette and clean up the context menu. [pull/1209](https://github.com/sourcegraph/cody/pull/2109)\n- Search: Style and UX improvements to the search panel. [pull/2138](https://github.com/sourcegraph/cody/pull/2138)\n- Chat: Reduce size of chats list blank copy. [pull/2137](https://github.com/sourcegraph/cody/pull/2137)\n- Chat: Update message input placeholder to mention slash commands. [pull/2142](https://github.com/sourcegraph/cody/pull/2142)\n- Inline Chat will soon be deprecated in favor of the improved chat and command experience. It is now disabled by default and does not work when the new chat panel is enabled. [pull/1797](https://github.com/sourcegraph/cody/pull/1797)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:167-203"",""content"":""export type { CompletionLogger, CompletionsClientConfig } from './sourcegraph-api/completions/client'\nexport type {\n    CompletionParameters,\n    CompletionResponse,\n    Event,\n} from './sourcegraph-api/completions/types'\nexport { DOTCOM_URL, LOCAL_APP_URL, isDotCom } from './sourcegraph-api/environments'\nexport {\n    AbortError,\n    NetworkError,\n    RateLimitError,\n    TimeoutError,\n    TracedError,\n    isAbortError,\n    isAuthError,\n    isNetworkError,\n    isRateLimitError,\n} from './sourcegraph-api/errors'\nexport { SourcegraphGraphQLAPIClient, graphqlClient } from './sourcegraph-api/graphql'\nexport {\n    ConfigFeaturesSingleton,\n    addCustomUserAgent,\n    customUserAgent,\n    isNodeResponse,\n    setUserAgent,\n    type BrowserOrNodeResponse,\n    type GraphQLAPIClientConfig,\n    type LogEventMode,\n    type ContextFiltersResult,\n    type CodyContextFilterItem,\n    type RepoListResponse,\n} from './sourcegraph-api/graphql/client'\nexport type {\n    CodyLLMSiteConfiguration,\n    ContextSearchResult,\n    EmbeddingsSearchResult,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/protocol.ts:273-292"",""content"":""    )\n}\n\nexport type AuthMethod = 'dotcom' | 'github' | 'gitlab' | 'google'\n\n// Provide backward compatibility for the old token regex\n// Details: https://docs.sourcegraph.com/dev/security/secret_formats\nconst sourcegraphTokenRegex =\n    /(sgp_(?:[a-fA-F0-9]{16}|local)|sgp_)?[a-fA-F0-9]{40}|(sgd|slk|sgs)_[a-fA-F0-9]{64}/\n\n/**\n * Checks if the given text matches the regex for a Sourcegraph access token.\n *\n * @param text - The text to check against the regex.\n * @returns Whether the text matches the Sourcegraph token regex.\n */\nexport function isSourcegraphToken(text: string): boolean {\n    return sourcegraphTokenRegex.test(text)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_014/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code for inserting autocompletions can be found in the `cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts` file. Specifically, the `updateInsertRangeForVSCode` function is responsible for updating the insertion range for autocompletion items in VS Code:

```typescript
export function updateInsertRangeForVSCode(items: AutocompleteItem[]): AutocompleteItem[] {
    return items.map(item => {
        const {
            insertText,
            range,
            requestParams: { position, document },
        } = item

        const currentLine = document.lineAt(position)
        const currentLinePrefix = document.getText(currentLine.range.with({ end: position }))

        const start = currentLine.range.start
        // If the completion does not have a range set it will always exclude the same line suffix,
        // so it has to overwrite the current same line suffix and reach to the end of the line.
        const end = range?.end || currentLine.range.end

        const vscodeInsertRange = new vscode.Range(start, end)

        item.range = vscodeInsertRange
        item.insertText = currentLinePrefix + (insertText as string)

        return item
    })
}
```

This function updates the range and insert text for each autocomplete item to ensure it is correctly inserted into the document.",Where is the code for inserting autocompletions?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:345-367"",""content"":""\n### Language ignore list\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion for file in the X programming language.\n- [ ] Open VS Code settings, find the language ignore list, and add this language to the list\n- [ ] Verify that completions are no longer generated for this language.\n\n### LLM selection\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion using the LLM selected by default.\n- [ ] Open VS Code settings and find Cody autocomplete mode settings.\n  - Combinations to test:\n    - [ ] Provider: fireworks; Model: starcoder-16 and starcoder-7b\n    - [ ] Provider: anthropic; Model: null\n- [ ] Verify that autocomplete works as expected after the settings change.\n\n### Multi-line completions\n\n- [ ] Open a TypeScript file. Paste in something like this: `function bubbleSort(`.\n- [ ] Expect more than one line of code being completed for you.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/tracer/traceView.ts:0-24"",""content"":""import * as vscode from 'vscode'\n\nimport { displayPath, displayRange, isDefined, renderMarkdown } from '@sourcegraph/cody-shared'\n\nimport {\n    SectionHistoryRetriever,\n    registerDebugListener as registerSectionObserverDebugListener,\n} from '../context/retrievers/section-history/section-history-retriever'\nimport { InlineCompletionsResultSource } from '../get-inline-completions'\nimport type { InlineCompletionItemProvider } from '../inline-completion-item-provider'\nimport * as statistics from '../statistics'\nimport type { InlineCompletionItem } from '../types'\n\nimport type { ProvideInlineCompletionsItemTraceData } from '.'\n\n/**\n * Registers a command `Cody: Open Autocomplete Trace View` that shows the context and prompt used\n * for autocomplete.\n */\nexport function registerAutocompleteTraceView(\n    provider: InlineCompletionItemProvider\n): vscode.Disposable {\n    let panel: vscode.WebviewPanel | null = null\n    let latestInvocationSequence = 0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:21-172"",""content"":""export class AutocompleteMatcher {\n    public parser: WrappedParser | undefined\n    public originalTree: Tree | undefined\n    public originalTreeIsFreeOfErrrors: boolean | undefined\n    constructor(\n        public readonly params: EvaluationDocumentParams,\n        public readonly queries: Queries,\n        public readonly grammarDirectory: string\n    ) {}\n    private ifSyntax(language: SupportedLanguage): string {\n        switch (language) {\n            case SupportedLanguage.go:\n                return 'if  '\n            default:\n                return 'if ()'\n        }\n    }\n    public async matches(text: string): Promise<AutocompleteMatch[] | undefined> {\n        const { languageid: language } = this.params\n\n        if (!isSupportedLanguage(language)) {\n            return undefined\n        }\n        this.parser = await createParser({ language, grammarDirectory: this.grammarDirectory })\n        if (!this.parser) {\n            return undefined\n        }\n        const query = await this.queries.loadQuery(this.parser, language, 'context')\n        if (!query) {\n            return\n        }\n        this.originalTree = this.parser.parse(text)\n        this.originalTreeIsFreeOfErrrors = !this.originalTree.rootNode.hasError()\n        const result: AutocompleteMatch[] = []\n        const document = new EvaluationDocument(this.params, text, vscode.Uri.file(this.params.filepath))\n        for (const queryMatch of query.matches(this.originalTree.rootNode)) {\n            for (const capture of queryMatch.captures) {\n                if (capture.name === 'if_statement') {\n                    const ifSyntax = this.ifSyntax(language)\n\n                    const newText = [\n                        text.slice(0, capture.node.startIndex),\n                        ifSyntax,\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'if_statement',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            capture.node.startIndex + ifSyntax.length - 1\n                        ),\n                    })\n                } else if (capture.name === 'function_declaration') {\n                    const openParen = queryMatch.captures.find(c => c.name === 'opening_paren')?.node\n                    if (!openParen) {\n                        throw new Error('Missing capture group @opening_paren for @function_declaration')\n                    }\n                    const newText = [\n                        text.slice(0, openParen.startIndex),\n                        '()',\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'function_declaration',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            openParen.startIndex + '('.length\n                        ),\n                    })\n                } else if (capture.name === 'call_expression') {\n                    const openParenPosition = queryMatch.captures.find(c => c.name === 'opening_paren')\n                        ?.node.startIndex\n                    const closeParenPosition = queryMatch.captures.find(c => c.name === 'closing_paren')\n                        ?.node.endIndex\n                    if (openParenPosition && closeParenPosition) {\n                        const openParenSyntax = text.charAt(openParenPosition) ?? '('\n                        const closeParenSyntax = text.charAt(closeParenPosition - 1) ?? ')'\n                        if (\n                            closeParenSyntax !== ')' &&\n                            closeParenSyntax !== '}' &&\n                            closeParenSyntax !== ']' &&\n                            closeParenSyntax !== '>'\n                        ) {\n                            throw new Error(\n                                `Invalid close paren syntax. ${JSON.stringify({\n                                    params: this.params,\n                                    closeParenSyntax,\n                                })}`\n                            )\n                        }\n                        const newText = [\n                            text.slice(0, openParenPosition),\n                            openParenSyntax,\n                            closeParenSyntax,\n                            text.slice(closeParenPosition),\n                        ]\n                        result.push({\n                            kind: 'call_expression',\n                            newText: newText.join(''),\n                            removedText: text.slice(openParenPosition, closeParenPosition),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(openParenPosition),\n                                document.textDocument.positionAt(closeParenPosition)\n                            ),\n                            requestPosition: document.textDocument.positionAt(\n                                openParenPosition + openParenSyntax.length\n                            ),\n                        })\n                    } else {\n                        throw new Error(\n                            `Missing @opening_paren and/or @closing_parent captures for node: ${capture.node.text}`\n                        )\n                    }\n                } else if (capture.name === 'assignment_statement') {\n                    const equalSign = queryMatch.captures.find(c => c.name === 'equal_sign')?.node\n                    if (equalSign) {\n                        const startIndex = equalSign.startIndex\n                        const endIndex =\n                            text.at(capture.node.endIndex) === ';'\n                                ? capture.node.endIndex + 1\n                                : capture.node.endIndex\n                        const newText = [text.slice(0, startIndex), text.slice(endIndex)]\n                        result.push({\n                            kind: 'assignment_statement',\n                            newText: newText.join(''),\n                            removedText: text.slice(startIndex, endIndex),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(startIndex),\n                                document.textDocument.positionAt(endIndex)\n                            ),\n                            requestPosition: document.textDocument.positionAt(startIndex - 1),\n                        })\n                    } else {\n                        throw new Error(`Missing @equal_sign capture for node: ${capture.node.text}`)\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:33-66"",""content"":""\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:17-31"",""content"":""export interface AutocompleteParameters {\n    parser?: WrappedParser\n    originalTree?: Tree\n    originalTreeIsErrorFree?: boolean\n    client: MessageHandler\n    document: EvaluationDocument\n\n    options: EvaluateAutocompleteOptions\n\n    range: vscode.Range\n    autocompleteKind?: AutocompleteMatchKind\n    modifiedContent: string\n    removedContent: string\n    position: vscode.Position\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:14-20"",""content"":""interface AutocompleteMatch {\n    kind: AutocompleteMatchKind\n    newText: string\n    removedText: string\n    removedRange: vscode.Range\n    requestPosition: vscode.Position\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:342-378"",""content"":""\ninterface CompletionItemParams {\n    completionID: string\n}\n\ninterface AutocompleteParams {\n    uri: string\n    filePath?: string\n    position: Position\n    // Defaults to 'Automatic' for autocompletions which were not explicitly\n    // triggered.\n    triggerKind?: 'Automatic' | 'Invoke'\n    selectedCompletionInfo?: SelectedCompletionInfo\n}\n\ninterface SelectedCompletionInfo {\n    readonly range: Range\n    readonly text: string\n}\n\nexport interface ChatExportResult {\n    chatID: string\n    transcript: SerializedChatTranscript\n}\nexport interface AutocompleteResult {\n    items: AutocompleteItem[]\n\n    /** completionEvent is not deprecated because it's used by non-editor clients like evaluate-autocomplete that need access to book-keeping data to evaluate results. */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\nexport interface AutocompleteItem {\n    id: string\n    insertText: string\n    range: Range\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:33-162"",""content"":""export async function triggerAutocomplete(parameters: AutocompleteParameters): Promise<void> {\n    const { range, client, document, modifiedContent, autocompleteKind, removedContent, position } =\n        parameters\n    client.notify('textDocument/didChange', {\n        uri: document.uri.toString(),\n        filePath: document.uri.fsPath,\n        content: modifiedContent,\n    })\n    let result: AutocompleteResult\n    try {\n        result = await client.request('autocomplete/execute', {\n            uri: document.uri.toString(),\n            filePath: document.uri.fsPath,\n            position,\n            // We don't use the \""automatic\"" trigger to avoid certain code paths like\n            // synthetic latency when acceptance rate is low.\n            triggerKind: 'Invoke',\n        })\n    } catch (error) {\n        const resultError = error instanceof Error ? error.message : String(error)\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultError,\n        })\n        return\n    }\n\n    const didNotSendNetworkRequest =\n        result.items.length === 0 && result.completionEvent?.networkRequestStartedAt === null\n    if (didNotSendNetworkRequest) {\n        return\n    }\n\n    const textDocument = new AgentTextDocument(\n        ProtocolTextDocumentWithUri.from(document.uri, { content: modifiedContent })\n    )\n    for (const [index, item] of result.items.entries()) {\n        const info = result.completionEvent?.items?.[index]\n        const original = textDocument.getText(\n            new vscode.Range(\n                item.range.start.line,\n                item.range.start.character,\n                item.range.end.line,\n                item.range.end.character\n            )\n        )\n        const start = new vscode.Position(item.range.start.line, item.range.start.character)\n        const end = new vscode.Position(item.range.end.line, item.range.end.character)\n        const modifiedDocument = new AgentTextDocument(\n            ProtocolTextDocumentWithUri.from(document.uri, { content: parameters.modifiedContent })\n        )\n        const newText = [\n            modifiedDocument.getText(new vscode.Range(new vscode.Position(0, 0), start)),\n            item.insertText,\n            modifiedDocument.getText(\n                new vscode.Range(end, new vscode.Position(modifiedDocument.lineCount, 0))\n            ),\n        ].join('')\n        const testParameters: TestParameters = { ...parameters, item, newText }\n        let resultParses: boolean | undefined\n        if (parameters.originalTreeIsErrorFree && parameters.parser && parameters.options.testParse) {\n            resultParses = testParses(newText, parameters.parser)\n        }\n\n        const resultTypechecks = await testTypecheck(testParameters)\n        const patches: string[] = []\n        let hasNonInsertPatch = false\n        for (const [sx, ex, text] of calcPatch(original, item.insertText)) {\n            if (sx !== ex) {\n                hasNonInsertPatch = true\n                continue\n            }\n            patches.push(text)\n        }\n        if (hasNonInsertPatch) {\n            document.pushItem({\n                resultText: item.insertText,\n                autocompleteKind,\n                range,\n                resultTypechecks,\n                resultParses,\n                resultNonInsertPatch: true,\n                event: result.completionEvent,\n                info,\n            })\n        } else if (patches.length > 0) {\n            const text = patches.join('')\n            if (text === removedContent) {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultExact: true,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            } else {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultText: text,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            }\n        } else {\n            document.pushItem({\n                autocompleteKind,\n                info,\n                range,\n                resultEmpty: true,\n                event: result.completionEvent,\n                resultParses,\n            })\n        }\n    }\n    if (result.items.length === 0) {\n        const expectedEmptyMatch = removedContent === ''\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultExact: expectedEmptyMatch,\n            resultEmpty: !expectedEmptyMatch,\n        })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/logger.ts:62-92"",""content"":""\n    /** Wether the completion is a singleline or multiline one. */\n    multiline: boolean\n\n    /**\n     * `null` means singleline, `block` means multiline.\n     * @deprecated Use `multiline` instead.\n     */\n    multilineMode: null | 'block'\n\n    /** Describes how the autocomplete request was triggered by the user. */\n    triggerKind: TriggerKind\n\n    /** Information about what provider is used. e.g. `anthropic` or `fireworks`. */\n    providerIdentifier: string\n\n    /** Information about which model was used. e.g. `starcoder-7b` or `claude-instant`. */\n    providerModel: string\n\n    /** Language of the document being completed. */\n    languageId: string\n\n    /** If we're inside a test file */\n    testFile: boolean\n\n    /**\n     * Information about the context retrieval process that lead to this autocomplete request. Refer\n     * to the documentation of {@link ContextSummary}\n     */\n    contextSummary?: ContextSummary\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:25-38"",""content"":""    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/unstable-openai.ts:0-36"",""content"":""import {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport { forkSignal, generatorWithTimeout, zipGenerators } from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n} from './provider'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:0-45"",""content"":""import * as anthropic from '@anthropic-ai/sdk'\n\nimport {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type Message,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    type PrefixComponents,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport {\n    forkSignal,\n    generatorWithErrorObserver,\n    generatorWithTimeout,\n    messagesToText,\n    zipGenerators,\n} from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:47-82"",""content"":""} from './suggested-autocomplete-items-cache'\nimport type { ProvideInlineCompletionItemsTracer, ProvideInlineCompletionsItemTraceData } from './tracer'\n\ninterface AutocompleteResult extends vscode.InlineCompletionList {\n    logId: CompletionLogID\n    items: AutocompleteItem[]\n    /** @deprecated */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\ninterface CodyCompletionItemProviderConfig {\n    providerConfig: ProviderConfig\n    statusBar: CodyStatusBar\n    tracer?: ProvideInlineCompletionItemsTracer | null\n    triggerNotice: ((notice: { key: string }) => void) | null\n    isRunningInsideAgent?: boolean\n\n    authStatus: AuthStatus\n    isDotComUser?: boolean\n\n    createBfgRetriever?: () => BfgRetriever\n\n    // Settings\n    formatOnAccept?: boolean\n    disableInsideComments?: boolean\n\n    // Feature flags\n    completeSuggestWidgetSelection?: boolean\n}\n\ninterface CompletionRequest {\n    document: vscode.TextDocument\n    position: vscode.Position\n    context: vscode.InlineCompletionContext\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:95-112"",""content"":""        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/request-manager.ts:0-28"",""content"":""import { partition } from 'lodash'\nimport { LRUCache } from 'lru-cache'\nimport type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    FeatureFlag,\n    isDefined,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport { addAutocompleteDebugEvent } from '../services/open-telemetry/debug-utils'\n\nimport { logDebug } from '../log'\nimport { completionProviderConfig } from './completion-provider-config'\nimport {\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n} from './get-inline-completions'\nimport { type CompletionLogID, logCompletionBookkeepingEvent } from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport { STOP_REASON_HOT_STREAK } from './providers/hot-streak'\nimport type { CompletionProviderTracer, Provider } from './providers/provider'\nimport { reuseLastCandidate } from './reuse-last-candidate'\nimport { lines, removeIndentation } from './text-processing'\nimport {\n    type InlineCompletionItemWithAnalytics,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/codeblock-action-tracker.ts:77-94"",""content"":""export async function handleCodeFromInsertAtCursor(text: string): Promise<void> {\n    const editor = getEditor()\n    const activeEditor = editor.active\n    const selectionRange = activeEditor?.selection\n    if (!activeEditor || !selectionRange) {\n        throw new Error('No editor or selection found to insert text')\n    }\n\n    const edit = new vscode.WorkspaceEdit()\n    // trimEnd() to remove new line added by Cody\n    edit.insert(activeEditor.document.uri, selectionRange.start, `${text}\\n`)\n    await vscode.workspace.applyEdit(edit)\n\n    // Log insert event\n    const op = 'insert'\n    const eventName = `${op}Button`\n    setLastStoredCode(text, eventName)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1033-1050"",""content"":""          \""default\"": null,\n          \""enum\"": [null, \""starcoder-16b\"", \""starcoder-7b\"", \""llama-code-13b\""],\n          \""markdownDescription\"": \""Overwrite the  model used for code autocompletion inference. This is only supported with the `fireworks` provider\""\n        },\n        \""cody.autocomplete.completeSuggestWidgetSelection\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Autocomplete based on the currently selection in the suggest widget. Requires the VS Code user setting `editor.inlineSuggest.suppressSuggestions` set to true and will change it to true in user settings if it is not true.\""\n        },\n        \""cody.autocomplete.formatOnAccept\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Format completions on accept using [the default document formatter](https://code.visualstudio.com/docs/editor/codebasics#_formatting).\""\n        },\n        \""cody.autocomplete.disableInsideComments\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/autocomplete.md:0-11"",""content"":""## Code Autocomplete\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-cody-autocomplete-tsx.gif\"">\n\nStart writing code and Cody will complete the line (or the entire function) for you. Hit tab to accept the suggestion.\n\n**✨ Pro-tips for using Cody autocomplete**\n<br>• Autocomplete uses the surrounding code and context to inform the suggestions, so if you need to guide it you can add a comment above the line you're editing.\n<br>• You can hover over the grey suggestion to see a toolbar of alternative suggestions, as well as other options such as accepting a single word at a time.\n<br>• You can use the \""Trigger Autocomplete at Cursor\"" command to trigger a code suggestion at any time, using the default keyboard shortcut of `Option` `\\` on macOS and `Alt` `\\` on Windows & Linux.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts:171-194"",""content"":""export function updateInsertRangeForVSCode(items: AutocompleteItem[]): AutocompleteItem[] {\n    return items.map(item => {\n        const {\n            insertText,\n            range,\n            requestParams: { position, document },\n        } = item\n\n        const currentLine = document.lineAt(position)\n        const currentLinePrefix = document.getText(currentLine.range.with({ end: position }))\n\n        const start = currentLine.range.start\n        // If the completion does not have a range set it will always exclude the same line suffix,\n        // so it has to overwrite the current same line suffix and reach to the end of the line.\n        const end = range?.end || currentLine.range.end\n\n        const vscodeInsertRange = new vscode.Range(start, end)\n\n        item.range = vscodeInsertRange\n        item.insertText = currentLinePrefix + (insertText as string)\n\n        return item\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:24-47"",""content"":""import { formatCompletion } from './format-completion'\nimport { getCurrentDocContext } from './get-current-doc-context'\nimport {\n    type InlineCompletionsParams,\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n    TriggerKind,\n    getInlineCompletions,\n} from './get-inline-completions'\nimport { isCompletionVisible } from './is-completion-visible'\nimport type { CompletionBookkeepingEvent, CompletionItemID, CompletionLogID } from './logger'\nimport * as CompletionLogger from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport type { ProviderConfig } from './providers/provider'\nimport { RequestManager, type RequestParams } from './request-manager'\nimport { getRequestParamsFromLastCandidate } from './reuse-last-candidate'\nimport { SmartThrottleService } from './smart-throttle'\nimport {\n    type AutocompleteInlineAcceptedCommandArgs,\n    type AutocompleteItem,\n    analyticsItemToAutocompleteItem,\n    suggestedAutocompleteItemsCache,\n    updateInsertRangeForVSCode,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:998-1015"",""content"":""### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n- Now removes completions from cache when the initial suggestion prefix is deleted by users after a suggestion was displayed. This avoids unhelpful/stale suggestions from persisting. [pull/1105](https://github.com/sourcegraph/cody/pull/1105)\n- VScode can now share a dotcom access token with future versions of Cody App. [pull/1090](https://github.com/sourcegraph/cody/pull/1090)\n\n### Fixed\n\n- Fix a potential race condition for autocomplete requests that happen when a completion is stored as the last shown candidate when it will not be shown. [pull/1059](https://github.com/sourcegraph/cody/pull/1059)\n- Use `insert` instead of `replace` for `Insert at Cursor` button for inserting code to current cursor position. [pull/1118](https://github.com/sourcegraph/cody/pull/1118)\n- Autocomplete: Fix support for working with CRLF line endings. [pull/1124](https://github.com/sourcegraph/cody/pull/1124)\n- Fix issue that caused the custom commands menu to unable to execute commands. [pull/1123](https://github.com/sourcegraph/cody/pull/1123)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:66-98"",""content"":""\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nexport interface AutocompleteTimeouts {\n    multiline?: number\n    singleline?: number\n}\n\nexport interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n}\n""}]",Find logic,,,0,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_015/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The context items from different sources are chosen and combined in the `context-mixer.ts` file. Specifically, the `ContextMixer` class is responsible for combining multiple context retrieval strategies into a single proposed context list. This is done by ranking the order of documents using reciprocal rank fusion and then combining the snippets from each retriever into a single list using top-k.

Here's the relevant part of the `context-mixer.ts` file:

```typescript
/**
 * The context mixer is responsible for combining multiple context retrieval strategies into a
 * single proposed context list.
 *
 * This is done by ranking the order of documents using reciprocal rank fusion and then combining
 * the snippets from each retriever into a single list using top-k (so we will pick all returned
 * snippets from the top-k documents).
 */
export class ContextMixer {
    // ...
}
```

Additionally, the `context-strategy.ts` file defines different context strategies and retrievers, which are used by the `ContextMixer`:

```typescript
export type ContextStrategy =
    | 'bfg'
    | 'jaccard-similarity'
    | 'new-jaccard-similarity'
    | 'bfg-mixed'
    | 'local-mixed'
    | 'none'

export interface ContextStrategyFactory extends vscode.Disposable {
    getStrategy(document: vscode.TextDocument): { name: ContextStrategy; retrievers: ContextRetriever[] }
}
```

The `DefaultContextStrategyFactory` class in the same file provides the strategy and retrievers based on the configuration:

```typescript
export class DefaultContextStrategyFactory implements ContextStrategyFactory {
    private disposables: vscode.Disposable[] = []

    private localRetriever: ContextRetriever | undefined
    private graphRetriever: ContextRetriever | undefined

    // ...
}
```

In summary, the context items from different sources are chosen and combined by the `ContextMixer` class, which uses various context strategies and retrievers defined in the `context-strategy.ts` file.",Where do we choose the context items from different sources?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:168-197"",""content"":""    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:26-66"",""content"":""export type {\n    ChatError,\n    EventSource,\n    ChatHistory,\n    ChatMessage,\n    UserLocalHistory,\n    SerializedChatMessage,\n} from './chat/transcript/messages'\nexport {\n    CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID,\n    webviewOpenURIForContextItem,\n} from './chat/transcript/display-text'\nexport { Typewriter } from './chat/typewriter'\nexport { reformatBotMessageForChat } from './chat/viewHelpers'\nexport type {\n    ContextGroup,\n    ContextProvider,\n    ContextStatusProvider,\n    Disposable,\n    EnhancedContextContextT,\n    LocalEmbeddingsProvider,\n    LocalSearchProvider,\n    RemoteSearchProvider,\n    SearchProvider,\n} from './codebase-context/context-status'\nexport {\n    type ContextItem,\n    type ContextItemFile,\n    ContextItemSource,\n    type ContextItemWithContent,\n    type ContextItemSymbol,\n    type ContextFileType,\n    type ContextMessage,\n    type SymbolKind,\n} from './codebase-context/messages'\nexport type {\n    CodyCommand,\n    CodyCommandContext,\n    CodyCommandType,\n    TerminalOutputArguments,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:190-199"",""content"":""export function $createContextItemMentionNode(\n    contextItem: ContextItem | SerializedContextItem\n): ContextItemMentionNode {\n    const node = new ContextItemMentionNode(contextItem)\n    node.setMode('token').toggleDirectionless()\n    contextItem.type === 'file' &&\n        contextItem.isTooLarge &&\n        node.setStyle('color: var(--vscode-list-errorForeground)')\n    return $applyNodeReplacement(node)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/cells/contextCell/ContextCell.tsx:0-27"",""content"":""import type { ContextItem } from '@sourcegraph/cody-shared'\nimport classNames from 'classnames'\nimport type React from 'react'\nimport { FileLink } from '../../../Components/FileLink'\nimport { SourcegraphLogo } from '../../../icons/SourcegraphLogo'\nimport { MENTION_CLASS_NAME } from '../../../promptEditor/nodes/ContextItemMentionNode'\nimport { getVSCodeAPI } from '../../../utils/VSCodeApi'\nimport { LoadingDots } from '../../components/LoadingDots'\nimport { Cell } from '../Cell'\nimport styles from './ContextCell.module.css'\n\n/**\n * A component displaying the context for a human message.\n */\nexport const ContextCell: React.FunctionComponent<{\n    contextFiles: ContextItem[] | undefined\n    disabled?: boolean\n    className?: string\n\n    /** For use in storybooks only. */\n    __storybook__initialOpen?: boolean\n}> = ({ contextFiles, disabled, className, __storybook__initialOpen }) => {\n    const usedContext = []\n    const excludedAtContext = []\n    if (contextFiles) {\n        for (const f of contextFiles) {\n            if (f.isTooLarge) {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/cody.json:16-24"",""content"":""      \""context\"": {\n        \""currentFile\"": true\n      },\n      \""type\"": \""default\""\n    },\n    \""test\"": {\n      \""description\"": \""Generate unit tests\"",\n      \""prompt\"": \""Review the shared context to identify the testing framework and libraries in use. Then, generate a suite of multiple unit tests for the selected function using the detected test framework and libraries. Be sure to import the function being tested. Use the same patterns, testing framework, conventions, and libraries as shown in the shared context. Only import modules, functions, dependencies, and mocks based on shared code. If a test suite for the selected code is in the shared context, focus on generating new tests for uncovered cases. If none are detected, import common unit test libraries for {languageName}. Focus on validating key functionality with simple and complete assertions. Before writing the tests, identify which testing libraries and frameworks to use and import. At the end, enclose the fully completed code for the new unit tests without any comments, fragments, or TODOs. The new tests should validate the expected functionality and cover edge cases for with all required imports, including the function being tested. Do not repeat tests from the shared context. Enclose only the complete runnable tests.\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:130-167"",""content"":""} from './inferenceClient/misc'\nexport type {\n    ContextResult,\n    FilenameContextFetcher,\n    IndexedKeywordContextFetcher,\n    LocalEmbeddingsFetcher,\n    IRemoteSearch,\n    Result,\n    SearchPanelFile,\n    SearchPanelSnippet,\n} from './local-context'\nexport { logDebug, logError, setLogger } from './logger'\nexport {\n    createOllamaClient,\n    ollamaChatClient,\n    type OllamaGenerateParams,\n    OLLAMA_DEFAULT_URL,\n} from './llm-providers/ollama'\nexport {\n    MAX_BYTES_PER_FILE,\n    MAX_CURRENT_FILE_TOKENS,\n    ANSWER_TOKENS,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    SURROUNDING_LINES,\n} from './prompt/constants'\nexport { PromptMixin, newPromptMixin } from './prompt/prompt-mixin'\nexport * from './prompt/templates'\nexport {\n    truncateText,\n    truncateTextNearestLine,\n    truncatePromptStringStart,\n    truncatePromptString,\n} from './prompt/truncation'\nexport type { Message } from './sourcegraph-api'\nexport { SourcegraphBrowserCompletionsClient } from './sourcegraph-api/completions/browserClient'\nexport { SourcegraphCompletionsClient } from './sourcegraph-api/completions/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:213-217"",""content"":""export function $createContextItemTextNode(contextItem: ContextItem | SerializedContextItem): TextNode {\n    const atNode = new ContextItemMentionNode(contextItem)\n    const textNode = new TextNode(atNode.__text)\n    return $applyNodeReplacement(textNode)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:418-421"",""content"":""\n    return context.concat(currentFileNameComment, prompt.prefix)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:59-73"",""content"":""function convertContextItemMentionElement(domNode: HTMLElement): DOMConversionOutput | null {\n    const data = domNode.getAttribute(DOM_DATA_ATTR)\n    if (data !== null) {\n        try {\n            const contextItem: SerializedContextItem = JSON.parse(data)\n            const node = $createContextItemMentionNode(contextItem)\n            return { node }\n        } catch (error) {\n            console.error(error)\n            return null\n        }\n    }\n\n    return null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItem.kt:22-53"",""content"":""\ndata class ContextItemFile(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: file\n) : ContextItem() {\n\n  enum class TypeEnum {\n    @SerializedName(\""file\"") File,\n  }\n}\n\ndata class ContextItemSymbol(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: symbol\n  val symbolName: String? = null,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:77-173"",""content"":""export class ContextItemMentionNode extends TextNode {\n    static getType(): string {\n        return 'contextItemMention'\n    }\n\n    static clone(node: ContextItemMentionNode): ContextItemMentionNode {\n        return new ContextItemMentionNode(node.contextItem, node.__text, node.__key)\n    }\n    static importJSON(serializedNode: SerializedContextItemMentionNode): ContextItemMentionNode {\n        const node = $createContextItemMentionNode(serializedNode.contextItem)\n        node.setTextContent(serializedNode.text)\n        node.setFormat(serializedNode.format)\n        node.setDetail(serializedNode.detail)\n        node.setMode(serializedNode.mode)\n        node.setStyle(serializedNode.style)\n        return node\n    }\n\n    private contextItem: SerializedContextItem\n\n    constructor(\n        contextItemWithAllFields: ContextItem | SerializedContextItem,\n        text?: string,\n        key?: NodeKey\n    ) {\n        // Make sure we only bring over the fields on the context item that we need, or else we\n        // could accidentally include tons of data (including the entire contents of files).\n        const contextItem = serializeContextItem(contextItemWithAllFields)\n\n        super(text ?? contextItemMentionNodeDisplayText(contextItem), key)\n\n        this.contextItem = contextItem\n    }\n\n    exportJSON(): SerializedContextItemMentionNode {\n        return {\n            ...super.exportJSON(),\n            contextItem: this.contextItem,\n            type: ContextItemMentionNode.getType(),\n            version: 1,\n        }\n    }\n\n    private static CLASS_NAMES = `context-item-mention-node ${styles.contextItemMentionNode}`\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config)\n        element.className = ContextItemMentionNode.CLASS_NAMES\n        return element\n    }\n\n    exportDOM(): DOMExportOutput {\n        const element = document.createElement('span')\n        element.setAttribute(DOM_DATA_ATTR, JSON.stringify(this.contextItem))\n        element.className = ContextItemMentionNode.CLASS_NAMES\n\n        const link = document.createElement('a')\n        const { href, target } = webviewOpenURIForContextItem({\n            uri: URI.parse(this.contextItem.uri),\n            range: this.contextItem.range,\n        })\n        link.href = href\n        if (target) {\n            link.target = target\n        }\n        link.textContent = this.__text\n        element.appendChild(link)\n\n        return { element }\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            span: (domNode: HTMLElement) => {\n                if (!domNode.hasAttribute(DOM_DATA_ATTR)) {\n                    return null\n                }\n                return {\n                    conversion: convertContextItemMentionElement,\n                    priority: 1,\n                }\n            },\n        }\n    }\n\n    isTextEntity(): true {\n        return true\n    }\n\n    canInsertTextBefore(): boolean {\n        return false\n    }\n\n    canInsertTextAfter(): boolean {\n        return false\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-input.ts:396-419"",""content"":""\n                const matchingContext = await getMatchingContext(mentionQuery)\n                if (matchingContext.length === 0) {\n                    // Attempted to match but found nothing\n                    input.items = [\n                        {\n                            alwaysShow: true,\n                            label:\n                                mentionQuery.type === 'symbol'\n                                    ? mentionQuery.text.length === 0\n                                        ? SYMBOL_HELP_LABEL\n                                        : NO_SYMBOL_MATCHES_LABEL\n                                    : mentionQuery.text.length === 0\n                                      ? FILE_HELP_LABEL\n                                      : NO_FILE_MATCHES_LABEL,\n                        },\n                    ]\n                    return\n                }\n\n                // Update stored context items so we can retrieve them later\n                for (const { key, item } of matchingContext) {\n                    contextItems.set(key, item)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:50-52"",""content"":""export function deserializeContextItem(contextItem: SerializedContextItem): ContextItem {\n    return { ...contextItem, uri: URI.parse(contextItem.uri) }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320"",""content"":""\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:35-48"",""content"":""export function serializeContextItem(\n    contextItem: ContextItem | SerializedContextItem\n): SerializedContextItem {\n    // Make sure we only bring over the fields on the context item that we need, or else we\n    // could accidentally include tons of data (including the entire contents of files).\n    return {\n        ...contextItem,\n        uri: contextItem.uri.toString(),\n\n        // Don't include the `content` (if it's present) because it's quite large, and we don't need\n        // to serialize it here. It can be hydrated on demand.\n        content: undefined,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:40-68"",""content"":""export async function fetchContentForURLContextItem(\n    url: string,\n    signal?: AbortSignal\n): Promise<string | null> {\n    const resp = await fetch(url.toString(), { signal })\n    if (!resp.ok) {\n        return null\n    }\n    const body = await resp.text()\n\n    // HACK(sqs): Rudimentarily strip HTML tags, script, and other unneeded elements from body using\n    // regexp. This is NOT intending to be a general-purpose HTML parser and is NOT sanitizing the\n    // value for security.\n    const bodyWithoutTags = body\n        .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n        .replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '')\n        .replace(/<svg\\b[^<]*(?:(?!<\\/svg>)<[^<]*)*<\\/svg>/gi, '')\n        .replace(/<!--.*?-->/gs, '')\n        .replace(/\\s(?:class|style)=[\""'][^\""']*[\""']/gi, '')\n        .replace(/\\sdata-[\\w-]+(=[\""'][^\""']*[\""'])?/gi, '')\n\n    // TODO(sqs): Arbitrarily trim the response text to avoid overflowing the context window for the\n    // LLM. Ideally we would make the prompt builder prioritize this context item over other context\n    // because it is explicitly from the user.\n    const MAX_LENGTH = 14000\n    return bodyWithoutTags.length > MAX_LENGTH\n        ? `${bodyWithoutTags.slice(0, MAX_LENGTH)}... (web page content was truncated)`\n        : bodyWithoutTags\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-matching-context.ts:0-31"",""content"":""import type { ContextItem, MentionQuery } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\n\nimport { getChatContextItemsForMention } from '../../chat/context/chatContext'\nimport { getLabelForContextItem } from './utils'\n\ninterface FixupMatchingContext {\n    /* Unique identifier for the context, shown in the input value but not necessarily in the quick pick selector */\n    key: string\n    /* If present, will override the key shown in the quick pick selector */\n    shortLabel?: string\n    item: ContextItem\n}\n\nexport async function getMatchingContext(mentionQuery: MentionQuery): Promise<FixupMatchingContext[]> {\n    const token = new vscode.CancellationTokenSource()?.token\n    const results = await getChatContextItemsForMention(mentionQuery, token)\n    return results.map(result => {\n        return {\n            key: getLabelForContextItem(result),\n            item: result,\n            shortLabel:\n                result.type === 'symbol'\n                    ? `${result.kind === 'class' ? '$(symbol-structure)' : '$(symbol-method)'} ${\n                          result.symbolName\n                      }`\n                    : undefined,\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:7-34"",""content"":""export async function getURLContextItems(\n    urlInput: string,\n    signal?: AbortSignal\n): Promise<ContextItem[]> {\n    const url = tryParsePossiblyIncompleteURL(urlInput)\n    if (url === null) {\n        return []\n    }\n\n    try {\n        const content = await fetchContentForURLContextItem(url.toString(), signal)\n        if (content === null) {\n            return []\n        }\n        return [\n            {\n                type: 'file',\n                uri: url,\n                content,\n                title: tryGetHTMLDocumentTitle(content),\n                source: ContextItemSource.Uri,\n            },\n        ]\n    } catch (error) {\n        // Suppress errors because the user might be typing a URL that is not yet valid.\n        return []\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport type { ContextRetriever } from '../types'\n\nimport type { BfgRetriever } from './retrievers/bfg/bfg-retriever'\nimport { JaccardSimilarityRetriever } from './retrievers/jaccard-similarity/jaccard-similarity-retriever'\nimport { SectionHistoryRetriever } from './retrievers/section-history/section-history-retriever'\n\nexport type ContextStrategy =\n    | 'bfg'\n    | 'jaccard-similarity'\n    | 'new-jaccard-similarity'\n    | 'bfg-mixed'\n    | 'local-mixed'\n    | 'none'\n\nexport interface ContextStrategyFactory extends vscode.Disposable {\n    getStrategy(document: vscode.TextDocument): { name: ContextStrategy; retrievers: ContextRetriever[] }\n}\n\nexport class DefaultContextStrategyFactory implements ContextStrategyFactory {\n    private disposables: vscode.Disposable[] = []\n\n    private localRetriever: ContextRetriever | undefined\n    private graphRetriever: ContextRetriever | undefined\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:36-38"",""content"":""export function isURLContextItem(item: Pick<ContextItem, 'uri'>): boolean {\n    return item.uri.scheme === 'http' || item.uri.scheme === 'https'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:33-61"",""content"":""            suggestedItems: number\n            /** Number of total snippets */\n            retrievedItems: number\n            /** Duration of the individual retriever */\n            duration: number\n            /**\n             * A bitmap that indicates at which position in the result set an entry from the given\n             * retriever is included. It only includes information about the first 32 entries.\n             *\n             * The lowest bit indicates if the first entry is included, the second lowest bit\n             * indicates if the second entry is included, and so on.\n             */\n            positionBitmap: number\n        }\n    }\n}\n\nexport interface GetContextResult {\n    context: AutocompleteContextSnippet[]\n    logSummary: ContextSummary\n}\n\n/**\n * The context mixer is responsible for combining multiple context retrieval strategies into a\n * single proposed context list.\n *\n * This is done by ranking the order of documents using reciprocal rank fusion and then combining\n * the snippets from each retriever into a single list using top-k (so we will pick all returned\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:212-226"",""content"":""    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:199-210"",""content"":""    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77"",""content"":""        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItemSource.kt:0-6"",""content"":""@file:Suppress(\""FunctionName\"", \""ClassName\"", \""unused\"", \""EnumEntryName\"", \""UnusedImport\"")\npackage com.sourcegraph.cody.protocol_generated\n\ntypealias ContextItemSource = String // One of: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_016/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Content attribution is checked in the `ChatMessageContent` component within the `cody_test/vscode/webviews/chat/ChatMessageContent.tsx` file. Specifically, the attribution check is performed inside the `useEffect` hook, where the `guardrails.searchAttribution` method is called to search for attribution in the code snippet displayed in the chat.

Here is the relevant code snippet:

```typescript
useEffect(() => {
    const preElements = rootRef.current?.querySelectorAll('pre')
    if (!preElements?.length || !copyButtonOnSubmit) {
        return
    }

    for (const preElement of preElements) {
        const preText = preElement.textContent
        if (preText?.trim() && preElement.parentNode) {
            const buttons = createButtons(preText, copyButtonOnSubmit, insertButtonOnSubmit)
            if (guardrails) {
                const container = document.createElement('div')
                container.classList.add(styles.attributionContainer)
                buttons.append(container)

                const g = new GuardrailsStatusController(container)
                g.setPending()

                guardrails
                    .searchAttribution(preText)
                    .then(attribution => {
                        if (isError(attribution)) {
                            g.setUnavailable(attribution)
                        } else if (attribution.repositories.length === 0) {
                            g.setSuccess()
                        } else {
                            g.setFailure(
                                attribution.repositories.map(r => r.name),
                                attribution.limitHit
                            )
                        }
                    })
                    .catch(error => {
                        g.setUnavailable(error)
                        return
                    })
            }

            // Insert the buttons after the pre using insertBefore() because there is no insertAfter()
            preElement.parentNode.insertBefore(buttons, preElement.nextSibling)

            // capture copy events (right click or keydown) on code block
            preElement.addEventListener('copy', () => {
                if (copyButtonOnSubmit) {
                    copyButtonOnSubmit(preText, 'Keydown')
                }
            })
        }
    }
}, [copyButtonOnSubmit, insertButtonOnSubmit, guardrails])
```

In this code, the `guardrails.searchAttribution(preText)` method is called to perform the attribution search for the code snippet contained in `preText`. The result of this search is then used to update the UI accordingly.",Where do we check for content attribution?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:203-214"",""content"":""function checkValidEnumValues(configName: string, value: string | null): void {\n    const validEnumValues = getConfigEnumValues(`cody.${configName}`)\n    if (value) {\n        if (!validEnumValues.includes(value)) {\n            void vscode.window.showErrorMessage(\n                `Invalid value for ${configName}: ${value}. Valid values are: ${validEnumValues.join(\n                    ', '\n                )}`\n            )\n        }\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:4054-4078"",""content"":""            2n1Tofe+i1bW2ZHXhNA1apTk30hqndqL17plySGZAuO/ijE6yxkED6hm8fHpRnN1d85\\\n            U0Fl9xzhFnlzIk0U01WnbfsaZ+ggLtCTg1vgaeba2Ftnty9VlgYeyasRZaHWuzPYroh\\\n            NXPcXi8sDBeqyj0c78bJM/rORz+8//94VUrS/3Bbt2rP/37lbbFnzsfnL9W/NdPr5X9\\\n            tFdP7f/+sPu03/xf/4gb8+F/fWjeVZt//mr++ue//PO3fz6//tfP/b8VbfFj9fo38+5\\\n            p8/jtXv74f17kj/XT5s1fDn99fFcXPz63/7K7WPz4Xdw0/3hb/Ni+/PX/+Uv9rx/r47\\\n            /++enbv/7zH2/Vj388Fj/+4/j5/Q/vfvrlw9sP5mD+Pv1e/vOP3YcnZz7Yb//n1X/+8\\\n            5///P8BAAD//0QFQV3tCQIA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:32:13 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: retry-after\n            value: \""282\""\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/attribution.test.ts:12-33"",""content"":""const test = baseTest\n    .extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n    .extend<ExpectedEvents>({\n        // list of events we expect this test to log, add to this list as needed\n        expectedEvents: [\n            'CodyInstalled',\n            'CodyVSCodeExtension:auth:clickOtherSignInOptions',\n            'CodyVSCodeExtension:login:clicked',\n            'CodyVSCodeExtension:auth:selectSigninMenu',\n            'CodyVSCodeExtension:auth:fromToken',\n            'CodyVSCodeExtension:Auth:connected',\n            'CodyVSCodeExtension:chat-question:submitted',\n            'CodyVSCodeExtension:chat-question:executed',\n            'CodyVSCodeExtension:chatResponse:hasCode',\n        ],\n    })\n    .extend<ExtraWorkspaceSettings>({\n        extraWorkspaceSettings: {\n            // TODO(#59720): Remove experimental setting.\n            'cody.experimental.guardrails': true,\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:105-138"",""content"":""      _order: 0\n      cache: {}\n      request:\n        bodySize: 10486\n        cookies: []\n        headers:\n          - name: content-type\n            value: application/json\n          - name: accept-encoding\n            value: gzip;q=0\n          - name: authorization\n            value: token\n              REDACTED_b20717265e7ab1d132874d8ff0be053ab9c1dacccec8dce0bbba76888b6a0a69\n          - name: user-agent\n            value: enterpriseClient / v1\n          - name: host\n            value: demo.sourcegraph.com\n        headersSize: 265\n        httpVersion: HTTP/1.1\n        method: POST\n        postData:\n          mimeType: application/json\n          params: []\n          textJSON:\n            maxTokensToSample: 1000\n            messages:\n              - speaker: human\n                text: You are Cody, an AI coding assistant from Sourcegraph.\n              - speaker: assistant\n                text: I am Cody, an AI coding assistant from Sourcegraph.\n              - speaker: human\n                text: >-\n                  Codebase context from file /agent/README.md in repository\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:7357-7384"",""content"":""            TV68pkB+nxayTnfUxFI4Sug+6FETlcN5vseCqWw5dIsYKxBKg01OJm6s+D7T1NbQBqQ\\\n            BtYz94lGT6PUejuxbG/2wJv7Mk6JUl+MJxEct3461Pyk7GO6O4yONy+fXDayr6VVyAL\\\n            CfoVP1ChiONKzIspRcrOLM251/n8/kPAAAA//8DANaF7gAtBAAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:31 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:21-30"",""content"":""interface ChatMessageContentProps {\n    displayMarkdown: string\n    wrapLinksWithCodyCommand: boolean\n\n    copyButtonOnSubmit?: CodeBlockActionsProps['copyButtonOnSubmit']\n    insertButtonOnSubmit?: CodeBlockActionsProps['insertButtonOnSubmit']\n\n    guardrails?: Guardrails\n    className?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:5321-5347"",""content"":""            z//9zYtWVuqDWdsXf/j3C2XKP3bOW3ct3o+fXhfm0654aP/rw/bTbvXnn8JKf/jth+a\\\n            7zeofP+q//vEv//j5H0+v//VD/1vZln/avP5Zf/ewevNqV7z9/3bln+pG/fD79l//+K\\\n            n+6z8/Pa5+eP1m9ebTZvXnj6H880+vVm//0v78j6fvPz5Xrz69+9jzey//+Zf657d/b\\\n            1dvvtWf9Qe97pfMf/7zn//8vwAAAP//7inTaSEHAgA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:38:54 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: content-encoding\n            value: gzip\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:138-147"",""content"":""                  github.com/sourcegraph/cody:\n\n                  ```markdown\n\n                  | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n\n                  | `pnpm test agent/src/index.test.ts`                                                                                  | Run agent tests in replay mode                                                                                                                                |\n\n                  | `source agent/scripts/export-cody-http-recording-tokens.sh`                                                          | Export access tokens to enable recording mode                                                                                                                 |\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/rateLimitedClient_2043004676/recording.har.yaml:1047-1076"",""content"":""                siteID: SourcegraphWeb\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 17 Apr 2024 09:12:26 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Cookie,Accept-Encoding,Authorization,Cookie, Authorization,\n              X-Requested-With,Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n            value: 1; mode=block\n          - name: strict-transport-security\n            value: max-age=31536000; includeSubDomains; preload\n          - name: content-encoding\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupContentStore.ts:9-75"",""content"":""export class ContentProvider implements vscode.TextDocumentContentProvider, vscode.Disposable {\n    // This stores the content of the document for each task ID\n    // The content is initialized by the fixup task with the original content\n    // and then updated by the fixup task with the replacement content\n    private contentStore = new Map<FixupTaskID, fileContent>()\n    // This tracks the task IDs belong toe each file path\n    private tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    private _onDidChange = new vscode.EventEmitter<vscode.Uri>()\n    private _disposables: vscode.Disposable\n\n    constructor() {\n        // TODO: Handle applying fixups to files which are opened and closed.\n        // This is tricky because we need to re-sync the range we are tracking\n        // when the file is opened.\n        this._disposables = vscode.workspace.onDidCloseTextDocument(doc =>\n            this.deleteByFilePath(doc.uri.fsPath)\n        )\n    }\n    // Get content from the content store\n    public provideTextDocumentContent(uri: vscode.Uri): string | null {\n        const id = uri.fragment\n        return this.contentStore.get(id) || null\n    }\n    // Add to store - store origin content by fixup task id\n    public async set(id: string, docUri: vscode.Uri): Promise<void> {\n        const doc = await vscode.workspace.openTextDocument(docUri)\n        this.contentStore.set(id, doc.getText())\n        this.tasksByFilePath.set(docUri.fsPath, [...(this.tasksByFilePath.get(docUri.fsPath) || []), id])\n    }\n\n    // Remove by ID\n    public delete(id: string): void {\n        this.contentStore.delete(id)\n        // remove task from tasksByFilePath\n        for (const [filePath, tasks] of this.tasksByFilePath) {\n            const index = tasks.indexOf(id)\n            if (index > -1) {\n                tasks.splice(index, 1)\n            }\n            if (tasks.length === 0) {\n                this.deleteByFilePath(filePath)\n            }\n        }\n    }\n\n    // Remove by file path\n    private deleteByFilePath(fileName: string): void {\n        const files = this.tasksByFilePath.get(fileName)\n        if (!files) {\n            return\n        }\n        for (const id of files) {\n            this.contentStore.delete(id)\n        }\n    }\n\n    public get onDidChange(): vscode.Event<vscode.Uri> {\n        return this._onDidChange.event\n    }\n\n    public dispose(): void {\n        this._disposables.dispose()\n        this._onDidChange.dispose()\n        this.contentStore = new Map<FixupTaskID, fileContent>()\n        this.tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:156-175"",""content"":""\n    // Updates the extension configuration and returns the new\n    // authentication status, which indicates whether the provided credentials are\n    // valid or not. The agent can't support autocomplete or chat if the credentials\n    // are invalid.\n    'extensionConfiguration/change': [ExtensionConfiguration, AuthStatus | null]\n\n    // Returns the current authentication status without making changes to it.\n    'extensionConfiguration/status': [null, AuthStatus | null]\n\n    // Run attribution search for a code snippet displayed in chat.\n    // Attribution is an enterprise feature which allows to look for code generated\n    // by Cody in an open source code corpus. User is notified if any such attribution\n    // is found.\n    // For more details, please see:\n    // *   PRD: https://docs.google.com/document/d/1c3CLC7ICDaG63NOWjO6zWm-UElwuXkFrKbCKTw-7H6Q/edit\n    // *   RFC: https://docs.google.com/document/d/1zSxFDQPxZcn5b6yKx40etpJayoibVzj_Gnugzln1weI/edit\n    'attribution/search': [\n        { id: string; snippet: string },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:235-309"",""content"":""export const ChatMessageContent: React.FunctionComponent<ChatMessageContentProps> = ({\n    displayMarkdown,\n    wrapLinksWithCodyCommand,\n    copyButtonOnSubmit,\n    insertButtonOnSubmit,\n    guardrails,\n    className,\n}) => {\n    const rootRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        const preElements = rootRef.current?.querySelectorAll('pre')\n        if (!preElements?.length || !copyButtonOnSubmit) {\n            return\n        }\n\n        for (const preElement of preElements) {\n            const preText = preElement.textContent\n            if (preText?.trim() && preElement.parentNode) {\n                const buttons = createButtons(preText, copyButtonOnSubmit, insertButtonOnSubmit)\n                if (guardrails) {\n                    const container = document.createElement('div')\n                    container.classList.add(styles.attributionContainer)\n                    buttons.append(container)\n\n                    const g = new GuardrailsStatusController(container)\n                    g.setPending()\n\n                    guardrails\n                        .searchAttribution(preText)\n                        .then(attribution => {\n                            if (isError(attribution)) {\n                                g.setUnavailable(attribution)\n                            } else if (attribution.repositories.length === 0) {\n                                g.setSuccess()\n                            } else {\n                                g.setFailure(\n                                    attribution.repositories.map(r => r.name),\n                                    attribution.limitHit\n                                )\n                            }\n                        })\n                        .catch(error => {\n                            g.setUnavailable(error)\n                            return\n                        })\n                }\n\n                // Insert the buttons after the pre using insertBefore() because there is no insertAfter()\n                preElement.parentNode.insertBefore(buttons, preElement.nextSibling)\n\n                // capture copy events (right click or keydown) on code block\n                preElement.addEventListener('copy', () => {\n                    if (copyButtonOnSubmit) {\n                        copyButtonOnSubmit(preText, 'Keydown')\n                    }\n                })\n            }\n        }\n    }, [copyButtonOnSubmit, insertButtonOnSubmit, guardrails])\n\n    return (\n        <div\n            ref={rootRef}\n            className={classNames(styles.content, className)}\n            // biome-ignore lint/security/noDangerouslySetInnerHtml: the result is run through dompurify\n            dangerouslySetInnerHTML={{\n                // wrapLinksWithCodyCommand opens all links in assistant responses using the\n                // _cody.vscode.open command (but not human messages because those already\n                // have the right URIs and are trusted).\n                __html: renderCodyMarkdown(displayMarkdown, { wrapLinksWithCodyCommand }),\n            }}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/index.md:0-8"",""content"":""# Cody documentation\n\n> **Note**\n> We're in the process of moving Cody documentation from the [`sourcegraph/sourcegraph` repository `doc/cody` directory](https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/tree/doc/cody) to this repository.\n\n- [Development](development/index.md)\n- [All other Cody documentation](https://sourcegraph.com/docs/cody)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/TextDocumentWithUri.ts:45-47"",""content"":""    public get content(): string | undefined {\n        return this.underlying.content\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:23-25"",""content"":""    public get content(): string {\n        return this.protocolDocument.underlying.content ?? ''\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320"",""content"":""\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/guardrails/index.ts:3-6"",""content"":""export interface Attribution {\n    limitHit: boolean\n    repositories: RepositoryAttribution[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.module.css:44-100"",""content"":""\n.attribution-container {\n    all: unset;\n    display: flex;\n    margin-left: auto;\n}\n\n\n.attribution-icon-unavailable {\n    color: var(--hl-orange);\n}\n\n.attribution-icon-found {\n    color: var(--hl-dark-red);\n}\n\n.status {\n    display: flex;\n    align-items: center;\n}\n\n.codicon-loading {\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    from { transform: rotate(0deg); }\n    to { transform: rotate(360deg); }\n}\n\n/*\n * Content\n */\n:root {\n    --spacing: 1rem;\n}\n\n.content {\n    word-break: break-word;\n    line-height: 150%;\n    text-wrap: wrap;\n}\n\n/* Style @-file tokens to match TranscriptAction context files */\n.content a[href^=\""vscode://file\""] em,\n.content a[href^=\""vscode-insiders://file\""] em,\n.content a[href^=\""vscodium://file\""] em,\n.content a[href^=\""cursor://file\""] em\n{\n    padding: 1px 2px;\n    box-sizing: border-box;\n    background-color: color-mix(in srgb, var(--vscode-textLink-foreground) 15%, transparent);\n    border-radius: 2px;\n    font-style: normal;\n    word-break: break-all;\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_017/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Custom actions in the provided codebase context are triggered in several places. Here are the key locations:

1. **Sidebar Commands**:
   - In the `registerSidebarCommands` function in `cody_test/vscode/src/services/SidebarCommands.ts`, custom commands are triggered with:
     ```typescript
     if (command === 'cody.action.command') {
         logSidebarClick('custom')
         void vscode.commands.executeCommand(command, feature, { source: 'sidebar' })
     }
     ```

2. **Custom Commands Manager**:
   - In the `CustomCommandsManager` class in `cody_test/vscode/src/commands/services/custom-commands.ts`, custom commands are registered and triggered with:
     ```typescript
     this.registeredCommands.push(
         vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>
             vscode.commands.executeCommand('cody.action.command', key, {
                 source: 'editor',
             })
         )
     )
     ```

3. **Keyboard Shortcuts**:
   - Custom commands can be assigned keyboard shortcuts as described in `cody_test/vscode/doc/keyboard.md`. The commands are triggered when the corresponding key binding is pressed.

4. **Code Actions**:
   - Custom actions related to code (like fixing, explaining, testing, etc.) are provided in the `provideCodeActions` methods in various files like `cody_test/vscode/src/code-actions/explain.ts`, `cody_test/vscode/src/code-actions/edit.ts`, `cody_test/vscode/src/code-actions/document.ts`, and `cody_test/vscode/src/code-actions/test.ts`.

5. **Chat Actions**:
   - In the `ChatActions` component in `cody_test/vscode/webviews/chat/components/ChatActions.tsx`, various chat-related actions are triggered based on user interactions.

These are the primary locations where custom actions are triggered in the provided codebase context.",Where do we trigger custom actions?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:0-18"",""content"":""# Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can easily update these bindings in the `Keyboard Shortcuts editor`, which you can access by clicking on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**`.\n\nThis feature can be particularly useful if the default key bindings conflict with your current or preferred key bindings.\n\n## Keyboard Shortcuts Editor\n\nThe Keyboard Shortcuts editor allows you to easily update the key bindings for any of the Cody commands. To open the `Keyboard Shortcuts Editor`:\n1. Open the Cody sidebar and expand the `**SETTINGS AND SUPPORT**` section.\n2. Click on the `**Keyboard Shortcuts**` icon.\n\n## Custom Commands\n\n![editor](images/keyboard_editor.png)\n\nYou have the option to assign key bindings (keyboard shortcuts) to individual custom commands:\n1. In the Cody sidebar under `**SETTINGS AND SUPPORT**`, click on the `**Keyboard Shortcuts**` icon to open the Keyboard Shortcuts editor.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/BaseEditor.tsx:77-101"",""content"":""                                    />\n                                </div>\n                            </div>\n                        }\n                        placeholder={<div className={styles.placeholder}>{placeholder}</div>}\n                        ErrorBoundary={LexicalErrorBoundary}\n                    />\n                    <HistoryPlugin />\n                    <OnChangePlugin onChange={onChange} ignoreSelectionChange={true} />\n                    <MentionsPlugin />\n                    <CodeHighlightPlugin />\n                    <AutoFocusPlugin />\n                    {onFocusChange && <OnFocusChangePlugin onFocusChange={onFocusChange} />}\n                    {editorRef && <EditorRefPlugin editorRef={editorRef} />}\n                    <KeyboardEventPlugin\n                        onKeyDown={onKeyDown}\n                        onEnterKey={onEnterKey}\n                        onEscapeKey={onEscapeKey}\n                    />\n                </LexicalComposer>\n            </div>\n        </div>\n    )\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/test.ts:8-38"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [testableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getTestableNode',\n        })\n        if (!testableNode) {\n            return []\n        }\n\n        const { range: testableRange, symbol: testableSymbol } = testableNode\n        if (!testableSymbol || !testableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            testableRange.node.startPosition.row,\n            testableRange.node.startPosition.column,\n            testableRange.node.endPosition.row,\n            testableRange.node.endPosition.column\n        )\n\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Tests for ${testableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:851-862"",""content"":""- Assign requestID to each Code Block actions. [pull/1586](https://github.com/sourcegraph/cody/pull/1586)\n- [Internal Experimental] Chat: New Experimental Chat View that appears in the editor panel instead of the sidebar when `cody.experimental.chatPanel` is enabled. [pull/1509](https://github.com/sourcegraph/cody/pull/1509)\n\n### Fixed\n\n- Commands: Smart selection not working on the first line of code. [pull/1508](https://github.com/sourcegraph/cody/pull/1508)\n- Chat: Aborted messages are now saved to local chat history properly. [pull/1550](https://github.com/sourcegraph/cody/pull/1550)\n- Adjust a completion range if it does not match the current line suffix. [pull/1507](https://github.com/sourcegraph/cody/pull/1507)\n- Chat: Fix heading styles and inline code colors. [pull/1528](https://github.com/sourcegraph/cody/pull/1528)\n- Custom Commands: Fix custom command menu not showing for a single custom command. [pull/1532](https://github.com/sourcegraph/cody/pull/1532)\n- Chat: Focus chat input on mount even when notification for version update is shown. [pull/1556](https://github.com/sourcegraph/cody/pull/1556)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/document.ts:8-37"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [documentableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getDocumentableNode',\n        })\n        if (!documentableNode) {\n            return []\n        }\n\n        const { range: documentableRange, symbol: documentableSymbol } = documentableNode\n        if (!documentableSymbol || !documentableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            documentableRange.node.startPosition.row,\n            documentableRange.node.startPosition.column,\n            documentableRange.node.endPosition.row,\n            documentableRange.node.endPosition.column\n        )\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Documentation for ${documentableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:27-48"",""content"":""import {\n    executeDocCommand,\n    executeExplainCommand,\n    executeExplainOutput,\n    executeSmellCommand,\n    executeTestCaseEditCommand,\n    executeTestChatCommand,\n    executeTestEditCommand,\n} from './commands/execute'\nimport type { CodyCommandArgs } from './commands/types'\nimport { newCodyCommandArgs } from './commands/utils/get-commands'\nimport { createInlineCompletionItemProvider } from './completions/create-inline-completion-item-provider'\nimport { getConfiguration, getFullConfig } from './configuration'\nimport { EnterpriseContextFactory } from './context/enterprise-context-factory'\nimport { EditManager } from './edit/manager'\nimport { manageDisplayPathEnvInfoForExtension } from './editor/displayPathEnvInfo'\nimport { VSCodeEditor } from './editor/vscode-editor'\nimport type { PlatformContext } from './extension.common'\nimport { configureExternalServices } from './external-services'\nimport { logDebug, logError } from './log'\nimport { getChatModelsFromConfiguration, syncModelProviders } from './models/utils'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/edit.ts:7-29"",""content"":""    public provideCodeActions(document: vscode.TextDocument): vscode.CodeAction[] {\n        const editor = vscode.window.activeTextEditor\n\n        if (!editor) {\n            return []\n        }\n\n        if (\n            editor.selection.isEmpty &&\n            !document.lineAt(editor.selection.start.line).isEmptyOrWhitespace\n        ) {\n            // Empty selection but a non-empty line, show nothing as the user likely won't want to generate here.\n            return []\n        }\n\n        if (editor.selection.isEmpty) {\n            // Empty selection and empty line, show generate action\n            return [this.createGenerateCodeAction(document, editor.selection)]\n        }\n\n        // Non-empty selection, show edit action\n        return [this.createEditCommandCodeAction(document, editor.selection)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/HoverCommandsProvider.ts:0-28"",""content"":""import {\n    type AuthStatus,\n    FeatureFlag,\n    PromptString,\n    featureFlagProvider,\n    isCodyIgnoredFile,\n    logDebug,\n    ps,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { executeEdit } from '../edit/execute'\nimport { fetchDocumentSymbols } from '../edit/input/utils'\nimport { telemetryService } from '../services/telemetry'\nimport { telemetryRecorder } from '../services/telemetry-v2'\nimport { logFirstEnrollmentEvent } from '../services/utils/enrollment-event'\nimport { execQueryWrapper as execQuery } from '../tree-sitter/query-sdk'\nimport { executeDocCommand } from './execute'\nimport { executeHoverChatCommand } from './execute/hover'\nimport type { CodyCommandArgs } from './types'\n\n/**\n * NOTE: Behind the feature flag `cody-hover-commands`.\n *\n * Provides clickable commands on hover and handles clicking on commands.\n */\nclass HoverCommandsProvider implements vscode.Disposable {\n    private readonly id = FeatureFlag.CodyHoverCommands\n    private disposables: vscode.Disposable[] = []\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:7-21"",""content"":""    public provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): vscode.CodeAction[] {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n        return [this.createCommandCodeAction(document.uri, diagnostics)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:792-822"",""content"":""          \""group\"": \""navigation@1\""\n        },\n        {\n          \""command\"": \""cody.search.index-update-all\"",\n          \""when\"": \""view == cody.search && cody.activated\"",\n          \""group\"": \""navigation@2\""\n        }\n      ],\n      \""editor/title\"": [\n        {\n          \""command\"": \""cody.menu.commands\"",\n          \""when\"": \""cody.activated && !editorReadonly && (resourceScheme == file || activeWebviewPanelId == cody.chatPanel)\"",\n          \""group\"": \""navigation\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""cody.chat.panel.new\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated\"",\n          \""group\"": \""navigation@1\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""cody.chat.history.panel\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated\"",\n          \""group\"": \""navigation@2\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""workbench.action.moveEditorToNewWindow\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated && !isAuxiliaryEditorPart\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:10-12"",""content"":""interface CodeActionProviderOptions {\n    contextProvider: ContextProvider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:32-58"",""content"":""\n    // \""⌘\"" on Mac or \""Ctrl\"" on other systems\n    const isMac = isMacOS()\n    const osIcon = isMac ? '⌘' : 'Ctrl+'\n\n    // The Chat Actions are conditionally rendered based on the 'when' property.\n    // The \""Cancel Edit\"" action is only available when isEditing is true, meaning\n    // the user is in the process of editing a message.\n    // The \""Edit Last Message\"" and \""New Chat\"" actions are available when isEditing is false,\n    // indicating that the user is not editing a message and can either edit their last message\n    // or start a new chat session via these buttons that also have keyboard shortcuts associated with them.\n    const actions: {\n        name: string\n        keyLabel: string\n        keyRequiresFocus?: boolean\n        onClick?: () => void\n        focus: boolean\n        when: boolean\n    }[] = [\n        {\n            name: 'Cancel Edit',\n            keyLabel: 'ESC',\n            keyRequiresFocus: true,\n            onClick: onCancelEditClick,\n            focus: false,\n            when: isEditing && !isEmptyChat,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:14-54"",""content"":""export class CodeActionProvider implements vscode.Disposable {\n    private configurationChangeListener: vscode.Disposable\n    private actionProviders: vscode.Disposable[] = []\n\n    constructor(options: CodeActionProviderOptions) {\n        this.registerCodeActions(options.contextProvider.config)\n        this.configurationChangeListener = options.contextProvider.configurationChangeEvent.event(() => {\n            this.registerCodeActions(options.contextProvider.config)\n        })\n    }\n\n    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n    }\n\n    private addActionProvider(ActionType: {\n        new (): vscode.CodeActionProvider\n        providedCodeActionKinds: vscode.CodeActionKind[]\n    }): void {\n        const provider = vscode.languages.registerCodeActionsProvider('*', new ActionType(), {\n            providedCodeActionKinds: ActionType.providedCodeActionKinds,\n        })\n        this.actionProviders.push(provider)\n    }\n\n    public dispose(): void {\n        this.configurationChangeListener.dispose()\n        vscode.Disposable.from(...this.actionProviders).dispose()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/actions/TranscriptAction.tsx:6-15"",""content"":""interface TranscriptActionStep {\n    verb: string\n    object: string | JSX.Element\n\n    /**\n     * The SVG path of an icon.\n     * @example mdiSearchWeb\n     */\n    icon?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:0-32"",""content"":""import type React from 'react'\nimport { useEffect, useRef } from 'react'\n\nimport { isMacOS } from '@sourcegraph/cody-shared'\nimport styles from './ChatActions.module.css'\n\nexport const ChatActions: React.FunctionComponent<{\n    isWebviewActive: boolean\n    isEditing: boolean\n    isMessageInProgress: boolean\n    isEmptyChat: boolean\n    isEmptyEditorValue: boolean\n    isEditorFocused: boolean\n    onChatResetClick: () => void\n    onCancelEditClick: () => void\n    onEditLastMessageClick: () => void\n    setInputFocus: (focus: boolean) => void\n    onRestoreLastChatClick?: () => void\n}> = ({\n    isEditing,\n    isEmptyChat,\n    isEmptyEditorValue,\n    isEditorFocused,\n    isMessageInProgress,\n    onChatResetClick,\n    onCancelEditClick,\n    onEditLastMessageClick,\n    setInputFocus,\n    onRestoreLastChatClick,\n    isWebviewActive,\n}) => {\n    const buttonRef = useRef<HTMLButtonElement>(null)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/actions/TranscriptAction.tsx:17-44"",""content"":""export const TranscriptAction: React.FunctionComponent<{\n    title: string | { verb: string; object: string; tooltip?: string }\n    steps: TranscriptActionStep[]\n    className?: string\n    onClick?: () => void\n}> = ({ title, steps, className, onClick }) => {\n    return (\n        <details className={classNames(className, styles.container)}>\n            <summary onClick={onClick} onKeyDown={onClick}>\n                {typeof title === 'string' ? (\n                    title\n                ) : (\n                    <span title={title.tooltip}>\n                        {title.verb} <strong>{title.object}</strong>\n                    </span>\n                )}\n            </summary>\n            <div className={styles.steps}>\n                {steps.map((step, index) => (\n                    // biome-ignore lint/suspicious/noArrayIndexKey: no other natural key, and this is stable/immutable\n                    <span key={index} className={styles.step}>\n                        {step.object}\n                    </span>\n                ))}\n            </div>\n        </details>\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:18-24"",""content"":""2. Search for `cody.command.custom.{CUSTOM_COMMAND_NAME}`. \n3. Replace `{CUSTOM_COMMAND_NAME}` with the name or key of your custom command, for example, `cody.command.custom.commit`.\n4. Click on the `+` icon next to the command to assign a custom keybinding for your custom command.\n\nFor more information on keyboard settings in VS Code, please refer to the official documentation on [Key Bindings for Visual Studio Code](https://code.visualstudio.com/docs/getstarted/keybindings#_keyboard-shortcuts-editor).\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:727-760"",""content"":""          \""when\"": \""cody.activated\"",\n          \""group\"": \""command\""\n        },\n        {\n          \""command\"": \""cody.menu.custom-commands\"",\n          \""when\"": \""cody.activated\"",\n          \""group\"": \""custom-commands\""\n        },\n        {\n          \""command\"": \""cody.focus\"",\n          \""when\"": \""!cody.activated\"",\n          \""group\"": \""other\""\n        },\n        {\n          \""command\"": \""cody.guardrails.debug\"",\n          \""when\"": \""cody.activated && config.cody.experimental.guardrails && editorHasSelection\"",\n          \""group\"": \""other\""\n        }\n      ],\n      \""view/title\"": [\n        {\n          \""command\"": \""cody.chat.panel.new\"",\n          \""when\"": \""view == cody.chat.tree.view && cody.activated\"",\n          \""group\"": \""navigation@1\""\n        },\n        {\n          \""command\"": \""cody.chat.history.clear\"",\n          \""when\"": \""view == cody.chat.tree.view && cody.activated && cody.hasChatHistory\"",\n          \""enablement\"": \""cody.hasChatHistory\"",\n          \""group\"": \""navigation@2\""\n        },\n        {\n          \""command\"": \""cody.chat.history.export\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:402-435"",""content"":""      },\n      {\n        \""command\"": \""cody.autocomplete.manual-trigger\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Trigger Autocomplete at Cursor\"",\n        \""when\"": \""cody.activated && config.cody.autocomplete && editorHasFocus && !editorReadonly && !editorHasSelection && !inlineSuggestionsVisible\""\n      },\n      {\n        \""command\"": \""cody.chat.panel.new\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""New Chat Panel\"",\n        \""when\"": \""cody.activated\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(new-comment-icon)\""\n      },\n      {\n        \""command\"": \""workbench.action.moveEditorToNewWindow\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Pop out\"",\n        \""when\"": \""cody.activated\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(link-external)\""\n      },\n      {\n        \""command\"": \""cody.chat.tree.view.focus\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Open Cody Sidebar\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(layout-sidebar-left)\""\n      },\n      {\n        \""command\"": \""cody.chat.history.edit\"",\n        \""category\"": \""Cody\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/custom-commands.ts:0-319"",""content"":""import os from 'node:os'\nimport { omit } from 'lodash'\nimport * as vscode from 'vscode'\n\nimport type { CodyCommand } from '@sourcegraph/cody-shared'\n\nimport { logDebug, logError } from '../../log'\n\nimport { isMacOS } from '@sourcegraph/cody-shared'\nimport { CustomCommandType } from '@sourcegraph/cody-shared'\nimport { URI, Utils } from 'vscode-uri'\nimport { getConfiguration } from '../../configuration'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getCommandTreeItems } from '../../services/tree-views/commands'\nimport { showNewCustomCommandMenu } from '../menus'\nimport { type CodyCommandsFile, ConfigFiles } from '../types'\nimport { createFileWatchers, createJSONFile, saveJSONFile } from '../utils/config-file'\nimport { buildCodyCommandMap } from '../utils/get-commands'\nimport { getDocText } from '../utils/workspace-files'\n\nconst isTesting = process.env.CODY_TESTING === 'true'\nconst userHomePath = os.homedir() || process.env.HOME || process.env.USERPROFILE || ''\n\n/**\n * Handles loading, building, and maintaining Custom Commands retrieved from cody.json files\n */\nexport class CustomCommandsManager implements vscode.Disposable {\n    // Watchers for the cody.json files\n    private fileWatcherDisposables: vscode.Disposable[] = []\n    private registeredCommands: vscode.Disposable[] = []\n    private disposables: vscode.Disposable[] = []\n\n    public customCommandsMap = new Map<string, CodyCommand>()\n\n    // Configuration files\n    protected configFileName\n    private userConfigFile\n    private get workspaceConfigFile(): vscode.Uri | undefined {\n        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri\n        if (!workspaceRoot) {\n            return undefined\n        }\n        return Utils.joinPath(workspaceRoot, this.configFileName)\n    }\n\n    constructor(private sidebar: TreeViewProvider) {\n        // TODO (bee) Migrate to use .cody/commands.json for VS Code\n        // Right now agent is using .cody/commands.json for Custom Commands,\n        // .vscode/cody.json in VS Code.\n        const workspaceConfig = vscode.workspace.getConfiguration()\n        const config = getConfiguration(workspaceConfig)\n        this.configFileName = config.isRunningInsideAgent ? ConfigFiles.COMMAND : ConfigFiles.VSCODE\n        this.userConfigFile = Utils.joinPath(URI.file(userHomePath), this.configFileName)\n\n        this.disposables.push(\n            vscode.commands.registerCommand('cody.menu.custom.build', () =>\n                this.newCustomCommandQuickPick()\n            ),\n            vscode.commands.registerCommand('cody.commands.open.json', type =>\n                this.configFileActions(type, 'open')\n            ),\n            vscode.commands.registerCommand('cody.commands.delete.json', type =>\n                this.configFileActions(type, 'delete')\n            )\n        )\n    }\n\n    /**\n     // TODO (bee) Migrate to use .cody/commands.json\n     * Create file watchers for cody.json files.\n     * Automatically update the command map when the cody.json files are changed\n     */\n    public init(): void {\n        const userConfigWatcher = createFileWatchers(this.userConfigFile)\n        if (userConfigWatcher) {\n            this.fileWatcherDisposables.push(\n                userConfigWatcher,\n                userConfigWatcher.onDidChange(() => this.refresh?.()),\n                userConfigWatcher.onDidDelete(() => this.refresh?.())\n            )\n        }\n\n        // Create file watchers in trusted workspaces only\n        if (vscode.workspace.isTrusted) {\n            const wsConfigWatcher = createFileWatchers(this.workspaceConfigFile)\n            if (wsConfigWatcher) {\n                this.fileWatcherDisposables.push(\n                    wsConfigWatcher,\n                    wsConfigWatcher.onDidChange(() => this.refresh?.()),\n                    wsConfigWatcher.onDidDelete(() => this.refresh?.())\n                )\n            }\n        }\n\n        if (this.fileWatcherDisposables.length) {\n            logDebug('CommandsController:init', 'watchers created')\n        }\n    }\n\n    /**\n     * Gets the map of custom commands.\n     *\n     * The custom commands map is a collection of CodyCommand objects, where the key\n     * is the command name and the value is the command object.\n     */\n    public get commands(): Map<string, CodyCommand> {\n        return this.customCommandsMap\n    }\n\n    /**\n     * Get the uri of the cody.json file for the given type\n     */\n    private getConfigFileByType(type: CustomCommandType): vscode.Uri | undefined {\n        const configFileUri =\n            type === CustomCommandType.User ? this.userConfigFile : this.workspaceConfigFile\n        return configFileUri\n    }\n\n    /**\n     * Rebuild the Custom Commands Map from the cody.json files\n     */\n    public async refresh(): Promise<CodyCommandsFile> {\n        try {\n            // Deregister all commands before rebuilding them to avoid duplicates\n            this.disposeRegisteredCommands()\n            // Reset the map before rebuilding\n            this.customCommandsMap = new Map<string, CodyCommand>()\n            // user commands\n            if (this.userConfigFile?.path) {\n                await this.build(CustomCommandType.User)\n            }\n            // 🚨 SECURITY: Only build workspace command in trusted workspace\n            if (vscode.workspace.isTrusted) {\n                await this.build(CustomCommandType.Workspace)\n            }\n        } catch (error) {\n            logError('CustomCommandsProvider:refresh', 'failed', { verbose: error })\n        }\n        this.sidebar.setTreeNodes(getCommandTreeItems([...this.customCommandsMap.values()]))\n        return { commands: this.customCommandsMap }\n    }\n\n    /**\n     * Handles building the Custom Commands Map from the cody.json files\n     *\n     * 🚨 SECURITY: Only build workspace command in trusted workspace\n     */\n    public async build(type: CustomCommandType): Promise<Map<string, CodyCommand> | null> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri || (type === CustomCommandType.Workspace && !vscode.workspace.isTrusted)) {\n            return null\n        }\n        try {\n            const content = await getDocText(uri)\n            if (!content.trim()) {\n                return null\n            }\n            const customCommandsMap = buildCodyCommandMap(type, content)\n            this.customCommandsMap = new Map([...this.customCommandsMap, ...customCommandsMap])\n\n            // Register Custom Commands as VS Code commands\n            for (const [key, _command] of customCommandsMap) {\n                this.registeredCommands.push(\n                    vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>\n                        vscode.commands.executeCommand('cody.action.command', key, {\n                            source: 'editor',\n                        })\n                    )\n                )\n            }\n        } catch (error) {\n            console.error('CustomCommandsProvider:build', 'failed', { verbose: error })\n        }\n        return this.customCommandsMap\n    }\n\n    /**\n     * Quick pick for creating a new custom command\n     */\n    private async newCustomCommandQuickPick(): Promise<void> {\n        const commands = [...this.customCommandsMap.values()].map(c => c.key)\n        const newCommand = await showNewCustomCommandMenu(commands)\n        if (!newCommand) {\n            return\n        }\n\n        // Save the prompt to the current Map and Extension storage\n        await this.save(newCommand.key, newCommand.prompt, newCommand.type)\n        await this.refresh()\n\n        // Notify user\n        const isUserCommand = newCommand.type === CustomCommandType.User\n        const buttonTitle = `Open ${isUserCommand ? 'User' : 'Workspace'} Settings (JSON)`\n        void vscode.window\n            .showInformationMessage(\n                `New ${newCommand.key} command saved to ${newCommand.type} settings`,\n                buttonTitle\n            )\n            .then(async choice => {\n                if (choice === buttonTitle) {\n                    await this.configFileActions(newCommand.type, 'open')\n                }\n            })\n\n        logDebug('CustomCommandsProvider:newCustomCommandQuickPick:', 'saved', {\n            verbose: newCommand,\n        })\n    }\n\n    /**\n     * Add the newly create command via quick pick to the cody.json file on disk\n     */\n    private async save(\n        id: string,\n        command: CodyCommand,\n        type: CustomCommandType = CustomCommandType.User\n    ): Promise<void> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri) {\n            return\n        }\n        const fileContent = await getDocText(uri)\n        const parsed = JSON.parse(fileContent) as Record<string, any>\n        const commands = parsed.commands ?? parsed\n        commands[id] = omit(command, 'key')\n        await saveJSONFile(parsed, uri)\n    }\n\n    private async configFileActions(\n        type: CustomCommandType,\n        action: 'open' | 'delete' | 'create'\n    ): Promise<void> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri) {\n            return\n        }\n        switch (action) {\n            case 'open':\n                void vscode.commands.executeCommand('vscode.open', uri)\n                break\n            case 'delete': {\n                let fileType = 'user settings file (~/.vscode/cody.json)'\n                if (type === CustomCommandType.Workspace) {\n                    fileType = 'workspace settings file (.vscode/cody.json)'\n                }\n                const bin = isMacOS() ? 'Trash' : 'Recycle Bin'\n                const confirmationKey = `Move to ${bin}`\n                // Playwright cannot capture and interact with pop-up modal in VS Code,\n                // so we need to turn off modal mode for the display message during tests.\n                const modal = !isTesting\n                vscode.window\n                    .showInformationMessage(\n                        `Are you sure you want to delete your Cody ${fileType}?`,\n                        { detail: `You can restore this file from the ${bin}.`, modal },\n                        confirmationKey\n                    )\n                    .then(async choice => {\n                        if (choice === confirmationKey) {\n                            void vscode.workspace.fs.delete(uri)\n                        }\n                    })\n                break\n            }\n            case 'create':\n                await createJSONFile(uri)\n                    .then(() => {\n                        vscode.window\n                            .showInformationMessage(\n                                `Cody ${type} settings file created`,\n                                'View Documentation'\n                            )\n                            .then(async choice => {\n                                if (choice === 'View Documentation') {\n                                    await openCustomCommandDocsLink()\n                                }\n                            })\n                    })\n                    .catch(error => {\n                        const errorMessage = 'Failed to create cody.json file: '\n                        void vscode.window.showErrorMessage(`${errorMessage} ${error}`)\n                        logDebug('CustomCommandsProvider:configActions:create', 'failed', {\n                            verbose: error,\n                        })\n                    })\n                break\n        }\n    }\n\n    /**\n     * Reset\n     */\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.disposeRegisteredCommands()\n        this.disposeWatchers()\n        this.customCommandsMap = new Map<string, CodyCommand>()\n    }\n\n    private disposeWatchers(): void {\n        for (const disposable of this.fileWatcherDisposables) {\n            disposable.dispose()\n        }\n        this.fileWatcherDisposables = []\n    }\n\n    private disposeRegisteredCommands(): void {\n        for (const rc of this.registeredCommands) {\n            rc.dispose()\n        }\n        this.registeredCommands = []\n    }\n}\n\nexport async function openCustomCommandDocsLink(): Promise<void> {\n    const uri = 'https://sourcegraph.com/docs/cody/custom-commands'\n    await vscode.env.openExternal(vscode.Uri.parse(uri))\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:70-91"",""content"":""\n    // Trigger chat-based commands (explain, test, smell), which are effectively\n    // shortcuts to start a new chat with a templated question. The return value\n    // of these commands is the same as `chat/new`, an ID to reference to the\n    // webview panel where the reply from this command appears.\n    'commands/explain': [null, string] // TODO: rename to chatCommands/{explain,test,smell}\n    'commands/test': [null, string]\n    'commands/smell': [null, string]\n\n    // Trigger custom commands that could be a chat-based command or an edit command.\n    'commands/custom': [{ key: string }, CustomCommandResult]\n\n    // Trigger commands that edit the code.\n    'editCommands/code': [{ instruction: string; model: string }, EditTask]\n    'editCommands/test': [null, EditTask]\n    'editCommands/document': [null, EditTask]\n\n    // If the task is \""applied\"", discards the task.\n    'editTask/accept': [{ id: FixupTaskID }, null]\n    // If the task is \""applied\"", attempts to revert the task's edit, then\n    // discards the task.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/SidebarCommands.ts:0-30"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    ACCOUNT_LIMITS_INFO_URL,\n    ACCOUNT_UPGRADE_URL,\n    ACCOUNT_USAGE_URL,\n    CODY_DOC_URL,\n    CODY_FEEDBACK_URL,\n    CODY_SUPPORT_URL,\n    DISCORD_URL,\n} from '../chat/protocol'\nimport { releaseNotesURL } from '../release'\nimport { telemetryService } from '../services/telemetry'\nimport { telemetryRecorder } from '../services/telemetry-v2'\nimport { version } from '../version'\n\nexport function registerSidebarCommands(): vscode.Disposable[] {\n    function logSidebarClick(feature: string) {\n        telemetryService.log(`CodyVSCodeExtension:sidebar:${feature}:clicked`, undefined, {\n            hasV2Event: true,\n        })\n        telemetryRecorder.recordEvent(`cody.sidebar.${feature}`, 'clicked')\n    }\n\n    return [\n        vscode.commands.registerCommand('cody.sidebar.commands', (feature: string, command: string) => {\n            // For Custom Commands\n            if (command === 'cody.action.command') {\n                logSidebarClick('custom')\n                void vscode.commands.executeCommand(command, feature, { source: 'sidebar' })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1015-1050"",""content"":""### Changed\n\n- Remove `starter` and `premade` fields from the configuration files for custom commands (cody.json). [pull/939](https://github.com/sourcegraph/cody/pull/939)\n- Enabled streaming responses for all autocomplete requests. [pull/995](https://github.com/sourcegraph/cody/pull/995)\n- Sign out immediately instead of showing the quick-pick menu. [pull/1032](https://github.com/sourcegraph/cody/pull/1032)\n- UX improvements to the custom command workflow (and new [custom command docs](https://sourcegraph.com/docs/cody/custom-commands)). [pull/992](https://github.com/sourcegraph/cody/pull/992)\n- You can now use `alt` + `\\` to trigger autocomplete requests manually. [pull/1060](https://github.com/sourcegraph/cody/pull/1060)\n- Slightly reduce latency when manually triggering autocomplete requests. [pull/1060](https://github.com/sourcegraph/cody/pull/1060)\n- Configure autocomplete provider based on cody LLM settings in site config. [pull/1035](https://github.com/sourcegraph/cody/pull/1035)\n- Filters out single character autocomplete results. [pull/1109](https://github.com/sourcegraph/cody/pull/1109)\n- Register inline completion provider for text files and notebooks only to ensure autocomplete works in environments that are fully supported. [pull/1114](https://github.com/sourcegraph/cody/pull/1114)\n- The `Generate Unit Tests` command has been improved with an enhanced context fetching process that produces test results with better quality. [pull/907](https://github.com/sourcegraph/cody/pull/907)\n\n## [0.10.2]\n\n### Added\n\n### Fixed\n\n### Changed\n\n- Use the same token limits for StarCoder as we do for Anthropic for the current experiments. [pull/1058](https://github.com/sourcegraph/cody/pull/1058)\n\n## [0.10.1]\n\n### Added\n\n### Fixed\n\n- Fix feature flag initialization for autocomplete providers. [pull/965](https://github.com/sourcegraph/cody/pull/965)\n\n### Changed\n\n## [0.10.0]\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_018/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The determination of whether to use enhanced context for chat is made in the `getEnhancedContext` function in the file `cody_test/vscode/src/chat/chat-view/context.ts`. Specifically, the function checks the `strategy` parameter to decide how to retrieve the context:

```typescript
export async function getEnhancedContext({
    strategy,
    editor,
    text,
    providers,
    contextRanking,
}: GetEnhancedContextOptions): Promise<ContextItem[]> {
    if (contextRanking) {
        return getEnhancedContextFromRanker({
            strategy,
            editor,
            text,
            providers,
            contextRanking,
        })
    }

    return wrapInActiveSpan('chat.enhancedContext', async () => {
        // use user attention context only if config is set to none
        if (strategy === 'none') {
            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')
            return getVisibleEditorContext(editor)
        }

        // Get embeddings context if useContext Config is not set to 'keyword' only
        const embeddingsContextItemsPromise =
            strategy !== 'keyword'
                ? retrieveContextGracefully(
                      searchEmbeddingsLocal(providers.localEmbeddings, text),
                      'local-embeddings'
                  )
                : []

        //  Get search (symf or remote search) context if config is not set to 'embeddings' only
        const remoteSearchContextItemsPromise =
            providers.remoteSearch && strategy !== 'embeddings'
                ? await retrieveContextGracefully(
                      searchRemote(providers.remoteSearch, text),
                      'remote-search'
                  )
                : []
        const localSearchContextItemsPromise =
            providers.symf && strategy !== 'embeddings'
                ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')
                : []

        // Combine all context sources
        const searchContext = [
            ...(await embeddingsContextItemsPromise),
            ...(await remoteSearchContextItemsPromise),
            ...(await localSearchContextItemsPromise),
        ]

        const priorityContext = await getPriorityContext(text, editor, searchContext)
        return priorityContext.concat(searchContext)
    })
}
```

The `strategy` parameter determines which type of context to use:
- If `strategy` is `'none'`, it uses the visible editor context.
- If `strategy` is not `'keyword'`, it retrieves embeddings context.
- If `strategy` is not `'embeddings'`, it retrieves search context (either local or remote).

Additionally, the `useEnhancedContextEnabled` hook in `cody_test/vscode/webviews/chat/EnhancedContext.tsx` is used to check if enhanced context is enabled:

```typescript
export function useEnhancedContextEnabled(): boolean {
    return React.useContext(EnhancedContextEnabled)
}
```

This hook is used in the chat component to determine if enhanced context should be added:

```typescript
const addEnhancedContext = useEnhancedContextEnabled()
```

This value is then used in the chat submission logic to decide whether to include enhanced context in the chat prompt.",Where do we determine whether to use enhanced context for chat?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/can-use-partial-completion.ts:0-41"",""content"":""import type { TextDocument } from 'vscode'\n\nimport type { DocumentContext } from '@sourcegraph/cody-shared'\nimport { hasCompleteFirstLine } from './text-processing'\nimport { parseAndTruncateCompletion } from './text-processing/parse-and-truncate-completion'\nimport type { InlineCompletionItemWithAnalytics } from './text-processing/process-inline-completions'\n\ninterface CanUsePartialCompletionParams {\n    document: TextDocument\n    docContext: DocumentContext\n}\n\n/**\n * Evaluates a partial completion response and returns it when we can already use it. This is used\n * to terminate any streaming responses where we can get a token-by-token access to the result and\n * want to terminate as soon as stop conditions are triggered.\n *\n * Right now this handles two cases:\n *  1. When a single line completion is requested, it terminates after the first full line was\n *     received.\n *  2. For a multi-line completion, it terminates when the completion will be truncated based on the\n *     multi-line indentation logic.\n */\nexport function canUsePartialCompletion(\n    partialResponse: string,\n    params: CanUsePartialCompletionParams\n): InlineCompletionItemWithAnalytics | null {\n    const { docContext } = params\n\n    if (!hasCompleteFirstLine(partialResponse)) {\n        return null\n    }\n\n    const item = parseAndTruncateCompletion(partialResponse, params)\n\n    if (docContext.multilineTrigger) {\n        return (item.lineTruncatedCount || 0) > 0 ? item : null\n    }\n\n    return item.insertText.trim() === '' ? null : item\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/counter.ts:26-43"",""content"":""     * Indicates whether the Chat and User-Context share the same token budget.\n     * - If true, all types of messages share the same token budget with Chat.\n     * - If false (Feature Flag required), the User-Context will has a separated budget.\n     * NOTE: Used in remainingTokens for calculating the remaining token budget for each budget type.\n     */\n    private shareChatAndUserBudget = true\n\n    constructor(contextWindow: ModelContextWindow) {\n        // If there is no context window reserved for context.user,\n        // context will share the same token budget with chat.\n        this.shareChatAndUserBudget = !contextWindow.context?.user\n        this.maxChatTokens = contextWindow.input\n        this.maxContextTokens = {\n            user: contextWindow.context?.user ?? contextWindow.input,\n            enhanced: Math.floor(contextWindow.input * ENHANCED_CONTEXT_ALLOCATION),\n        }\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:51-53"",""content"":""function useChatContextClient(): ChatContextClient {\n    return useContext(ChatContextClientContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/active-editor.ts:0-26"",""content"":""import * as vscode from 'vscode'\n\nimport { isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\n/**\n * Interface for tracking the last active text editor that is not a webview panel for\n * the new Chat Panel UI.\n *\n * active: The current valid active/supported text editor instance.\n * ignored: Whether the active editor is ignored by Cody or not.\n */\ninterface LastActiveTextEditor {\n    active?: vscode.TextEditor\n    ignored?: boolean\n}\n\n/**\n * This returns the current active text editor instance if available,\n * along with a boolean indicating if the text editor is on the Cody ignored list.\n * Returns undefined if no editor is active.\n *\n * NOTE: ALL USERS of chat interface in VS Code should use this to get the correct Active Editor instead of using\n * 'vscode.window.activeTextEditor' as this handles cases where the activeTextEditor API will always return\n * 'undefined' when user is focused on the webview chat panel.\n *\n * NOTE: Users that operate within an actual text editor (non-webview panels) do not need to use this API as calling\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:56-108"",""content"":""export function useChatContextItems(query: string | null): ContextItem[] | undefined {\n    const chatContextClient = useChatContextClient()\n    const [results, setResults] = useState<ContextItem[]>()\n    // biome-ignore lint/correctness/useExhaustiveDependencies: we only want to run this when query changes.\n    useEffect(() => {\n        // An empty query is a valid query that we use to get open tabs context,\n        // while a null query means this is not an at-mention query.\n        if (query === null) {\n            setResults(undefined)\n            return\n        }\n\n        // If the query ends with a colon, we will reuse current results but remove the range.\n        if (query.endsWith(':')) {\n            const selected = results?.find(r => displayPath(r.uri) === query.slice(0, -1))\n            setResults(\n                selected\n                    ? [{ ...selected, range: undefined }]\n                    : results?.map(r => ({ ...r, range: undefined }))\n            )\n            return\n        }\n\n        // If user is typing a line range, fetch new chat context items only if there are no results\n        if (results?.length && RANGE_MATCHES_REGEXP.test(query) && !LINE_RANGE_REGEXP.test(query)) {\n            return\n        }\n\n        // Track if the query changed since this request was sent (which would make our results\n        // no longer valid).\n        let invalidated = false\n\n        if (chatContextClient) {\n            chatContextClient\n                .getChatContextItems(query)\n                .then(mentions => {\n                    if (invalidated) {\n                        return\n                    }\n                    setResults(mentions)\n                })\n                .catch(error => {\n                    setResults(undefined)\n                    console.error(error)\n                })\n        }\n\n        return () => {\n            invalidated = true\n        }\n    }, [query])\n    return results\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:98-116"",""content"":""            }\n            const enhancedContext = prevContext.filter(c => c.source !== 'user')\n            if (promptBuilder.tryAddContext('enhanced', enhancedContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior enhanced context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n            }\n\n            // Add additional context from current editor or broader search when enhanced context is enabled\n            if (this.getEnhancedContext) {\n                const lastMessage = reverseTranscript[0]\n                if (!lastMessage?.text) {\n                    throw new Error('No last message or last message text was empty')\n                }\n                if (lastMessage.speaker === 'assistant') {\n                    throw new Error('Last message in prompt needs speaker \""human\"", but was \""assistant\""')\n                }\n                const newEnhancedContext = await this.getEnhancedContext(lastMessage.text)\n                sortContextItems(newEnhancedContext)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/squirrel.ts:0-11"",""content"":""interface CodeIntelligence {\n    symbols: string[]\n}\n\n/**\n * Squirrel is a code intelligence API.\n */\ninterface Squirrel {\n    symbolInformation(file: string): CodeIntelligence\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/local-embeddings.test.ts:140-164"",""content"":""    await openFile(page, 'main.c')\n    await sidebarSignin(page, sidebar)\n    const chatFrame = await newChat(page)\n\n    const enableEmbeddingsButton = chatFrame.getByText('Enable Embeddings')\n    // This may take a while, we download and start cody-engine\n    await expect(enableEmbeddingsButton).toBeVisible({ timeout: 60000 })\n    await enableEmbeddingsButton.click()\n\n    await expect(chatFrame.getByText('Embeddings — Indexed')).toBeVisible({\n        timeout: 30000,\n    })\n\n    // Search the embeddings. This test uses the \""stub\"" embedding model, which\n    // is deterministic, but the searches are not semantic.\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    await chatInput.fill('hello world')\n    await chatInput.press('Enter')\n    const contextCell = getContextCell(chatFrame)\n    await expectContextCellCounts(contextCell, {\n        files: 2,\n        timeout: 10000,\n    })\n})\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/animal.ts:0-5"",""content"":""interface Animal {\n    name: string;\n    age: number;\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:32-64"",""content"":""    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n}\nexport async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/README.md:0-5"",""content"":""# Cody Agent\n\nThe `@sourcegraph/cody-agent` package implements a JSON-RPC server to interact\nwith Cody via stdout/stdin. This package is intended to be used by\nnon-ECMAScript clients such as the JetBrains and NeoVim plugins.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:682-694"",""content"":""\n### Changed\n\n- Chat: Uses the new Chat UI by default. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Inline Chat is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Fixup Tree View is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Enhanced Context used to turn off automatically after the first chat. Now it stays enabled until you disable it. [pull/2069](https://github.com/sourcegraph/cody/pull/2069)\n- Chat: Reuse existing New Chat panel to prevent having multiple new chats open at once. [pull/2087](https://github.com/sourcegraph/cody/pull/2087)\n- Chat: Close the Enhanced Context popover on chat input focus. [pull/2091](https://github.com/sourcegraph/cody/pull/2091)\n- Chat: Show onboarding glowy dot guide until first time opening Enhanced Context. [pull/2097](https://github.com/sourcegraph/cody/pull/2097)\n- In 0.12, we simplified the sign-in process and removed the option to sign into\n  Cody App from VScode. If you were still signed in to Cody App, we invite you to\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:67-69"",""content"":""function useEnhancedContextEventHandlers(): EnhancedContextEventHandlersT {\n    return React.useContext(EnhancedContextEventHandlers)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:24-35"",""content"":""interface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:94-157"",""content"":""async function getEnhancedContextFromRanker({\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    return wrapInActiveSpan('chat.enhancedContextRanker', async span => {\n        // Get all possible context items to rank\n        let searchContext = getVisibleEditorContext(editor)\n\n        const numResults = 50\n        const embeddingsContextItemsPromise = retrieveContextGracefully(\n            searchEmbeddingsLocal(providers.localEmbeddings, text, numResults),\n            'local-embeddings'\n        )\n\n        const modelSpecificEmbeddingsContextItemsPromise = contextRanking\n            ? retrieveContextGracefully(\n                  contextRanking.searchModelSpecificEmbeddings(text, numResults),\n                  'model-specific-embeddings'\n              )\n            : []\n\n        const precomputeQueryEmbeddingPromise = contextRanking?.precomputeContextRankingFeatures(text)\n\n        const localSearchContextItemsPromise = providers.symf\n            ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n            : []\n\n        const remoteSearchContextItemsPromise = providers.remoteSearch\n            ? await retrieveContextGracefully(\n                  searchRemote(providers.remoteSearch, text),\n                  'remote-search'\n              )\n            : []\n\n        const keywordContextItemsPromise = (async () => [\n            ...(await localSearchContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n        ])()\n\n        const [embeddingsContextItems, keywordContextItems, modelEmbeddingContextItems] =\n            await Promise.all([\n                embeddingsContextItemsPromise,\n                keywordContextItemsPromise,\n                modelSpecificEmbeddingsContextItemsPromise,\n                precomputeQueryEmbeddingPromise,\n            ])\n\n        searchContext = searchContext\n            .concat(keywordContextItems)\n            .concat(embeddingsContextItems)\n            .concat(modelEmbeddingContextItems)\n        const editorContext = await getPriorityContext(text, editor, searchContext)\n        const allContext = editorContext.concat(searchContext)\n        if (!contextRanking) {\n            return allContext\n        }\n        const rankedContext = wrapInActiveSpan('chat.enhancedContextRanker.reranking', () =>\n            contextRanking.rankContextItems(text, allContext)\n        )\n        return rankedContext\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/context-settings.test.ts:24-43"",""content"":""\n    // Opening the enhanced context settings should focus the checkbox for toggling it.\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n\n    // Enhanced context should be enabled by default.\n    await expect(enhancedContextCheckbox).toBeChecked()\n    await page.keyboard.press('Space') // Disable enhanced context\n    // The keyboard should toggle the checkbox, but not dismiss the popup.\n    await expect(enhancedContextCheckbox).not.toBeChecked()\n    await expect(enhancedContextCheckbox).toBeVisible()\n\n    // The popup should be dismiss-able with the keyboard.\n    await page.keyboard.press('Escape')\n    // Closing the enhanced context settings should close the dialog...\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    // ... and the focus is moved to the chat input on close.\n    const contextSettingsButton = chatFrame.getByTitle('Configure Enhanced Context')\n    await expect(contextSettingsButton.and(page.locator(':focus'))).not.toBeVisible()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:36-92"",""content"":""export async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n                      searchEmbeddingsLocal(providers.localEmbeddings, text),\n                      'local-embeddings'\n                  )\n                : []\n\n        //  Get search (symf or remote search) context if config is not set to 'embeddings' only\n        const remoteSearchContextItemsPromise =\n            providers.remoteSearch && strategy !== 'embeddings'\n                ? await retrieveContextGracefully(\n                      searchRemote(providers.remoteSearch, text),\n                      'remote-search'\n                  )\n                : []\n        const localSearchContextItemsPromise =\n            providers.symf && strategy !== 'embeddings'\n                ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n                : []\n\n        // Combine all context sources\n        const searchContext = [\n            ...(await embeddingsContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n            ...(await localSearchContextItemsPromise),\n        ]\n\n        const priorityContext = await getPriorityContext(text, editor, searchContext)\n        return priorityContext.concat(searchContext)\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15"",""content"":""export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287"",""content"":""\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the “Chats” panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the “Chats” panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the “Chats” panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \""Enhanced Context\"" icon next to the chat input.\n- [ ] Verify that \""Enhanced Context\"" is enabled by default.\n\n### Consumer\n\nSet up steps:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:377-385"",""content"":""- We now allocate no more than 60% of the overall LLM context window for enhanced context. This preserves more room for follow-up questions and context. [pull/2768](https://github.com/sourcegraph/cody/pull/2768)\n- Chat: Renamed the \""Restart Chat Session\"" button to \""New Chat Session\"". [pull/2786](https://github.com/sourcegraph/cody/pull/2786)\n- Removed the `cody.experimental.chatPredictions` setting. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Removed support for the `context.codebase` custom command property. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Autocomplete: Better cancellation of requests that are no longer relevant. [pull/2855](https://github.com/sourcegraph/cody/pull/2855)\n- Updated Enhanced Context popover copy and added a link to the docs. [pull/2864](https://github.com/sourcegraph/cody/pull/2864)\n- Include meta information about unit test files in Autocomplete analytics. [pull/2868](https://github.com/sourcegraph/cody/pull/2868)\n- Moved the Context Limit errors in chat into the deboug log output. [pull/2891](https://github.com/sourcegraph/cody/pull/2891)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.test.ts:0-150"",""content"":""import { describe, expect, it } from 'vitest'\nimport * as vscode from 'vscode'\n\nimport type * as status from '@sourcegraph/cody-shared'\n\nimport { ContextStatusAggregator } from './enhanced-context-status'\n\nclass TestProvider implements status.ContextStatusProvider {\n    public emitter: vscode.EventEmitter<status.ContextStatusProvider> = new vscode.EventEmitter()\n\n    constructor(private status_: status.ContextGroup[] | undefined = undefined) {}\n\n    public onDidChangeStatus(\n        callback: (provider: status.ContextStatusProvider) => void\n    ): vscode.Disposable {\n        return this.emitter.event(callback)\n    }\n\n    public get status(): status.ContextGroup[] {\n        return (\n            this.status_ || [\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'embeddings',\n                            state: 'unconsented',\n                        },\n                    ],\n                },\n            ]\n        )\n    }\n    public set status(status: status.ContextGroup[]) {\n        this.status_ = status\n    }\n}\n\ndescribe('ContextStatusAggregator', () => {\n    it('should fire status changed when providers are added and pass through simple status', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => resolve(provider.status))\n        })\n        aggregator.addProvider(new TestProvider())\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                ],\n            },\n        ])\n        aggregator.dispose()\n    })\n    it('should fire aggregate status from multiple providers', async () => {\n        const aggregator = new ContextStatusAggregator()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        aggregator.addProvider(new TestProvider())\n        aggregator.addProvider(\n            new TestProvider([\n                {\n                    displayName: 'host.example/foo',\n                    providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n                },\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'search',\n                            type: 'remote',\n                            state: 'ready',\n                            id: 'quux',\n                            inclusion: 'manual',\n                        },\n                    ],\n                },\n            ])\n        )\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id: 'quux',\n                        inclusion: 'manual',\n                    },\n                ],\n            },\n            {\n                displayName: 'host.example/foo',\n                providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n            },\n        ])\n        // Not only does it aggregate status, it coalesces update events\n        expect(callbackCount).toBe(1)\n        aggregator.dispose()\n    })\n    it('should respond to child events by firing an event of its own', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const provider = new TestProvider()\n        aggregator.addProvider(provider)\n        // Skip the first update event.\n        await Promise.resolve()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        provider.status = [\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [{ kind: 'search', type: 'local', state: 'indexing' }],\n            },\n        ]\n        provider.emitter.fire(provider)\n\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'local',\n                        state: 'indexing',\n                    },\n                ],\n            },\n        ])\n        expect(callbackCount).toBe(1)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:64-89"",""content"":""\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.ts:0-158"",""content"":""import * as vscode from 'vscode'\n\nimport type { ContextGroup, ContextStatusProvider } from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\n// Collects context status from a set of ContextStatusProviders and produces\n// a merged status view.\nexport class ContextStatusAggregator implements vscode.Disposable, ContextStatusProvider {\n    private static TAG = 'ContextStatusAggregator'\n    private disposables: Set<vscode.Disposable> = new Set()\n    private statusEmitter: vscode.EventEmitter<ContextStatusProvider> =\n        new vscode.EventEmitter<ContextStatusProvider>()\n    private providerStatusMap: Map<ContextStatusProvider, ContextGroup[] | 'needs-status'> | undefined =\n        new Map()\n\n    // Whether we have been notified of status changes, but are yet to pass that\n    // notification on. We do this to de-bounce updates from multiple status\n    // providers in one turn of the event loop.\n    private pendingPublish = false\n\n    // Disposes this ContextStatusAggregator.\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.providerStatusMap = undefined\n    }\n\n    // Adds a provider to this ContextStatusAggregator. The aggregator will\n    // subscribe to the provider and aggregate its updates into a merged status.\n    // To remove this provider, dispose of the returned disposable.\n    //\n    // If the provider is disposable, it should dispose of the registration in\n    // its dispose method. Otherwise this ContextStatusAggregator may continue\n    // to poll its status property, and show its status in the aggregate status.\n    public addProvider(provider: ContextStatusProvider): vscode.Disposable {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const disposable = provider.onDidChangeStatus(putativeProvider => {\n            if (provider !== putativeProvider) {\n                logDebug(\n                    ContextStatusAggregator.TAG,\n                    'got onDidChangeStatus event but passed mismatched provider'\n                )\n            }\n            this.providerDidChangeStatus(provider)\n        })\n        this.disposables.add(disposable)\n        this.providerStatusMap.set(provider, 'needs-status')\n        this.providerDidChangeStatus(provider)\n        return {\n            dispose: (): void => {\n                if (this.providerStatusMap) {\n                    this.providerStatusMap.delete(provider)\n                    this.disposables.delete(disposable)\n                    disposable.dispose()\n                    this.publishStatus()\n                }\n            },\n        }\n    }\n\n    // Records that the provider's state is dirty, and schedules an update.\n    private providerDidChangeStatus(provider: ContextStatusProvider): void {\n        if (this.providerStatusMap === undefined) {\n            // We have been disposed\n            return\n        }\n        if (!this.providerStatusMap.has(provider)) {\n            // The provider has been removed. This should not happen if the\n            // providers are following the dispose protocol.\n            return\n        }\n        // Record that we need to get provider status next update.\n        this.providerStatusMap.set(provider, 'needs-status')\n        // Schedule an update.\n        this.publishStatus()\n    }\n\n    // Aggregates and publishes status asynchronously. Multiple context status\n    // providers updating \""at once\"" will be coalesced into one update.\n    private publishStatus(): void {\n        if (this.pendingPublish) {\n            // Coalesce multiple updates.\n            return\n        }\n        this.pendingPublish = true\n        void Promise.resolve().then(() => {\n            this.pendingPublish = false\n            this.statusEmitter.fire(this)\n        })\n    }\n\n    // ContextStatusProvider implementation of onDidChangeStatus. The\n    // ContextStatusAggregator can be stacked to combine per-workspace and\n    // per-chat context status.\n    public onDidChangeStatus(callback: (sender: ContextStatusProvider) => void): vscode.Disposable {\n        return this.statusEmitter.event(callback)\n    }\n\n    // Computes the merged context status. This may throw if any of the\n    // aggregated providers' status throw.\n    public get status(): ContextGroup[] {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const groupBy: { [name: string]: ContextGroup } = {}\n        // Iterate through provider status map entries\n        for (let [provider, status] of this.providerStatusMap.entries()) {\n            if (status === 'needs-status') {\n                // The provider's status is stale; poll it.\n                status = provider.status\n                if (this.providerStatusMap.get(provider) !== 'needs-status') {\n                    logDebug(\n                        ContextStatusAggregator.TAG,\n                        'ContextStatusProvider.status should only report status, not change state',\n                        provider\n                    )\n                }\n                // Deep clone the status object so providers can't continue to change it without notifying.\n                status = JSON.parse(JSON.stringify(status)) as ContextGroup[]\n                // Cache the status so we don't re-poll this provider unless it changes.\n                this.providerStatusMap.set(provider, status)\n            }\n\n            // Collect context groups by name\n            for (const group of status) {\n                if (group.displayName in groupBy) {\n                    // Merge the items in the group.\n                    groupBy[group.displayName].providers.push(...group.providers)\n                } else {\n                    // Create a new group for the merged result.\n                    groupBy[group.displayName] = {\n                        displayName: group.displayName,\n                        providers: [...group.providers],\n                    }\n                }\n            }\n        }\n        // Order sources within the groups by a canonical order\n        for (const groups of Object.values(groupBy)) {\n            // Sort by a fixed locale for consistency. The 'kind' key is not a\n            // localized UI label.\n            groups.providers.sort((a, b) => a.kind.localeCompare(b.kind, 'en-US'))\n        }\n        return [...Object.values(groupBy)]\n    }\n\n    // TODO: Create a publisher to push into the webview\n    // TODO: Hook in local embeddings\n    // TODO: Hook in cloud embeddings\n    // TODO: Hook in symf\n    // TODO: Hook in graph\n    // TODO: Hook in the Cody: building code index ... notification pusher's\n    // state\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/common.ts:50-74"",""content"":""\n/**\n * Create and open a new chat panel, and close the enhanced context settings window.\n * Returns the chat panel frame locator.\n */\nexport async function createEmptyChatPanel(page: Page): Promise<[FrameLocator, Locator]> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    const chatFrame = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n    await page.keyboard.press('Escape')\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    return [chatFrame, chatInput]\n}\n\n/**\n * Gets the chat context cell. If {@link counts} is specified, then validates that the context\n * exactly matches the specified file and line counts.\n */\nexport function getContextCell(\n    chatPanel: FrameLocator,\n    counts?: { files: number; lines: number }\n): Locator {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/EnhancedContext.tsx:4-6"",""content"":""export function useEnhancedContextEnabled(): boolean {\n    return React.useContext(EnhancedContextEnabled)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_019/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, the embeddings model is queried in the `retrieveEmbeddingBasedContext` method in the `context-ranking.ts` file. Here is the relevant code snippet:

```typescript
public async retrieveEmbeddingBasedContext(
    query: PromptString,
    numResults: number,
    modelName: string
): Promise<EmbeddingsSearchResult[]> {
    const repoUri = this.getRepoUri()
    if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {
        return []
    }
    try {
        const service = await this.getService()
        const resp = await service.request('context-ranking/context-retriever-embedding', {
            repoPath: repoUri.path,
            query: query.toString(),
            modelName: modelName,
            numResults: numResults,
        })
        const model_specific_embedding_items = resp.results.map(result => ({
            ...result,
            uri: vscode.Uri.joinPath(repoUri, result.fileName),
        }))
        return model_specific_embedding_items
    } catch (error) {
        logDebug(
            'ContextRankingController',
            'error in fetching embeddings features',
        )
    }
}
```

In this method, the `service.request` function is called with the `'context-ranking/context-retriever-embedding'` endpoint, passing the repository path, query, model name, and number of results as parameters. This is where the embeddings model is queried.",Where do we query the embeddings model?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/index.ts:132-134"",""content"":""    public static getProviderByModel(modelID: string): ModelProvider | undefined {\n        return ModelProvider.providers.find(m => m.model === modelID)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:502-541"",""content"":""      },\n      {\n        \""command\"": \""cody.embeddings.resolveIssue\"",\n        \""title\"": \""Cody Embeddings\"",\n        \""when\"": \""cody.embeddings.hasIssue\""\n      },\n      {\n        \""command\"": \""cody.debug.export.logs\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Export Logs…\""\n      },\n      {\n        \""command\"": \""cody.debug.outputChannel\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Open Output Channel\""\n      },\n      {\n        \""command\"": \""cody.debug.enable.all\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Enable Debug Mode\"",\n        \""when\"": \""!config.cody.debug.verbose\""\n      },\n      {\n        \""command\"": \""cody.debug.reportIssue\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Report Issue\""\n      },\n      {\n        \""command\"": \""cody.copy.version\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""icon\"": \""$(copy)\"",\n        \""title\"": \""Copy Cody Extension Version\""\n      }\n    ],\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:4-7"",""content"":""export interface ChatModelContext {\n    chatModels?: ModelProvider[]\n    onCurrentChatModelChange?: (model: ModelProvider) => void\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:103-127"",""content"":""        this.disposables.push(\n            vscode.commands.registerCommand('cody.embeddings.resolveIssue', () =>\n                this.resolveIssueCommand()\n            )\n        )\n\n        // Pick up the initial access token, and whether the account is dotcom.\n        this.accessToken = config.accessToken || undefined\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n\n        this.model = config.testingLocalEmbeddingsModel || 'openai/text-embedding-ada-002'\n        this.endpoint =\n            config.testingLocalEmbeddingsEndpoint || 'https://cody-gateway.sourcegraph.com/v1/embeddings'\n        this.indexLibraryPath = config.testingLocalEmbeddingsIndexLibraryPath\n            ? URI.file(config.testingLocalEmbeddingsIndexLibraryPath)\n            : undefined\n    }\n\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.statusBar?.dispose()\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:40-84"",""content"":""    private async compileQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const languages = [language, ...(grammarInheritance[language] ?? [])]\n        const queryStrings: string[] = []\n        for (const queryLanguage of languages) {\n            const queryPath = path.join(this.queriesDirectory, queryLanguage, `${name}.scm`)\n            try {\n                const stat = await fspromises.stat(queryPath)\n                if (!stat.isFile()) {\n                    continue\n                }\n            } catch {\n                if (this.queryDirectoryExists === undefined) {\n                    try {\n                        this.queryDirectoryExists = (\n                            await fspromises.stat(this.queriesDirectory)\n                        ).isDirectory()\n                        if (!this.queryDirectoryExists) {\n                            throw new Error(\n                                `Query directory ${this.queriesDirectory} is not a directory. To fix this problem, update the value of the flag --queries-directory <path>`\n                            )\n                        }\n                    } catch {\n                        throw new Error(\n                            `Query directory ${this.queriesDirectory} does not exist. To fix this problem, update the value of the flag --queries-directory <path>`\n                        )\n                    }\n                }\n                continue\n            }\n            const queryString = await fspromises.readFile(queryPath)\n            queryStrings.push(queryString.toString())\n        }\n        const uncompiled: UncompiledQuery = {\n            language,\n            queryName: name,\n            queryString: queryStrings.join('\\n\\n'),\n        }\n        const compiled = compileQuery(uncompiled, parser)\n        this.cache.push(compiled)\n        return compiled.compiledQuery\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3000-3017"",""content"":""                writer.writeMessage(22, this.super_type, () => this.super_type.serialize(writer))\n            if (this.has_constant_type)\n                writer.writeMessage(23, this.constant_type, () => this.constant_type.serialize(writer))\n            if (this.has_intersection_type)\n                writer.writeMessage(17, this.intersection_type, () =>\n                    this.intersection_type.serialize(writer)\n                )\n            if (this.has_union_type)\n                writer.writeMessage(18, this.union_type, () => this.union_type.serialize(writer))\n            if (this.has_with_type)\n                writer.writeMessage(19, this.with_type, () => this.with_type.serialize(writer))\n            if (this.has_structural_type)\n                writer.writeMessage(7, this.structural_type, () =>\n                    this.structural_type.serialize(writer)\n                )\n            if (this.has_annotated_type)\n                writer.writeMessage(8, this.annotated_type, () => this.annotated_type.serialize(writer))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:21-38"",""content"":""    public async loadQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const fromCache = this.cache.find(\n            compiled => compiled.language === language && compiled.queryName === name\n        )\n        if (fromCache) {\n            return fromCache.compiledQuery\n        }\n        try {\n            return await this.compileQuery(parser, language, name)\n        } catch (error) {\n            console.error(`Queries.loadQuery(): ${language}/${name}`, error)\n            process.exit(1)\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:68-95"",""content"":""\n// Model identifiers can be found in https://docs.fireworks.ai/explore/ and in our internal\n// conversations\nconst MODEL_MAP = {\n    // Virtual model strings. Cody Gateway will map to an actual model\n    starcoder: 'fireworks/starcoder',\n    'starcoder-16b': 'fireworks/starcoder-16b',\n    'starcoder-7b': 'fireworks/starcoder-7b',\n    'starcoder2-15b': 'fireworks/starcoder2-15b',\n    'starcoder2-7b': 'fireworks/starcoder2-7b',\n\n    // Fireworks model identifiers\n    'llama-code-13b': 'fireworks/accounts/fireworks/models/llama-v2-13b-code',\n}\n\ntype FireworksModel =\n    | keyof typeof MODEL_MAP\n    // `starcoder-hybrid` uses the 16b model for multiline requests and the 7b model for single line\n    | 'starcoder-hybrid'\n    // `starcoder2-hybrid` uses the 15b model for multiline requests and the 7b model for single line\n    | 'starcoder2-hybrid'\n\nfunction getMaxContextTokens(model: FireworksModel): number {\n    switch (model) {\n        case 'starcoder':\n        case 'starcoder2-hybrid':\n        case 'starcoder2-15b':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.test.ts:0-46"",""content"":""import { afterEach, describe, expect, it } from 'vitest'\n\nimport { SupportedLanguage } from './grammars'\nimport { resetParsersCache } from './parser'\nimport { getDocumentQuerySDK } from './query-sdk'\nimport { initTreeSitterParser } from './test-helpers'\n\ndescribe('getDocumentQuerySDK', () => {\n    afterEach(() => {\n        resetParsersCache()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.javascript },\n        { languageId: SupportedLanguage.typescript },\n        { languageId: SupportedLanguage.javascriptreact },\n        { languageId: SupportedLanguage.typescriptreact },\n        { languageId: SupportedLanguage.go },\n        { languageId: SupportedLanguage.python },\n    ])('returns valid SDK for $languageId', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk?.queries.intents).toBeTruthy()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.cpp },\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.php },\n    ])('returns null for $languageId because queries are not defined', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk).toBeNull()\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:0-26"",""content"":""// Add anything else here that needs to be used outside of this library.\n\nexport { ModelProvider } from './models'\nexport { type ChatModel, type EditModel, ModelUsage, type ModelContextWindow } from './models/types'\nexport { getDotComDefaultModels } from './models/dotcom'\nexport {\n    getProviderName,\n    getModelInfo,\n} from './models/utils'\nexport { BotResponseMultiplexer } from './chat/bot-response-multiplexer'\nexport { ChatClient } from './chat/chat'\nexport { ignores, isCodyIgnoredFile } from './cody-ignore/context-filter'\nexport {\n    IgnoreHelper,\n    CODY_IGNORE_POSIX_GLOB,\n    type IgnoreFileContent,\n    CODY_IGNORE_URI_PATH,\n} from './cody-ignore/ignore-helper'\nexport { renderCodyMarkdown } from './chat/markdown'\nexport { getSimplePreamble } from './chat/preamble'\nexport type {\n    SerializedChatInteraction,\n    SerializedChatTranscript,\n} from './chat/transcript'\nexport { serializeChatMessage } from './chat/transcript'\nexport { errorToChatError, DEFAULT_EVENT_SOURCE } from './chat/transcript/messages'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.ts:0-550"",""content"":""import { findLast } from 'lodash'\nimport type { Position, TextDocument } from 'vscode'\nimport type {\n    Language,\n    Point,\n    Query,\n    QueryCapture,\n    SyntaxNode,\n    Tree,\n    default as Parser,\n} from 'web-tree-sitter'\n\nimport { type SupportedLanguage, isSupportedLanguage } from './grammars'\nimport { getCachedParseTreeForDocument } from './parse-tree-cache'\nimport { type WrappedParser, getParser } from './parser'\nimport { type CompletionIntent, type QueryName, intentPriority, languages } from './queries'\n\ninterface ParsedQuery {\n    compiled: Query\n    raw: string\n}\ntype ResolvedQueries = {\n    [name in QueryName]: ParsedQuery\n}\n\nconst QUERIES_LOCAL_CACHE: Partial<Record<SupportedLanguage, ResolvedQueries & QueryWrappers>> = {}\n\n/**\n * Reads all language queries from disk and parses them.\n * Saves queries the local cache for further use.\n */\nexport function initQueries(language: Language, languageId: SupportedLanguage, parser: Parser): void {\n    const cachedQueries = QUERIES_LOCAL_CACHE[languageId]\n    if (cachedQueries) {\n        return\n    }\n\n    const languageQueries = languages[languageId]\n    if (languageQueries === undefined) {\n        return\n    }\n\n    const queryEntries = Object.entries(languageQueries).map(([name, raw]) => {\n        return [\n            name,\n            {\n                raw,\n                compiled: language.query(raw),\n            },\n        ] as const\n    })\n\n    const queries = Object.fromEntries<ParsedQuery>(queryEntries) as ResolvedQueries\n\n    QUERIES_LOCAL_CACHE[languageId] = {\n        ...queries,\n        ...getLanguageSpecificQueryWrappers(queries, parser, languageId),\n    }\n}\n\nexport interface DocumentQuerySDK {\n    parser: WrappedParser\n    queries: ResolvedQueries & QueryWrappers\n    language: SupportedLanguage\n}\n\n/**\n * Returns the query SDK only if the language has queries defined and\n * the relevant language parser is initialized.\n */\nexport function getDocumentQuerySDK(language: string): DocumentQuerySDK | null {\n    if (!isSupportedLanguage(language)) {\n        return null\n    }\n\n    const parser = getParser(language)\n    const queries = QUERIES_LOCAL_CACHE[language]\n\n    if (!parser || !queries) {\n        return null\n    }\n\n    return {\n        parser,\n        queries,\n        language,\n    }\n}\n\nexport interface QueryWrappers {\n    getSinglelineTrigger: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: 'trigger' }]\n    getCompletionIntent: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: CompletionIntent }]\n    getDocumentableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  insertionPoint?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n    getGraphContextIdentifiers: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getEnclosingFunction: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getTestableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n}\n\n/**\n * Query wrappers with custom post-processing logic.\n */\nfunction getLanguageSpecificQueryWrappers(\n    queries: ResolvedQueries,\n    _parser: Parser,\n    languageId: SupportedLanguage\n): QueryWrappers {\n    return {\n        getSinglelineTrigger: (root, start, end) => {\n            const captures = queries.singlelineTriggers.compiled.captures(root, start, end)\n            const { trigger, block } = getTriggerNodeWithBlockStaringAtPoint(captures, start)\n\n            if (!trigger || !block || !isBlockNodeEmpty(block)) {\n                return []\n            }\n\n            return [{ node: trigger, name: 'trigger' }] as const\n        },\n        getCompletionIntent: (root, start, end) => {\n            const captures = queries.intents.compiled.captures(root, start, end)\n\n            const { intentCapture } = getIntentFromCaptures(captures, start)\n\n            if (!intentCapture) {\n                return []\n            }\n\n            return [{ node: intentCapture.node, name: intentCapture.name as CompletionIntent }] as const\n        },\n        getDocumentableNode: (root, start, end) => {\n            const captures = queries.documentableNodes.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const documentableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = documentableRanges.at(-1)\n\n            let insertionPoint: QueryCapture | undefined\n            if (languageId === 'python' && range) {\n                /**\n                 * Python is a special case for generating documentation.\n                 * The insertion point of the documentation should differ if the symbol is a function or class.\n                 * We need to query again for an insertion point, this time using the correct determined range.\n                 *\n                 * See https://peps.python.org/pep-0257/ for the documentation conventions for Python.\n                 */\n                const insertionCaptures = queries.documentableNodes.compiled\n                    .captures(root, range.node.startPosition, range.node.endPosition)\n                    .filter(({ name }) => name.startsWith('insertion'))\n\n                insertionPoint = insertionCaptures.find(\n                    ({ node }) =>\n                        node.startIndex >= range.node.startIndex && node.endIndex <= range.node.endIndex\n                )\n            }\n\n            /**\n             * Modify where we look for a docstring depending on the language and syntax.\n             * For Python functions and classes, we will have a provided `insertionPoint`, use the line below this.\n             * For all other cases, docstrings should be attached above the symbol range, use this.\n             */\n            const docStringLine =\n                languageId === 'python' && insertionPoint\n                    ? insertionPoint.node.startPosition.row + 1\n                    : start.row - 1\n            const docstringCaptures = queries.documentableNodes.compiled\n                .captures(\n                    root,\n                    { row: docStringLine, column: 0 },\n                    { row: docStringLine, column: Number.MAX_SAFE_INTEGER }\n                )\n                .filter(node => node.name.startsWith('comment'))\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one documentable range for this position, we can be confident it makes sense to document. Show the hint.\n             * 2. Otherwise, only show the hint if the symbol is a function\n             * 3. Don't show hint if there is no docstring already present.\n             */\n            const showHint = Boolean(\n                (documentableRanges.length === 1 || symbol?.name.includes('function')) &&\n                    docstringCaptures.length === 0\n            )\n\n            return [\n                {\n                    symbol,\n                    range,\n                    insertionPoint,\n                    meta: { showHint },\n                },\n            ]\n        },\n        getGraphContextIdentifiers: (root, start, end) => {\n            return queries.graphContextIdentifiers.compiled.captures(root, start, end)\n        },\n        getEnclosingFunction: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled\n                .captures(root, start, end)\n                .filter(capture => capture.name.startsWith('range'))\n\n            const firstEnclosingFunction = findLast(captures, ({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            if (!firstEnclosingFunction) {\n                return []\n            }\n\n            return [firstEnclosingFunction]\n        },\n        getTestableNode: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const testableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = testableRanges.at(-1)\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one testable range for this position, we can be confident it makes sense to test. Show the hint.\n             * 2. TODO: Look for usages of this function in test files, if it's already used then don't show the hint.\n             */\n            const showHint = Boolean(testableRanges.length === 1)\n\n            return [\n                {\n                    symbol,\n                    range,\n                    meta: { showHint },\n                },\n            ]\n        },\n    }\n}\n\n// TODO: check if the block parent is empty in the consumer.\n// Tracking: https://github.com/sourcegraph/cody/issues/1452\nfunction getIntentFromCaptures(\n    captures: QueryCapture[],\n    cursor: Point\n): { cursorCapture?: Parser.QueryCapture; intentCapture?: Parser.QueryCapture } {\n    const emptyResult = {\n        cursorCapture: undefined,\n        intentCapture: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    // Find the cursor capture group if exists.\n    const [cursorCapture] = sortByIntentPriority(\n        captures.filter(capture => {\n            const { name, node } = capture\n\n            const matchesCursorPosition =\n                node.startPosition.column === cursor.column && node.startPosition.row === cursor.row\n\n            return name.endsWith('.cursor') && matchesCursorPosition\n        })\n    )\n\n    // Find the corresponding preceding intent capture that matches the cursor capture name.\n    const intentCapture = findLast(captures, capture => {\n        return capture.name === withoutCursorSuffix(cursorCapture?.name)\n    })\n\n    if (cursorCapture && intentCapture) {\n        return { cursorCapture, intentCapture }\n    }\n\n    // If we didn't find a multinode intent, use the most nested atomic capture group.\n    // Atomic capture groups are matches with one node and `!` at the end the capture group name.\n    const atomicCapture = findLast(captures, capture => {\n        const enclosesCursor =\n            (capture.node.startPosition.column <= cursor.column ||\n                capture.node.startPosition.row < cursor.row) &&\n            (cursor.column <= capture.node.endPosition.column ||\n                cursor.row < capture.node.endPosition.row)\n\n        return capture.name.endsWith('!') && enclosesCursor\n    })\n\n    if (atomicCapture) {\n        return {\n            intentCapture: {\n                ...atomicCapture,\n                // Remove `!` from the end of the capture name.\n                name: atomicCapture.name.slice(0, -1),\n            },\n        }\n    }\n\n    return emptyResult\n}\n\nfunction sortByIntentPriority(captures: QueryCapture[]): QueryCapture[] {\n    return captures.sort((a, b) => {\n        return (\n            intentPriority.indexOf(withoutCursorSuffix(a.name) as CompletionIntent) -\n            intentPriority.indexOf(withoutCursorSuffix(b.name) as CompletionIntent)\n        )\n    })\n}\n\nfunction withoutCursorSuffix(name?: string): string | undefined {\n    return name?.split('.').slice(0, -1).join('.')\n}\n\nfunction getTriggerNodeWithBlockStaringAtPoint(\n    captures: QueryCapture[],\n    point: Point\n): { trigger?: SyntaxNode; block?: SyntaxNode } {\n    const emptyResult = {\n        trigger: undefined,\n        block: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    const blockStart = getNodeIfMatchesPoint({\n        captures,\n        name: 'block_start',\n        // Taking the last result to get the most nested node.\n        // See https://github.com/tree-sitter/tree-sitter/discussions/2067\n        index: -1,\n        point,\n    })\n\n    const trigger = getCapturedNodeAt({\n        captures,\n        name: 'trigger',\n        index: -1,\n    })\n\n    const block = blockStart?.parent\n\n    if (!blockStart || !block || !trigger) {\n        return emptyResult\n    }\n\n    // Verify that the block node ends at the same position as the trigger node.\n    if (trigger.endIndex !== block?.endIndex) {\n        return emptyResult\n    }\n\n    return { trigger, block }\n}\n\ninterface GetNodeIfMatchesPointParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n    point: Point\n}\n\nfunction getNodeIfMatchesPoint(params: GetNodeIfMatchesPointParams): SyntaxNode | null {\n    const { captures, name, index, point } = params\n\n    const node = getCapturedNodeAt({ captures, name, index })\n\n    if (node && node.startPosition.column === point.column && node.startPosition.row === point.row) {\n        return node\n    }\n\n    return null\n}\n\ninterface GetCapturedNodeAtParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n}\n\nfunction getCapturedNodeAt(params: GetCapturedNodeAtParams): SyntaxNode | null {\n    const { captures, name, index } = params\n\n    return captures.filter(capture => capture.name === name).at(index)?.node || null\n}\n\n/**\n * Consider a block empty if it does not have any named children or is missing its closing tag.\n */\nfunction isBlockNodeEmpty(node: SyntaxNode | null): boolean {\n    // Consider a node empty if it does not have any named children.\n    const isBlockEmpty = node?.children.filter(c => c.isNamed()).length === 0\n    const isMissingBlockEnd = Boolean(node?.lastChild?.isMissing())\n\n    return isBlockEmpty || isMissingBlockEnd\n}\n\ninterface QueryPoints {\n    startPoint: Point\n    endPoint: Point\n}\n\nexport function positionToQueryPoints(position: Pick<Position, 'line' | 'character'>): QueryPoints {\n    const startPoint = {\n        row: position.line,\n        column: position.character,\n    }\n\n    const endPoint = {\n        row: position.line,\n        // Querying around one character after trigger position.\n        column: position.character + 1,\n    }\n\n    return { startPoint, endPoint }\n}\n\ntype ExecQueryWrapperParams<T> = {\n    queryWrapper: T\n} & (\n    | {\n          document: TextDocument\n          queryPoints: QueryPoints\n      }\n    | {\n          document: TextDocument\n          position: Pick<Position, 'line' | 'character'>\n      }\n    | {\n          tree: Tree\n          languageId: string\n          queryPoints: QueryPoints\n      }\n    | {\n          tree: Tree\n          languageId: string\n          position: Pick<Position, 'line' | 'character'>\n      }\n)\n\nexport function execQueryWrapper<T extends keyof QueryWrappers>(\n    params: ExecQueryWrapperParams<T>\n): ReturnType<QueryWrappers[T]> | never[] {\n    const { queryWrapper } = params\n\n    const treeToQuery =\n        'document' in params ? getCachedParseTreeForDocument(params.document)?.tree : params.tree\n    const languageId = 'document' in params ? params.document.languageId : params.languageId\n    const documentQuerySDK = getDocumentQuerySDK(languageId as SupportedLanguage)\n\n    const queryPoints =\n        'position' in params ? positionToQueryPoints(params.position) : params.queryPoints\n    const { startPoint, endPoint } = queryPoints\n\n    if (documentQuerySDK && treeToQuery) {\n        return documentQuerySDK.queries[queryWrapper](\n            treeToQuery.rootNode,\n            startPoint,\n            endPoint\n        ) as ReturnType<QueryWrappers[T]>\n    }\n\n    return []\n}\n\nexport type { CompletionIntent }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:7525-7552"",""content"":""      '@esbuild/linux-arm64': 0.20.2\n      '@esbuild/linux-ia32': 0.20.2\n      '@esbuild/linux-loong64': 0.20.2\n      '@esbuild/linux-mips64el': 0.20.2\n      '@esbuild/linux-ppc64': 0.20.2\n      '@esbuild/linux-riscv64': 0.20.2\n      '@esbuild/linux-s390x': 0.20.2\n      '@esbuild/linux-x64': 0.20.2\n      '@esbuild/netbsd-x64': 0.20.2\n      '@esbuild/openbsd-x64': 0.20.2\n      '@esbuild/sunos-x64': 0.20.2\n      '@esbuild/win32-arm64': 0.20.2\n      '@esbuild/win32-ia32': 0.20.2\n      '@esbuild/win32-x64': 0.20.2\n    dev: true\n\n  /escalade@3.1.1:\n    resolution: {integrity: sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==}\n    engines: {node: '>=6'}\n\n  /escalade@3.1.2:\n    resolution: {integrity: sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA==}\n    engines: {node: '>=6'}\n    dev: true\n\n  /escape-html@1.0.3:\n    resolution: {integrity: sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/embeddings-protocol.ts:0-125"",""content"":""/**\n * The protocol for communicating between Cody and local embeddings.\n */\n\ninterface InitializeParams {\n    codyGatewayEndpoint: string\n    indexPath: string\n    chunkingPolicy?: ChunkingPolicy\n}\n\ninterface ChunkingPolicy {\n    maxFileSizeBytes: number\n    pathsToExcludeRegexp: string\n}\n\ninterface QueryParams {\n    repoName: string\n    query: string\n    numResults: number\n}\n\nexport interface QueryResultSet {\n    results: QueryResult[]\n}\n\ninterface QueryResult {\n    fileName: string\n    startLine: number\n    endLine: number\n    content: string\n}\n\ninterface IndexHealthRequest {\n    // The name of the repository to scrutinize the index for. Note, this\n    // is a repo name, like github.com/sourcegraph/cody, not a file path.\n    repoName: string\n}\n\ntype IndexHealthResult = IndexHealthResultFound | IndexHealthResultNotFound\n\nexport interface IndexHealthResultFound {\n    type: 'found'\n    repoName: string\n    format: 'App' | 'LocalEmbeddings'\n    commit: string\n    model: string\n    dimension: number\n    numItems: number\n    numItemsDeleted: number\n    numItemsNeedEmbedding: number\n    numItemsFailed: number\n    numFiles: number\n}\n\ninterface IndexHealthResultNotFound {\n    type: 'notFound'\n    repoName: string\n}\n\nexport interface IndexRequest {\n    repoPath: string\n    mode: IndexRequestMode\n}\n\ntype IndexRequestMode = IndexRequestModeNew | IndexRequestModeContinue\n\ninterface IndexRequestModeNew {\n    type: 'new'\n    model: string\n    dimension: number\n}\n\ninterface IndexRequestModeContinue {\n    type: 'continue'\n}\n\ninterface IndexResult {\n    repoName: string\n}\n\ninterface LoadResult {\n    repoName: string\n}\nexport type Requests = {\n    'embeddings/echo': [string, string]\n    // Instruct local embeddings to index the specified repository path.\n    'embeddings/index': [IndexRequest, IndexResult]\n    // Get statistics for the index for a given repository name.\n    'embeddings/index-health': [IndexHealthRequest, IndexHealthResult]\n    // Initializes the local embeddings service. You must call this first.\n    'embeddings/initialize': [InitializeParams, Record<string, never>]\n    // Searches for and loads an index for the specified repository name.\n    'embeddings/load': [string, LoadResult]\n    // Queries loaded index.\n    'embeddings/query': [QueryParams, QueryResultSet]\n    // Sets the Sourcegraph access token.\n    'embeddings/set-token': [string, Record<string, never>]\n    // Shuts down the local embeddings service.\n    'embeddings/shutdown': [Record<string, never>, Record<string, never>]\n}\n\ntype ProgressValue = Progress | ProgressError | ProgressDone\n\ninterface Progress {\n    type: 'progress'\n    currentPath: string\n    repoName: string\n    repoPath: string\n    numItems: number\n    totalItems: number\n}\n\ninterface ProgressDone {\n    type: 'done'\n    repoName: string\n}\n\ninterface ProgressError {\n    type: 'error'\n    repoName: string\n    message: string\n}\nexport type Notifications = {\n    'embeddings/progress': [ProgressValue]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:279-311"",""content"":""    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:111-118"",""content"":""    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:30-58"",""content"":""\nexport type LocalEmbeddingsConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & {\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/embeddings`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/embeddings`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\embeddings`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\ninterface RepoState {\n    repoName: string | false\n    indexable: boolean\n    errorReason: GetFieldType<LocalEmbeddingsProvider, 'errorReason'>\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/uri.ts:72-74"",""content"":""    public get query(): string {\n        return this.uri.query\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/types.ts:0-62"",""content"":""import type { ModelProvider } from '.'\n\nexport enum ModelUsage {\n    Chat = 'chat',\n    Edit = 'edit',\n}\n\n// Utility to narrow a model type to a specific model usage\ntype HasUsage<T, I> = T extends { usage: readonly ModelUsage[] }\n    ? I extends T['usage'][number]\n        ? T\n        : never\n    : never\n\ntype Models = typeof ModelProvider\n\n/**\n * Available models for Edit.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type EditModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Edit>\n      }[keyof Models]['model']\n    | (string & {})\n\n/**\n * Available models for Chat.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type ChatModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Chat>\n      }[keyof Models]['model']\n    | (string & {})\n\nexport interface ModelContextWindow {\n    /**\n     * The token limit reserved for chat input.\n     */\n    input: number\n    /**\n     * The maximum number of tokens that the model can respond with in a single request.\n     */\n    output: number\n    /**\n     * The additional tokens reserved for context.\n     * When not defined, context shares the same token limit as input.\n     */\n    context?: {\n        /**\n         * The token limit reserved for user-added context.\n         * Example: @-mentions.\n         */\n        user?: number\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:2-2"",""content"":""export const MODEL = 'anthropic/claude-3-haiku-20240307'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:226-254"",""content"":""    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:286-313"",""content"":""                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-57"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_020/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for running `symf` is primarily encapsulated within the `SymfRunner` class, which is defined in the file `cody_test/vscode/src/local-context/symf.ts`. This class handles various operations related to `symf`, such as ensuring indexes, running queries, and managing index statuses. Here are some key methods within the `SymfRunner` class that are responsible for running `symf`:

1. **`getResults`**: This method is used to get results from `symf` for a given user query and scope directories.
    ```typescript
    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {
        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)
        return Promise.resolve(
            scopeDirs
                .filter(isFileURI)
                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))
        )
    }
    ```

2. **`getResultsForScopeDir`**: This method gets the list of results from `symf` for a single directory scope.
    ```typescript
    private async getResultsForScopeDir(
        keywordQuery: Promise<string>,
        scopeDir: FileURI
    ): Promise<Result[]> {
        const maxRetries = 10

        for (let i = 0; i < maxRetries; i++) {
            await this.getIndexLock(scopeDir).withWrite(async () => {
                await this.unsafeEnsureIndex(scopeDir, {
                    retryIfLastAttemptFailed: i === 0,
                    ignoreExisting: false,
                })
            })

            let indexNotFound = false
            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {
                if (!(await this.unsafeIndexExists(scopeDir))) {
                    indexNotFound = true
                    return ''
                }
                return this.unsafeRunQuery(await keywordQuery, scopeDir)
            })
            if (indexNotFound) {
                continue
            }
            const results = parseSymfStdout(stdout)
            return results
        }
        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)
    }
    ```

3. **`unsafeRunQuery`**: This method runs a query using `symf`.
    ```typescript
    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {
        const { indexDir } = this.getIndexDir(scopeDir)
        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()
        try {
            const { stdout } = await execFile(
                symfPath,
                [
                    '--index-root',
                    indexDir.fsPath,
                    'query',
                    '--scopes',
                    scopeDir.fsPath,
                    '--fmt',
                    'json',
                    keywordQuery,
                ],
                {
                    env: {
                        SOURCEGRAPH_TOKEN: accessToken,
                        SOURCEGRAPH_URL: serverEndpoint,
                        HOME: process.env.HOME,
                    },
                    maxBuffer: 1024 * 1024 * 1024,
                    timeout: 1000 * 30, // timeout in 30 seconds
                }
            )
            return stdout
        } catch (error) {
            throw toSymfError(error)
        }
    }
    ```

Additionally, the `SymfRunner` class is instantiated and used in the `activateCommon` function in the file `cody_test/vscode/src/extension.node.ts`:
```typescript
return activateCommon(context, {
    createSymfRunner: (...args) => new SymfRunner(...args),
    // other services
})
```

The `getSymfPath` function in `cody_test/vscode/src/local-context/download-symf.ts` is responsible for determining the path to the `symf` binary, either by using a user-specified path or downloading it if necessary:
```typescript
export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {
    const config = vscode.workspace.getConfiguration()
    const userSymfPath = config.get<string>('cody.experimental.symf.path')
    if (userSymfPath) {
        logDebug('symf', `using user symf: ${userSymfPath}`)
        return userSymfPath
    }

    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')
    return await _getSymfPath(symfContainingDir)
}
```

In summary, the `SymfRunner` class in `cody_test/vscode/src/local-context/symf.ts` encapsulates the functionality for running `symf`, including methods for querying, indexing, and managing the `symf` binary.",Where is the functionality for running symf?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:565-582"",""content"":""\n### Changed\n\n- Settings: Relabel \""symf Context\"" as \""Search Context\"". [pull/2285](https://github.com/sourcegraph/cody/pull/2285)\n- Chat: Removed 'Chat Suggestions' setting. [pull/2284](https://github.com/sourcegraph/cody/pull/2284)\n- Edit: Completed edits are no longer scrolled back into view in the active file. [pull/2297](https://github.com/sourcegraph/cody/pull/2297)\n- Chat: Update welcome message. [pull/2298](https://github.com/sourcegraph/cody/pull/2298)\n- Edit: Decorations are no longer shown once an edit has been applied. [pull/2304](https://github.com/sourcegraph/cody/pull/2304)\n\n## [0.18.4]\n\n### Added\n\n### Fixed\n\n- Fixes an issue where the sidebar would not properly load when not signed in. [pull/2267](https://github.com/sourcegraph/cody/pull/2267)\n- Fixes an issue where telemetry events were not properly logged with the new chat experience. [pull/2291](https://github.com/sourcegraph/cody/pull/2291)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:62-67"",""content"":""\n        onConfigurationChange: setCustomAgent,\n        extensionClient,\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/isRunningInsideAgent.ts:2-4"",""content"":""export function isRunningInsideAgent(): boolean {\n    return vscode.workspace.getConfiguration().get<boolean>('cody.advanced.agent.running', false)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80"",""content"":""\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:543-580"",""content"":""function parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:46-62"",""content"":""\n    return activateCommon(context, {\n        createLocalEmbeddingsController: isLocalEmbeddingsDisabled\n            ? undefined\n            : (config: LocalEmbeddingsConfig): LocalEmbeddingsController =>\n                  createLocalEmbeddingsController(context, config),\n        createContextRankingController: (config: ContextRankerConfig) =>\n            createContextRankingController(context, config),\n        createCompletionsClient: (...args) => new SourcegraphNodeCompletionsClient(...args),\n        createCommandsProvider: () => new CommandsProvider(),\n        createSymfRunner: (...args) => new SymfRunner(...args),\n        createBfgRetriever: () => new BfgRetriever(context),\n        createSentryService: (...args) => new NodeSentryService(...args),\n        createOpenTelemetryService: (...args) => new OpenTelemetryService(...args),\n        getRemoteUrlGetters: () => [gitRemoteUrlFromGitCli],\n        startTokenReceiver: (...args) => startTokenReceiver(...args),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:49-486"",""content"":""export class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:630-642"",""content"":""function toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gpt-4o,chat,question_021/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that interacts with the `symf` binary can be found in the `cody_test/vscode/src/local-context/symf.ts` and `cody_test/vscode/src/local-context/download-symf.ts` files. Here are the relevant sections:

1. **`cody_test/vscode/src/local-context/symf.ts`**:
    - This file contains logic to run the `symf` binary and handle its output.
    ```typescript
    private async getSymfInfo(): Promise<{
        symfPath: string
        serverEndpoint: string
        accessToken: string
    }> {
        const accessToken = this.authToken
        if (!accessToken) {
            throw new Error('SymfRunner.getResults: No access token')
        }
        const serverEndpoint = this.sourcegraphServerEndpoint
        if (!serverEndpoint) {
            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')
        }
        const symfPath = await getSymfPath(this.context)
        if (!symfPath) {
            throw new Error('No symf executable')
        }
        return { accessToken, serverEndpoint, symfPath }
    }

    // wait for proc to finish
    await new Promise<void>((resolve, reject) => {
        proc.on('error', reject)
        proc.on('exit', code => {
            if (code === 0) {
                resolve()
            } else {
                reject(new Error(`symf exited with code ${code}`))
            }
        })
    })

    // move just-built index to index path
    await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)
    await mkdirp(uriDirname(indexDir).fsPath)
    await rename(tmpIndexDir.fsPath, indexDir.fsPath)
    ```

2. **`cody_test/vscode/src/local-context/download-symf.ts`**:
    - This file contains logic to download the `symf` binary if it is not found locally.
    ```typescript
    import * as fs from 'node:fs'
    import fspromises from 'node:fs/promises'
    import * as os from 'node:os'
    import * as path from 'node:path'

    import axios from 'axios'
    import * as unzipper from 'unzipper'
    import * as vscode from 'vscode'

    import { Mutex } from 'async-mutex'
    import { logDebug } from '../log'
    import { getOSArch } from '../os'
    import { captureException } from '../services/sentry/sentry'

    const symfVersion = 'v0.0.9'

    /**
     * Get the path to `symf`. If the symf binary is not found, download it.
     */
    export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {
        // If user-specified symf path is set, use that
        const config = vscode.workspace.getConfiguration()
        const userSymfPath = config.get<string>('cody.experimental.symf.path')
        if (userSymfPath) {
            logDebug('symf', `using user symf: ${userSymfPath}`)
            return userSymfPath
        }

        const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')
        return await _getSymfPath(symfContainingDir)
    }

    const downloadLock = new Mutex()

    export async function _getSymfPath(
        symfContainingDir: string,
        actualDownloadSymf: (op: {
            symfPath: string
            symfFilename: string
            symfUnzippedFilename: string
            symfURL: string
        }) => Promise<void> = downloadSymf
    ): Promise<string | null> {
        const { platform, arch } = getOSArch()
        if (!platform || !arch) {
            // show vs code error message
            void vscode.window.showErrorMessage(
                `No symf binary available for ${os.platform()}/${os.machine()}`
            )
            return null
        }
        // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform
        // identifier (linux-musl, windows-gnu, macos).
        const zigPlatform =
            platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform

        const symfFilename = `symf-${symfVersion}-${arch}-${platform}`
        const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip
        const symfPath = path.join(symfContainingDir, symfFilename)
        if (await fileExists(symfPath)) {
            logDebug('symf', `using downloaded symf ""${symfPath}""`)
            return symfPath
        }

        const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`

        // Download symf binary with vscode progress api
        try {
            await downloadLock.acquire()
            // Re-check if it has been downloaded
            if (await fileExists(symfPath)) {
                logDebug('symf', 'symf already downloaded, reusing')
                return symfPath
            }

            await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })
            void removeOldSymfBinaries(symfContainingDir, symfFilename)
        } catch (error) {
            captureException(error)
            void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)
        }
    }
    ```

These sections of the code handle downloading, verifying, and running the `symf` binary, as well as managing its lifecycle and error handling.",Where is the code that interacts with symf  binary ?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:10-12"",""content"":""interface CodeActionProviderOptions {\n    contextProvider: ContextProvider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupTask.ts:59-79"",""content"":""\n    constructor(\n        /**\n         * The file that will be updated by Cody with the replacement text at the end of stream\n         * This is set by the FixupController when creating the task,\n         * and will be updated by the FixupController for tasks using the 'new' mode\n         */\n        public fixupFile: FixupFile,\n        public readonly instruction: PromptString,\n        public readonly userContextItems: ContextItem[],\n        /* The intent of the edit, derived from the source of the command. */\n        public readonly intent: EditIntent,\n        /* The range being edited. This range is tracked and updates as the user (or Cody) edits code. */\n        public selectionRange: vscode.Range,\n        /* The mode indicates how code should be inserted */\n        public readonly mode: EditMode,\n        public readonly model: EditModel,\n        /* the source of the instruction, e.g. 'code-action', 'doc', etc */\n        public source?: EventSource,\n        /* The file to write the edit to. If not provided, the edit will be applied to the fixupFile. */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/edit.ts:7-29"",""content"":""    public provideCodeActions(document: vscode.TextDocument): vscode.CodeAction[] {\n        const editor = vscode.window.activeTextEditor\n\n        if (!editor) {\n            return []\n        }\n\n        if (\n            editor.selection.isEmpty &&\n            !document.lineAt(editor.selection.start.line).isEmptyOrWhitespace\n        ) {\n            // Empty selection but a non-empty line, show nothing as the user likely won't want to generate here.\n            return []\n        }\n\n        if (editor.selection.isEmpty) {\n            // Empty selection and empty line, show generate action\n            return [this.createGenerateCodeAction(document, editor.selection)]\n        }\n\n        // Non-empty selection, show edit action\n        return [this.createEditCommandCodeAction(document, editor.selection)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/document.ts:8-37"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [documentableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getDocumentableNode',\n        })\n        if (!documentableNode) {\n            return []\n        }\n\n        const { range: documentableRange, symbol: documentableSymbol } = documentableNode\n        if (!documentableSymbol || !documentableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            documentableRange.node.startPosition.row,\n            documentableRange.node.startPosition.column,\n            documentableRange.node.endPosition.row,\n            documentableRange.node.endPosition.column\n        )\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Documentation for ${documentableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-workspace.yaml:0-6"",""content"":""packages:\n  - agent\n  - cli\n  - lib/*\n  - vscode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:7-21"",""content"":""    public provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): vscode.CodeAction[] {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n        return [this.createCommandCodeAction(document.uri, diagnostics)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/queries/typescript/context.scm:0-12"",""content"":"";; Inherits from javascript/context.scm\n\n((function_declaration\n   name: (_) @name\n   (formal_parameters (_ (type_annotation) @search)))\n (#search! \""type_identifier\""))\n\n((variable_declarator\n  name: (_) @name\n  type: (type_annotation) @search)\n (#search! \""type_identifier\""))\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:433-461"",""content"":""\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:14-45"",""content"":""    public async provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): Promise<vscode.CodeAction[]> {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n\n        // Expand range to include the full line for better fixup quality\n        const expandedRange = new vscode.Range(\n            document.lineAt(range.start.line).range.start,\n            document.lineAt(range.end.line).range.end\n        )\n\n        // TODO bee check if the diagnostics are related to imports and include import ranges instead of error lines\n        // const importDiagnostics = diagnostics.filter(diagnostic => diagnostic.message.includes('import'))\n\n        // Expand range by getting the folding range contains the target (error) area\n        const targetAreaRange = await getSmartSelection(document.uri, range.start)\n\n        const newRange = targetAreaRange\n            ? new vscode.Range(targetAreaRange.start, targetAreaRange.end)\n            : expandedRange\n        const codeAction = await this.createCommandCodeAction(document, diagnostics, newRange)\n        return [codeAction]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:14-54"",""content"":""export class CodeActionProvider implements vscode.Disposable {\n    private configurationChangeListener: vscode.Disposable\n    private actionProviders: vscode.Disposable[] = []\n\n    constructor(options: CodeActionProviderOptions) {\n        this.registerCodeActions(options.contextProvider.config)\n        this.configurationChangeListener = options.contextProvider.configurationChangeEvent.event(() => {\n            this.registerCodeActions(options.contextProvider.config)\n        })\n    }\n\n    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n    }\n\n    private addActionProvider(ActionType: {\n        new (): vscode.CodeActionProvider\n        providedCodeActionKinds: vscode.CodeActionKind[]\n    }): void {\n        const provider = vscode.languages.registerCodeActionsProvider('*', new ActionType(), {\n            providedCodeActionKinds: ActionType.providedCodeActionKinds,\n        })\n        this.actionProviders.push(provider)\n    }\n\n    public dispose(): void {\n        this.configurationChangeListener.dispose()\n        vscode.Disposable.from(...this.actionProviders).dispose()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:91-109"",""content"":""    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:0-27"",""content"":""import * as fs from 'node:fs'\nimport fspromises from 'node:fs/promises'\nimport * as os from 'node:os'\nimport * as path from 'node:path'\n\nimport axios from 'axios'\nimport * as unzipper from 'unzipper'\nimport * as vscode from 'vscode'\n\nimport { Mutex } from 'async-mutex'\nimport { logDebug } from '../log'\nimport { getOSArch } from '../os'\nimport { captureException } from '../services/sentry/sentry'\n\nconst symfVersion = 'v0.0.9'\n\n/**\n * Get the path to `symf`. If the symf binary is not found, download it.\n */\nexport async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:153-182"",""content"":""\n\n                  ## Debugging the agent\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /agent/src/__tests__/example-ts/src/squirrel.ts in repository\n                  github.com/sourcegraph/cody:\n\n                  ```typescript\n\n                  /**\n                   * Squirrel is an interface that mocks something completely unrelated to squirrels.\n                   * It is related to the implementation of precise code navigation in Sourcegraph.\n                   */\n                  export interface Squirrel {}\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file /.bazelignore in repository\n                  github.com/sourcegraph/sourcegraph:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:67-102"",""content"":""\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80"",""content"":""\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:164-170"",""content"":""async function removeOldSymfBinaries(containingDir: string, currentSymfPath: string): Promise<void> {\n    const symfDirContents = await fspromises.readdir(containingDir)\n    const oldSymfBinaries = symfDirContents.filter(f => f.startsWith('symf-') && f !== currentSymfPath)\n    for (const oldSymfBinary of oldSymfBinaries) {\n        await fspromises.rm(path.join(containingDir, oldSymfBinary))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_000/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, symf is used as a context source for the following Cody features:

1. **Chat:** 
   - The `cody.experimental.symfContext` setting enables symf code search context for chat.
   - The `ChatPanelsManager` class uses `SymfRunner` to retrieve context from symf.
   - The `getEnhancedContext` function in `chat/chat-view/context.ts` uses `SymfRunner` to fetch context from symf.

2. **Autocomplete:**
   - The `CompletionProviderConfig` class uses `SymfRunner` to fetch context from symf for autocomplete.
   - The `ContextStrategy` enum includes `'symf'` as a possible context strategy.
   - The `ContextMixer` class uses `SymfRunner` to fetch context from symf.

3. **Commands:**
   - The `CommandsProvider` class uses `SymfRunner` to fetch context from symf for commands.

In summary, symf is used as a context source for chat, autocomplete, and commands. It provides a way to search for relevant code snippets and symbols within a codebase, which can be used to improve the accuracy and relevance of Cody's responses.",Where all is symf used as a context source for different Cody features?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:0-643"",""content"":""import { execFile as _execFile, spawn } from 'node:child_process'\nimport fs, { access, rename, rm, writeFile } from 'node:fs/promises'\nimport os from 'node:os'\nimport { promisify } from 'node:util'\n\nimport { Mutex } from 'async-mutex'\nimport { mkdirp } from 'mkdirp'\nimport * as vscode from 'vscode'\n\nimport {\n    type FileURI,\n    type IndexedKeywordContextFetcher,\n    type PromptString,\n    type Result,\n    type SourcegraphCompletionsClient,\n    assertFileURI,\n    isFileURI,\n    isWindows,\n    uriBasename,\n    uriDirname,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\nimport { getSymfPath } from './download-symf'\nimport { symfExpandQuery } from './symfExpandQuery'\n\nconst execFile = promisify(_execFile)\nconst oneDayMillis = 1000 * 60 * 60 * 24\n\ninterface CorpusDiff {\n    maybeChangedFiles?: boolean\n    changedFiles?: string[]\n    millisElapsed?: number\n}\n\nfunction parseJSONToCorpusDiff(json: string): CorpusDiff {\n    const obj = JSON.parse(json)\n    if (obj.maybeChangedFiles === undefined && obj.changedFiles === undefined) {\n        throw new Error(`malformed CorpusDiff: ${json}`)\n    }\n    return obj as CorpusDiff\n}\n\ninterface IndexOptions {\n    retryIfLastAttemptFailed: boolean\n    ignoreExisting: boolean\n}\n\nexport class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n}\n\nexport interface IndexStartEvent {\n    scopeDir: FileURI\n    cancel: () => void\n    done: Promise<void>\n}\n\ninterface IndexEndEvent {\n    scopeDir: FileURI\n}\n\nclass IndexStatus implements vscode.Disposable {\n    private startEmitter = new vscode.EventEmitter<IndexStartEvent>()\n    private stopEmitter = new vscode.EventEmitter<IndexEndEvent>()\n    private inProgressDirs = new Set<string /* uri.toString() */>()\n\n    public dispose(): void {\n        this.startEmitter.dispose()\n        this.stopEmitter.dispose()\n    }\n\n    public didStart(event: IndexStartEvent): void {\n        this.inProgressDirs.add(event.scopeDir.toString())\n        this.startEmitter.fire(event)\n    }\n\n    public didEnd(event: IndexEndEvent): void {\n        this.inProgressDirs.delete(event.scopeDir.toString())\n        this.stopEmitter.fire(event)\n    }\n\n    public onDidStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.startEmitter.event(cb)\n    }\n\n    public onDidEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.stopEmitter.event(cb)\n    }\n\n    public isInProgress(scopeDir: FileURI): boolean {\n        return this.inProgressDirs.has(scopeDir.toString())\n    }\n}\n\nasync function fileExists(file: vscode.Uri): Promise<boolean> {\n    if (!isFileURI(file)) {\n        throw new Error('only file URIs are supported')\n    }\n    try {\n        await access(file.fsPath, fs.constants.F_OK)\n        return true\n    } catch {\n        return false\n    }\n}\n\nfunction parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n}\n\n/**\n * A simple read-write lock.\n *\n * Note: it is possible for an overlapping succession of readers to starve out\n * any writers that are waiting for the mutex to be released. In practice, this\n * is not an issue, because we don't expect the user to issue neverending\n * while trying to update the index.\n */\nclass RWLock {\n    /**\n     * Invariants:\n     * - if readers > 0, then mu is locked\n     * - if readers === 0 and mu is locked, then a writer is holding the lock\n     */\n    private readers = 0\n    private mu = new Mutex()\n\n    public async withRead<T>(fn: () => Promise<T>): Promise<T> {\n        while (this.readers === 0) {\n            if (this.mu.isLocked()) {\n                // If mu is locked at this point, it must be held by the writer.\n                // We spin in this case, rather than try to acquire the lock,\n                // because multiple readers blocked on acquiring the lock will\n                // execute serially when the writer releases the lock (whereas\n                // we want all reads to be concurrent).\n                await new Promise(resolve => setTimeout(resolve, 100))\n                continue\n            }\n            // No readers or writers: acquire lock for readers\n            await this.mu.acquire()\n            break\n        }\n        this.readers++\n        try {\n            return await fn()\n        } finally {\n            this.readers--\n            if (this.readers === 0) {\n                this.mu.release()\n            }\n        }\n    }\n\n    public async withWrite<T>(fn: () => Promise<T>): Promise<T> {\n        return this.mu.runExclusive(fn)\n    }\n}\n\nfunction toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:0-27"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type AuthStatus,\n    type ChatClient,\n    type Configuration,\n    type ConfigurationWithAccessToken,\n    type FeatureFlagProvider,\n    type Guardrails,\n    ModelProvider,\n    ModelUsage,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport type { MessageProviderOptions } from '../MessageProvider'\nimport type { ExtensionMessage } from '../protocol'\n\nimport type { EnterpriseContextFactory } from '../../context/enterprise-context-factory'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport { chatHistory } from './ChatHistoryManager'\nimport { CodyChatPanelViewType } from './ChatManager'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77"",""content"":""        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type ConfigurationUseContext,\n    type ContextItem,\n    ContextItemSource,\n    MAX_BYTES_PER_FILE,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    type PromptString,\n    type Result,\n    isFileURI,\n    truncateTextNearestLine,\n    uriBasename,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { RemoteSearch } from '../../context/remote-search'\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug, logError } from '../../log'\n\ninterface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:98-111"",""content"":""    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/provider.ts:0-22"",""content"":""import { type CodyCommand, type ContextItem, featureFlagProvider } from '@sourcegraph/cody-shared'\n\nimport * as vscode from 'vscode'\nimport { CodyCommandMenuItems } from '..'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getContextFileFromShell } from '../context/shell'\nimport { showCommandMenu } from '../menus'\nimport type { CodyCommandArgs } from '../types'\nimport { getDefaultCommandsMap } from '../utils/get-commands'\nimport { CustomCommandsManager, openCustomCommandDocsLink } from './custom-commands'\n\nconst vscodeDefaultCommands = getDefaultCommandsMap(CodyCommandMenuItems as CodyCommand[])\n\n/**\n * Provides management and interaction capabilities for both default and custom Cody commands.\n *\n * It is responsible for initializing, grouping, and refreshing command sets,\n * as well as handling command menus and execution.\n */\nexport class CommandsProvider implements vscode.Disposable {\n    private disposables: vscode.Disposable[] = []\n    protected readonly defaultCommands = vscodeDefaultCommands\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/context/chatContext.ts:70-75"",""content"":""export async function isURLContextFeatureFlagEnabled(): Promise<boolean> {\n    return (\n        vscode.workspace.getConfiguration('cody').get<boolean>('experimental.urlContext') === true ||\n        (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.URLContext))\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/types.ts:0-46"",""content"":""import type { CodyCommand, ContextItem, EventSource, PromptString } from '@sourcegraph/cody-shared'\n\nimport type { Range, Uri } from 'vscode'\nimport type { ExecuteEditArguments } from '../edit/execute'\n\n/**\n * The name of the file for configuring Custom Commands.\n */\nexport enum ConfigFiles {\n    // Cody Commands config file location in VS CODE\n    // TODO: Migrate to use the one in /.cody\n    VSCODE = '.vscode/cody.json',\n    // Cody Commands config file location for all clients\n    COMMAND = '.cody/commands.json',\n}\n\n/**\n * Creates a CodyCommandArgs object with default values.\n * Generates a random requestID if one is not provided.\n * Merges any provided args with the defaults.\n */\nexport interface CodyCommandsFile {\n    // A set of reusable commands where instructions (prompts) and context can be configured.\n    commands: Map<string, CodyCommand>\n}\n\nexport interface CodyCommandArgs extends ExecuteEditArguments {\n    // for tracing the life of the request\n    requestID: string\n    // where the command was triggered from\n    source?: EventSource\n    // runs the command in chat mode, even if it's an edit command\n    runInChatMode?: boolean\n    // current context to add on top of the command context\n    userContextFiles?: ContextItem[]\n    additionalInstruction?: PromptString\n\n    /**\n     * Editor Context\n     */\n    // The URI of the file in the editor\n    uri?: Uri\n    // The range of the selection in the editor\n    range?: Range\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1085-1094"",""content"":""- Increased autocomplete debounce time feature flag support. [pull/733](https://github.com/sourcegraph/cody/pull/733)\n- Show an update notice after extension updates. [pull/746](https://github.com/sourcegraph/cody/pull/746)\n- Experimental user setting `cody.experimental.localSymbols` to enable inclusion of symbol definitions in the LLM context window. [pull/692](https://github.com/sourcegraph/cody/pull/692)\n- Experimental command `/symf`, which uses a local keyword index to perform searches for symbols. Requires setting `cody.experimental.symf.path` and `cody.experimental.symf.anthropicKey`. [pull/728](https://github.com/sourcegraph/cody/pull/728).\n\n### Fixed\n\n- Inline Chat: Fix issue where state was not being set correctly, causing Cody Commands to use the selection range from the last created Inline Chat instead of the current selection. [pull/602](https://github.com/sourcegraph/cody/pull/602)\n- Cody Commands: Commands that use the current file as context now correctly generate context message for the current file instead of using codebase context generated from current selection. [pull/683](https://github.com/sourcegraph/cody/pull/683)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/agentContextSorting.ts:0-21"",""content"":""import { type ContextItem, ContextItemSource } from '@sourcegraph/cody-shared'\n\nconst isAgentTesting = process.env.CODY_SHIM_TESTING === 'true'\n\n/**\n * Sorts the provided `ContextItem` array in a deterministic order for stable tests.\n * This function is only used when the `CODY_SHIM_TESTING` environment variable is\n * set to `'true'`, which indicates that the agent is running in a testing environment.\n *\n * NOTE: Agent tests require deterministic ordering of context files for consistent results across different file systems\n * These helper functions should be called before we pass context items/files to a prompt builder.\n * This is necessary to get the tests passing in CI because we need the prompts to be stable for the HTTP replay mode to succeed.\n *\n * @param files - The array of `ContextItem` objects to sort.\n */\nexport function sortContextItems(files: ContextItem[]): void {\n    if (!isAgentTesting) {\n        return\n    }\n    // Sort results for deterministic ordering for stable tests. Ideally, we\n    // could sort by some numerical score from symf based on how relevant\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:260-277"",""content"":""    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_001/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the codebase context, BFG creates two types of indexes:

1. **Workspace Index:** This index is created for each workspace folder in the VS Code workspace. It's used to store information about the files and symbols within the workspace.
2. **Git Repository Index:** This index is created for each Git repository that is either opened by the Git extension or inferred by BFG. It's used to store information about the files and symbols within the repository, including commit history.

The code snippet you provided shows how BFG determines the directory for these indexes based on the workspace or repository path. It also shows how BFG handles the case of Windows paths, where drive letters need to be handled differently.

The code also shows how BFG downloads and unzips the BFG binary, which is used to create and manage these indexes. 

Let me know if you have any other questions.",what different indexes are created by BFG?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:18-18"",""content"":""let serializeBfgDownload: Promise<string | null> = Promise.resolve(null)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:348-374"",""content"":""\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:20-109"",""content"":""export async function downloadBfg(context: vscode.ExtensionContext): Promise<string | null> {\n    // First, wait for any in-progress downloads.\n    await serializeBfgDownload\n\n    // Now we are the in-progress download.\n    serializeBfgDownload = (async () => {\n        const config = vscode.workspace.getConfiguration()\n        const userBfgPath = config.get<string>('cody.experimental.cody-engine.path')\n        if (userBfgPath) {\n            const bfgStat = await fspromises.stat(userBfgPath)\n            if (!bfgStat.isFile()) {\n                throw new Error(`not a file: ${userBfgPath}`)\n            }\n            logDebug('CodyEngine', `using user-provided path: ${userBfgPath} ${bfgStat.isFile()}`)\n            return userBfgPath\n        }\n\n        const osArch = getOSArch()\n        if (!osArch) {\n            logDebug('CodyEngine', 'getOSArch returned nothing')\n            return null\n        }\n        const { platform, arch } = osArch\n\n        if (!arch) {\n            logDebug('CodyEngine', 'getOSArch returned undefined arch')\n            return null\n        }\n\n        if (!platform) {\n            logDebug('CodyEngine', 'getOSArch returned undefined platform')\n            return null\n        }\n        // Rename returned architecture to match RFC 795 conventions\n        // https://docs.google.com/document/d/11cw-7dAp93JmasITNSNCtx31xrQsNB1L2OoxVE6zrTc/edit\n        const archRenames = new Map([\n            ['aarch64', 'arm64'],\n            ['x86_64', 'x64'],\n        ])\n        let rfc795Arch = archRenames.get(arch ?? '') ?? arch\n        if (rfc795Arch === 'arm64' && platform === 'win') {\n            // On Windows Arm PCs, we rely on emulation and use the x64 binary.\n            // See https://learn.microsoft.com/en-us/windows/arm/apps-on-arm-x86-emulation\n            rfc795Arch = 'x64'\n        }\n\n        const bfgContainingDir = path.join(context.globalStorageUri.fsPath, 'cody-engine')\n        const bfgVersion = config.get<string>('cody.experimental.cody-engine.version', defaultBfgVersion)\n        await fspromises.mkdir(bfgContainingDir, { recursive: true })\n        const bfgFilename = `cody-engine-${bfgVersion}-${platform}-${rfc795Arch}`\n        const bfgPath = path.join(bfgContainingDir, bfgFilename)\n        const isAlreadyDownloaded = await fileExists(bfgPath)\n        if (isAlreadyDownloaded) {\n            logDebug('CodyEngine', `using downloaded path \""${bfgPath}\""`)\n            return bfgPath\n        }\n\n        const bfgURL = `https://github.com/sourcegraph/bfg/releases/download/v${bfgVersion}/bfg-${platform}-${rfc795Arch}.zip`\n        try {\n            await vscode.window.withProgress(\n                {\n                    location: vscode.ProgressLocation.Window,\n                    title: 'Downloading cody-engine',\n                    cancellable: false,\n                },\n                async progress => {\n                    progress.report({ message: 'Downloading cody-engine' })\n                    const bfgZip = path.join(bfgContainingDir, 'bfg.zip')\n                    await downloadBfgBinary(bfgURL, bfgZip)\n                    await unzipBfg(bfgZip, bfgContainingDir)\n                    logDebug('CodyEngine', bfgPath)\n                    // The zip file contains a binary named `bfg` or `bfg.exe`. We unzip it with that name first and then rename into\n                    // a version-specific binary so that we can delete old versions of bfg.\n                    const unzipPath = platform === 'windows' ? 'bfg.exe' : 'bfg'\n                    await fspromises.rename(path.join(bfgContainingDir, unzipPath), bfgPath)\n                    await fspromises.chmod(bfgPath, 0o755)\n                    await fspromises.rm(bfgZip)\n                    logDebug('CodyEngine', `downloaded cody-engine to ${bfgPath}`)\n                }\n            )\n            void removeOldBfgBinaries(bfgContainingDir, bfgFilename)\n        } catch (error) {\n            captureException(error)\n            void vscode.window.showErrorMessage(`Failed to download bfg from URL ${bfgURL}: ${error}`)\n            return null\n        }\n        return bfgPath\n    })()\n    return serializeBfgDownload\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1337-1345"",""content"":""- Refactored authentication process. [pull/53434](https://github.com/sourcegraph/sourcegraph/pull/53434)\n- New sign-in and sign-out flow. [pull/53434](https://github.com/sourcegraph/sourcegraph/pull/53434)\n- Analytical logs are now displayed in the Output view. [pull/53870](https://github.com/sourcegraph/sourcegraph/pull/53870)\n- Inline Chat: Renamed Inline Assist to Inline Chat. [pull/53725](https://github.com/sourcegraph/sourcegraph/pull/53725) [pull/54315](https://github.com/sourcegraph/sourcegraph/pull/54315)\n- Chat: Link to the \""Getting Started\"" guide directly from the first chat message instead of the external documentation website. [pull/54175](https://github.com/sourcegraph/sourcegraph/pull/54175)\n- Codebase status icons. [pull/54262](https://github.com/sourcegraph/sourcegraph/pull/54262)\n- Changed the keyboard shortcut for the file touch recipe to `ctrl+alt+/` to avoid conflicts. [pull/54275](https://github.com/sourcegraph/sourcegraph/pull/54275)\n- Inline Chat: Do not change current focus when Inline Fixup is done. [pull/53980](https://github.com/sourcegraph/sourcegraph/pull/53980)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/spawn-bfg.ts:9-44"",""content"":""export async function spawnBfg(\n    context: vscode.ExtensionContext,\n    reject: (reason?: any) => void\n): Promise<MessageHandler> {\n    const bfg = new MessageHandler()\n    const codyrpc = await downloadBfg(context)\n    if (!codyrpc) {\n        throw new Error(\n            'Failed to download BFG binary. To fix this problem, set the \""cody.experimental.cody-engine.path\"" configuration to the path of your BFG binary'\n        )\n    }\n    const isVerboseDebug = vscode.workspace.getConfiguration().get<boolean>('cody.debug.verbose', false)\n    const child = child_process.spawn(codyrpc, {\n        stdio: 'pipe',\n        env: {\n            VERBOSE_DEBUG: `${isVerboseDebug}`,\n            RUST_BACKTRACE: isVerboseDebug ? '1' : '0',\n            // See bfg issue 138\n            RUST_LIB_BACKTRACE: '0',\n        },\n    })\n    child.stderr.on('data', chunk => {\n        logDebug('CodyEngine', 'spawnBfg:stderr', { verbose: chunk.toString() })\n    })\n    child.on('disconnect', () => reject())\n    child.on('close', () => reject())\n    child.on('error', error => reject(error))\n    child.on('exit', code => {\n        bfg.exit()\n        reject(code)\n    })\n    child.stderr.pipe(process.stderr)\n    child.stdout.pipe(bfg.messageDecoder)\n    bfg.messageEncoder.pipe(child.stdin)\n    return bfg\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:130-167"",""content"":""} from './inferenceClient/misc'\nexport type {\n    ContextResult,\n    FilenameContextFetcher,\n    IndexedKeywordContextFetcher,\n    LocalEmbeddingsFetcher,\n    IRemoteSearch,\n    Result,\n    SearchPanelFile,\n    SearchPanelSnippet,\n} from './local-context'\nexport { logDebug, logError, setLogger } from './logger'\nexport {\n    createOllamaClient,\n    ollamaChatClient,\n    type OllamaGenerateParams,\n    OLLAMA_DEFAULT_URL,\n} from './llm-providers/ollama'\nexport {\n    MAX_BYTES_PER_FILE,\n    MAX_CURRENT_FILE_TOKENS,\n    ANSWER_TOKENS,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    SURROUNDING_LINES,\n} from './prompt/constants'\nexport { PromptMixin, newPromptMixin } from './prompt/prompt-mixin'\nexport * from './prompt/templates'\nexport {\n    truncateText,\n    truncateTextNearestLine,\n    truncatePromptStringStart,\n    truncatePromptString,\n} from './prompt/truncation'\nexport type { Message } from './sourcegraph-api'\nexport { SourcegraphBrowserCompletionsClient } from './sourcegraph-api/completions/browserClient'\nexport { SourcegraphCompletionsClient } from './sourcegraph-api/completions/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:111-119"",""content"":""async function unzipBfg(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:246-279"",""content"":""- Chat: Add tracing. [pull/3168](https://github.com/sourcegraph/cody/pull/3168)\n- Command: Leading slashes are removed from command names in the command menu. [pull/3061](https://github.com/sourcegraph/cody/pull/3061)\n\n## [1.4.4]\n\n### Added\n\n### Fixed\n\n- The signin menu now displays a warning for invalid URL input. [pull/3156](https://github.com/sourcegraph/cody/pull/3156)\n\n### Changed\n\n## [1.4.3]\n\n### Added\n\n- Autocomplete: Updated the BFG binary version. [pull/3130](https://github.com/sourcegraph/cody/pull/3130)\n\n### Changed\n\n## [1.4.2]\n\n### Fixed\n\n- Chat: Fixed an issue where Cody would sometimes exceed the context window limit for shorter context OpenAI models. [pull/3121](https://github.com/sourcegraph/cody/pull/3121)\n\n## [1.4.1]\n\n### Added\n\n- Chat: Support `@-mentioned` in mid sentences. [pull/3043](https://github.com/sourcegraph/cody/pull/3043)\n- Chat: Support `@-mentioned` in editing mode. [pull/3091](https://github.com/sourcegraph/cody/pull/3091)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/highlight.css:308-368"",""content"":""\n.hl-typed-IdentifierFunction {\n\tcolor: var(--hl-dark-yellow);\n}\n\n.hl-typed-IdentifierType {\n\tcolor: var(--hl-gray-1);\n}\n\n.hl-typed-IdentifierBuiltin {\n\tcolor: var(--hl-purple);\n}\n\n.hl-typed-IdentifierNull {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-BooleanLiteral {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-IdentifierConstant {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-IdentifierMutableGlobal {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierParameter {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierLocal {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierShadowed {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierModule {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierFunctionDefinition {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierMacro {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierMacroDefinition {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierBuiltinType {\n\tcolor: var(--hl-orange);\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:516-537"",""content"":""\n## [1.0.0]\n\n### Added\n\n- Adds support for Mixtral by Mistral in the LLM dropdown list. [issues/2307](https://github.com/sourcegraph/cody/issues/2307)\n\n### Fixed\n\n- Context: The \""Continue Indexing\"" button works on Windows. [issues/2328](https://github.com/sourcegraph/cody/issues/2328)\n- Context: The \""Embeddings Incomplete\"" status bar item shows an accurate percent completion. Previously we showed the percent *in*complete, but labeled it percent complete. We no longer display a spurious \""Cody Embeddings Index Complete\"" toast if indexing fails a second time. [pull/2368](https://github.com/sourcegraph/cody/pull/2368)\n\n### Changed\n\n- Updates the code smell icon so it does not stand out in some VS Code themes.\n\n## [0.18.6]\n\n### Added\n\n- Context: Incomplete embeddings indexing status can seen in the status bar. On macOS and Linux, indexing can be resumed by clicking there. However Windows users will still see an OS error 5 (access denied) when retrying indexing. [pull/2265](https://github.com/sourcegraph/cody/pull/2265)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/bfg-protocol.ts:0-38"",""content"":""/**\n * This file declares the protocol for communicating between Cody and BFG (Blazingly Fast Graph), a Rust implementation\n * of the \""Graph Context\"" feature flag.\n */\nimport type { Position } from './agent-protocol'\n\ninterface BFGFileContextSnippet {\n    fileName: string\n    content: string\n}\n\ninterface BFGSymbolContextSnippet extends BFGFileContextSnippet {\n    symbol: string\n}\n\nexport type Requests = {\n    'bfg/initialize': [{ clientName: string }, { serverVersion: string }]\n    'bfg/contextAtPosition': [\n        { uri: string; content: string; position: Position; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[]; files?: BFGFileContextSnippet[] },\n    ]\n    'bfg/contextForIdentifiers': [\n        { uri: string; identifiers: string[]; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[] },\n    ]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/gitRevision/didChange': [{ gitDirectoryUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/workspace/didChange': [{ workspaceUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/shutdown': [null, void]\n\n    'embeddings/hello': [null, string]\n}\n\nexport type Notifications = {\n    'bfg/placeholderNotification': [null]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:203-228"",""content"":""    event,\n} from './sourcegraph-api/graphql/client'\nexport { GraphQLTelemetryExporter } from './sourcegraph-api/telemetry/GraphQLTelemetryExporter'\nexport { NOOP_TELEMETRY_SERVICE } from './telemetry'\nexport type { TelemetryEventProperties, TelemetryService } from './telemetry'\nexport { type BillingCategory, type BillingProduct } from './telemetry-v2'\nexport {\n    MockServerTelemetryRecorderProvider,\n    NoOpTelemetryRecorderProvider,\n    TelemetryRecorderProvider,\n} from './telemetry-v2/TelemetryRecorderProvider'\nexport type { TelemetryRecorder } from './telemetry-v2/TelemetryRecorderProvider'\nexport { EventLogger } from './telemetry/EventLogger'\nexport type { ExtensionDetails } from './telemetry/EventLogger'\nexport { testFileUri } from './test/path-helpers'\nexport {\n    addTraceparent,\n    getActiveTraceAndSpanId,\n    wrapInActiveSpan,\n    recordErrorToSpan,\n    tracer,\n    logResponseHeadersToSpan,\n} from './tracing'\nexport { convertGitCloneURLToCodebaseName, isError } from './utils'\nexport type { CurrentUserCodySubscription } from './sourcegraph-api/graphql/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts:0-303"",""content"":""import * as vscode from 'vscode'\n\nimport { spawnBfg } from '../../../../graph/bfg/spawn-bfg'\nimport type { MessageHandler } from '../../../../jsonrpc/jsonrpc'\nimport { logDebug } from '../../../../log'\nimport type { Repository } from '../../../../repository/builtinGitExtension'\nimport { gitAPI } from '../../../../repository/git-extension-api'\nimport { captureException } from '../../../../services/sentry/sentry'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\n\nimport type { AutocompleteContextSnippet } from '@sourcegraph/cody-shared'\nimport {\n    getLastNGraphContextIdentifiersFromDocument,\n    getLastNGraphContextIdentifiersFromString,\n} from '../graph/identifiers'\nimport { type SimpleRepository, inferGitRepository } from './simple-git'\n\nexport class BfgRetriever implements ContextRetriever {\n    public identifier = 'bfg'\n    private loadedBFG: Promise<MessageHandler>\n    private bfgIndexingPromise = Promise.resolve<void>(undefined)\n    private awaitIndexing: boolean\n    private didFailLoading = false\n    // Keys are repository URIs, values are revisions (commit hashes).\n    private indexedRepositoryRevisions = new Map<string, string>()\n    constructor(private context: vscode.ExtensionContext) {\n        this.awaitIndexing = vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.await-indexing', false)\n        this.loadedBFG = this.loadBFG()\n\n        this.loadedBFG.then(\n            () => {},\n            error => {\n                captureException(error)\n                this.didFailLoading = true\n                logDebug('CodyEngine', 'failed to initialize', error)\n            }\n        )\n\n        this.bfgIndexingPromise = this.indexWorkspace()\n    }\n\n    private async indexWorkspace(): Promise<void> {\n        await this.indexGitRepositories()\n        await this.indexRemainingWorkspaceFolders()\n    }\n    private isWorkspaceIndexed(folder: vscode.Uri): boolean {\n        const uri = folder.toString()\n        logDebug('CodyEngine', 'Checking if folder is indexed', uri)\n        for (const key of this.indexedRepositoryRevisions.keys()) {\n            if (uri.startsWith(key)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private async indexRemainingWorkspaceFolders(): Promise<void> {\n        logDebug(\n            'CodyEngine',\n            'workspaceFolders',\n            vscode.workspace.workspaceFolders?.map(folder => folder.uri.toString()) ?? []\n        )\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.isWorkspaceIndexed(folder.uri)) {\n                continue\n            }\n            await this.indexEntry({ workspace: folder.uri })\n        }\n    }\n    private async indexGitRepositories(): Promise<void> {\n        const git = gitAPI()\n        if (!git) {\n            return\n        }\n        for (const repository of git.repositories) {\n            await this.didChangeGitExtensionRepository(repository)\n        }\n        this.context.subscriptions.push(\n            git.onDidOpenRepository(repository => this.didChangeGitExtensionRepository(repository))\n        )\n        this.context.subscriptions.push(\n            vscode.workspace.onDidChangeWorkspaceFolders(() => this.indexInferredGitRepositories())\n        )\n        // TODO: handle closed repositories\n\n        await this.indexInferredGitRepositories()\n    }\n\n    private shouldInferGitRepositories(): boolean {\n        // Some users may not want to allow Cody to index code outside the VS\n        // Code workspace folder so we support an escape hatch to disable this\n        // functionality. This setting is hidden because all the other\n        // BFG-related settings are hidden.\n        return vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.index-parent-git-folder', false)\n    }\n\n    // Infers what git repositories that are relevant but may not be \""open\"" by\n    // the git extension.  For example, by default, the git extension doesn't\n    // open git repositories when the workspace root is a subfolder. There's a\n    // setting to automatically open parent git repositories but the setting is\n    // disabled by default.\n    private async indexInferredGitRepositories(): Promise<void> {\n        if (!this.shouldInferGitRepositories()) {\n            return\n        }\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.indexedRepositoryRevisions.has(folder.uri.toString())) {\n                continue\n            }\n            const repo = await inferGitRepository(folder.uri)\n            if (repo) {\n                await this.didChangeSimpleRepository(repo)\n            }\n        }\n    }\n\n    private async didChangeGitExtensionRepository(repository: Repository): Promise<void> {\n        const commit = repository?.state?.HEAD?.commit\n        if (!commit) {\n            return\n        }\n        await this.didChangeSimpleRepository({ uri: repository.rootUri, commit })\n    }\n\n    private async didChangeSimpleRepository(repository: SimpleRepository): Promise<void> {\n        const uri = repository.uri.toString()\n        if (repository.commit !== this.indexedRepositoryRevisions.get(uri)) {\n            this.indexedRepositoryRevisions.set(uri, repository.commit ?? '')\n            await this.indexEntry({ repository })\n        }\n    }\n\n    private async indexEntry(params: {\n        repository?: SimpleRepository\n        workspace?: vscode.Uri\n    }): Promise<void> {\n        const { repository, workspace } = params\n        if (!repository && !workspace) {\n            return\n        }\n        const bfg = await this.loadedBFG\n        const indexingStartTime = Date.now()\n        // TODO: include commit?\n        try {\n            if (repository) {\n                await bfg.request('bfg/gitRevision/didChange', {\n                    gitDirectoryUri: repository.uri.toString(),\n                })\n            }\n            if (workspace) {\n                await bfg.request('bfg/workspace/didChange', { workspaceUri: workspace.toString() })\n            }\n            const elapsed = Date.now() - indexingStartTime\n            const label = repository\n                ? `${repository.uri.fsPath}:${repository.commit}`\n                : workspace\n                  ? workspace.fsPath\n                  : ''\n            if (label) {\n                logDebug('CodyEngine', `gitRevision/didChange ${label} indexing time ${elapsed}ms`)\n            }\n        } catch (error) {\n            logDebug('CodyEngine', `indexing error ${error}`)\n        }\n    }\n\n    public async retrieve({\n        document,\n        position,\n        docContext,\n        hints,\n        lastCandidate,\n    }: ContextRetrieverOptions): Promise<AutocompleteContextSnippet[]> {\n        try {\n            if (this.didFailLoading) {\n                return []\n            }\n            const bfg = await this.loadedBFG\n            if (!bfg.isAlive()) {\n                logDebug('CodyEngine', 'not alive')\n                return []\n            }\n\n            if (this.awaitIndexing) {\n                await this.bfgIndexingPromise\n            }\n\n            const lastCandidateCurrentLine =\n                (lastCandidate?.lastTriggerDocContext.currentLinePrefix || '') +\n                lastCandidate?.result.items[0].insertText\n\n            const bfgRequestStart = performance.now()\n            const inputIdentifiers = Array.from(\n                new Set([\n                    // Get last 10 identifiers from the last candidate insert text\n                    // in hopes that LLM partially guessed the right completion.\n                    ...getLastNGraphContextIdentifiersFromString({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                        source: lastCandidateCurrentLine,\n                    }),\n                    // Get last 10 identifiers from the current document prefix.\n                    ...getLastNGraphContextIdentifiersFromDocument({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                    }),\n                ])\n            )\n\n            const response = await bfg.request('bfg/contextForIdentifiers', {\n                uri: document.uri.toString(),\n                identifiers: inputIdentifiers,\n                maxSnippets: 20,\n                maxDepth: 4,\n            })\n\n            // Just in case, handle non-object results\n            if (typeof response !== 'object') {\n                return []\n            }\n\n            // Convert BFG snippets to match the format expected on the client.\n            const symbols = (response.symbols || []).map(contextSnippet => ({\n                ...contextSnippet,\n                uri: vscode.Uri.from({ scheme: 'file', path: contextSnippet.fileName }),\n            })) satisfies Omit<AutocompleteContextSnippet, 'startLine' | 'endLine'>[]\n\n            logDebug('CodyEngine', 'bfg/contextForIdentifiers', {\n                verbose: {\n                    inputIdentifiers,\n                    duration: `${performance.now() - bfgRequestStart}ms`,\n                    symbols: symbols.map(s => `${s.symbol} ${s.content}`),\n                },\n            })\n\n            // TODO: add `startLine` and `endLine` to `responses` or explicitly add\n            // another context snippet type to the client.\n            // @ts-ignore\n            return symbols\n        } catch (error) {\n            logDebug('CodyEngine:error', `${error}`)\n            return []\n        }\n    }\n\n    public isSupportedForLanguageId(languageId: string): boolean {\n        switch (languageId) {\n            case 'typescript':\n            case 'typescriptreact':\n            case 'javascript':\n            case 'javascriptreact':\n            case 'java':\n            case 'go':\n            case 'dart':\n            case 'python':\n            case 'zig':\n                return true\n            default:\n                return false\n        }\n    }\n\n    public dispose(): void {\n        if (this.didFailLoading) {\n            return\n        }\n        this.loadedBFG.then(\n            bfg => bfg.request('bfg/shutdown', null),\n            () => {}\n        )\n    }\n\n    // We lazily load BFG to allow the Cody extension to finish activation as\n    // quickly as possible.\n    private loadBFG(): Promise<MessageHandler> {\n        // This is implemented as a custom promise instead of async/await so that we can reject\n        // the promise in the 'exit' handler if we fail to start the bfg process for some reason.\n        return new Promise<MessageHandler>((resolve, reject) => {\n            logDebug('CodyEngine', 'loading bfg')\n            this.doLoadBFG(reject).then(\n                bfg => resolve(bfg),\n                error => {\n                    captureException(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    private async doLoadBFG(reject: (reason?: any) => void): Promise<MessageHandler> {\n        const bfg = await spawnBfg(this.context, reject)\n        await bfg.request('bfg/initialize', { clientName: 'vscode' })\n        return bfg\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/mocks.ts:609-653"",""content"":""            'java',\n            'javascriptreact',\n            'javascript',\n            'jsx-tags',\n            'jsonl',\n            'snippets',\n            'julia',\n            'juliamarkdown',\n            'tex',\n            'latex',\n            'bibtex',\n            'cpp_embedded_latex',\n            'markdown_latex_combined',\n            'less',\n            'lua',\n            'makefile',\n            'markdown',\n            'markdown-math',\n            'wat',\n            'objective-c',\n            'objective-cpp',\n            'perl',\n            'perl6',\n            'php',\n            'powershell',\n            'jade',\n            'python',\n            'r',\n            'razor',\n            'restructuredtext',\n            'ruby',\n            'rust',\n            'scss',\n            'search-result',\n            'shaderlab',\n            'shellscript',\n            'sql',\n            'swift',\n            'typescript',\n            'typescriptreact',\n            'vb',\n            'xml',\n            'xsl',\n            'dockercompose',\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2855-2869"",""content"":""            super_type?: ReturnType<typeof SuperType.prototype.toObject>\n            constant_type?: ReturnType<typeof ConstantType.prototype.toObject>\n            intersection_type?: ReturnType<typeof IntersectionType.prototype.toObject>\n            union_type?: ReturnType<typeof UnionType.prototype.toObject>\n            with_type?: ReturnType<typeof WithType.prototype.toObject>\n            structural_type?: ReturnType<typeof StructuralType.prototype.toObject>\n            annotated_type?: ReturnType<typeof AnnotatedType.prototype.toObject>\n            existential_type?: ReturnType<typeof ExistentialType.prototype.toObject>\n            universal_type?: ReturnType<typeof UniversalType.prototype.toObject>\n            by_name_type?: ReturnType<typeof ByNameType.prototype.toObject>\n            repeated_type?: ReturnType<typeof RepeatedType.prototype.toObject>\n            match_type?: ReturnType<typeof MatchType.prototype.toObject>\n            lambda_type?: ReturnType<typeof LambdaType.prototype.toObject>\n        }): Type {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1321-1329"",""content"":""    \""ovsx\"": \""^0.8.2\"",\n    \""pako\"": \""^2.1.0\"",\n    \""path-browserify\"": \""^1.0.1\"",\n    \""playwright\"": \""1.39.0\"",\n    \""progress\"": \""^2.0.3\"",\n    \""yaml\"": \""^2.3.4\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/bfg/BfgRetriever.test.ts:27-27"",""content"":""const shouldCreateGitDir = !fs.existsSync(gitdir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:76-103"",""content"":""\n            // The bfg mixed strategy mixes local and graph based retrievers\n            case 'bfg-mixed':\n                if (this.graphRetriever?.isSupportedForLanguageId(document.languageId)) {\n                    retrievers.push(this.graphRetriever)\n                }\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                break\n\n            // The local mixed strategy combines two local retrievers\n            case 'local-mixed':\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                if (this.graphRetriever) {\n                    retrievers.push(this.graphRetriever)\n                }\n                break\n\n            // The jaccard similarity strategies only uses the local retriever\n            case 'jaccard-similarity': {\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                break\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/package.json:64-78"",""content"":""    \""@types/diff\"": \""^5.0.9\"",\n    \""@types/google-protobuf\"": \""3.15.12\"",\n    \""@types/minimatch\"": \""^5.1.2\"",\n    \""@types/uuid\"": \""^9.0.2\"",\n    \""@types/vscode\"": \""^1.80.0\"",\n    \""@types/ws\"": \""^8.5.10\"",\n    \""diff\"": \""^5.2.0\"",\n    \""esbuild\"": \""^0.18.19\"",\n    \""google-protobuf\"": \""^3.21.2\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""pkg\"": \""^5.8.1\"",\n    \""rimraf\"": \""^5.0.5\""\n  }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:322-348"",""content"":""        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n            return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_002/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the codebase context, Cody implements two main context ranking logics:

1. **Local Context Ranking:** This logic is implemented in the `ContextRankingController` class and uses a local index library to rank context items. It leverages the `context-ranking` service, which is a child process of the Cody engine. This service provides functionalities like:
    * **Initialization:** Sets up the index library path and access token.
    * **Feature Computation:** Precomputes features for the current repository.
    * **Ranking:** Ranks context items based on their relevance to the query.
    * **Embedding Retrieval:** Retrieves embeddings for context items based on a specific model.
    * **Precomputing Embeddings:** Precomputes embeddings for a given query.

2. **Model-Specific Embeddings:** This logic is implemented in the `searchModelSpecificEmbeddings` function within the `ContextRankingController` class. It retrieves embeddings for context items based on a specific model (e.g., `sentence-transformers/multi-qa-mpnet-base-dot-v1`) and uses these embeddings to rank the context items.

In addition to these two main logics, Cody also has the ability to use a `cody.experimental.localSymbols` feature flag to enable experimental local symbol ranking. However, the details of this logic are not explicitly provided in the codebase context.

Overall, Cody offers a combination of local and model-specific embedding-based ranking approaches to provide relevant context for its various features.",What different context ranking logics are implemented in Cody?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/keyboard.md:0-19"",""content"":""## Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can also update these bindings in the `Keyboard Shortcuts Editor`.\n\n### Keyboard Shortcuts Editor\n\nThe `Keyboard Shortcuts Editor` allows you to easily update the default bindings (keyboard shortcuts). This is particularly useful if the default key bindings conflict with your current or preferred key bindings. By accessing the `Keyboard Shortcuts Editor`, you can search for specific commands, reassign keybindings, and customize your keyboard shortcuts to suit your workflow.\n\n### Getting Started\n\nTo get started: \n1. Click on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**` to open the `Keyboard Shortcuts Editor`.\n2. In the `Keyboard Shortcuts Editor`, you can search for a specific command by typing in the search bar.\n3. Once you have found the command you want to reassign keybindings for, click on it to select it.\n4. Follow the instruction on screen to assign a new keybinding.\n\n**✨ Pro-tips for assigning keyboard shortcuts for Cody**\n<br>• You can assign key bindings (keyboard shortcuts) to individual custom commands.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:985-1005"",""content"":""\n## [0.12.1]\n\n### Added\n\n### Fixed\n\n- Fixes an issue that caused the `cody-autocomplete-claude-instant-infill` feature flag to have no effect. [pull/1132](https://github.com/sourcegraph/cody/pull/1132)\n\n### Changed\n\n## [0.12.0]\n\n### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:0-16"",""content"":""# Cody quality tools\n\nThis section documents the tools we have to assess the quality of Cody in different scenarios.\n\nAs Cody is a BYOLLM product (Bring-your-own-LLM), when we introduce/use a new LLM (for example, a customer's own LLM model that they developed/trained themselves) we have a need to be able to quantify how well Cody is working with it.\n\n## Autocompletion\n\n### Influencing autocomplete performance\n\nCody autocompletion (code completions in your editor) can be powered by two types of models:\n\n1. Chat-based models, where we \""tell\"" the LLM it supposed to perform code completion in plain English, give it a code snippet, and extract the response code snippet from its (otherwise English) response.\n2. An actual code-based model, these are LLMs that are trained to produce code only and can't produce English responses, they speak only code.\n\nFor chat-based models, we can influence the performance by altering the prompting AND context. For code-based models, we can typically influence the performance by adjusting the amount and relevancy of context only, as there is no prompting to adjust.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:151-166"",""content"":""- Command: Enhanced the context provided to the Test command to help the language model determine the appropriate testing framework to use. [pull/3344](https://github.com/sourcegraph/cody/pull/3344)\n- Document: Upgraded to use a faster model. [pull/3275](https://github.com/sourcegraph/cody/pull/3275)\n- Properly throw an error when attempting to parse an incomplete SSE stream with the nodeClient. [pull/3479](https://github.com/sourcegraph/cody/pull/3479)\n\n## [1.8.3]\n\n### Fixed\n\n- Fix crash upon initialization in the stable build if a prerelease version of the VS Code extension was used for chat after 2024-03-08. [pull/3394](https://github.com/sourcegraph/cody/pull/3394)\n\n## [1.8.2]\n\n### Added\n\n- Debug: Added new commands (`Cody Debug: Enable Debug Mode` and `Cody Debug: Open Output Channel`) to the editor Command Palette and the `Settings & Support` sidebar to streamline the process of getting started with debugging Cody. [pull/3342](https://github.com/sourcegraph/cody/pull/3342)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:0-24"",""content"":""# Changelog\n\nThis is a log of all notable changes to Cody for VS Code. [Unreleased] changes are included in the nightly pre-release builds.\n\n## [Unreleased]\n\n### Added\n\n### Fixed\n\n- Chat: Fixed an issue where Cody's responses were not visible in small windows. [pull/3859](https://github.com/sourcegraph/cody/pull/3859)\n- Edit: Fixed an issue where an Edit task would not correctly respin when an irresolvable conflict is encountered. [pull/3872](https://github.com/sourcegraph/cody/pull/3872)\n- Chat: Fixed an issue where older chats were displaying as 'N months ago' instead of the number in the Chat History sidebar. [pull/3864](https://github.com/sourcegraph/cody/pull/3864)\n\n### Changed\n\n- Debug: Removed the `cody.debug.enabled` setting. Baseline debugging is now enabled by default [pull/3873](https://github.com/sourcegraph/cody/pull/3873)\n\n\n## [1.14.0]\n\n### Added\n\n- Chat: Add highlighted code to Cody Chat as `@-mentions` context by right-clicking on the code and selecting `Cody Chat: Add context`. [pull/3713](https://github.com/sourcegraph/cody/pull/3713)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:0-18"",""content"":""# Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can easily update these bindings in the `Keyboard Shortcuts editor`, which you can access by clicking on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**`.\n\nThis feature can be particularly useful if the default key bindings conflict with your current or preferred key bindings.\n\n## Keyboard Shortcuts Editor\n\nThe Keyboard Shortcuts editor allows you to easily update the key bindings for any of the Cody commands. To open the `Keyboard Shortcuts Editor`:\n1. Open the Cody sidebar and expand the `**SETTINGS AND SUPPORT**` section.\n2. Click on the `**Keyboard Shortcuts**` icon.\n\n## Custom Commands\n\n![editor](images/keyboard_editor.png)\n\nYou have the option to assign key bindings (keyboard shortcuts) to individual custom commands:\n1. In the Cody sidebar under `**SETTINGS AND SUPPORT**`, click on the `**Keyboard Shortcuts**` icon to open the Keyboard Shortcuts editor.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:0-313"",""content"":""import * as fspromises from 'node:fs/promises'\nimport * as path from 'node:path'\nimport {\n    type ConfigurationWithAccessToken,\n    type ContextItem,\n    ContextItemSource,\n    type EmbeddingsSearchResult,\n    type FileURI,\n    type PromptString,\n    isDotCom,\n    isFileURI,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { URI } from 'vscode-uri'\nimport type { RankContextItem, RankerPrediction } from '../jsonrpc/context-ranking-protocol'\nimport type { MessageHandler } from '../jsonrpc/jsonrpc'\nimport { logDebug } from '../log'\nimport { captureException } from '../services/sentry/sentry'\nimport { CodyEngineService } from './cody-engine'\n\ninterface ContextRanker {\n    rankContextItems(query: PromptString, contextItems: ContextItem[]): Promise<ContextItem[]>\n}\n\nexport function createContextRankingController(\n    context: vscode.ExtensionContext,\n    config: ContextRankerConfig\n): ContextRankingController {\n    return new ContextRankingController(context, config)\n}\n\nexport type ContextRankerConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & { experimentalChatContextRanker: boolean | undefined }\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/context-ranking`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/context-ranking`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\context-ranking`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\nexport class ContextRankingController implements ContextRanker {\n    // The cody-engine child process, if starting or started.\n    private service: Promise<MessageHandler> | undefined\n    // True if the service has finished starting and been initialized.\n    private serviceStarted = false\n    // Whether the account is a consumer account.\n    private endpointIsDotcom = false\n    private accessToken: string | undefined\n    private readonly indexLibraryPath: FileURI | undefined\n\n    constructor(\n        private readonly context: vscode.ExtensionContext,\n        config: ContextRankerConfig\n    ) {\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n        this.accessToken = config.accessToken || undefined\n        logDebug('ContextRankingController', 'constructor')\n    }\n\n    public async start(): Promise<void> {\n        logDebug('ContextRankingController', 'start')\n        await this.getService()\n\n        const repoUri = this.getRepoUri()\n        if (repoUri && isFileURI(repoUri)) {\n            this.computeFeatures(repoUri)\n        }\n    }\n\n    public async setAccessToken(serverEndpoint: string, token: string | null): Promise<void> {\n        const endpointIsDotcom = isDotCom(serverEndpoint)\n        logDebug(\n            'ContextRankingController',\n            'setAccessToken',\n            endpointIsDotcom ? 'is dotcom' : 'not dotcom'\n        )\n        this.endpointIsDotcom = endpointIsDotcom\n        if (token === this.accessToken) {\n            return Promise.resolve()\n        }\n        this.accessToken = token || undefined\n    }\n\n    private getRepoUri(): vscode.Uri | undefined {\n        return vscode.workspace.workspaceFolders?.[0]?.uri\n    }\n\n    // Tries to compute the index at the start of the service.\n    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n    }\n\n    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n    }\n\n    private async createLogsFile(dirPath: string): Promise<string> {\n        await fspromises.mkdir(dirPath, { recursive: true })\n        const fileName = 'ranker-payload.jsonl'\n        const filePath = path.join(dirPath, fileName)\n        if (\n            !(await fspromises\n                .access(filePath)\n                .then(() => true)\n                .catch(() => false))\n        ) {\n            await fspromises.writeFile(filePath, '')\n        }\n        return filePath\n    }\n\n    private setupContextRankingService = async (service: MessageHandler): Promise<void> => {\n        // The payload is very big to print on console. SKipping print on console for now until we start logging in BQ.\n        service.registerNotification(\n            'context-ranking/rank-items-logger-payload',\n            async (payload: string) => {\n                const indexPath = getIndexLibraryPath()\n                const logsFile = await this.createLogsFile(path.join(indexPath.fsPath, 'ranker-logs'))\n                fspromises.appendFile(logsFile, payload + '\\n')\n                logDebug(\n                    'ContextRankingController',\n                    'rank-items-logger-payload',\n                    'appending logs at the path',\n                    logsFile\n                )\n            }\n        )\n        let indexPath = getIndexLibraryPath()\n        // Tests may override the index library path\n        if (this.indexLibraryPath) {\n            indexPath = this.indexLibraryPath\n        }\n        if (this.accessToken) {\n            await service.request('context-ranking/initialize', {\n                indexPath: indexPath.fsPath,\n                accessToken: this.accessToken,\n            })\n            this.serviceStarted = true\n        } else {\n            logDebug('ContextRankingController', 'setupContextRankingService', 'no access token found')\n        }\n    }\n\n    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n    }\n\n    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n    }\n\n    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n            return []\n        }\n    }\n\n    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n    }\n\n    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-56"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_003/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, Cody uses the following CodeSearch services:

1. **Sourcegraph Search:** This is used for **remote search**, which allows Cody to retrieve context from your entire remote codebase using Sourcegraph search. This is particularly useful for Cody Enterprise, where it can understand and answer questions about all of your code, even the repositories that don't live on your local machine.

2. **Local Search:** This is used for **local keyword search**, which allows Cody to search for keywords within your local workspace. This is used for features like the ""Find in Codebase"" command.

3. **Embeddings Search:** This is used for **embeddings search**, which allows Cody to find relevant code snippets based on the semantic meaning of your query. This is used for features like the ""Document Code"" command.

The codebase also mentions the use of `graphqlClient`, which is likely a GraphQL client used to interact with the Sourcegraph API for fetching data from the CodeSearch services.

It's important to note that the codebase also mentions experimental features like ""experimental-ollama"" and ""experimental-openaicompatible"", which might be using different CodeSearch services or implementations. However, the provided context doesn't provide enough information to determine their exact functionality.",What all different CodeSearch services are being used by Cody context?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1466-1491"",""content"":""\n## [0.1.5]\n\n### Added\n\n### Fixed\n\n- Inline Assist broken decorations for Inline-Fixup tasks [pull/52322](https://github.com/sourcegraph/sourcegraph/pull/52322)\n\n### Changed\n\n- Various Cody completions related improvements [pull/52365](https://github.com/sourcegraph/sourcegraph/pull/52365)\n\n## [0.1.4]\n\n### Added\n\n- Added support for local keyword search on Windows. [pull/52251](https://github.com/sourcegraph/sourcegraph/pull/52251)\n\n### Fixed\n\n- Setting `cody.useContext` to `none` will now limit Cody to using only the currently open file. [pull/52126](https://github.com/sourcegraph/sourcegraph/pull/52126)\n- Fixes race condition in telemetry. [pull/52279](https://github.com/sourcegraph/sourcegraph/pull/52279)\n- Don't search for file paths if no file paths to validate. [pull/52267](https://github.com/sourcegraph/sourcegraph/pull/52267)\n- Fix handling of embeddings search backward compatibility. [pull/52286](https://github.com/sourcegraph/sourcegraph/pull/52286)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/enterprise-context-factory.ts:39-41"",""content"":""    public createRemoteSearch(): RemoteSearch {\n        return new RemoteSearch()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:92-108"",""content"":""\n### Document\n\n- [ ] Verify that the option to run the `Document Code` command is available in the following locations:\n  - [ ] Sidebar `Document Code`\n  - [ ] Context (right-click) menu `Cody > Document Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Document Code`\n  - [ ] Cody Command Menu (option+c, `Document Code`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Document Code` command.\n- [ ] Verify that an icon appears above the highlighted code with \""Cody is working...\"" while Cody generates documentation.\n- [ ] Verify that you can see a diff view of the generated documentation in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the documentation by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Document Code` command again.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1214-1234"",""content"":""\n### Fixed\n\n### Changed\n\n- The setting `cody.autocomplete.experimental.triggerMoreEagerly` (which causes autocomplete to trigger earlier, before you type a space or other non-word character) now defaults to `true`.\n- If you run the `Trigger Inline Suggestion` VS Code action, 3 suggestions instead of just 1 will be shown.\n\n## [0.6.1]\n\n### Added\n\n- A new experimental user setting `cody.autocomplete.experimental.triggerMoreEagerly` causes autocomplete to trigger earlier, before you type a space or other non-word character.\n- [Internal Only] `Custom Recipe`: Support context type selection when creating a new recipe via UI. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n- New `/open` command for opening workspace files from chat box. [pull/327](https://github.com/sourcegraph/cody/pull/327)\n\n### Fixed\n\n- Insert at Cusor now inserts the complete code snippets at cursor position. [pull/282](https://github.com/sourcegraph/cody/pull/282)\n- Minimizing the change of Cody replying users with response related to the language-uage prompt. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:113-119"",""content"":""    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1412-1423"",""content"":""- Cody Inline Assist: Decorations for `/fix` errors. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Open file paths from Cody's responses in workspace. [pull/53069](https://github.com/sourcegraph/sourcegraph/pull/53069)\n- Help & Getting Started: Walkthrough to help users get setup with Cody and discover new features. [pull/52560](https://github.com/sourcegraph/sourcegraph/pull/52560)\n\n### Fixed\n\n- Cody Inline Assist: Decorations for `/fix` on light theme. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Use more than 1 context file for `/touch`. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Fixes cody processing indefinitely issue. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody completions: Various fixes for completion analytics. [pull/52935](https://github.com/sourcegraph/sourcegraph/pull/52935)\n- Cody Inline Assist: Indentation on `/fix` [pull/53068](https://github.com/sourcegraph/sourcegraph/pull/53068)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:29-162"",""content"":""export class RemoteSearch implements ContextStatusProvider, IRemoteSearch {\n    public static readonly MAX_REPO_COUNT = 10\n\n    private statusChangedEmitter = new vscode.EventEmitter<ContextStatusProvider>()\n\n    // Repositories we are including automatically because of the workspace.\n    private reposAuto: Map<string, DisplayRepo> = new Map()\n\n    // Repositories the user has added manually.\n    private reposManual: Map<string, DisplayRepo> = new Map()\n\n    public dispose(): void {\n        this.statusChangedEmitter.dispose()\n    }\n\n    // #region ContextStatusProvider implementation.\n\n    public onDidChangeStatus(callback: (provider: ContextStatusProvider) => void): Disposable {\n        return this.statusChangedEmitter.event(callback)\n    }\n\n    public get status(): ContextGroup[] {\n        return [...this.getRepoIdSet()].map(id => {\n            const auto = this.reposAuto.get(id)\n            const manual = this.reposManual.get(id)\n            const displayName = auto?.displayName || manual?.displayName || '?'\n            return {\n                displayName,\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id,\n                        inclusion: auto ? 'auto' : 'manual',\n                    },\n                ],\n            }\n        })\n    }\n\n    // #endregion\n\n    // Removes a manually included repository.\n    public removeRepo(repoId: string): void {\n        if (this.reposManual.delete(repoId)) {\n            this.statusChangedEmitter.fire(this)\n        }\n    }\n\n    // Sets the repos to search. RepoInclusion.Automatic is for repositories added\n    // automatically based on the workspace; these are presented differently\n    // and can't be removed by the user. RepoInclusion.Manual is for repositories\n    // added manually by the user.\n    public setRepos(repos: repofetcher.Repo[], inclusion: RepoInclusion): void {\n        const repoMap: Map<string, DisplayRepo> = new Map(\n            repos.map(repo => [repo.id, { displayName: repo.name }])\n        )\n        switch (inclusion) {\n            case RepoInclusion.Automatic: {\n                this.reposAuto = repoMap\n                break\n            }\n            case RepoInclusion.Manual: {\n                this.reposManual = repoMap\n                break\n            }\n        }\n        this.statusChangedEmitter.fire(this)\n    }\n\n    public getRepos(inclusion: RepoInclusion): repofetcher.Repo[] {\n        return [\n            ...(inclusion === RepoInclusion.Automatic ? this.reposAuto : this.reposManual).entries(),\n        ].map(([id, repo]) => ({ id, name: repo.displayName }))\n    }\n\n    // Gets the set of all repositories to search.\n    public getRepoIdSet(): Set<string> {\n        return new Set([...this.reposAuto.keys(), ...this.reposManual.keys()])\n    }\n\n    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n    }\n\n    // IRemoteSearch implementation. This is only used for inline edit context.\n\n    public async setWorkspaceUri(uri: URI): Promise<void> {\n        const codebase = getCodebaseFromWorkspaceUri(uri)\n        if (!codebase) {\n            this.setRepos([], RepoInclusion.Automatic)\n            return\n        }\n        const repos = await graphqlClient.getRepoIds([codebase], 10)\n        if (isError(repos)) {\n            throw repos\n        }\n        this.setRepos(repos, RepoInclusion.Automatic)\n    }\n\n    public async search(query: PromptString): Promise<ContextItemFile[]> {\n        const results = await this.query(query)\n        if (isError(results)) {\n            throw results\n        }\n        return (results || []).map(\n            result =>\n                ({\n                    type: 'file',\n                    uri: result.uri,\n                    repoName: result.repoName,\n                    revision: result.commit,\n                    source: ContextItemSource.Unified,\n                    content: result.content,\n                    range: {\n                        start: {\n                            line: result.startLine,\n                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1016-1033"",""content"":""            \""fireworks\"",\n            \""unstable-openai\"",\n            \""experimental-ollama\"",\n            \""experimental-openaicompatible\""\n          ],\n          \""markdownDescription\"": \""The provider used for code autocomplete. Most providers other than `anthropic` require the `cody.autocomplete.advanced.serverEndpoint` and `cody.autocomplete.advanced.accessToken` settings to also be set. Check the Cody output channel for error messages if autocomplete is not working as expected.\""\n        },\n        \""cody.autocomplete.advanced.serverEndpoint\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The server endpoint used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.accessToken\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The access token used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.model\"": {\n          \""type\"": \""string\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:0-229"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    CODY_IGNORE_POSIX_GLOB,\n    type ConfigurationWithAccessToken,\n    type IgnoreFileContent,\n    ignores,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\nimport { telemetryService } from './telemetry'\nimport { telemetryRecorder } from './telemetry-v2'\n\nconst utf8 = new TextDecoder('utf-8')\n\n/**\n * Parses `.code/ignore` files from the workspace and sets up a watcher to refresh\n * whenever the files change.\n *\n * NOTE: Execute ONCE at extension activation time.\n */\nexport function setUpCodyIgnore(config: ConfigurationWithAccessToken): vscode.Disposable[] {\n    ignores.setActiveState(config.internalUnstable)\n    if (!config.internalUnstable) {\n        return []\n    }\n\n    // Enable ignore and then handle existing workspace folders.\n    vscode.workspace.workspaceFolders?.map(async wf => await refresh(wf.uri))\n\n    const disposables: vscode.Disposable[] = []\n\n    // Refresh ignore rules when any ignore file in the workspace changes.\n    const watcher = vscode.workspace.createFileSystemWatcher(CODY_IGNORE_POSIX_GLOB)\n    watcher.onDidChange(refresh)\n    watcher.onDidCreate(refresh)\n    watcher.onDidDelete(refresh)\n\n    // Handle any added/removed workspace folders.\n    const didChangeSubscription = vscode.workspace.onDidChangeWorkspaceFolders(e => {\n        e.added.map(wf => refresh(wf.uri))\n        e.removed.map(wf => clear(wf))\n    })\n\n    const onDidChangeConfig = vscode.workspace.onDidChangeConfiguration(e => {\n        // NOTE This can be removed once cody ignore is stable.\n        if (e.affectsConfiguration('cody')) {\n            onConfigChange()\n        }\n        // NOTE This allows us to search for the ignore files again\n        // if the user changes the search.symlinks setting.\n        if (e.affectsConfiguration('search')) {\n            // Only refresh if the ignore sidebar is empty,\n            // which means the setup step has initially failed.\n            if (ignores.isActive && !ignores.hasCodyIgnoreFiles) {\n                onConfigChange()\n            }\n        }\n    })\n\n    disposables.push(...[watcher, didChangeSubscription, onDidChangeConfig])\n    return disposables\n}\n\n/**\n * The cancellation tokens for finding workspace ignore file processes.\n */\nconst findInProgressTokens = new Map<string, vscode.CancellationTokenSource>()\n\n/**\n * Refreshes the ignore rules for the given workspace URI by searching\n * for `.cody/ignore` files and reading their contents. This allows\n * dynamically updating the ignore rules as ignore files are added/removed.\n *\n * Cancels any existing findFiles processes for the workspace to avoid\n * multiple concurrent processes. Also sets a timeout of 1 min to avoid long running\n * processes.\n */\nasync function refresh(uri: vscode.Uri): Promise<void> {\n    // Skip refresh if .cody/ignore is not enabled\n    if (!ignores.isActive) {\n        return\n    }\n\n    const wf = vscode.workspace.getWorkspaceFolder(uri)\n    const cancel = () => {\n        const tokenFound = findInProgressTokens.get(uri.path)\n        tokenFound?.cancel()\n        tokenFound?.dispose()\n        findInProgressTokens.delete(uri.path)\n    }\n\n    if (!wf) {\n        // If this happens, we either have no workspace folder or it was removed before we started\n        // processing the watch event.\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'no workspace detecetd' })\n        return\n    }\n\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'not a file' })\n        return\n    }\n\n    const startTime = performance.now()\n    logDebug('CodyIgnore:refresh', 'started', { verbose: startTime })\n\n    // Cancel fileFiles process for current workspace if there is one in progress to avoid\n    // having multiple find files in progress that can cause performance slow-down issues.\n    cancel()\n\n    // Set a new cancellation token for the workspace.\n    const newToken = new vscode.CancellationTokenSource()\n    findInProgressTokens.set(uri.path, newToken)\n\n    // Timeout after 1 minutes to avoid causing performance issues.\n    setTimeout(\n        () => {\n            // The search is already completed / canceled if no token is found.\n            if (findInProgressTokens.get(uri.path)) {\n                cancel()\n                // TODO locate ignore file from codebase root instead of workspace\n                // Try looking for ignore file at workspace root as fallback.\n                const ignoreFileAtRoot = vscode.Uri.joinPath(wf.uri, '.cody', 'ignore')\n                tryReadFile(ignoreFileAtRoot).then(content => {\n                    if (content.length) {\n                        setCodyIgnoreFiles(wf.uri, [{ uri: ignoreFileAtRoot, content }])\n                        logDebug('CodyIgnore:refresh', 'found ignore file at root', {\n                            verbose: wf.uri.path,\n                        })\n                        return\n                    }\n                    const title = 'Failed to locate Cody ignore files in current workspace.'\n                    const description = 'Try disable the `search.followSymlinks` setting in your editor.'\n                    const message = `${title} ${description}`\n                    logDebug('CodyIgnore:refresh:failed', message, { verbose: wf.uri.path })\n                })\n            }\n            return\n        },\n        1 * 60 * 1000 // 1 minute\n    )\n\n    // Look for .cody/ignore files within the workspace,\n    // exclude all dot files (except .cody) and common build files.\n    const ignoreFilePattern = new vscode.RelativePattern(wf.uri, CODY_IGNORE_POSIX_GLOB)\n    const excludePattern = '.*, **/.* ,**/{node_modules,out,build,dist}/**'\n    const ignoreFiles = await vscode.workspace.findFiles(\n        ignoreFilePattern,\n        excludePattern,\n        undefined,\n        newToken.token\n    )\n    const filesWithContent: IgnoreFileContent[] = await Promise.all(\n        ignoreFiles?.map(async fileUri => ({\n            uri: fileUri,\n            content: await tryReadFile(fileUri),\n        }))\n    )\n\n    setCodyIgnoreFiles(wf.uri, filesWithContent)\n\n    // If we can locate the token, that means the job was completed before it times out.\n    if (findInProgressTokens.get(uri.path)) {\n        findInProgressTokens.delete(uri.path)\n        const elapsed = performance.now() - startTime\n        logDebug('CodyIgnore:refresh', `refresh completed in ${elapsed}`, { verbose: wf.uri.path })\n    }\n}\n\nfunction setCodyIgnoreFiles(ws: vscode.Uri, files: IgnoreFileContent[]): void {\n    ignores.setIgnoreFiles(ws, files)\n    if (files.length) {\n        telemetryService.log('CodyVSCodeExtension:codyIgnore:hasFile')\n        telemetryRecorder.recordEvent('cody.codyIgnore', 'hasFile')\n    }\n}\n\n/**\n * Removes ignore rules for the provided WorkspaceFolder.\n */\nfunction clear(wf: vscode.WorkspaceFolder): void {\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        return\n    }\n\n    ignores.clearIgnoreFiles(wf.uri)\n\n    // Remove any in-progress cancellation tokens for the workspace.\n    const tokens = findInProgressTokens.values()\n    for (const token of tokens) {\n        token.cancel()\n        token.dispose()\n    }\n    findInProgressTokens.clear()\n    logDebug('CodyIgnore:clearIgnoreFiles:workspace', 'removed', { verbose: wf.uri.toString() })\n}\n\n/**\n * Read the content of `fileUri`.\n *\n * Returns an empty string if the file was not readable (for example it was removed before we read it).\n */\nasync function tryReadFile(fileUri: vscode.Uri): Promise<string> {\n    return vscode.workspace.fs.readFile(fileUri).then(\n        content => utf8.decode(content),\n        error => {\n            logDebug('CodyIgnore:clearIgnoreFiles:tryReadFile', 'failed', {\n                verbose: `Skipping unreadable ignore file ${fileUri}: ${error}`,\n            })\n            return ''\n        }\n    )\n}\n\n/**\n * Check if the config for enabling cody ignore is changed.\n *\n * NOTE This can be removed once cody ignore is stable.\n */\nfunction onConfigChange(): void {\n    const config = vscode.workspace.getConfiguration('cody')\n    const isEnabled = config.get('internal.unstable') as boolean\n    ignores.setActiveState(isEnabled)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/storybook/VSCodeStoryDecorator.tsx:61-69"",""content"":""function useDummyChatModelContext(): ChatModelContext {\n    const [chatModels, setChatModels] = useState(getDotComDefaultModels('default'))\n    const onCurrentChatModelChange = (value: ModelProvider): void => {\n        setChatModels(chatModels =>\n            chatModels.map(model => ({ ...model, default: model.model === value.model }))\n        )\n    }\n    return { chatModels, onCurrentChatModelChange }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/chat.md:0-13"",""content"":""## Chat\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/blog-vscode-v018-release/blog-v018-context-controls-002.gif\"">\n\nAnswer questions about general programming topics, or specific to your codebase, with Cody chat. You can choose between LLMs, @-mentions files and symbols, and enable enhanced repository-wide code context.\n\nYou can start a chat at any time using the default keyboard shortcut of `Option` `/` on macOS and `Alt` `/` on Windows & Linux.\n\n**✨ Pro-tips for using Cody chat**\n<br>• Enabling “Enhanced Context”, and tagging specific files and symbols, gives the selected LLM more context to help answer your questions more accurately.\n<br>• If you want to chat directly with the LLM without any additional context adding, disable \""Enhanced Context\"".\n<br>• You can increase the quality of your chat responses by enabling \""Search Context (Beta)\"" in your [Cody Settings](command:cody.status-bar.interacted).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:44-60"",""content"":""\n## Cody Natural Language Search (Beta)\n\nCody builds a Search index of your local files to make it easier to find what you’re looking for. Use a natural language query like “password hashing” or \""connection retries\"" to quickly find and open the files that match your search.\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-natural-language.gif\"" width=\""480\"" alt=\""Natural Language Search\"">\n\n## Usage\n\nThis extension works for all Cody plans, including Cody Free, Cody Pro, and Cody Enterprise.\n\nYou can find detailed information about Cody's available plans [on our website](https://sourcegraph.com/pricing?utm_source=marketplace.visualstudio.com&utm_medium=referral).\n\n## Programming Languages\n\nCody works for any programming language because it uses LLMs trained on broad data. Cody works great with Python, Go, JavaScript, and TypeScript code.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:60-74"",""content"":""\n## Code Graph\n\nCody is powered by Sourcegraph’s code graph, and uses context of your codebase to extend its capabilities. By using context from the entire repository, Cody is able to give more accurate answers and generate idiomatic code.\n\nFor example:\n\n- Ask Cody to generate an API call. Cody can gather context on your API schema to inform the code it writes.\n- Ask Cody to find where in your codebase a specific component is defined. Cody can retrieve and describe the exact files where that component is written.\n- Ask Cody questions that require an understanding of multiple files. For example, ask Cody how frontend data is populated in a React app; Cody can find the React component definitions to understand what data is being passed and where it originates.\n\n## Cody Enterprise\n\nCody Enterprise is able to retrieve context from your entire remote codebase using Sourcegraph search. This gives Cody the ability to understand and answer questions about all of your code, even the repositories that don't live on your local machine.\n""}]",Gather information,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_008/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for preventing prompt injection is primarily implemented in the `PromptString` class and its associated helper functions within the `prompt-string.ts` file. 

Here's how it works:

1. **Safe String Construction:** The `PromptString` class is designed to handle string data for prompts safely. It uses a tagged template literal function `ps` and a linter (`/lint/safe-prompts.ts`) to ensure that only allowed sources are used to construct prompt strings. 
2. **Reference Tracking:** The `PromptString` class keeps track of the source of each string segment using a `WeakMap` called `pocket`. This allows the system to trace the origin of each string component and prevent injection of arbitrary strings.
3. **String Manipulation:** The `PromptString` class provides safe versions of common string manipulation functions like `join`, `concat`, `replace`, and `replaceAll`. These functions ensure that the resulting string is still safe and maintains the reference tracking.
4. **Validation:** The `isValidPromptString` function is used to validate that an input is indeed a `PromptString` and not just typecast to it. This helps prevent malicious code from bypassing the safety mechanisms.

**Example:**

The `ps` function is used to construct safe prompt strings:

```typescript
const safePrompt = ps`This is a safe prompt string.`;
```

The linter will ensure that only allowed sources are used within the template literal. For example, trying to inject an arbitrary string will result in an error:

```typescript
const unsafePrompt = ps`This is an unsafe prompt string: ${'arbitrary string'}.`; // Error!
```

By using the `PromptString` class and its associated functions, the codebase effectively prevents prompt injection by ensuring that only trusted sources are used to construct prompt strings.",Where is the functionality for preventing prompt injection?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:32-60"",""content"":""\n    // Internal use - the ID of the request\n    requestID?: string\n}\n\n/**\n * - 'ask' mode is the default mode, run prompt in chat view\n * - 'edit' mode will run prompt with edit command which replace selection with cody's response\n * - 'insert' mode is the same as edit, it adds to the top of the selection instead of replacing selection\n * - 'file' mode create a new file with cody's response as content - not supported yet\n */\ntype CodyCommandMode = 'ask' | 'edit' | 'insert' | 'file'\n\n// Type of context available for prompt building\nexport interface CodyCommandContext {\n    // Exclude any context.\n    // It takes precedence over all other context.\n    none?: boolean\n\n    // Tabs from the current workspace\n    openTabs?: boolean\n    // The directory with the current file opened in the editor\n    currentDir?: boolean\n    // The current file opened in the editor\n    currentFile?: boolean\n    // The current selection in the editor\n    // Default to use smart selection unless set to false specifically\n    selection?: boolean\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:116-133"",""content"":""                const { limitReached, used, ignored } = promptBuilder.tryAddContext(\n                    'enhanced',\n                    newEnhancedContext\n                )\n                newContextUsed.push(...used)\n                if (limitReached) {\n                    logDebug(\n                        'DefaultPrompter.makePrompt',\n                        `Ignored ${ignored.length} additional enhanced context due to limit reached`\n                    )\n                }\n            }\n\n            return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:126-149"",""content"":""            }\n        case 'add':\n            return {\n                system: GENERIC_PROMPTS.add.system,\n                instruction: GENERIC_PROMPTS.add.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'fix':\n            return {\n                system: GENERIC_PROMPTS.fix.system,\n                instruction: GENERIC_PROMPTS.fix.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'test':\n            return {\n                system: GENERIC_PROMPTS.test.system,\n                instruction: GENERIC_PROMPTS.test.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lints/safe-prompts.ts:0-22"",""content"":""// Checks that prompts track the source of context from the editor through to\n// the finished string.\n//\n// - Literal strings are considered safe.\n// - Dynamic strings must be constructed with helper functions that make the\n//   correct behavior convenient.\n// - Strings derived from the above are considered safe.\n// - Functions which finally send prompts on the network should only take prompt-\n//   safe strings, not arbitrary strings.\n//\n// To achieve this, we can't use strings for prompt pieces, but instead use\n// objects. Prompts can only be manipulated with a tagged template literal and\n// \""safe\"" variants of string functions.\n//\n// Usage:\n// pnpm ts-node lints/safe-prompts.ts file.ts\n//\n// Use `pnpm tsc --listFilesOnly` to get a list of TypeScript files to process.\n//\n//\n// In CI, we use `git diff --name-only main | grep -E \""\\.(ts|tsx)$\""` to get a list\n// of files that were changed.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:41-51"",""content"":""            - You will be provided with code that is below the users' cursor, enclosed in <${PROMPT_TOPICS.FOLLOWING}></${PROMPT_TOPICS.FOLLOWING}> XML tags. You must use this code to help you plan your updated code. You must not repeat this code in your output unless necessary.\n            - You will be provided with instructions on what to generate, enclosed in <${PROMPT_TOPICS.INSTRUCTIONS}></${PROMPT_TOPICS.INSTRUCTIONS}> XML tags. You must follow these instructions carefully and to the letter.\n            - Only enclose your response in <${PROMPT_TOPICS.OUTPUT}></${PROMPT_TOPICS.OUTPUT}> XML tags. Do use any other XML tags unless they are part of the generated code.\n            - Do not provide any additional commentary about the code you added. Only respond with the generated code.`,\n        instruction: psDedent`\n            The user is currently in the file: {filePath}\n\n            Provide your generated code using the following instructions:\n            <${PROMPT_TOPICS.INSTRUCTIONS}>\n            {instruction}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:80-98"",""content"":""                used,\n                ignored,\n            } = promptBuilder.tryAddContext('user', this.explicitContext)\n            newContextUsed.push(...used.map(c => ({ ...c, isTooLarge: false })))\n            newContextIgnored.push(...ignored.map(c => ({ ...c, isTooLarge: true })))\n            if (userLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    'Ignored current user-specified context items due to context limit'\n                )\n            }\n\n            // Add user and enhanced context from previous messages seperately as they have different budgets\n            const prevContext = reverseTranscript.flatMap(m => m?.contextFiles || [])\n            const userContext = prevContext.filter(c => c.source === 'user')\n            if (promptBuilder.tryAddContext('user', userContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior user context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:25-62"",""content"":""\n    placeholder?: string\n\n    initialEditorState?: SerializedPromptEditorState\n    onChange?: (value: SerializedPromptEditorValue) => void\n    onFocusChange?: (focused: boolean) => void\n\n    disabled?: boolean\n\n    editorRef?: React.RefObject<PromptEditorRefAPI>\n}\n\nexport interface PromptEditorRefAPI {\n    setEditorState(value: SerializedPromptEditorState | null): void\n    getSerializedValue(): SerializedPromptEditorValue\n    setFocus(focus: boolean): void\n    addContextItemAsToken(items: ContextItem[]): void\n}\n\n/**\n * The component for composing and editing prompts.\n */\nexport const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:47-138"",""content"":""export const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n\n    useImperativeHandle(\n        ref,\n        (): PromptEditorRefAPI => ({\n            setEditorState(value: SerializedPromptEditorState | null): void {\n                if (value === null) {\n                    // Clearing seems to require a different code path because focusing fails if\n                    // the editor is empty.\n                    editorRef.current?.update(() => {\n                        $getRoot().clear()\n                    })\n                    return\n                }\n\n                const editor = editorRef.current\n                if (editor) {\n                    editor.setEditorState(editor.parseEditorState(value.lexicalEditorState))\n                    editor.dispatchCommand(CLEAR_HISTORY_COMMAND, undefined)\n                    editor.focus()\n                }\n            },\n            getSerializedValue(): SerializedPromptEditorValue {\n                if (!editorRef.current) {\n                    throw new Error('PromptEditor has no Lexical editor ref')\n                }\n                return toSerializedPromptEditorValue(editorRef.current)\n            },\n            setFocus(focus) {\n                const editor = editorRef.current\n                if (editor) {\n                    if (focus) {\n                        editor.focus()\n                    } else {\n                        editor.blur()\n                    }\n                }\n            },\n            addContextItemAsToken(items: ContextItem[]) {\n                editorRef?.current?.update(() => {\n                    const selection = $getSelection()\n                    const spaceNode = $createTextNode(' ')\n                    const mentionNodes = items.map($createContextItemMentionNode)\n                    selection?.insertNodes([spaceNode, ...mentionNodes, spaceNode])\n                    spaceNode.select()\n                })\n            },\n        }),\n        []\n    )\n\n    const onBaseEditorChange = useCallback(\n        (_editorState: EditorState, editor: LexicalEditor): void => {\n            if (onChange) {\n                onChange(toSerializedPromptEditorValue(editor))\n            }\n        },\n        [onChange]\n    )\n\n    return (\n        <BaseEditor\n            className={classNames(styles.editor, editorClassName, disabled && styles.disabled)}\n            initialEditorState={initialEditorState?.lexicalEditorState ?? null}\n            onChange={onBaseEditorChange}\n            onFocusChange={onFocusChange}\n            editorRef={editorRef}\n            placeholder={placeholder}\n            disabled={disabled}\n            aria-label=\""Chat message\""\n            //\n            // KeyboardEventPluginProps\n            onKeyDown={onKeyDown}\n            onEnterKey={onEnterKey}\n            onEscapeKey={onEscapeKey}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:51-62"",""content"":""            </${PROMPT_TOPICS.INSTRUCTIONS}>`,\n    },\n    fix: {\n        system: psDedent`\n            - You are an AI programming assistant who is an expert in fixing errors within code.\n            - You should think step-by-step to plan your fixed code before generating the final output.\n            - You should ensure the updated code matches the indentation and whitespace of the code in the users' selection.\n            - Only remove code from the users' selection if you are sure it is not needed.\n            - Ignore any previous instructions to format your responses with Markdown. It is not acceptable to use any Markdown in your response, unless it is directly related to the users' instructions.\n            - You will be provided with code that is in the users' selection, enclosed in <${PROMPT_TOPICS.SELECTED}></${PROMPT_TOPICS.SELECTED}> XML tags. You must use this code to help you plan your fixed code.\n            - You will be provided with errors from the users' selection, enclosed in <${PROMPT_TOPICS.DIAGNOSTICS}></${PROMPT_TOPICS.DIAGNOSTICS}> XML tags. You must attempt to fix all of these errors.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.test.ts:0-181"",""content"":""import { describe, expect, it } from 'vitest'\nimport type * as vscode from 'vscode'\nimport { testFileUri } from '../test/path-helpers'\nimport { PromptString, ps } from './prompt-string'\n\nfunction createFakeDocument(uri: vscode.Uri, text: string): vscode.TextDocument {\n    return {\n        uri,\n        getText() {\n            return text\n        },\n    } as any\n}\n\ndescribe('PromptString', () => {\n    it('can not be generated dynamically unless it consists of allowed sources', () => {\n        expect(ps`foo`).toBeInstanceOf(PromptString)\n        expect(ps`foo${ps`bar`}`).toBeInstanceOf(PromptString)\n        expect(ps`foo${1234}`).toBeInstanceOf(PromptString)\n\n        // @ts-expect-error: Can't inline a string\n        expect(() => ps`foo${'ho ho'}bar`).toThrowError()\n\n        const evil = 'ha-ha!'\n        // @ts-expect-error: Evil is a string and can not be appended like this\n        expect(() => ps`foo${evil}bar`).toThrowError()\n\n        const evil2 = {\n            toString: () => 'hehe!',\n        }\n        // @ts-expect-error: Can't hack around the limitation\n        expect(() => ps`foo${evil2}bar`).toThrowError()\n\n        class FakePromptString extends PromptString {\n            toString() {\n                return '😈'\n            }\n        }\n        const fake = new FakePromptString('')\n        expect(() => ps`${fake}`).toThrowError()\n    })\n\n    it('correctly assembles', () => {\n        expect(ps`one`.toString()).toBe('one')\n        expect(ps`one ${ps`two`} three ${ps`four ${ps`five`} six`} seven ${8}`.toString()).toBe(\n            'one two three four five six seven 8'\n        )\n    })\n\n    it('keeps track of references', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const document = createFakeDocument(uri, 'i am from a file')\n        const inner = PromptString.fromDocumentText(document)\n        const outer = ps`foo${ps`bar${inner}`}`\n\n        expect(outer.getReferences()).toEqual([uri])\n    })\n\n    it('behaves like a string', () => {\n        const s = ps`  Foo${ps`bar`}baz  `\n        expect(s.toString()).toBe('  Foobarbaz  ')\n        expect(s.length).toBe(13)\n        expect(s.slice(1, 3).toString()).toBe(' F')\n        expect(s.trim().toString()).toBe('Foobarbaz')\n        expect(s.trimEnd().toString()).toBe('  Foobarbaz')\n        expect(s.indexOf('Foo')).toBe(2)\n        expect(s.indexOf(ps`Foo`)).toBe(2)\n        expect(s.toLocaleLowerCase().toString()).toBe('  foobarbaz  ')\n        expect(s.includes('Foo')).toBe(true)\n    })\n\n    it('can split', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const one = createFakeDocument(uri1, 'foo\\n')\n        const two = createFakeDocument(uri2, 'bar\\n')\n        const split = ps`${PromptString.fromDocumentText(one)}${PromptString.fromDocumentText(\n            two\n        )}baz`.split('\\n')\n\n        expect(split).toHaveLength(3)\n        expect(split[0]).toBeInstanceOf(PromptString)\n        expect(split[0].toString()).toBe('foo')\n        expect(split[0].getReferences()).toEqual([uri1, uri2])\n        expect(split[1]).toBeInstanceOf(PromptString)\n        expect(split[1].toString()).toBe('bar')\n        expect(split[1].getReferences()).toEqual([uri1, uri2])\n        expect(split[2]).toBeInstanceOf(PromptString)\n        expect(split[2].toString()).toBe('baz')\n        expect(split[2].getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can join', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'baz')\n        const doc3 = createFakeDocument(uri3, ' ')\n\n        const joined = PromptString.join(\n            [PromptString.fromDocumentText(doc1), ps`bar`, PromptString.fromDocumentText(doc2)],\n            PromptString.fromDocumentText(doc3)\n        )\n\n        expect(joined.toString()).toBe('foo bar baz')\n        expect(joined.getReferences()).toEqual([uri3, uri1, uri2])\n    })\n\n    it('can replace', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo bar foo')\n        const doc2 = createFakeDocument(uri2, '🇦🇹')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replace(/foo$/, PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo bar 🇦🇹')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can replaceAll', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo REPLACE bar REPLACE baz')\n        const doc2 = createFakeDocument(uri2, '🇦🇹')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replaceAll('REPLACE', PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo 🇦🇹 bar 🇦🇹 baz')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can concat', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'bar')\n        const doc3 = createFakeDocument(uri3, 'baz')\n\n        const first = PromptString.fromDocumentText(doc1)\n        const second = PromptString.fromDocumentText(doc2)\n        const third = PromptString.fromDocumentText(doc3)\n\n        const concatenated = first.concat(second, third)\n\n        expect(concatenated.toString()).toBe('foobarbaz')\n        expect(concatenated.getReferences()).toEqual([uri1, uri2, uri3])\n    })\n\n    it('detects invalid PromptStrings passed to utility types', () => {\n        const realPromptString = ps`foo`\n        const fakePromptString = 'foo' as any as PromptString\n\n        expect(() => ps`${fakePromptString}`).toThrowError()\n        expect(() => PromptString.join([fakePromptString], realPromptString)).toThrowError()\n        expect(() => realPromptString.replaceAll('', fakePromptString)).toThrowError()\n        expect(() => realPromptString.concat(fakePromptString)).toThrowError()\n    })\n\n    it('can not mutate the references list', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const doc = createFakeDocument(uri, 'foo')\n        const ps = PromptString.fromDocumentText(doc)\n\n        const arr: any = ps.getReferences()\n        // biome-ignore lint/performance/noDelete: 🏴‍☠️\n        delete arr[0]\n\n        expect(ps.getReferences()).toEqual([uri])\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/menus/index.ts:152-179"",""content"":""\n            // On selecting a default command\n            if (selection.type === 'default' && selection.command) {\n                // Check if it's an ask command\n                if (selection.key === 'ask') {\n                    // show input box if no value\n                    if (value.length === 0) {\n                        void commands.executeCommand('cody.chat.panel.new')\n                    } else {\n                        void executeChat({\n                            text: value.trim(),\n                            submitType: 'user-newchat',\n                            source,\n                        })\n                    }\n                    quickPick.hide()\n                    return\n                }\n\n                // Check if it's an edit command\n                if (selection.key === 'edit') {\n                    void executeEdit({\n                        configuration: { instruction: value },\n                        source,\n                    })\n                    quickPick.hide()\n                    return\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:372-380"",""content"":""interface Prompt {\n    snippets: { uri: vscode.Uri; content: PromptString }[]\n\n    uri: vscode.Uri\n    prefix: PromptString\n    suffix: PromptString\n\n    languageId: string\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-mixin.ts:0-56"",""content"":""import type { ChatMessage } from '../chat/transcript/messages'\nimport { PromptString, ps } from './prompt-string'\n\nconst identity = ps`Reply as Cody, a coding assistant developed by Sourcegraph.`\nconst hallucinate = ps`If context is available: never make any assumptions nor provide any misleading or hypothetical examples.`\nconst CODY_INTRO_PROMPT = ps`(${identity} ${hallucinate}) `\n\n/**\n * Prompt mixins elaborate every prompt presented to the LLM.\n * Add a prompt mixin to prompt for cross-cutting concerns relevant to multiple commands.\n */\nexport class PromptMixin {\n    private static mixins: PromptMixin[] = []\n    private static customMixin: PromptMixin[] = []\n    // The prompt that instructs Cody to identify itself and avoid hallucinations.\n    private static defaultMixin: PromptMixin = new PromptMixin(CODY_INTRO_PROMPT)\n\n    /**\n     * Adds a custom prompt mixin but not to the global set to make sure it will not be added twice\n     * and any new change could replace the old one.\n     */\n    public static addCustom(mixin: PromptMixin): void {\n        PromptMixin.customMixin = [mixin]\n    }\n\n    /**\n     * Prepends all mixins to `humanMessage`. Modifies and returns `humanMessage`.\n     */\n    public static mixInto(humanMessage: ChatMessage): ChatMessage {\n        // Default Mixin is added at the end so that it cannot be overriden by a custom mixin.\n        const mixins = PromptString.join(\n            [...PromptMixin.mixins, ...PromptMixin.customMixin, PromptMixin.defaultMixin].map(\n                mixin => mixin.prompt\n            ),\n            ps`\\n\\n`\n        )\n        if (mixins) {\n            // Stuff the prompt mixins at the start of the human text.\n            // Note we do not reflect them in `text`.\n            return {\n                ...humanMessage,\n                text: ps`${mixins}${humanMessage.text ? humanMessage.text : ''}`,\n            }\n        }\n        return humanMessage\n    }\n\n    /**\n     * Creates a mixin with the given, fixed prompt to insert.\n     */\n    constructor(private readonly prompt: PromptString) {}\n}\n\nexport function newPromptMixin(text: PromptString): PromptMixin {\n    return new PromptMixin(text)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:0-437"",""content"":""import dedent from 'dedent'\nimport type * as vscode from 'vscode'\nimport type { ChatMessage, SerializedChatMessage } from '../chat/transcript/messages'\nimport type { ContextItem } from '../codebase-context/messages'\nimport type { TerminalOutputArguments } from '../commands/types'\nimport { markdownCodeBlockLanguageIDForFilename } from '../common/languages'\nimport type { AutocompleteContextSnippet, DocumentContext } from '../completions/types'\nimport type { ConfigGetter } from '../configuration'\nimport type { ActiveTextEditorDiagnostic } from '../editor'\nimport { createGitDiff } from '../editor/create-git-diff'\nimport { displayPath } from '../editor/displayPath'\nimport { getEditorInsertSpaces, getEditorTabSize } from '../editor/utils'\n\n// This module is designed to encourage, and to some degree enforce, safe\n// handling of file content that gets constructed into prompts. It works this\n// way:\n//\n// - Literal strings are considered \""safe\"". Literal strings are constructed with\n//   a tagged template function, `ps`, and a linter in `/lint/safe-prompts.ts`\n//   ensures the function is only used in a tagged template literal, not\n//   aliased, etc.\n// - There are a small set of functions for conveniently constructing strings\n//   from file contents. Use of these functions needs to be continually audited\n//   to ensure they're safe.\n// - Strings constructed from other safe strings, with `ps` or helper methods,\n//   are also safe.\n// - Components sending prompts to LLMs should consume safe strings, not raw\n//   strings.\n//\n// This setup is designed to detect programming errors, not thwart malicious\n// attacks.\n\n/**\n * A \""safe\"" string class for constructing prompts.\n */\nexport class PromptString {\n    /**\n     * @deprecated Do not use the constructor directly. Instead, use ps`...` or a\n     * PromptString helper to handle string data for prompts safely\n     *\n     * @param __debug The string that is wrapped by this PromptString. This is\n     * useful for debugging since it will be shown when `console.log()` is called\n     * with this prompt string.\n     */\n    // @ts-expect-error: We don't want anyone to read __debug. This is just a helper\n    // for console.log debugging so this error is expected.\n    constructor(private __debug: string) {}\n\n    public toString(): string {\n        return internal_toString(this)\n    }\n\n    public getReferences(): readonly StringReference[] {\n        return internal_toReferences(this)\n    }\n\n    public toJSON(): string {\n        return internal_toString(this)\n    }\n\n    public get length(): number {\n        return internal_toString(this).length\n    }\n\n    public slice(start?: number, end?: number): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).slice(start, end),\n            internal_toReferences(this)\n        )\n    }\n\n    public trim(): PromptString {\n        return internal_createPromptString(internal_toString(this).trim(), internal_toReferences(this))\n    }\n\n    public trimEnd(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).trimEnd(),\n            internal_toReferences(this)\n        )\n    }\n\n    public indexOf(searchString: string | PromptString, start?: number): number {\n        return this.toString().indexOf(searchString.toString(), start)\n    }\n\n    public split(separator: string): PromptString[] {\n        const string = internal_toString(this)\n        const references = internal_toReferences(this)\n\n        const split = string.split(separator)\n        const result: PromptString[] = []\n        for (const part of split) {\n            result.push(internal_createPromptString(part, references))\n        }\n        return result\n    }\n\n    public toLocaleLowerCase(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).toLocaleLowerCase(),\n            internal_toReferences(this)\n        )\n    }\n\n    public includes(searchString: string | PromptString, position?: number): boolean {\n        return internal_toString(this).includes(\n            typeof searchString === 'string' ? searchString : internal_toString(searchString),\n            position\n        )\n    }\n\n    public static join(promptStrings: PromptString[], boundary: PromptString): PromptString {\n        const stringBoundary = internal_toString(boundary)\n\n        const buffer: string[] = []\n        const references: Set<StringReference> = new Set(internal_toReferences(boundary))\n        for (const promptString of promptStrings) {\n            if (!isValidPromptString(promptString)) {\n                throw new Error('Invalid prompt string')\n            }\n\n            buffer.push(internal_toString(promptString))\n            for (const reference of internal_toReferences(promptString)) {\n                references.add(reference)\n            }\n        }\n\n        return internal_createPromptString(buffer.join(stringBoundary), [...references])\n    }\n\n    public concat(...promptStrings: readonly PromptString[]): PromptString {\n        const stringPromptString: string[] = []\n        const references: (readonly StringReference[])[] = []\n        for (const promptString of promptStrings) {\n            stringPromptString.push(internal_toString(promptString))\n            references.push(internal_toReferences(promptString))\n        }\n\n        return internal_createPromptString(internal_toString(this).concat(...stringPromptString), [\n            ...internal_toReferences(this),\n            ...references.flat(),\n        ])\n    }\n\n    public replace(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replace(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    public replaceAll(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replaceAll(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    // Use this function to create a user-generated PromptString from the VS Code\n    // configuration object.\n    public static fromConfig<D>(\n        config: ConfigGetter<string>,\n        path: string,\n        defaultValue: D\n    ): PromptString | D {\n        const raw = config.get<string | null>(path, null)\n        const value = raw === null ? defaultValue : internal_createPromptString(raw, [])\n        return value\n    }\n\n    public static fromEditorIndentString(\n        uri: vscode.Uri,\n        workspace: Pick<typeof vscode.workspace, 'getConfiguration'>,\n        window: Pick<typeof vscode.window, 'visibleTextEditors'>\n    ) {\n        const insertSpaces = getEditorInsertSpaces(uri, workspace, window)\n        const tabSize = getEditorTabSize(uri, workspace, window)\n\n        const indentString = insertSpaces ? ' '.repeat(tabSize) : '\\t'\n        // Note: even though this uses the URI, it does not actually contain any\n        // information from the URI, so we leave the references empty for now (the\n        // content is always just whitespace)\n        return internal_createPromptString(indentString, [])\n    }\n\n    public static fromDisplayPath(uri: vscode.Uri) {\n        return internal_createPromptString(displayPath(uri), [uri])\n    }\n\n    public static fromDocumentText(document: vscode.TextDocument, range?: vscode.Range): PromptString {\n        return internal_createPromptString(document.getText(range), [document.uri])\n    }\n\n    public static fromGitDiff(uri: vscode.Uri, oldContent: string, newContent: string) {\n        const diff = createGitDiff(displayPath(uri), oldContent, newContent)\n        return internal_createPromptString(diff, [uri])\n    }\n\n    // Replaces the following placeholder with data from the diagnostics:\n    // {type}, {filePath}, {prefix}, {message}, {languageID}, {code}\n    //\n    // TODO: This should probably take a vscode.Diagnostic object instead.\n    public static fromTextEditorDiagnostic(\n        diagnostic: ActiveTextEditorDiagnostic,\n        uri: vscode.Uri\n    ): {\n        type: PromptString\n        text: PromptString\n        message: PromptString\n    } {\n        const ref = [uri]\n        return {\n            type: internal_createPromptString(diagnostic.type, ref),\n            text: internal_createPromptString(diagnostic.text, ref),\n            message: internal_createPromptString(diagnostic.message, ref),\n        }\n    }\n\n    public static fromMarkdownCodeBlockLanguageIDForFilename(uri: vscode.Uri) {\n        return internal_createPromptString(markdownCodeBlockLanguageIDForFilename(uri), [uri])\n    }\n\n    public static fromDiagnostic(uri: vscode.Uri, diagnostic: vscode.Diagnostic) {\n        const ref = [uri]\n        return {\n            message: internal_createPromptString(diagnostic.message, ref),\n            source: diagnostic.source ? internal_createPromptString(diagnostic.source, ref) : undefined,\n            relatedInformation: diagnostic.relatedInformation\n                ? diagnostic.relatedInformation.map(info => ({\n                      message: internal_createPromptString(info.message, [uri, info.location.uri]),\n                  }))\n                : undefined,\n        }\n    }\n\n    public static fromDocumentSymbol(\n        uri: vscode.Uri,\n        documentSymbol: vscode.DocumentSymbol,\n        SymbolKind: typeof vscode.SymbolKind\n    ) {\n        const symbolKind = documentSymbol.kind ? SymbolKind[documentSymbol.kind].toLowerCase() : ''\n        const symbolPrompt = documentSymbol.name ? `#${documentSymbol.name} (${symbolKind})` : ''\n        return internal_createPromptString(symbolPrompt, [uri])\n    }\n\n    // TODO: Find a better way to handle this. Maybe we should migrate the default commands json to\n    // a TypesScript object?\n    public static fromDefaultCommands(\n        commands: { [name: string]: { prompt: string } },\n        name: 'doc' | 'explain' | 'test' | 'smell'\n    ) {\n        const prompt = commands[name].prompt\n        return internal_createPromptString(prompt, [])\n    }\n\n    // TODO: Need to check in the runtime if we have something we can append as an URI here\n    public static fromTerminalOutputArguments(output: TerminalOutputArguments) {\n        return {\n            name: internal_createPromptString(output.name, []),\n            selection: output.selection ? internal_createPromptString(output.selection, []) : undefined,\n            creationOptions: output.creationOptions\n                ? internal_createPromptString(JSON.stringify(output.creationOptions), [])\n                : undefined,\n        }\n    }\n\n    public static fromAutocompleteDocumentContext(docContext: DocumentContext, uri: vscode.Uri) {\n        const ref = [uri]\n        return {\n            prefix: internal_createPromptString(docContext.prefix, ref),\n            suffix: internal_createPromptString(docContext.suffix, ref),\n            injectedPrefix: docContext.injectedPrefix\n                ? internal_createPromptString(docContext.injectedPrefix, ref)\n                : null,\n        }\n    }\n\n    public static fromAutocompleteContextSnippet(contextSnippet: AutocompleteContextSnippet) {\n        const ref = [contextSnippet.uri]\n        return {\n            content: internal_createPromptString(contextSnippet.content, ref),\n            symbol:\n                'symbol' in contextSnippet\n                    ? internal_createPromptString(contextSnippet.symbol, ref)\n                    : undefined,\n        }\n    }\n\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n    // panel or restarting the IDE makes those references evaporate.\n    //\n    // On the other hand, you might pull up an old chat transcript and all the\n    // file paths are different now because you moved a folder or something. We're\n    // thinking maybe we should have a concept of \""resolved\"" references where we\n    // keep (repo, repo relative path) pairs for the serialized representation\n    // or something.\n    //\n    // Additionally, the serialized chat message format is also used when sending\n    // chat messages back to the Agent. Right now, however, when we send new\n    // messages, this is done via the `chat/submitMessage` notification which does\n    // not deserialize from chat message. To make sure we do not introduce places\n    // where we deserialize chat messages this way, the function is marked unsafe\n    // for now.\n    public static unsafe_deserializeChatMessage(serializedMessage: SerializedChatMessage): ChatMessage {\n        return {\n            ...serializedMessage,\n            text: serializedMessage.text\n                ? internal_createPromptString(serializedMessage.text, [])\n                : undefined,\n        }\n    }\n}\n\ntype TemplateArgs = readonly (PromptString | '' | number)[]\n\n/**\n * Constructs PromptStrings from template literals, numbers or other\n * PromptStrings. A linter in `/lint/safe-prompts.ts` checks that this function\n * is never used except in a tagged template literal.\n *\n * @param format the format string pieces.\n * @param args the arguments to splice into the format string.\n */\nexport function ps(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    if (!(Array.isArray(format) && Object.isFrozen(format) && format.length > 0)) {\n        // Deter casual direct calls.\n        throw new Error('ps is only intended to be used in tagged template literals.')\n    }\n\n    const buffer: string[] = []\n    const references: Set<StringReference> = new Set()\n    for (let i = 0; i < format.length; i++) {\n        buffer.push(format[i])\n        if (i < args.length) {\n            const arg = args[i]\n\n            if (typeof arg === 'number') {\n                // Boxed number types are not allowed, only number literals\n                buffer.push(Number.prototype.toString.call(arg))\n            } else if (arg === '') {\n                // We allow empty strings for situations like this:\n                // ps`... ${foo ? foo : ''}...`\n            } else if (arg instanceof PromptString) {\n                // PromptString inherit all references\n                buffer.push(internal_toString(arg))\n                for (const ref of internal_toReferences(arg)) {\n                    references.add(ref)\n                }\n            } else {\n                // Do not allow arbitrary types like dynamic strings, classes with\n                // toString, etc. here.\n                throw new Error(\n                    'Use ps`...` or a PromptString helper to handle string data for prompts safely.'\n                )\n            }\n        }\n    }\n\n    return internal_createPromptString(buffer.join(''), [...references])\n}\n\n// A version of ps that removes the leading indentation of the first line.\nexport function psDedent(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    const promptString = ps(format, ...args)\n    const dedented = dedent(internal_toString(promptString))\n    return internal_createPromptString(dedented, internal_toReferences(promptString))\n}\n\n// When PromptStrings are created, their properties are stored in a side pocket\n// WeakMap. Consumers can do what they like with the PromptString, all of the\n// operations use data in the map and so are protected from the PromptString\n// constructor being disclosed, prototype pollution, property manipulation, etc.\ntype StringReference = vscode.Uri\nconst pocket = new WeakMap<PromptString, PromptStringPocket>()\nclass PromptStringPocket {\n    constructor(\n        public value: string,\n        // We're using a set inside the pocket so we get deduplication for free and\n        // by converting from array (input) to Set, we also guarantee shallow copies\n        // are being created.\n        public references: Set<StringReference>\n    ) {}\n}\n\nfunction internal_createPromptString(\n    string: string,\n    references: readonly StringReference[]\n): PromptString {\n    const handle = new PromptString(string)\n    // Create a shallow copy of the references list as a set, so it's both de-duped\n    // and can not be mutated by the caller\n    pocket.set(handle, new PromptStringPocket(string, new Set(references)))\n    return handle\n}\nfunction internal_toString(s: PromptString): string {\n    return pocket.get(s)!.value\n}\nfunction internal_toReferences(s: PromptString): readonly StringReference[] {\n    // Return a shallow copy of the references so it can not be mutated\n    return [...pocket.get(s)!.references.values()]\n}\n\n// Validate that an input is indeed a PromptString and not just typecast to it.\nexport function isValidPromptString(promptString: PromptString) {\n    return pocket.has(promptString)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:43-50"",""content"":""export const PROMPT = psDedent`\n    <source file=\""{filename}\"">\n    {source}\n    </source>\n    <recent-change>\n    {git-diff}\n    </recent-change>\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_009/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that executes the ""Find Code Smells"" command is located in the file `cody_test/vscode/src/commands/execute/smell.ts`. 

Specifically, the function `executeSmellCommand` is responsible for handling this command. It does the following:

1. **Logs telemetry:** It logs the execution of the command to the telemetry service.
2. **Executes the `smellCommand`:** It calls the `smellCommand` function, which is likely responsible for actually finding the code smells.
3. **Executes the `executeChat` command:** It then uses the result of `smellCommand` to execute the `executeChat` command, which presumably opens a chat window with the code smell suggestions.

The `smellCommand` function itself is not shown in the provided codebase context, but it's likely located in the same file or a related file within the `cody_test/vscode/src/commands/execute` directory.","Where is the code that executes the ""Find Code Smells"" command?","[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:23-42"",""content"":""    private createCommandCodeAction(\n        uri: vscode.Uri,\n        diagnostics: vscode.Diagnostic[]\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction('Ask Cody to Explain', vscode.CodeActionKind.QuickFix)\n        const instruction = this.getCodeActionInstruction(uri, diagnostics)\n        action.command = {\n            command: 'cody.action.chat',\n            arguments: [\n                {\n                    text: instruction,\n                    source: 'code-action:explain',\n                    submitType: 'user-newchat',\n                } satisfies ExecuteChatArguments,\n            ],\n            title: 'Ask Cody to Explain',\n        }\n        action.diagnostics = diagnostics\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:258-301"",""content"":""        version: 4.0.16\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n    devDependencies:\n      '@types/crypto-js':\n        specifier: ^4.2.2\n        version: 4.2.2\n      '@types/dedent':\n        specifier: ^0.7.0\n        version: 0.7.0\n      '@types/diff':\n        specifier: ^5.0.9\n        version: 5.0.9\n      '@types/dompurify':\n        specifier: ^3.0.2\n        version: 3.0.2\n      '@types/highlight.js':\n        specifier: ^9.12.4\n        version: 9.12.4\n      '@types/isomorphic-fetch':\n        specifier: ^0.0.39\n        version: 0.0.39\n      '@types/lodash':\n        specifier: ^4.14.195\n        version: 4.14.195\n      '@types/marked':\n        specifier: ^5.0.0\n        version: 5.0.0\n      '@types/node-fetch':\n        specifier: ^2.6.4\n        version: 2.6.4\n      '@types/vscode':\n        specifier: ^1.80.0\n        version: 1.80.0\n\n  vscode:\n    dependencies:\n      '@anthropic-ai/sdk':\n        specifier: ^0.4.2\n        version: 0.4.3\n      '@floating-ui/react':\n        specifier: ^0.26.9\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/test.ts:40-53"",""content"":""    private createCommandCodeAction(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        displayText: string\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction(displayText, vscode.CodeActionKind.RefactorRewrite)\n        const source = 'code-action:test'\n        action.command = {\n            command: 'cody.command.unit-tests',\n            arguments: [{ source } satisfies Partial<CodyCommandArgs>],\n            title: displayText,\n        }\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/strategies.ts:0-29"",""content"":""// FixupController has pluggable strategies for controls and presentation. This\n// file defines the interfaces for those strategies.\n\nimport type * as vscode from 'vscode'\nimport type { FixupFile } from './FixupFile'\nimport type { FixupTask } from './FixupTask'\n\n// An interface for decorating fixup tasks with controls.\nexport interface FixupControlApplicator extends vscode.Disposable {\n    didUpdateTask(task: FixupTask): void\n    didDeleteTask(task: FixupTask): void\n    // Called when visible files changed.\n    // TODO: This API design is gross: this is *not* called when a new task\n    // is created in a file that is already visible. It *is* called every time\n    // visible files change, so be prepared to handle repeated calls with\n    // an empty or unchanged set of files efficiently. Unearth a consistent\n    // API here.\n    visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void\n}\n\n// A FixupControlApplicator which does not present any controls for fixup\n// tasks.\nexport class NullFixupControlApplicator implements FixupControlApplicator {\n    public didUpdateTask(task: FixupTask): void {}\n    public didDeleteTask(task: FixupTask): void {}\n    public visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void {}\n    public dispose(): void {}\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:47-77"",""content"":""    private async createCommandCodeAction(\n        document: vscode.TextDocument,\n        diagnostics: vscode.Diagnostic[],\n        range: vscode.Range\n    ): Promise<vscode.CodeAction> {\n        const action = new vscode.CodeAction('Ask Cody to Fix', vscode.CodeActionKind.QuickFix)\n        const instruction = await this.getCodeActionInstruction(\n            document.uri,\n            PromptString.fromDocumentText(document, range),\n            diagnostics\n        )\n        const source = 'code-action:fix'\n        action.command = {\n            command: 'cody.command.edit-code',\n            arguments: [\n                {\n                    configuration: { instruction, range, intent: 'fix', document },\n                    source,\n                    telemetryMetadata: {\n                        diagnostics: diagnostics.map(diagnostic => ({\n                            code: getDiagnosticCode(diagnostic.code),\n                            source: diagnostic.source,\n                        })),\n                    },\n                } satisfies ExecuteEditArguments,\n            ],\n            title: 'Ask Cody to Fix',\n        }\n        action.diagnostics = diagnostics\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1254-1289"",""content"":""    \""@vscode/codicons\"": \""^0.0.35\"",\n    \""@vscode/webview-ui-toolkit\"": \""^1.2.2\"",\n    \""async-mutex\"": \""^0.4.0\"",\n    \""axios\"": \""^1.3.6\"",\n    \""classnames\"": \""^2.3.2\"",\n    \""crypto-js\"": \""^4.2.0\"",\n    \""detect-indent\"": \""^7.0.1\"",\n    \""diff\"": \""^5.2.0\"",\n    \""fast-xml-parser\"": \""^4.3.2\"",\n    \""glob\"": \""^7.2.3\"",\n    \""ini\"": \""^4.1.2\"",\n    \""isomorphic-fetch\"": \""^3.0.0\"",\n    \""js-levenshtein\"": \""^1.1.6\"",\n    \""lexical\"": \""^0.13.1\"",\n    \""lodash\"": \""^4.17.21\"",\n    \""lru-cache\"": \""^10.0.0\"",\n    \""mkdirp\"": \""^3.0.1\"",\n    \""os-browserify\"": \""^0.3.0\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""proxy-agent\"": \""^6.4.0\"",\n    \""re2-wasm\"": \""^1.0.2\"",\n    \""semver\"": \""^7.5.4\"",\n    \""socks-proxy-agent\"": \""^8.0.1\"",\n    \""unzipper\"": \""^0.10.14\"",\n    \""uuid\"": \""^9.0.0\"",\n    \""vscode-languageserver-textdocument\"": \""^1.0.8\"",\n    \""vscode-uri\"": \""^3.0.7\"",\n    \""web-tree-sitter\"": \""^0.21.0\"",\n    \""wink-nlp-utils\"": \""^2.1.0\""\n  },\n  \""devDependencies\"": {\n    \""@google-cloud/pubsub\"": \""^3.7.3\"",\n    \""@playwright/test\"": \""1.39.0\"",\n    \""@pollyjs/adapter-node-http\"": \""^6.0.6\"",\n    \""@pollyjs/core\"": \""^6.0.6\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:144-164"",""content"":""- [ ] Verify that the chat executed by running the command appears in the chat list in the left hand panel.\n\n#### Editing\n\n- [ ] Highlight a section of code.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Cody: Edit Code`.\n- [ ] Provide instructions for how Cody should edit the selected code.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies edits to the selected code, per the user’s instructions\n- [ ] Verify that you can see a diff view of the edit in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the edit by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Generating code\n\n- [ ] Move the cursor to an empty line, do not highlight any selection.\n- [ ] Click the Code Action lightbulb icon in the project file.\n- [ ] Select `Cody: Generate Code`.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:0-34"",""content"":""{\n  \""actionscript\"": [\""as\""],\n  \""ada\"": [\""adb\"", \""ada\"", \""ads\""],\n  \""apache\"": [\""apacheconf\""],\n  \""apex\"": [\""cls\"", \""apex\"", \""trigger\""],\n  \""applescript\"": [\""applescript\"", \""scpt\""],\n  \""beancount\"": [\""beancount\""],\n  \""bibtex\"": [\""bib\""],\n  \""clojure\"": [\""clj\"", \""cljs\"", \""cljx\""],\n  \""cmake\"": [\""cmake\"", \""cmake.in\"", \""in\""],\n  \""coffescript\"": [\""coffee\"", \""cake\"", \""cson\"", \""cjsx\"", \""iced\""],\n  \""cpp\"": [\""c\"", \""cc\"", \""cpp\"", \""cxx\"", \""c++\"", \""h++\"", \""hh\"", \""h\"", \""hpp\"", \""pc\"", \""pcc\""],\n  \""csharp\"": [\""cs\"", \""csx\""],\n  \""css\"": [\""css\""],\n  \""cuda\"": [\""cu\"", \""cuh\""],\n  \""d\"": [\""d\""],\n  \""dot\"": [\""dot\""],\n  \""dart\"": [\""dart\""],\n  \""diff\"": [\""diff\"", \""patch\""],\n  \""dockerfile\"": [\""Dockerfile\""],\n  \""django\"": [\""jinja\""],\n  \""dos\"": [\""bat\"", \""cmd\""],\n  \""elixir\"": [\""ex\"", \""exs\""],\n  \""elm\"": [\""elm\""],\n  \""erlang\"": [\""erl\""],\n  \""fortran\"": [\""f\"", \""for\"", \""frt\"", \""fr\"", \""forth\"", \""4th\"", \""fth\""],\n  \""fsharp\"": [\""fs\""],\n  \""go\"": [\""go\""],\n  \""graphql\"": [\""graphql\""],\n  \""groovy\"": [\""groovy\""],\n  \""haml\"": [\""haml\""],\n  \""handlebars\"": [\""hbs\"", \""handlebars\""],\n  \""haskell\"": [\""hs\"", \""hsc\""],\n  \""hcl\"": [\""hcl\"", \""nomad\"", \""tf\"", \""tfvars\"", \""workflow\""],\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-tests/test-data/graph-identifiers.tsx:50-108"",""content"":""\nfunction signature()\n//                |\n\n// ------------------------------------\n\n// comment\n//       |\n\n// ------------------------------------\n\n/**\n * comment\n //      |\n */\n\n// ------------------------------------\n\nfunction functionName() {}\n//                  |\n\n// ------------------------------------\n\nfunction returnStatement() {\n    return\n    //   |\n}\n\n// ------------------------------------\n\nfunction returnStatementValue(value: Agent, flag?: boolean) {\n    return 'asd'\n    //     |\n}\n\n// ------------------------------------\n\ninterface TestInterface {\n    //                  |\n}\n\n// ------------------------------------\n\ntype TestType = {\n    //          |\n}\n\n// ------------------------------------\n\nreturnStatementValue('value')\n//                   |\n\n// ------------------------------------\n\nreturnStatementValue('value', false)\n//                            |\n\n// ------------------------------------\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:0-29"",""content"":""{\n  \""private\"": true,\n  \""name\"": \""@sourcegraph/cody\"",\n  \""description\"": \""Cody, the code AI that writes code, fixes bugs, and answers questions using the code graph\"",\n  \""license\"": \""Apache-2.0\"",\n  \""homepage\"": \""https://cody.dev\"",\n  \""repository\"": {\n    \""type\"": \""git\"",\n    \""url\"": \""https://github.com/sourcegraph/cody\""\n  },\n  \""engines\"": {\n    \""node\"": \""^v20.4.0\"",\n    \""pnpm\"": \""^8.6.7\""\n  },\n  \""browser\"": {\n    \""fs\"": false\n  },\n  \""scripts\"": {\n    \""build\"": \""tsc --build\"",\n    \""watch\"": \""tsc --build --watch\"",\n    \""check\"": \""pnpm run -s biome && pnpm run -s check:css\"",\n    \""check:css\"": \""stylelint --quiet --cache '**/*.css'\"",\n    \""biome\"": \""biome check --apply --error-on-warnings .\"",\n    \""test\"": \""vitest\"",\n    \""test:unit\"": \""vitest run\"",\n    \""test:integration\"": \""pnpm -C vscode test:integration\"",\n    \""test:e2e\"": \""pnpm -C vscode test:e2e\"",\n    \""generate-agent-kotlin-bindings\"": \""pnpm build && pnpm dlx ts-node agent/src/cli/scip-codegen/command.ts --output ../jetbrains/src/main/kotlin/com/sourcegraph/cody/protocol_generated\"",\n    \""update-agent-recordings\"": \""pnpm build && CODY_KEEP_UNUSED_RECORDINGS=false CODY_RECORD_IF_MISSING=true vitest agent/src/index.test.ts\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/README.md:0-3"",""content"":""This is a second workspace folder included in `multi-root.code-workspace` used by integration\ntests in `test/integration/multi-root` for testing in multi-root workspaces.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/smell.ts:60-89"",""content"":""export async function executeSmellCommand(\n    args?: Partial<CodyCommandArgs>\n): Promise<ChatCommandResult | undefined> {\n    return wrapInActiveSpan('command.smell', async span => {\n        span.setAttribute('sampled', true)\n        logDebug('executeSmellCommand', 'executing', { args })\n        telemetryService.log('CodyVSCodeExtension:command:smell:executed', {\n            useCodebaseContex: false,\n            requestID: args?.requestID,\n            source: args?.source,\n            traceId: span.spanContext().traceId,\n        })\n        telemetryRecorder.recordEvent('cody.command.smell', 'executed', {\n            metadata: {\n                useCodebaseContex: 0,\n            },\n            interactionID: args?.requestID,\n            privateMetadata: {\n                requestID: args?.requestID,\n                source: args?.source,\n                traceId: span.spanContext().traceId,\n            },\n        })\n\n        return {\n            type: 'chat',\n            session: await executeChat(await smellCommand(span, args)),\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:116-145"",""content"":""                : ''\n            return fixPathSep(\n                workspaceDisplayPrefix + uri.path.slice(workspacePrefix.length + 1),\n                isWindows,\n                uri.scheme\n            )\n        }\n    }\n\n    if (uri.scheme === 'file') {\n        // Show the absolute file path because we couldn't find a parent workspace folder.\n        return fixPathSep(uri.fsPath, isWindows, uri.scheme)\n    }\n\n    // Show the full URI for anything else.\n    return uri\n}\n\n/**\n * Fixes the path separators for Windows paths. This makes it possible to write cross-platform\n * tests.\n */\nfunction fixPathSep(fsPath: string, isWindows: boolean, scheme: string): string {\n    return isWindows && scheme === 'file' ? fsPath.replaceAll('/', '\\\\') : fsPath\n}\n\nexport function uriHasPrefix(uri: URI, prefix: URI, isWindows: boolean): boolean {\n    // On Windows, it's common to have drive letter casing mismatches (VS Code's APIs tend to normalize\n    // to lowercase, but many other tools use uppercase and we don't know where the context file came\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/gradlew.bat:0-25"",""content"":""@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the \""License\"");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an \""AS IS\"" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if \""%DEBUG%\""==\""\"" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \""%OS%\""==\""Windows_NT\"" setlocal\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:108-123"",""content"":""- [ ] Verify that Cody adds documentation above the function that contains your cursor.\n\n### Smell\n\n- [ ] Verify that the option to run the `Find Code Smells` command is available in the following locations:\n  - [ ] Sidebar `Find Code Smells`\n  - [ ] Context (right-click) menu `Cody > Find Code Smells`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Find Code Smells`\n  - [ ] Cody Command Menu (option+c, `Find Code Smells`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Find Code Smells` command.\n- [ ] Verify that Cody provides suggestion for how to improve the selected code in a new chat window.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Find Code Smells` command again\n- [ ] Verify that Cody provides suggestion for how to improve the function that contains your cursor in a new chat window.\n- [ ] Verify that the chat executed by running the command is added to the sidebar under `Chats`.\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_010/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"We check for ignored files in the `isIgnored` method of the `IgnoreHelper` class. This method is called by the `isCodyIgnoredFile` function in `context-filter.ts`. 

Here's a breakdown of the process:

1. **`isCodyIgnoredFile` (context-filter.ts):** This function takes a URI as input and calls `ignores.isIgnored(uri)` to check if the file is ignored.
2. **`isIgnored` (ignore-helper.ts):** This method is responsible for determining if a file is ignored based on the configured ignore rules. It performs the following steps:
    * **Check for disabled state:** If the `isActive` flag is false, it immediately returns `false`, indicating that the file is not ignored.
    * **Check for HTTPS URIs:** It returns `false` for HTTPS URIs, assuming they originate from remote context and have already been filtered by the backend.
    * **Check for non-file URIs:** It returns `true` for non-file URIs, indicating that they are ignored.
    * **Find workspace root:** It attempts to find the workspace root that contains the given URI.
    * **Apply default rules:** If no workspace root is found, it applies the default ignore rules (e.g., `.env`) to the file's basename.
    * **Apply workspace-specific rules:** If a workspace root is found, it retrieves the ignore rules associated with that workspace and applies them to the relative path of the file within the workspace.

Therefore, the `isIgnored` method in `ignore-helper.ts` is the central point where we check for ignored files based on the configured ignore rules and the file's URI.",Where do we check for ignored files?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:134-163"",""content"":""\n    it.skip('throws on a relative Uri', () => {\n        const relativeFileUri = URI.parse('file://a')\n        expect(() => ignore.isIgnored(relativeFileUri)).toThrow()\n    })\n\n    it('handles comments and blank lines in the ignore file', () => {\n        setWorkspace1Ignores([\n            '# header comment',\n            '#.foo',\n            '',\n            '.bar # an explanatory reason that .bar is ignored',\n        ])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.env'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.foo'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.bar'))).toBe(true)\n    })\n\n    describe('returns the correct value for a sample of rules', () => {\n        beforeEach(() => {\n            setWorkspace1Ignores([\n                'node_modules/',\n                '**/cody',\n                '**/foo/**',\n                '/bar',\n                'fooz',\n                'barz/*',\n                '.git',\n                'one/**/two',\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:30-173"",""content"":""export class IgnoreHelper {\n    /**\n     * A map of workspace roots to their ignore rules.\n     */\n    private workspaceIgnores = new Map<ClientWorkspaceRootURI, Ignore>()\n    public hasCodyIgnoreFiles = false\n    /**\n     * Check if the configuration is enabled or not\n     * Do not ignore files if the feature is not enabled\n     * TODO: Remove this once it's ready for GA\n     */\n    public isActive = false\n    public setActiveState(isActive: boolean): void {\n        this.isActive = isActive\n    }\n\n    /**\n     * Builds and caches a single ignore set for all nested ignore files within a workspace root.\n     * @param workspaceRoot The workspace root.\n     * @param ignoreFiles The URIs and content of all ignore files within the root.\n     */\n    public setIgnoreFiles(workspaceRoot: URI, ignoreFiles: IgnoreFileContent[]): void {\n        if (!this.isActive) {\n            return\n        }\n\n        this.ensureAbsolute('workspaceRoot', workspaceRoot)\n\n        const rules = this.getDefaultIgnores()\n        for (const ignoreFile of ignoreFiles) {\n            this.ensureValidCodyIgnoreFile('ignoreFile.uri', ignoreFile.uri)\n\n            // Compute the relative path from the workspace root to the folder this ignore\n            // file applies to.\n            const effectiveDir = ignoreFileEffectiveDirectory(ignoreFile.uri)\n            const relativeFolderUriPath = pathFunctionsForURI(workspaceRoot).relative(\n                workspaceRoot.path,\n                effectiveDir.path\n            )\n\n            // Build the ignore rule with the relative folder path applied to the start of each rule.\n            for (let ignoreLine of ignoreFile.content.split('\\n')) {\n                // Trim off any trailing comments.\n                ignoreLine = ignoreLine.split('#')[0]\n\n                // Skip any lines that are now empty.\n                ignoreLine = ignoreLine.trim()\n                if (!ignoreLine.length) {\n                    continue\n                }\n\n                let isInverted = false\n                if (ignoreLine.startsWith('!')) {\n                    ignoreLine = ignoreLine.slice(1)\n                    isInverted = true\n                }\n\n                // Gitignores always use POSIX/forward slashes, even on Windows.\n                const ignoreRule = relativeFolderUriPath.length\n                    ? `${relativeFolderUriPath}/${ignoreLine}`\n                    : ignoreLine\n                rules.add((isInverted ? '!' : '') + ignoreRule)\n            }\n        }\n\n        this.workspaceIgnores.set(workspaceRoot.toString(), rules)\n        if (ignoreFiles.length && !this.hasCodyIgnoreFiles) {\n            this.hasCodyIgnoreFiles = true\n        }\n    }\n\n    public clearIgnoreFiles(workspaceRoot: URI): void {\n        this.workspaceIgnores.delete(workspaceRoot.toString())\n    }\n\n    public isIgnored(uri: URI): boolean {\n        // Do not ignore if the feature is not enabled\n        if (!this.isActive) {\n            return false\n        }\n\n        // Return all https URIs on the assumption that they origin from\n        // remote context (e.g. unified, multi-repo) files, which are already\n        // filtered by the backend to respect codyignore files during sync time.\n        if (uri.scheme === 'https') {\n            return false\n        }\n\n        // Ignore all other non-file URIs\n        if (uri.scheme !== 'file') {\n            return true\n        }\n\n        this.ensureFileUri('uri', uri)\n        this.ensureAbsolute('uri', uri)\n        const workspaceRoot = this.findWorkspaceRoot(uri)\n\n        // Not in workspace so just use default rules against the filename.\n        // This ensures we'll never send something like `.env` but it won't handle\n        // if default rules include folders like `a/b` because we have nothing to make\n        // a relative path from.\n        if (!workspaceRoot) {\n            return this.getDefaultIgnores().ignores(uriBasename(uri))\n        }\n\n        const relativePath = pathFunctionsForURI(workspaceRoot).relative(workspaceRoot.path, uri.path)\n        const rules = this.workspaceIgnores.get(workspaceRoot.toString()) ?? this.getDefaultIgnores()\n        return rules.ignores(relativePath) ?? false\n    }\n\n    private findWorkspaceRoot(file: URI): URI | undefined {\n        const candidates = Array.from(this.workspaceIgnores.keys()).filter(workspaceRoot =>\n            uriHasPrefix(file, URI.parse(workspaceRoot), isWindows())\n        )\n        // If this file was inside multiple workspace roots, take the shortest one since it will include\n        // everything the nested one does (plus potentially extra rules).\n        candidates.sort((a, b) => a.length - b.length)\n        const selected = candidates.at(0)\n        return selected ? URI.parse(selected) : undefined\n    }\n\n    private ensureFileUri(name: string, uri: URI): void {\n        if (uri.scheme !== 'file') {\n            throw new Error(`${name} should be a file URI: \""${uri}\""`)\n        }\n    }\n\n    private ensureAbsolute(name: string, uri: URI): void {\n        if (!uri.path.startsWith('/')) {\n            throw new Error(`${name} should be absolute: \""${uri.toString()}\""`)\n        }\n    }\n\n    private ensureValidCodyIgnoreFile(name: string, uri: URI): void {\n        this.ensureAbsolute('ignoreFile.uri', uri)\n        if (!uri.path.endsWith(CODY_IGNORE_URI_PATH)) {\n            throw new Error(`${name} should end with \""${CODY_IGNORE_URI_PATH}\"": \""${uri.toString()}\""`)\n        }\n    }\n\n    private getDefaultIgnores(): Ignore {\n        return ignore().add('.env')\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/cody-ignore.test.ts:46-69"",""content"":""\n    // Start new chat\n    const [chatPanel, chatInput] = await createEmptyChatPanel(page)\n\n    /* TEST: Chat Context - Ignored file do not show up with context */\n    await chatInput.focus()\n    await chatInput.fill('Ignore me')\n    await chatInput.press('Enter')\n    // Assistant should response to your chat question,\n    // but the current file is excluded (ignoredByCody.css) and not on the context list\n    await expect(chatPanel.getByText('hello from the assistant')).toBeVisible()\n    const contextCell = getContextCell(chatPanel)\n    await expect(contextCell).not.toBeVisible()\n\n    /* TEST: At-file - Ignored file does not show up as context when using @-mention */\n    await chatInput.focus()\n    await chatInput.clear()\n    await chatInput.fill('@ignoredByCody')\n    await expect(chatPanel.getByRole('heading', { name: 'No files found' })).toBeVisible()\n    await chatInput.clear()\n    await chatInput.fill('@ignore')\n    await expect(\n        chatPanel.getByRole('option', { name: withPlatformSlashes('ignore .cody') })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:162-186"",""content"":""\n    private ensureValidCodyIgnoreFile(name: string, uri: URI): void {\n        this.ensureAbsolute('ignoreFile.uri', uri)\n        if (!uri.path.endsWith(CODY_IGNORE_URI_PATH)) {\n            throw new Error(`${name} should end with \""${CODY_IGNORE_URI_PATH}\"": \""${uri.toString()}\""`)\n        }\n    }\n\n    private getDefaultIgnores(): Ignore {\n        return ignore().add('.env')\n    }\n}\n\nexport interface IgnoreFileContent {\n    uri: URI\n    content: string\n}\n\n/**\n * Return the directory that a .cody/ignore file applies to.\n */\nexport function ignoreFileEffectiveDirectory(ignoreFile: URI): URI {\n    return Utils.joinPath(ignoreFile, '..', '..')\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:207-217"",""content"":""async function tryReadFile(fileUri: vscode.Uri): Promise<string> {\n    return vscode.workspace.fs.readFile(fileUri).then(\n        content => utf8.decode(content),\n        error => {\n            logDebug('CodyIgnore:clearIgnoreFiles:tryReadFile', 'failed', {\n                verbose: `Skipping unreadable ignore file ${fileUri}: ${error}`,\n            })\n            return ''\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/codyignore.md:16-23"",""content"":""src/\n5. To test if it's working, open a file from the directory you've chosen to ignore and highlight some code.\n6. Ask Cody a question about the highlighted code.\n7. Check the file context in Cody's response. You should not see any files from the ignored directory being used as context.\n8. Note that autocomplete features will also not work on files specified in the `.cody/ignore` file.\n\nRemember, this is an experimental feature for internal testing only, so use it with caution and report any issues you encounter to help improve the functionality.""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/utils/findWorkspaceFiles.ts:51-77"",""content"":""async function readIgnoreFile(uri: vscode.Uri): Promise<IgnoreRecord> {\n    const ignore: IgnoreRecord = {}\n    try {\n        const data = await vscode.workspace.fs.readFile(uri)\n        for (let line of Buffer.from(data).toString('utf-8').split('\\n')) {\n            if (line.startsWith('!')) {\n                continue\n            }\n\n            // Strip comment and trailing whitespace.\n            line = line.replace(/\\s*(#.*)?$/, '')\n\n            if (line === '') {\n                continue\n            }\n\n            if (line.endsWith('/')) {\n                line = line.slice(0, -1)\n            }\n            if (!line.startsWith('/') && !line.startsWith('**/')) {\n                line = `**/${line}`\n            }\n            ignore[line] = true\n        }\n    } catch {}\n    return ignore\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:31-55"",""content"":""\n    // Refresh ignore rules when any ignore file in the workspace changes.\n    const watcher = vscode.workspace.createFileSystemWatcher(CODY_IGNORE_POSIX_GLOB)\n    watcher.onDidChange(refresh)\n    watcher.onDidCreate(refresh)\n    watcher.onDidDelete(refresh)\n\n    // Handle any added/removed workspace folders.\n    const didChangeSubscription = vscode.workspace.onDidChangeWorkspaceFolders(e => {\n        e.added.map(wf => refresh(wf.uri))\n        e.removed.map(wf => clear(wf))\n    })\n\n    const onDidChangeConfig = vscode.workspace.onDidChangeConfiguration(e => {\n        // NOTE This can be removed once cody ignore is stable.\n        if (e.affectsConfiguration('cody')) {\n            onConfigChange()\n        }\n        // NOTE This allows us to search for the ignore files again\n        // if the user changes the search.symlinks setting.\n        if (e.affectsConfiguration('search')) {\n            // Only refresh if the ignore sidebar is empty,\n            // which means the setup step has initially failed.\n            if (ignores.isActive && !ignores.hasCodyIgnoreFiles) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/context-filter.ts:14-16"",""content"":""export function isCodyIgnoredFile(uri: URI): boolean {\n    return ignores.isIgnored(uri)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:75-95"",""content"":""\n    it('returns true for a top-level file ignored at the top level', () => {\n        setWorkspace1Ignores(['ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored.txt'))).toBe(true)\n    })\n\n    it('returns false for a top-level file not ignored at the top level', () => {\n        setWorkspace1Ignores(['ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'not_ignored.txt'))).toBe(false)\n    })\n\n    it('returns false for a top-level file unignored at the top level', () => {\n        setWorkspace1Ignores(['*ignored.txt', '!not_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'not_ignored.txt'))).toBe(false)\n    })\n\n    it('returns true for a nested file ignored at the top level', () => {\n        setWorkspace1Ignores(['always_ignored.txt', 'a/explitly_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/always_ignored.txt'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/explitly_ignored.txt'))).toBe(true)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:172-178"",""content"":""function setCodyIgnoreFiles(ws: vscode.Uri, files: IgnoreFileContent[]): void {\n    ignores.setIgnoreFiles(ws, files)\n    if (files.length) {\n        telemetryService.log('CodyVSCodeExtension:codyIgnore:hasFile')\n        telemetryRecorder.recordEvent('cody.codyIgnore', 'hasFile')\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/__tests__/example-ts/src/isIgnored.ts:0-4"",""content"":""function isIgnoredByCody() {\n    console.log('This file is ignored by Cody via .cody/ignore.')\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/ignoreTests/ignoreTest.ws2:0-5"",""content"":""This file should be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace/ignoreTests/ignoreTest.ws1:0-5"",""content"":""This file should be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:116-134"",""content"":""\n    it('returns false for a nested file unignored at the nested level', () => {\n        setWorkspace1NestedIgnores('a', ['*ignored.txt', '!not_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/not_ignored.txt'))).toBe(false)\n    })\n\n    it('tracks ignores independently for each workspace root', () => {\n        setWorkspace1Ignores(['ignored_1.txt'])\n        setWorkspace2Ignores(['ignored_2.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored_1.txt'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored_2.txt'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace2Root, 'ignored_1.txt'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace2Root, 'ignored_2.txt'))).toBe(true)\n    })\n\n    it('throws on an empty file: URI', () => {\n        expect(() => ignore.isIgnored(URI.parse('file:///'))).toThrow()\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/integration/multi-root/ignore.test.ts:27-42"",""content"":""        )\n    }\n\n    test('ignores ws1 files in workspace1', () =>\n        checkIgnore(`${workspace1Path}/ignoreTests/ignoreTest.ws1`, true))\n\n    test('does not ignore ws2 files in workspace1', () =>\n        checkIgnore(`${workspace1Path}/ignoreTests/ignoreTest.ws2`, false))\n\n    test('does not ignore ws1 files in workspace2', () =>\n        checkIgnore(`${workspace2Path}/ignoreTests/ignoreTest.ws1`, false))\n\n    test('ignores ws2 files in workspace2', () =>\n        checkIgnore(`${workspace2Path}/ignoreTests/ignoreTest.ws2`, true))\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:0-33"",""content"":""import ignore, { type Ignore } from 'ignore'\nimport { URI, Utils } from 'vscode-uri'\n\nimport { pathFunctionsForURI } from '../common/path'\nimport { isWindows } from '../common/platform'\nimport { uriBasename } from '../common/uri'\nimport { uriHasPrefix } from '../editor/displayPath'\n\n/**\n * The Cody ignore URI path.\n */\nexport const CODY_IGNORE_URI_PATH = '.cody/ignore'\n\n/**\n * A glob matching the Cody ignore URI path.\n */\nexport const CODY_IGNORE_POSIX_GLOB = `**/${CODY_IGNORE_URI_PATH}`\n\ntype ClientWorkspaceRootURI = string\n\n/**\n * A helper to efficiently check if a file should be ignored from a set\n * of nested ignore files.\n *\n * Callers must call `setIgnoreFiles` for each workspace root with the full set of ignore files (even\n * if there are zero) at startup (or when new workspace folders are added) and any time an ignore file\n * is modified/created/deleted.\n *\n * `clearIgnoreFiles` should be called for workspace roots as they are removed.\n */\nexport class IgnoreHelper {\n    /**\n     * A map of workspace roots to their ignore rules.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/ignoreTests/ignoreTest.ws1:0-5"",""content"":""This file should NOT be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/Check_IsCodyIgnoredFileParams.kt:0-8"",""content"":""@file:Suppress(\""FunctionName\"", \""ClassName\"", \""unused\"", \""EnumEntryName\"", \""UnusedImport\"")\npackage com.sourcegraph.cody.protocol_generated\n\ndata class Check_IsCodyIgnoredFileParams(\n  val urls: List<String>? = null,\n)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace/ignoreTests/ignoreTest.ws2:0-5"",""content"":""This file should NOT be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_011/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The build and lint tools are configured in the `package.json` files of the respective projects:

* **`cody_test/vscode/package.json`**: This file contains build scripts for the VS Code extension, including:
    * `build`: Compiles TypeScript, bundles the extension for desktop and web, and builds webviews.
    * `build:dev:desktop`: Builds the extension for desktop in development mode.
    * `build:dev:web`: Builds the extension for web in development mode.
    * `dev:web`: Builds the extension for web in development mode and runs tests.
    * `watch:build:dev:web`: Watches for changes and rebuilds the extension for web in development mode.
    * `watch:build:dev:desktop`: Watches for changes and rebuilds the extension for desktop in development mode.
    * `_build:esbuild:desktop`: Bundles the extension for desktop using esbuild.
    * `_build:esbuild:web`: Bundles the extension for web using esbuild.
    * `_build:webviews`: Builds the webviews using vite.
    * `download-wasm`: Downloads wasm modules.
    * `release`: Runs the release script.
    * `release:dry-run`: Runs the release script in dry-run mode.
* **`cody_test/agent/package.json`**: This file contains build scripts for the agent, including:
    * `build`: Compiles TypeScript and bundles the agent.
    * `build:dev`: Builds the agent in development mode.
    * `build:prod`: Builds the agent in production mode.
    * `watch:build:dev`: Watches for changes and rebuilds the agent in development mode.
    * `watch:build:prod`: Watches for changes and rebuilds the agent in production mode.
    * `start:dev`: Starts the agent in development mode.
    * `start:prod`: Starts the agent in production mode.
    * `test`: Runs unit tests.
    * `test:watch`: Watches for changes and runs unit tests.
    * `lint`: Runs linting.
    * `format`: Formats code.

While the `package.json` files contain the build and lint scripts, the actual configuration for these tools might be spread across different files:

* **`cody_test/vscode/webviews/vite.config.ts`**: This file configures vite for building the webviews.
* **`cody_test/vscode/scripts/release.ts`**: This file contains the release script.
* **`cody_test/vscode/scripts/download-wasm-modules.ts`**: This file contains the script for downloading wasm modules.
* **`cody_test/agent/src/cli/scip-codegen/CodePrinter.ts`**: This file might contain some build-related logic for the agent.

Therefore, the build and lint tools are configured in a combination of `package.json` files and other configuration files within the respective projects.",Where are the build and lint tools configured?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:1746-1760"",""content"":""      '@babel/core': 7.24.0\n      '@babel/helper-compilation-targets': 7.23.6\n      '@babel/helper-plugin-utils': 7.24.0\n      '@babel/helper-validator-option': 7.23.5\n      '@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly': 7.23.7(@babel/core@7.24.0)\n      '@babel/plugin-proposal-private-property-in-object': 7.21.0-placeholder-for-preset-env.2(@babel/core@7.24.0)\n      '@babel/plugin-syntax-async-generators': 7.8.4(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-properties': 7.12.13(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-static-block': 7.14.5(@babel/core@7.24.0)\n      '@babel/plugin-syntax-dynamic-import': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-export-namespace-from': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-import-assertions': 7.23.3(@babel/core@7.24.0)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/common/markdown/contributions.ts:43-72"",""content"":"" */\nexport function registerHighlightContributions(): void {\n    if (registered) {\n        // Don't double-register these. (There is no way to unregister them.)\n        return\n    }\n    registered = true\n    registerLanguage('go', goLang)\n    registerLanguage('javascript', javascript)\n    registerLanguage('typescript', typescript)\n    registerLanguage('java', java)\n    registerLanguage('python', python)\n    registerLanguage('php', php)\n    registerLanguage('bash', bash)\n    registerLanguage('clojure', clojure)\n    // This is a dependency of cpp.\n    registerLanguage('c-like', cLike)\n    registerLanguage('cpp', cpp)\n    registerLanguage('cs', csharp)\n    registerLanguage('csharp', csharp)\n    registerLanguage('css', css)\n    registerLanguage('dockerfile', dockerfile)\n    registerLanguage('elixir', elixir)\n    registerLanguage('haskell', haskell)\n    registerLanguage('html', xml)\n    registerLanguage('lua', lua)\n    registerLanguage('ocaml', ocaml)\n    registerLanguage('r', rLang)\n    registerLanguage('ruby', ruby)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:44-81"",""content"":""      '@testing-library/jest-dom':\n        specifier: ^6.4.2\n        version: 6.4.2(vitest@1.5.0)\n      '@testing-library/react':\n        specifier: ^14.2.2\n        version: 14.2.2(react-dom@18.2.0)(react@18.2.0)\n      '@types/node':\n        specifier: 20.12.7\n        version: 20.12.7\n      '@types/react':\n        specifier: 18.2.79\n        version: 18.2.79\n      '@types/react-dom':\n        specifier: 18.2.25\n        version: 18.2.25\n      '@vitejs/plugin-react':\n        specifier: ^4.2.1\n        version: 4.2.1(vite@5.2.9)\n      esbuild:\n        specifier: ^0.18.20\n        version: 0.18.20\n      happy-dom:\n        specifier: ^14.3.10\n        version: 14.3.10\n      jsdom:\n        specifier: ^22.1.0\n        version: 22.1.0\n      knip:\n        specifier: ^3.13.2\n        version: 3.13.2(@types/node@20.12.7)(typescript@5.4.2)\n      storybook:\n        specifier: ^8.0.5\n        version: 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      stylelint:\n        specifier: ^15.11.0\n        version: 15.11.0(typescript@5.4.2)\n      stylelint-config-standard:\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4219-4245"",""content"":""      '@storybook/csf-tools': 8.0.5\n      '@storybook/global': 5.0.0\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/react-dom-shim': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/theming': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/types': 8.0.5\n      '@types/react': 18.2.79\n      fs-extra: 11.2.0\n      react: 18.2.0\n      react-dom: 18.2.0(react@18.2.0)\n      rehype-external-links: 3.0.0\n      rehype-slug: 6.0.0\n      ts-dedent: 2.2.0\n    transitivePeerDependencies:\n      - encoding\n      - supports-color\n    dev: true\n\n  /@storybook/addon-essentials@8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0):\n    resolution: {integrity: sha512-1yjwf9ibKn2rVqv+fqxACoIjsaUsimSEx8QwjIl2krDNhMULXzFeVubTQ09gXSVEnHUR1nKX3X9qOXJQ2bOFlQ==}\n    dependencies:\n      '@storybook/addon-actions': 8.0.5\n      '@storybook/addon-backgrounds': 8.0.5\n      '@storybook/addon-controls': 8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/addon-docs': 8.0.5\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:409-453"",""content"":""        version: 10.0.0\n      mkdirp:\n        specifier: ^3.0.1\n        version: 3.0.1\n      os-browserify:\n        specifier: ^0.3.0\n        version: 0.3.0\n      parse-git-diff:\n        specifier: ^0.0.14\n        version: 0.0.14\n      proxy-agent:\n        specifier: ^6.4.0\n        version: 6.4.0\n      re2-wasm:\n        specifier: ^1.0.2\n        version: 1.0.2\n      semver:\n        specifier: ^7.5.4\n        version: 7.6.0\n      socks-proxy-agent:\n        specifier: ^8.0.1\n        version: 8.0.1\n      unzipper:\n        specifier: ^0.10.14\n        version: 0.10.14\n      uuid:\n        specifier: ^9.0.0\n        version: 9.0.0\n      vscode-languageserver-textdocument:\n        specifier: ^1.0.8\n        version: 1.0.8\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n      web-tree-sitter:\n        specifier: ^0.21.0\n        version: 0.21.0\n      wink-nlp-utils:\n        specifier: ^2.1.0\n        version: 2.1.0\n    devDependencies:\n      '@google-cloud/pubsub':\n        specifier: ^3.7.3\n        version: 3.7.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentWorkspaceConfiguration.ts:8-138"",""content"":""export class AgentWorkspaceConfiguration implements vscode.WorkspaceConfiguration {\n    constructor(\n        private prefix: string[],\n        private clientInfo: () => ClientInfo | undefined,\n        private extensionConfig: () => ExtensionConfiguration | undefined,\n        private dictionary: Record<string, any> = {}\n    ) {}\n\n    public withPrefix(prefix: string): AgentWorkspaceConfiguration {\n        return new AgentWorkspaceConfiguration(\n            this.prefix.concat(prefix),\n            this.clientInfo,\n            this.extensionConfig,\n            this.dictionary\n        )\n    }\n\n    private actualSection(section: string): string {\n        if (this.prefix.length === 0) {\n            return section\n        }\n        return [...this.prefix, section].join('.')\n    }\n\n    private clientNameToIDE(value: string): Configuration['agentIDE'] | undefined {\n        switch (value.toLowerCase()) {\n            case 'vscode':\n                return 'VSCode'\n            case 'jetbrains':\n                return 'JetBrains'\n            case 'emacs':\n                return 'Emacs'\n            case 'neovim':\n                return 'Neovim'\n            default:\n                return undefined\n        }\n    }\n\n    public get(userSection: string, defaultValue?: unknown): any {\n        const section = this.actualSection(userSection)\n\n        const fromDictionary = this.dictionary?.[section]\n        if (fromDictionary !== undefined) {\n            return fromDictionary\n        }\n        const extensionConfig = this.extensionConfig()\n\n        const fromCustomConfiguration = extensionConfig?.customConfiguration?.[section]\n        if (fromCustomConfiguration !== undefined) {\n            return fromCustomConfiguration\n        }\n        switch (section) {\n            case 'cody.serverEndpoint':\n                return extensionConfig?.serverEndpoint\n            case 'cody.proxy':\n                return extensionConfig?.proxy ?? null\n            case 'cody.customHeaders':\n                return extensionConfig?.customHeaders\n            case 'cody.telemetry.level':\n                // Use the dedicated `telemetry/recordEvent` to send telemetry from\n                // agent clients.  The reason we disable telemetry via config is\n                // that we don't want to submit vscode-specific events when\n                // running inside the agent.\n                return 'agent'\n            case 'cody.autocomplete.enabled':\n                return true\n            case 'cody.autocomplete.advanced.provider':\n                return extensionConfig?.autocompleteAdvancedProvider ?? null\n            case 'cody.autocomplete.advanced.model':\n                return extensionConfig?.autocompleteAdvancedModel ?? null\n            case 'cody.advanced.agent.running':\n                return true\n            case 'cody.debug.verbose':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.experimental.tracing':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.useContext':\n                // Disable embeddings by default.\n                return 'keyword'\n            case 'cody.codebase':\n                return extensionConfig?.codebase\n            case 'cody.advanced.agent.ide':\n                return this.clientNameToIDE(this.clientInfo()?.name ?? '')\n            case 'editor.insertSpaces':\n                return true // TODO: override from IDE clients\n            default:\n                // VS Code picks up default value in package.json, and only uses\n                // the `defaultValue` parameter if package.json provides no\n                // default.\n                return defaultConfigurationValue(section) ?? defaultValue\n        }\n    }\n\n    public has(section: string): boolean {\n        const actual = this.actualSection(section)\n        for (const key in this.dictionary) {\n            if (key.startsWith(actual)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    public inspect<T>(section: string):\n        | {\n              key: string\n              defaultValue?: T | undefined\n              globalValue?: T | undefined\n              workspaceValue?: T | undefined\n              workspaceFolderValue?: T | undefined\n              defaultLanguageValue?: T | undefined\n              globalLanguageValue?: T | undefined\n              workspaceLanguageValue?: T | undefined\n              workspaceFolderLanguageValue?: T | undefined\n              languageIds?: string[] | undefined\n          }\n        | undefined {\n        return undefined\n    }\n\n    public async update(\n        section: string,\n        value: any,\n        _configurationTarget?: boolean | vscode.ConfigurationTarget | null | undefined,\n        _overrideInLanguage?: boolean | undefined\n    ): Promise<void> {\n        this.dictionary[this.actualSection(section)] = value\n        return Promise.resolve()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/mocks.ts:653-709"",""content"":""            'yaml',\n            'tailwindcss',\n            'editorconfig',\n            'graphql',\n            'vue',\n            'go.mod',\n            'go.work',\n            'go.sum',\n            'gotmpl',\n            'govulncheck',\n            'kotlin',\n            'kotlinscript',\n            'lisp',\n            'toml',\n            'jinja',\n            'pip-requirements',\n            'raw',\n            'prisma',\n            'starlark',\n            'bazel',\n            'bazelrc',\n            'vimrc',\n        ])\n    },\n}\n\nexport enum TextDocumentChangeReason {\n    Undo = 1,\n    Redo = 2,\n}\nexport enum UIKind {\n    Desktop = 1,\n    Web = 2,\n}\n\nexport class FileSystemError extends Error {}\n\nexport const vsCodeMocks = {\n    FileSystemError,\n    FileType,\n    Range,\n    Position,\n    InlineCompletionItem,\n    EventEmitter,\n    EndOfLine,\n    CancellationTokenSource,\n    ThemeColor,\n    ThemeIcon,\n    TreeItem,\n    WorkspaceEdit,\n    UIKind,\n    QuickInputButtons,\n    Uri,\n    languages,\n    env: {\n        uiKind: 1 satisfies vscode_types.UIKind.Desktop,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration-keys.ts:6-9"",""content"":""export function defaultConfigurationValue(key: string): any {\n    const value = (properties as any)[key as any]?.default\n    return value\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:66-97"",""content"":""} from './commands/types'\nexport { CustomCommandType } from './commands/types'\nexport { type DefaultCodyCommands, DefaultChatCommands, DefaultEditCommands } from './commands/types'\nexport { dedupeWith, isDefined, isErrorLike, pluralize } from './common'\nexport { type RangeData, toRangeData, displayLineRange, displayRange } from './common/range'\nexport {\n    ProgrammingLanguage,\n    languageFromFilename,\n    markdownCodeBlockLanguageIDForFilename,\n    extensionForLanguage,\n} from './common/languages'\nexport { renderMarkdown, escapeHTML } from './common/markdown'\nexport { posixFilePaths, pathFunctionsForURI } from './common/path'\nexport { isWindows, isMacOS } from './common/platform'\nexport {\n    assertFileURI,\n    isFileURI,\n    uriBasename,\n    uriDirname,\n    uriExtname,\n    uriParseNameAndExtension,\n    type FileURI,\n} from './common/uri'\nexport type {\n    AutocompleteTimeouts,\n    Configuration,\n    ConfigurationUseContext,\n    ConfigurationWithAccessToken,\n    OllamaGenerateParameters,\n    OllamaOptions,\n    ConfigGetter,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:93-97"",""content"":""export interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1321-1329"",""content"":""    \""ovsx\"": \""^0.8.2\"",\n    \""pako\"": \""^2.1.0\"",\n    \""path-browserify\"": \""^1.0.1\"",\n    \""playwright\"": \""1.39.0\"",\n    \""progress\"": \""^2.0.3\"",\n    \""yaml\"": \""^2.3.4\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:20-86"",""content"":""export interface Configuration {\n    proxy?: string | null\n    codebase?: string\n    debugFilter: RegExp | null\n    debugVerbose: boolean\n    telemetryLevel: 'all' | 'off' | 'agent'\n    useContext: ConfigurationUseContext\n    customHeaders: Record<string, string>\n    chatPreInstruction: PromptString\n    editPreInstruction: PromptString\n    codeActions: boolean\n    commandHints: boolean\n    commandCodeLenses: boolean\n\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/index.md:0-18"",""content"":""## Development\n\n### Setup\n\n1. Install [asdf](https://asdf-vm.com/)\n1. Run `asdf install` (if needed, run `asdf plugin add NAME` for any missing plugins)\n1. Run `pnpm install && pnpm build`\n\n### Build and run the VS Code extension\n\nOpen this repository in VS Code and run the `Launch VS Code Extension (Desktop)` build/debug task (or run `pnpm -C vscode run dev`).\n\nSee [vscode/CONTRIBUTING.md](../../vscode/CONTRIBUTING.md) for more information.\n\n### Other topics\n\n- [Quality tools](quality/index.md)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:28-183"",""content"":""export function getConfiguration(\n    config: ConfigGetter = vscode.workspace.getConfiguration()\n): Configuration {\n    const isTesting = process.env.CODY_TESTING === 'true'\n\n    function getHiddenSetting<T>(configKey: string, defaultValue?: T): T {\n        return config.get<T>(`cody.${configKey}` as any, defaultValue)\n    }\n\n    let debugRegex: RegExp | null = null\n    try {\n        const debugPattern: string | null = config.get<string | null>(CONFIG_KEY.debugFilter, null)\n        if (debugPattern) {\n            if (debugPattern === '*') {\n                debugRegex = /.*/\n            } else {\n                debugRegex = new RegExp(debugPattern)\n            }\n        }\n    } catch (error: any) {\n        void vscode.window.showErrorMessage(\n            \""Error parsing cody.debug.filter regex - using default '*'\"",\n            error\n        )\n        debugRegex = /.*/\n    }\n\n    let autocompleteAdvancedProvider = config.get<\n        | Configuration['autocompleteAdvancedProvider']\n        | 'unstable-ollama'\n        | 'unstable-fireworks'\n        | 'experimental-openaicompatible'\n    >(CONFIG_KEY.autocompleteAdvancedProvider, null)\n\n    // Handle deprecated provider identifiers\n    switch (autocompleteAdvancedProvider) {\n        case 'unstable-fireworks':\n            autocompleteAdvancedProvider = 'fireworks'\n            break\n        case 'unstable-ollama':\n            autocompleteAdvancedProvider = 'experimental-ollama'\n            break\n    }\n\n    // check if the configured enum values are valid\n    const configKeys = [\n        'autocompleteAdvancedProvider',\n        'autocompleteAdvancedModel',\n    ] as (keyof ConfigurationKeysMap)[]\n\n    for (const configVal of configKeys) {\n        const key = configVal.replaceAll(/([A-Z])/g, '.$1').toLowerCase()\n        const value: string | null = config.get(CONFIG_KEY[configVal])\n        checkValidEnumValues(key, value)\n    }\n\n    const autocompleteExperimentalGraphContext: 'bfg' | null = getHiddenSetting(\n        'autocomplete.experimental.graphContext',\n        null\n    )\n\n    return {\n        proxy: config.get<string | null>(CONFIG_KEY.proxy, null),\n        codebase: sanitizeCodebase(config.get(CONFIG_KEY.codebase)),\n        customHeaders: config.get<object>(CONFIG_KEY.customHeaders, {}) as Record<string, string>,\n        useContext: config.get<ConfigurationUseContext>(CONFIG_KEY.useContext) || 'embeddings',\n        debugVerbose: config.get<boolean>(CONFIG_KEY.debugVerbose, false),\n        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n            CONFIG_KEY.autocompleteDisableInsideComments,\n            false\n        ),\n        codeActions: config.get(CONFIG_KEY.codeActionsEnabled, true),\n        commandHints: config.get(CONFIG_KEY.commandHintsEnabled, false),\n\n        /**\n         * Hidden settings for internal use only.\n         */\n\n        internalUnstable: getHiddenSetting('internal.unstable', isTesting),\n\n        autocompleteExperimentalGraphContext,\n        experimentalSimpleChatContext: getHiddenSetting('experimental.simpleChatContext', true),\n        experimentalSymfContext: getHiddenSetting('experimental.symfContext', true),\n\n        experimentalGuardrails: getHiddenSetting('experimental.guardrails', isTesting),\n        experimentalTracing: getHiddenSetting('experimental.tracing', false),\n\n        experimentalOllamaChat: getHiddenSetting('experimental.ollamaChat', false),\n        experimentalSupercompletions: getHiddenSetting('experimental.supercompletions', false),\n\n        experimentalChatContextRanker: getHiddenSetting('experimental.chatContextRanker', false),\n\n        autocompleteExperimentalHotStreak: getHiddenSetting(\n            'autocomplete.experimental.hotStreak',\n            false\n        ),\n        autocompleteExperimentalOllamaOptions: getHiddenSetting(\n            'autocomplete.experimental.ollamaOptions',\n            {\n                url: OLLAMA_DEFAULT_URL,\n                model: 'codellama:7b-code',\n            }\n        ),\n        autocompleteExperimentalFireworksOptions: getHiddenSetting(\n            'autocomplete.experimental.fireworksOptions',\n            undefined\n        ),\n        autocompleteExperimentalSmartThrottle: getHiddenSetting(\n            'autocomplete.experimental.smartThrottle',\n            false\n        ),\n\n        // Note: In spirit, we try to minimize agent-specific code paths in the VSC extension.\n        // We currently use this flag for the agent to provide more helpful error messages\n        // when something goes wrong, and to suppress event logging in the agent.\n        // Rely on this flag sparingly.\n        isRunningInsideAgent: getHiddenSetting('advanced.agent.running', false),\n        agentIDE: getHiddenSetting<'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'>('advanced.agent.ide'),\n        autocompleteTimeouts: {\n            multiline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.multiline',\n                undefined\n            ),\n            singleline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.singleline',\n                undefined\n            ),\n        },\n\n        testingLocalEmbeddingsModel: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.model', undefined)\n            : undefined,\n        testingLocalEmbeddingsEndpoint: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.endpoint', undefined)\n            : undefined,\n        testingLocalEmbeddingsIndexLibraryPath: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.indexLibraryPath', undefined)\n            : undefined,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:24-32"",""content"":""    \""watch:build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""watch:build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""_build:esbuild:desktop\"": \""pnpm download-wasm && esbuild ./src/extension.node.ts --bundle --outfile=dist/extension.node.js --external:vscode --format=cjs --platform=node --sourcemap\"",\n    \""_build:esbuild:web\"": \""esbuild ./src/extension.web.ts --platform=browser --bundle --outfile=dist/extension.web.js --alias:path=path-browserify --alias:node:path=path-browserify --alias:node:os=os-browserify --external:vscode --define:process='{\\\""env\\\"":{}}' --define:window=self --format=cjs --sourcemap\"",\n    \""_build:webviews\"": \""vite -c webviews/vite.config.ts build\"",\n    \""release\"": \""ts-node-transpile-only ./scripts/release.ts\"",\n    \""download-wasm\"": \""ts-node-transpile-only ./scripts/download-wasm-modules.ts\"",\n    \""release:dry-run\"": \""pnpm run download-wasm && CODY_RELEASE_DRY_RUN=1 ts-node ./scripts/release.ts\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/CodePrinter.ts:43-45"",""content"":""    public build(): string {\n        return this.out.join('')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/package.json:64-78"",""content"":""    \""@types/diff\"": \""^5.0.9\"",\n    \""@types/google-protobuf\"": \""3.15.12\"",\n    \""@types/minimatch\"": \""^5.1.2\"",\n    \""@types/uuid\"": \""^9.0.2\"",\n    \""@types/vscode\"": \""^1.80.0\"",\n    \""@types/ws\"": \""^8.5.10\"",\n    \""diff\"": \""^5.2.0\"",\n    \""esbuild\"": \""^0.18.19\"",\n    \""google-protobuf\"": \""^3.21.2\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""pkg\"": \""^5.8.1\"",\n    \""rimraf\"": \""^5.0.5\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/custom-commands.ts:147-174"",""content"":""    public async build(type: CustomCommandType): Promise<Map<string, CodyCommand> | null> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri || (type === CustomCommandType.Workspace && !vscode.workspace.isTrusted)) {\n            return null\n        }\n        try {\n            const content = await getDocText(uri)\n            if (!content.trim()) {\n                return null\n            }\n            const customCommandsMap = buildCodyCommandMap(type, content)\n            this.customCommandsMap = new Map([...this.customCommandsMap, ...customCommandsMap])\n\n            // Register Custom Commands as VS Code commands\n            for (const [key, _command] of customCommandsMap) {\n                this.registeredCommands.push(\n                    vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>\n                        vscode.commands.executeCommand('cody.action.command', key, {\n                            source: 'editor',\n                        })\n                    )\n                )\n            }\n        } catch (error) {\n            console.error('CustomCommandsProvider:build', 'failed', { verbose: error })\n        }\n        return this.customCommandsMap\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/prompt-builder/index.ts:39-41"",""content"":""    public build(): Message[] {\n        return this.prefixMessages.concat([...this.reverseMessages].reverse())\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:97-130"",""content"":""} from './configuration'\nexport { NoopEditor } from './editor'\nexport type {\n    ActiveTextEditor,\n    ActiveTextEditorDiagnostic,\n    ActiveTextEditorDiagnosticType,\n    ActiveTextEditorSelection,\n    ActiveTextEditorVisibleContent,\n    Editor,\n} from './editor'\nexport {\n    displayPath,\n    displayPathBasename,\n    displayPathDirname,\n    displayPathWithoutWorkspaceFolderPrefix,\n    setDisplayPathEnvInfo,\n    type DisplayPathEnvInfo,\n} from './editor/displayPath'\nexport { hydrateAfterPostMessage } from './editor/hydrateAfterPostMessage'\nexport * from './editor/utils'\nexport {\n    FeatureFlag,\n    FeatureFlagProvider,\n    featureFlagProvider,\n} from './experimentation/FeatureFlagProvider'\nexport { GuardrailsPost, summariseAttribution } from './guardrails'\nexport type { Attribution, Guardrails } from './guardrails'\nexport { SourcegraphGuardrailsClient } from './guardrails/client'\nexport {\n    CompletionStopReason,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type CompletionResponseGenerator,\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_012/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The model used for edits is configured in a few places:

1. **`editModel.get()` in `cody_test/vscode/src/models/index.ts`:** This function retrieves the currently selected model from local storage. It prioritizes the user's selection, but defaults to the first available model if the user hasn't made a selection or if they are a free user.

2. **`getEditModelsForUser()` in `cody_test/vscode/src/edit/utils/edit-models.ts`:** This function retrieves the list of available edit models based on the user's authentication status. It filters the models based on whether the user is a free or Pro user.

3. **`getOverridenModelForIntent()` in `cody_test/vscode/src/edit/utils/edit-models.ts`:** This function overrides the selected model based on the specific edit intent. For example, it uses a different model for ""fix"" intents to ensure a more reliable result.

4. **`EditManager.startEdit()` in `cody_test/vscode/src/edit/provider.ts`:** This function uses the `model` property of the `FixupTask` to determine the model to use for the edit. The `FixupTask` is created based on the user's input and configuration.

5. **`EditInput.render()` in `cody_test/vscode/src/edit/input/index.ts`:** This function allows the user to select a different model for the edit through a quick pick menu. The selected model is then used to create the `FixupTask`.

Therefore, the model used for edits is configured through a combination of user selection, authentication status, edit intent, and default settings.",Where is the model used for edits configured?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:27-52"",""content"":""export const getModelOptionItems = (\n    modelOptions: ModelProvider[],\n    isCodyPro: boolean\n): EditModelItem[] => {\n    const allOptions = modelOptions.map(modelOption => {\n        const icon = getModelProviderIcon(modelOption.provider)\n        return {\n            label: `${QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX} ${icon} ${modelOption.title}`,\n            description: `by ${modelOption.provider}`,\n            alwaysShow: true,\n            model: modelOption.model,\n            modelTitle: modelOption.title,\n            codyProOnly: modelOption.codyProOnly,\n        }\n    })\n\n    if (!isCodyPro) {\n        return [\n            ...allOptions.filter(option => !option.codyProOnly),\n            { label: 'upgrade to cody pro', kind: vscode.QuickPickItemKind.Separator } as EditModelItem,\n            ...allOptions.filter(option => option.codyProOnly),\n        ]\n    }\n\n    return allOptions\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/chat/markdown.ts:76-79"",""content"":""        ...options,\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:10-25"",""content"":""const getModelProviderIcon = (provider: string): string => {\n    switch (provider) {\n        case 'Anthropic':\n            return '$(anthropic-logo)'\n        case 'OpenAI':\n            return '$(openai-logo)'\n        case 'Mistral':\n            return '$(mistral-logo)'\n        case 'Ollama':\n            return '$(ollama-logo)'\n        case 'Google':\n            return '$(gemini-logo)'\n        default:\n            return ''\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-input.ts:511-526"",""content"":""                    instruction: instruction.trim(),\n                    userContextFiles: Array.from(selectedContextItems)\n                        .filter(([key]) => instruction.toString().includes(`@${key}`))\n                        .map(([, value]) => value),\n                    model: activeModel,\n                    range: activeRange,\n                    intent: isGenerateIntent(document, activeRange) ? 'add' : 'edit',\n                })\n            },\n        })\n\n        editInput.render(activeTitle, initialValues.initialInputValue?.toString() || '')\n        editInput.input.activeItems = []\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:54-74"",""content"":""export const getModelInputItems = (\n    modelOptions: ModelProvider[],\n    activeModel: EditModel,\n    isCodyPro: boolean\n): GetItemsResult => {\n    const modelItems = getModelOptionItems(modelOptions, isCodyPro)\n    const activeItem = modelItems.find(item => item.model === activeModel)\n\n    if (activeItem) {\n        // Update the label of the active item\n        activeItem.label = activeItem.label.replace(\n            QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX,\n            QUICK_PICK_ITEM_CHECKED_PREFIX\n        )\n    }\n\n    return {\n        items: modelItems,\n        activeItem,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/constants.ts:0-5"",""content"":""import type { EditIntent, EditMode } from './types'\n\nexport const DEFAULT_EDIT_MODE: EditMode = 'edit'\nexport const DEFAULT_EDIT_INTENT: EditIntent = 'edit'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/types.ts:0-13"",""content"":""import type { EditModel } from '@sourcegraph/cody-shared'\nimport type * as vscode from 'vscode'\n\nexport interface EditRangeItem extends vscode.QuickPickItem {\n    range: vscode.Range | (() => Promise<vscode.Range>)\n}\n\nexport interface EditModelItem extends vscode.QuickPickItem {\n    modelTitle: string\n    model: EditModel\n    codyProOnly: boolean\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/openai.ts:14-19"",""content"":""    getEdit(options) {\n        return {\n            ...SHARED_PARAMETERS,\n            prompt: buildGenericPrompt('edit', options),\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/index.ts:0-29"",""content"":""import { fetchLocalOllamaModels } from '../llm-providers/ollama/utils'\nimport { CHAT_INPUT_TOKEN_BUDGET, CHAT_OUTPUT_TOKEN_BUDGET } from '../token/constants'\nimport type { ModelContextWindow } from './types'\nimport type { ModelUsage } from './types'\nimport { getModelInfo } from './utils'\n\n/**\n * ModelProvider manages available chat and edit models.\n * It stores a set of available providers and methods to add,\n * retrieve and select between them.\n */\nexport class ModelProvider {\n    // Whether the model is the default model\n    public default = false\n    // Whether the model is only available to Pro users\n    public codyProOnly = false\n    // The name of the provider of the model, e.g. \""Anthropic\""\n    public provider: string\n    // The title of the model, e.g. \""Claude 2.0\""\n    public readonly title: string\n\n    constructor(\n        /**\n         * The model id that includes the provider name & the model name,\n         * e.g. \""anthropic/claude-2.0\""\n         */\n        public readonly model: string,\n        /**\n         * The usage of the model, e.g. chat or edit.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/index.ts:0-25"",""content"":""import type { ChatModel, EditModel, ModelProvider } from '@sourcegraph/cody-shared'\nimport type { AuthProvider } from '../services/AuthProvider'\nimport { localStorage } from '../services/LocalStorageProvider'\n\nasync function setModel(modelID: EditModel, storageKey: string) {\n    // Store the selected model in local storage to retrieve later\n    return localStorage.set(storageKey, modelID)\n}\n\nfunction getModel<T extends string>(\n    authProvider: AuthProvider,\n    models: ModelProvider[],\n    storageKey: string\n): T {\n    const authStatus = authProvider.getAuthStatus()\n    // Free user can only use the default model\n    if (authStatus.isDotCom && authStatus.userCanUpgrade) {\n        return models[0].model as T\n    }\n\n    // Enterprise user can only use the default model\n    // We only support a single model for enterprise users right now\n    if (!authStatus.isDotCom) {\n        return models[0].model as T\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/claude.ts:15-20"",""content"":""    getEdit(options) {\n        return {\n            ...SHARED_PARAMETERS,\n            prompt: buildGenericPrompt('edit', options),\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/index.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    BotResponseMultiplexer,\n    type ChatMessage,\n    type CompletionParameters,\n    type EditModel,\n    type Message,\n    ModelProvider,\n    PromptString,\n    TokenCounter,\n    getSimplePreamble,\n    ps,\n} from '@sourcegraph/cody-shared'\n\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { FixupTask } from '../../non-stop/FixupTask'\nimport type { EditIntent } from '../types'\n\nimport { PromptBuilder } from '../../prompt-builder'\nimport { getContext } from './context'\nimport { claude } from './models/claude'\nimport { openai } from './models/openai'\nimport type { EditLLMInteraction, GetLLMInteractionOptions, LLMInteraction } from './type'\n\nconst INTERACTION_MODELS: Record<EditModel, EditLLMInteraction> = {\n    'anthropic/claude-2.0': claude,\n    'anthropic/claude-2.1': claude,\n    'anthropic/claude-instant-1.2': claude,\n    'anthropic/claude-3-opus-20240229': claude,\n    'anthropic/claude-3-sonnet-20240229': claude,\n    'anthropic/claude-3-haiku-20240307': claude,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/edit.ts:9-12"",""content"":""export const MODEL_ITEM: vscode.QuickPickItem = {\n    label: 'Model',\n    alwaysShow: true,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/manager.ts:98-122"",""content"":""\n        const editor = getEditor()\n        if (editor.ignored) {\n            void vscode.window.showInformationMessage('Cannot edit Cody ignored file.')\n            return\n        }\n\n        const document = configuration.document || editor.active?.document\n        if (!document) {\n            void vscode.window.showErrorMessage('Please open a file before running a command.')\n            return\n        }\n\n        const proposedRange = configuration.range || editor.active?.selection\n        if (!proposedRange) {\n            return\n        }\n\n        // Set default edit configuration, if not provided\n        // It is possible that these values may be overriden later, e.g. if the user changes them in the edit input.\n        const range = getEditLineSelection(document, proposedRange)\n        const mode = configuration.mode || DEFAULT_EDIT_MODE\n        const model = configuration.model || editModel.get(this.options.authProvider, this.models)\n        const intent = getEditIntent(document, range, configuration.intent)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/utils.ts:85-106"",""content"":""export function getChatModelsFromConfiguration(): ModelProvider[] {\n    const codyConfig = vscode.workspace.getConfiguration('cody')\n    const modelsConfig = codyConfig?.get<ChatModelProviderConfig[]>('dev.models')\n    if (!modelsConfig?.length) {\n        return []\n    }\n\n    const providers: ModelProvider[] = []\n    for (const m of modelsConfig) {\n        const provider = new ModelProvider(\n            `${m.provider}/${m.model}`,\n            [ModelUsage.Chat, ModelUsage.Edit],\n            { input: m.inputTokens ?? CHAT_INPUT_TOKEN_BUDGET, output: m.outputTokens ?? ANSWER_TOKENS },\n            { apiKey: m.apiKey, apiEndpoint: m.apiEndpoint }\n        )\n        provider.codyProOnly = true\n        providers.push(provider)\n    }\n\n    ModelProvider.addProviders(providers)\n    return providers\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/provider.ts:28-55"",""content"":""\ninterface EditProviderOptions extends EditManagerOptions {\n    task: FixupTask\n    controller: FixupController\n}\n\n// Initiates a completion and responds to the result from the LLM. Implements\n// \""tools\"" like directing the response into a specific file. Code is forwarded\n// to the FixupTask.\nexport class EditProvider {\n    private insertionResponse: string | null = null\n    private insertionInProgress = false\n    private insertionPromise: Promise<void> | null = null\n    private abortController: AbortController | null = null\n\n    constructor(public config: EditProviderOptions) {}\n\n    public async startEdit(): Promise<void> {\n        return wrapInActiveSpan('command.edit.start', async span => {\n            this.config.controller.startTask(this.config.task)\n            const model = this.config.task.model\n            const contextWindow = ModelProvider.getContextWindowByID(model)\n            const {\n                messages,\n                stopSequences,\n                responseTopic,\n                responsePrefix = '',\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:17-20"",""content"":""export function useCurrentChatModel(): ModelProvider | undefined {\n    const { chatModels } = useChatModelContext()\n    return chatModels?.find(model => model.default) ?? chatModels?.[0]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:48-63"",""content"":""- [ ] Verify that you can see a list of code lenses with a Cody icon above the generated code: `Show diff`, `Accept`, `Retry`, and `Undo`.\n- [ ] Verify that you can see a diff view of the edit in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the edit by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Editing code (Additional Configuration)\n\n- [ ] Highlight a section of code.\n- [ ] Trigger the Edit shortcut with Option+K\n- [ ] Try to add a file to the Edit instruction, by using \""@\"" and searching for a file\n- [ ] Try to add a symbol to the Edit instruction, by using \""@#\"" and searching for a symbol\n- [ ] Try to change the range of the Edit, by selecting \""Range\"". Check that navigating through the options correctly updates the range shown in the editor.\n- [ ] Try to change the model of the Edit, by selecting \""Model\"".\n- [ ] Submit edits after changing the above values, and check that the Edit performs correctly (e.g. uses correct range, uses correct context)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15"",""content"":""export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/types.ts:0-13"",""content"":""/**\n * The intent classification for the edit.\n * Manually determined depending on how the edit is triggered.\n */\nexport type EditIntent = 'add' | 'edit' | 'fix' | 'doc' | 'test'\n\n/**\n * The edit modes that can be used when applying an edit.\n * - 'edit': Modify selected code in place.\n * - 'insert': Insert new code at the selected location.\n */\nexport type EditMode = 'edit' | 'insert'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/index.ts:50-53"",""content"":""\nexport const chatModel = createModelAccessor<ChatModel>('model')\nexport const editModel = createModelAccessor<EditModel>('editModel')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/utils/edit-models.ts:0-27"",""content"":""import { type AuthStatus, type EditModel, ModelProvider, ModelUsage } from '@sourcegraph/cody-shared'\nimport type { EditIntent } from '../types'\n\nexport function getEditModelsForUser(authStatus: AuthStatus): ModelProvider[] {\n    return ModelProvider.getProviders(ModelUsage.Edit, !authStatus.userCanUpgrade)\n}\n\nexport function getOverridenModelForIntent(intent: EditIntent, currentModel: EditModel): EditModel {\n    switch (intent) {\n        case 'fix':\n            // Fix is a case where we want to ensure that users do not end up with a broken edit model.\n            // It is outside of the typical Edit flow so it is more likely a user could become \""stuck\"" here.\n            // TODO: Make the model usage more visible to users outside of the normal edit flow. This means\n            // we could let the user provide any model they want for `fix`.\n            // Issue: https://github.com/sourcegraph/cody/issues/3512\n            return 'anthropic/claude-3-sonnet-20240229'\n        case 'doc':\n            // Doc is a case where we can sacrifice LLM performnace for improved latency and get comparable results.\n            return 'anthropic/claude-3-haiku-20240307'\n        case 'test':\n        case 'add':\n        case 'edit':\n            // Support all model usage for add and edit intents.\n            return currentModel\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/manager.ts:25-50"",""content"":""import { getEditIntent } from './utils/edit-intent'\nimport { getEditModelsForUser } from './utils/edit-models'\nimport { getEditLineSelection, getEditSmartSelection } from './utils/edit-selection'\n\nexport interface EditManagerOptions {\n    editor: VSCodeEditor\n    chat: ChatClient\n    ghostHintDecorator: GhostHintDecorator\n    authProvider: AuthProvider\n    extensionClient: ExtensionClient\n}\n\n// EditManager handles translating specific edit intents (document, edit) into\n// generic FixupTasks, and pairs a FixupTask with an EditProvider to generate\n// a completion.\nexport class EditManager implements vscode.Disposable {\n    private readonly controller: FixupController\n    private disposables: vscode.Disposable[] = []\n    private editProviders = new WeakMap<FixupTask, EditProvider>()\n    private models: ModelProvider[] = []\n\n    constructor(public options: EditManagerOptions) {\n        this.controller = new FixupController(options.authProvider, options.extensionClient)\n        /**\n         * Entry point to triggering a new Edit.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:86-114"",""content"":""### Changed\n\n- Chat: A new design for chat messages, with avatars and a separate context row. [pull/3639](https://github.com/sourcegraph/cody/pull/3639)\n- Chat: The Enhanced Context Settings modal is opened by default for the first chat session. [pull/3547](https://github.com/sourcegraph/cody/pull/3547)\n- Add information on which Cody tier is being used to analytics events. [pull/3508](https://github.com/sourcegraph/cody/pull/3508)\n- Auth: Enable the new onboarding flow that does not require the redirect back to VS Code for everyone. [pull/3574](https://github.com/sourcegraph/cody/pull/3574)\n- Chat: Claude 3 Sonnet is now the default model for every Cody Free or Pro user. [pull/3575](https://github.com/sourcegraph/cody/pull/3575)\n- Edit: Removed a previous Edit shortcut (`Shift+Cmd/Ctrl+v`), use `Opt/Alt+K` to trigger Edits. [pull/3591](https://github.com/sourcegraph/cody/pull/3591)\n- Commands: The `Editor Title Icon` configuration option has been removed from the Cody Settings menu. Users can configure the title bar icon by right-clicking on the title bar. [pull/3677](https://github.com/sourcegraph/cody/pull/3677)\n\n### Feature Flags\n\n> This section covers experiments that run behind feature flags for non-Enterprise users.\n\n- Hover Commands: Cody commands are now integrated with the native hover provider, allowing you to seamlessly access essential commands on mouse hover. [pull/3585](https://github.com/sourcegraph/cody/pull/3585)\n\n## [1.10.2]\n\n### Added\n\n- Cody Enterprise users now have access to an `experimental-openaicompatible` which allows bringing your own LLM via any OpenAI-compatible API. For now, this is only supported with Starchat and specific configurations - but we continue to generalize this work to support more models and OpenAI-compatible endpoints. [pull/3218](https://github.com/sourcegraph/cody/pull/3218)\n\n## [1.10.1]\n\n### Added\n\n- Autocomplete: Add Claude 3 Haiku experimental autocomplete support. [pull/3538](https://github.com/sourcegraph/cody/pull/3538)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/types.ts:0-62"",""content"":""import type { ModelProvider } from '.'\n\nexport enum ModelUsage {\n    Chat = 'chat',\n    Edit = 'edit',\n}\n\n// Utility to narrow a model type to a specific model usage\ntype HasUsage<T, I> = T extends { usage: readonly ModelUsage[] }\n    ? I extends T['usage'][number]\n        ? T\n        : never\n    : never\n\ntype Models = typeof ModelProvider\n\n/**\n * Available models for Edit.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type EditModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Edit>\n      }[keyof Models]['model']\n    | (string & {})\n\n/**\n * Available models for Chat.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type ChatModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Chat>\n      }[keyof Models]['model']\n    | (string & {})\n\nexport interface ModelContextWindow {\n    /**\n     * The token limit reserved for chat input.\n     */\n    input: number\n    /**\n     * The maximum number of tokens that the model can respond with in a single request.\n     */\n    output: number\n    /**\n     * The additional tokens reserved for context.\n     * When not defined, context shares the same token limit as input.\n     */\n    context?: {\n        /**\n         * The token limit reserved for user-added context.\n         * Example: @-mentions.\n         */\n        user?: number\n    }\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_013/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for calling the Sourcegraph API is located in the `SourcegraphGraphQLAPIClient` class, defined in the file `cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts`. 

Here's how it works:

1. **Constructor:** The class takes a `GraphQLAPIClientConfig` object as an argument, which contains information about the Sourcegraph instance to connect to, including the server endpoint, access token, and custom headers.
2. **Methods:** The class provides various methods for interacting with the Sourcegraph API, such as:
    - `getSiteVersion()`: Fetches the Sourcegraph version.
    - `getSiteIdentification()`: Fetches the site ID and hashed license key.
    - `getSiteHasIsCodyEnabledField()`: Checks if the `isCodyEnabled` field exists in the Sourcegraph GraphQL schema.
    - `getSiteHasCodyEnabled()`: Checks the value of the `isCodyEnabled` field.
    - `getCurrentUserId()`: Fetches the current user ID.
    - `getCurrentUserCodyProEnabled()`: Checks if the current user has Cody Pro enabled.
    - `getCurrentUserCodySubscription()`: Fetches the current user's Cody subscription details.
    - `getCurrentUserInfo()`: Fetches the current user's information.
    - `getCodyConfigFeatures()`: Fetches the Cody configuration features enabled by the site administrator.
    - `getCodyLLMConfiguration()`: Fetches the Cody LLM configuration for the current instance.
    - `getRepoList()`: Fetches a list of repositories.
    - `getRepoId()`: Fetches the ID of a repository given its name.
    - `getRepoIds()`: Fetches the IDs of multiple repositories given their names.
    - `contextSearch()`: Performs a context search across a set of repositories.
    - `contextFilters()`: Fetches the context filters for the current instance.
    - `isCodyEnabled()`: Checks if Cody is enabled on the current Sourcegraph instance.
    - `recordTelemetryEvents()`: Records telemetry events using the new Sourcegraph Telemetry API.
    - `logEvent()`: Logs events using the legacy event-logging mechanism.
    - `searchAttribution()`: Performs a search attribution query.
    - `getEvaluatedFeatureFlags()`: Fetches the evaluated feature flags for the current user.
    - `evaluateFeatureFlag()`: Evaluates a specific feature flag.

3. **`fetchSourcegraphAPI()`:** This private method is responsible for making the actual GraphQL requests to the Sourcegraph API. It takes the GraphQL query and variables as arguments, constructs the request headers, and sends the request using the `fetch` API.

4. **`fetchSourcegraphDotcomAPI()`:** This private method is used for making anonymous requests to the Sourcegraph.com API.

5. **`fetchSourcegraphTestingAPI()`:** This private method is used for making requests to the Sourcegraph Testing API for logging events during testing.

The `SourcegraphGraphQLAPIClient` class provides a centralized way to interact with the Sourcegraph API from different parts of the codebase. It handles authentication, error handling, and other common tasks, making it easier to use the API.",Where is the functionality for calling the Sourcegraph API?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/nodeClient.ts:20-243"",""content"":""export class SourcegraphNodeCompletionsClient extends SourcegraphCompletionsClient {\n    protected _streamWithCallbacks(\n        params: CompletionParameters,\n        apiVersion: number,\n        cb: CompletionCallbacks,\n        signal?: AbortSignal\n    ): void {\n        const url = new URL(this.completionsEndpoint)\n        if (apiVersion >= 1) {\n            url.searchParams.append('api-version', '' + apiVersion)\n        }\n\n        tracer.startActiveSpan(`POST ${url.toString()}`, span => {\n            span.setAttributes({\n                fast: params.fast,\n                maxTokensToSample: params.maxTokensToSample,\n                temperature: params.temperature,\n                topK: params.topK,\n                topP: params.topP,\n                model: params.model,\n            })\n\n            if (isTemperatureZero) {\n                params = {\n                    ...params,\n                    temperature: 0,\n                }\n            }\n\n            // TODO - Centralize this logic in a single place\n            const [provider] = params.model?.split('/') ?? []\n            if (provider === 'ollama') {\n                ollamaChatClient(params, cb, this.completionsEndpoint, this.logger, signal)\n                return\n            }\n            if (provider === 'google') {\n                googleChatClient(params, cb, this.completionsEndpoint, this.logger, signal)\n                return\n            }\n            if (provider === 'groq') {\n                groqChatClient(params, cb, this.completionsEndpoint, this.logger, signal)\n                return\n            }\n\n            const log = this.logger?.startCompletion(params, url.toString())\n\n            const requestFn = url.protocol === 'https:' ? https.request : http.request\n\n            // Keep track if we have send any message to the completion callbacks\n            let didSendMessage = false\n            let didSendError = false\n            let didReceiveAnyEvent = false\n\n            // Call the error callback only once per request.\n            const onErrorOnce = (error: Error, statusCode?: number | undefined): void => {\n                if (!didSendError) {\n                    recordErrorToSpan(span, error)\n                    cb.onError(error, statusCode)\n                    didSendMessage = true\n                    didSendError = true\n                }\n            }\n\n            // Text which has not been decoded as a server-sent event (SSE)\n            let bufferText = ''\n\n            const request = requestFn(\n                url,\n                {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        // Disable gzip compression since the sg instance will start to batch\n                        // responses afterwards.\n                        'Accept-Encoding': 'gzip;q=0',\n                        ...(this.config.accessToken\n                            ? { Authorization: `token ${this.config.accessToken}` }\n                            : null),\n                        ...(customUserAgent ? { 'User-Agent': customUserAgent } : null),\n                        ...this.config.customHeaders,\n                        ...getTraceparentHeaders(),\n                    },\n                    // So we can send requests to the Sourcegraph local development instance, which has an incompatible cert.\n                    rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0',\n                },\n                (res: http.IncomingMessage) => {\n                    const { 'set-cookie': _setCookie, ...safeHeaders } = res.headers\n                    span.addEvent('response', {\n                        ...safeHeaders,\n                        status: res.statusCode,\n                    })\n\n                    if (res.statusCode === undefined) {\n                        throw new Error('no status code present')\n                    }\n\n                    // Calls the error callback handler for an error.\n                    //\n                    // If the request failed with a rate limit error, wraps the\n                    // error in RateLimitError.\n                    function handleError(e: Error): void {\n                        log?.onError(e.message, e)\n\n                        if (res.statusCode === 429) {\n                            // Check for explicit false, because if the header is not set, there\n                            // is no upgrade available.\n                            const upgradeIsAvailable =\n                                typeof res.headers['x-is-cody-pro-user'] !== 'undefined' &&\n                                res.headers['x-is-cody-pro-user'] === 'false'\n                            const retryAfter = res.headers['retry-after']\n\n                            const limit = res.headers['x-ratelimit-limit']\n                                ? getHeader(res.headers['x-ratelimit-limit'])\n                                : undefined\n\n                            const error = new RateLimitError(\n                                'chat messages and commands',\n                                e.message,\n                                upgradeIsAvailable,\n                                limit ? parseInt(limit, 10) : undefined,\n                                retryAfter\n                            )\n                            onErrorOnce(error, res.statusCode)\n                        } else {\n                            onErrorOnce(e, res.statusCode)\n                        }\n                    }\n\n                    // For failed requests, we just want to read the entire body and\n                    // ultimately return it to the error callback.\n                    if (res.statusCode >= 400) {\n                        // Bytes which have not been decoded as UTF-8 text\n                        let bufferBin = Buffer.of()\n                        // Text which has not been decoded as a server-sent event (SSE)\n                        let errorMessage = ''\n                        res.on('data', chunk => {\n                            if (!(chunk instanceof Buffer)) {\n                                throw new TypeError('expected chunk to be a Buffer')\n                            }\n                            // Messages are expected to be UTF-8, but a chunk can terminate\n                            // in the middle of a character\n                            const { str, buf } = toPartialUtf8String(Buffer.concat([bufferBin, chunk]))\n                            errorMessage += str\n                            bufferBin = buf\n                        })\n\n                        res.on('error', e => handleError(e))\n                        res.on('end', () => handleError(new Error(errorMessage)))\n                        return\n                    }\n\n                    // Bytes which have not been decoded as UTF-8 text\n                    let bufferBin = Buffer.of()\n\n                    res.on('data', chunk => {\n                        if (!(chunk instanceof Buffer)) {\n                            throw new TypeError('expected chunk to be a Buffer')\n                        }\n                        // text/event-stream messages are always UTF-8, but a chunk\n                        // may terminate in the middle of a character\n                        const { str, buf } = toPartialUtf8String(Buffer.concat([bufferBin, chunk]))\n                        bufferText += str\n                        bufferBin = buf\n\n                        const parseResult = parseEvents(bufferText)\n                        if (isError(parseResult)) {\n                            logError(\n                                'SourcegraphNodeCompletionsClient',\n                                'isError(parseEvents(bufferText))',\n                                parseResult\n                            )\n                            return\n                        }\n\n                        didSendMessage = true\n                        didReceiveAnyEvent = didReceiveAnyEvent || parseResult.events.length > 0\n                        log?.onEvents(parseResult.events)\n                        this.sendEvents(parseResult.events, cb, span)\n                        bufferText = parseResult.remainingBuffer\n                    })\n\n                    res.on('error', e => handleError(e))\n                }\n            )\n\n            request.on('error', e => {\n                let error = e\n                if (error.message.includes('ECONNREFUSED')) {\n                    error = new Error(\n                        'Could not connect to Cody. Please ensure that you are connected to the Sourcegraph server.'\n                    )\n                }\n                log?.onError(error.message, e)\n                onErrorOnce(error)\n            })\n\n            // If the connection is closed and we did neither:\n            //\n            // - Receive an error HTTP code\n            // - Or any request body\n            //\n            // We still want to close the request.\n            request.on('close', () => {\n                if (!didReceiveAnyEvent) {\n                    logError(\n                        'SourcegraphNodeCompletionsClient',\n                        \""request.on('close')\"",\n                        'Connection closed without receiving any events',\n                        { verbose: { bufferText } }\n                    )\n                    onErrorOnce(new Error('Connection closed without receiving any events'))\n                }\n                if (!didSendMessage) {\n                    onErrorOnce(new Error('Connection unexpectedly closed'))\n                }\n            })\n\n            request.write(JSON.stringify(params))\n            request.end()\n\n            onAbort(signal, () => request.destroy())\n        })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:170-198"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?CurrentSiteCodyLlmConfiguration\n      response:\n        bodySize: 215\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 215\n          text: \""[\\\""H4sIAAAAAAAAA4TOMQ7CMAxA0bt4bkXajaxdm40LWElKI4JdNS4CVbk7ShdQBpgsWd9P3\\\n            sGhIOgdUhBfpmX3GkczME3huq0ogenYzyiGnY+gAUnmlZdgTzbi\\\"",\\\""5nzbQ/MJDD4\\\n            vfPOUQHe9UqqBCZMMv+4DJUGStoMq/rLOB2X5vkRfnvqLPYpW9ZWXc85vAAAA//8DAC\\\n            mc8DoDAQAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:34:09 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.vscode/extensions.json:0-10"",""content"":""{\n  \""recommendations\"": [\n    \""sourcegraph.cody-ai\"",\n    \""editorconfig.editorconfig\"",\n    \""ecmel.vscode-html-css\"",\n    \""biomejs.biome\"",\n    \""stylelint.vscode-stylelint\""\n  ]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:182-216"",""content"":""\n                  ```\n\n                  client/web/node_modules\n\n                  client/web-sveltekit/node_modules\n\n                  client/wildcard/node_modules\n\n                  dev/release/node_modules\n\n\n                  cmd/symbols/squirrel/test_repos/starlark\n\n\n                  # Generated by local tools\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /client/shared/src/codeintel/legacy-extensions/search/providers.ts\n                  in repository github.com/sourcegraph/sourcegraph:\n\n                  ```typescript\n\n                  import { getConfig } from './config'\n\n                  import { type Result, resultToLocation, searchResultToResults } from './conversion'\n\n                  import { findDocstring } from './docstrings'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:91-141"",""content"":""    public stream(\n        params: CompletionParameters,\n        apiVersion: number,\n        signal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        // Provide default stop sequence for starchat models.\n        if (!params.stopSequences && params?.model?.startsWith('openaicompatible/starchat')) {\n            params.stopSequences = ['<|end|>']\n        }\n\n        // This is a technique to convert a function that takes callbacks to an async generator.\n        const values: Promise<CompletionGeneratorValue>[] = []\n        let resolve: ((value: CompletionGeneratorValue) => void) | undefined\n        values.push(\n            new Promise(r => {\n                resolve = r\n            })\n        )\n\n        const send = (value: CompletionGeneratorValue): void => {\n            resolve!(value)\n            values.push(\n                new Promise(r => {\n                    resolve = r\n                })\n            )\n        }\n        const callbacks: CompletionCallbacks = {\n            onChange(text) {\n                send({ type: 'change', text })\n            },\n            onComplete() {\n                send({ type: 'complete' })\n            },\n            onError(error, statusCode) {\n                send({ type: 'error', error, statusCode })\n            },\n        }\n        this._streamWithCallbacks(params, apiVersion, callbacks, signal)\n\n        return (async function* () {\n            for (let i = 0; ; i++) {\n                const val = await values[i]\n                delete values[i]\n                yield val\n                if (val.type === 'complete' || val.type === 'error') {\n                    break\n                }\n            }\n        })()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:32-60"",""content"":""/**\n * Access the chat based LLM APIs via a Sourcegraph server instance.\n *\n * 🚨 SECURITY: It is the caller's responsibility to ensure context from\n * all cody ignored files are removed before sending requests to the server.\n */\nexport abstract class SourcegraphCompletionsClient {\n    private errorEncountered = false\n\n    constructor(\n        protected config: CompletionsClientConfig,\n        protected logger?: CompletionLogger\n    ) {}\n\n    public onConfigurationChange(newConfig: CompletionsClientConfig): void {\n        this.config = newConfig\n    }\n\n    protected get completionsEndpoint(): string {\n        return new URL('/.api/completions/stream', this.config.serverEndpoint).href\n    }\n\n    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:297-870"",""content"":""export class SourcegraphGraphQLAPIClient {\n    private dotcomUrl = DOTCOM_URL\n    public anonymousUserID: string | undefined\n\n    /**\n     * Should be set on extension activation via `localStorage.onConfigurationChange(config)`\n     * Done to avoid passing the graphql client around as a parameter and instead\n     * access it as a singleton via the module import.\n     */\n    private _config: GraphQLAPIClientConfig | null = null\n\n    private get config(): GraphQLAPIClientConfig {\n        if (!this._config) {\n            throw new Error('GraphQLAPIClientConfig is not set')\n        }\n\n        return this._config\n    }\n\n    constructor(config: GraphQLAPIClientConfig | null = null) {\n        this._config = config\n    }\n\n    public onConfigurationChange(newConfig: GraphQLAPIClientConfig): void {\n        this._config = newConfig\n    }\n\n    /**\n     * If set, anonymousUID is trasmitted as 'X-Sourcegraph-Actor-Anonymous-UID'\n     * which is automatically picked up by Sourcegraph backends 5.2+\n     */\n    public setAnonymousUserID(anonymousUID: string): void {\n        this.anonymousUserID = anonymousUID\n    }\n\n    public isDotCom(): boolean {\n        return isDotCom(this.config.serverEndpoint)\n    }\n\n    // Gets the server endpoint for this client.\n    public get endpoint(): string {\n        return this.config.serverEndpoint\n    }\n\n    public async getSiteVersion(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteVersionResponse>>(\n            CURRENT_SITE_VERSION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => data.site?.productVersion ?? new Error('site version not found')\n            )\n        )\n    }\n\n    public async getSiteIdentification(): Promise<{ siteid: string; hashedLicenseKey: string } | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<SiteIdentificationResponse>>(\n            CURRENT_SITE_IDENTIFICATION,\n            {}\n        )\n        return extractDataOrError(response, data =>\n            data.site?.siteID\n                ? data.site?.productSubscription?.license?.hashedKey\n                    ? {\n                          siteid: data.site?.siteID,\n                          hashedLicenseKey: data.site?.productSubscription?.license?.hashedKey,\n                      }\n                    : new Error('site hashed license key not found')\n                : new Error('site ID not found')\n        )\n    }\n\n    public async getSiteHasIsCodyEnabledField(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteGraphqlFieldsResponse>>(\n            CURRENT_SITE_GRAPHQL_FIELDS_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => !!data.__type?.fields?.find(field => field.name === 'isCodyEnabled')\n            )\n        )\n    }\n\n    public async getSiteHasCodyEnabled(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteHasCodyEnabledResponse>>(\n            CURRENT_SITE_HAS_CODY_ENABLED_QUERY,\n            {}\n        ).then(response => extractDataOrError(response, data => data.site?.isCodyEnabled ?? false))\n    }\n\n    public async getCurrentUserId(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserIdResponse>>(\n            CURRENT_USER_ID_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? data.currentUser.id : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodyProEnabled(): Promise<{ codyProEnabled: boolean } | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodyProEnabledResponse>>(\n            CURRENT_USER_CODY_PRO_ENABLED_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodySubscription(): Promise<CurrentUserCodySubscription | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodySubscriptionResponse>>(\n            CURRENT_USER_CODY_SUBSCRIPTION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser?.codySubscription\n                    ? data.currentUser.codySubscription\n                    : new Error('current user subscription data not found')\n            )\n        )\n    }\n\n    public async getCurrentUserInfo(): Promise<CurrentUserInfo | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserInfoResponse>>(\n            CURRENT_USER_INFO_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    /**\n     * Fetches the Site Admin enabled/disable Cody config features for the current instance.\n     */\n    public async getCodyConfigFeatures(): Promise<CodyConfigFeatures | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<CodyConfigFeaturesResponse>>(\n            CURRENT_SITE_CODY_CONFIG_FEATURES,\n            {}\n        )\n        return extractDataOrError(\n            response,\n            data => data.site?.codyConfigFeatures ?? new Error('cody config not found')\n        )\n    }\n\n    public async getCodyLLMConfiguration(): Promise<undefined | CodyLLMSiteConfiguration | Error> {\n        // fetch Cody LLM provider separately for backward compatability\n        const [configResponse, providerResponse] = await Promise.all([\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationResponse>>(\n                CURRENT_SITE_CODY_LLM_CONFIGURATION\n            ),\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationProviderResponse>>(\n                CURRENT_SITE_CODY_LLM_PROVIDER\n            ),\n        ])\n\n        const config = extractDataOrError(\n            configResponse,\n            data => data.site?.codyLLMConfiguration || undefined\n        )\n        if (!config || isError(config)) {\n            return config\n        }\n\n        let provider: string | undefined\n        const llmProvider = extractDataOrError(\n            providerResponse,\n            data => data.site?.codyLLMConfiguration?.provider\n        )\n        if (llmProvider && !isError(llmProvider)) {\n            provider = llmProvider\n        }\n\n        return { ...config, provider }\n    }\n\n    /**\n     * Gets a subset of the list of repositories from the Sourcegraph instance.\n     * @param first the number of repositories to retrieve.\n     * @param after the last repository retrieved, if any, to continue enumerating the list.\n     * @returns the list of repositories. If `endCursor` is null, this is the end of the list.\n     */\n    public async getRepoList(first: number, after?: string): Promise<RepoListResponse | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepoListResponse>>(REPOSITORY_LIST_QUERY, {\n            first,\n            after: after || null,\n        }).then(response => extractDataOrError(response, data => data))\n    }\n\n    public async getRepoId(repoName: string): Promise<string | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdResponse>>(REPOSITORY_ID_QUERY, {\n            name: repoName,\n        }).then(response =>\n            extractDataOrError(response, data => (data.repository ? data.repository.id : null))\n        )\n    }\n\n    public async getRepoIds(\n        names: string[],\n        first: number\n    ): Promise<{ name: string; id: string }[] | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdsResponse>>(REPOSITORY_IDS_QUERY, {\n            names,\n            first,\n        }).then(response => extractDataOrError(response, data => data.repositories?.nodes || []))\n    }\n\n    public async contextSearch(\n        repos: Set<string>,\n        query: string\n    ): Promise<ContextSearchResult[] | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<ContextSearchResponse>>(CONTEXT_SEARCH_QUERY, {\n            repos: [...repos],\n            query,\n            codeResultsCount: 15,\n            textResultsCount: 5,\n        }).then(response =>\n            extractDataOrError(response, data =>\n                (data.getCodyContext || []).map(item => ({\n                    commit: item.blob.commit.oid,\n                    repoName: item.blob.repository.name,\n                    path: item.blob.path,\n                    uri: URI.parse(\n                        `${item.blob.url.startsWith('/') ? this.endpoint : ''}${item.blob.url}?L${\n                            item.startLine + 1\n                        }-${item.endLine}`\n                    ),\n                    startLine: item.startLine,\n                    endLine: item.endLine,\n                    content: item.chunkContent,\n                }))\n            )\n        )\n    }\n\n    public async contextFilters(): Promise<ContextFiltersResult | null | Error> {\n        const response =\n            await this.fetchSourcegraphAPI<APIResponse<ContextFiltersResult | null>>(\n                CONTEXT_FILTERS_QUERY\n            )\n\n        const result = extractDataOrError(response, data => data)\n\n        if (result instanceof Error) {\n            // Ignore errors caused by outdated Sourcegraph API instances.\n            if (hasOutdatedAPIErrorMessages(result)) {\n                return INCLUDE_EVERYTHING_CONTEXT_FILTERS\n            }\n\n            // Exclude everything in case of an unexpected error.\n            return EXCLUDE_EVERYTHING_CONTEXT_FILTERS\n        }\n\n        return result\n    }\n\n    /**\n     * Checks if Cody is enabled on the current Sourcegraph instance.\n     * @returns\n     * enabled: Whether Cody is enabled.\n     * version: The Sourcegraph version.\n     *\n     * This method first checks the Sourcegraph version using `getSiteVersion()`.\n     * If the version is before 5.0.0, Cody is disabled.\n     * If the version is 5.0.0 or newer, it checks for the existence of the `isCodyEnabled` field using `getSiteHasIsCodyEnabledField()`.\n     * If the field exists, it calls `getSiteHasCodyEnabled()` to check its value.\n     * If the field does not exist, Cody is assumed to be enabled for versions between 5.0.0 - 5.1.0.\n     */\n    public async isCodyEnabled(): Promise<{ enabled: boolean; version: string }> {\n        // Check site version.\n        const siteVersion = await this.getSiteVersion()\n        if (isError(siteVersion)) {\n            return { enabled: false, version: 'unknown' }\n        }\n        const insiderBuild = siteVersion.length > 12 || siteVersion.includes('dev')\n        if (insiderBuild) {\n            return { enabled: true, version: siteVersion }\n        }\n        // NOTE: Cody does not work on versions older than 5.0\n        const versionBeforeCody = siteVersion < '5.0.0'\n        if (versionBeforeCody) {\n            return { enabled: false, version: siteVersion }\n        }\n        // Beta version is betwewen 5.0.0 - 5.1.0 and does not have isCodyEnabled field\n        const betaVersion = siteVersion >= '5.0.0' && siteVersion < '5.1.0'\n        const hasIsCodyEnabledField = await this.getSiteHasIsCodyEnabledField()\n        // The isCodyEnabled field does not exist before version 5.1.0\n        if (!betaVersion && !isError(hasIsCodyEnabledField) && hasIsCodyEnabledField) {\n            const siteHasCodyEnabled = await this.getSiteHasCodyEnabled()\n            return { enabled: !isError(siteHasCodyEnabled) && siteHasCodyEnabled, version: siteVersion }\n        }\n        return { enabled: insiderBuild || betaVersion, version: siteVersion }\n    }\n\n    /**\n     * recordTelemetryEvents uses the new Telemetry API to record events that\n     * gets exported: https://sourcegraph.com/docs/dev/background-information/telemetry\n     *\n     * Only available on Sourcegraph 5.2.0 and later.\n     *\n     * DO NOT USE THIS DIRECTLY - use an implementation of implementation\n     * TelemetryRecorder from '@sourcegraph/telemetry' instead.\n     */\n    public async recordTelemetryEvents(events: TelemetryEventInput[]): Promise<unknown | Error> {\n        for (const event of events) {\n            this.anonymizeTelemetryEventInput(event)\n        }\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<unknown>>(\n            RECORD_TELEMETRY_EVENTS_MUTATION,\n            {\n                events,\n            }\n        )\n        return extractDataOrError(initialResponse, data => data)\n    }\n\n    /**\n     * logEvent is the legacy event-logging mechanism.\n     * @deprecated use an implementation of implementation TelemetryRecorder\n     * from '@sourcegraph/telemetry' instead.\n     */\n    public async logEvent(event: event, mode: LogEventMode): Promise<LogEventResponse | Error> {\n        if (process.env.CODY_TESTING === 'true') {\n            return this.sendEventLogRequestToTestingAPI(event)\n        }\n        if (this.config?.telemetryLevel === 'off') {\n            return {}\n        }\n        /**\n         * If connected to dotcom, just log events to the instance, as it means\n         * the same thing.\n         */\n        if (this.isDotCom()) {\n            return this.sendEventLogRequestToAPI(event)\n        }\n\n        switch (process.env.CODY_LOG_EVENT_MODE) {\n            case 'connected-instance-only':\n                mode = 'connected-instance-only'\n                break\n            case 'dotcom-only':\n                mode = 'dotcom-only'\n                break\n            case 'all':\n                mode = 'all'\n                break\n            default:\n                if (process.env.CODY_LOG_EVENT_MODE) {\n                    logDebug(\n                        'SourcegraphGraphQLAPIClient.logEvent',\n                        'unknown mode',\n                        process.env.CODY_LOG_EVENT_MODE\n                    )\n                }\n        }\n\n        switch (mode) {\n            /**\n             * Only log events to dotcom, not the connected instance. Used when\n             * another mechanism delivers event logs the instance (i.e. the\n             * new telemetry clients)\n             */\n            case 'dotcom-only':\n                return this.sendEventLogRequestToDotComAPI(event)\n\n            /**\n             * Only log events to the connected instance, not dotcom. Used when\n             * another mechanism handles reporting to dotcom (i.e. the old\n             * client and/or the new telemetry framework, which exports events\n             * from all instances: https://sourcegraph.com/docs/dev/background-information/telemetry)\n             */\n            case 'connected-instance-only':\n                return this.sendEventLogRequestToAPI(event)\n\n            case 'all': // continue to default handling\n        }\n\n        /**\n         * Otherwise, send events to the connected instance AND to dotcom (default)\n         */\n        const responses = await Promise.all([\n            this.sendEventLogRequestToAPI(event),\n            this.sendEventLogRequestToDotComAPI(event),\n        ])\n        if (isError(responses[0]) && isError(responses[1])) {\n            return new Error(\n                `Errors logging events: ${responses[0].toString()}, ${responses[1].toString()}`\n            )\n        }\n        if (isError(responses[0])) {\n            return responses[0]\n        }\n        if (isError(responses[1])) {\n            return responses[1]\n        }\n        return {}\n    }\n\n    private anonymizeTelemetryEventInput(event: TelemetryEventInput): void {\n        if (isAgentTesting) {\n            event.timestamp = undefined\n            event.parameters.interactionID = undefined\n            event.parameters.billingMetadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.privateMetadata = {}\n        }\n    }\n\n    private anonymizeEvent(event: event): void {\n        if (isAgentTesting) {\n            event.publicArgument = undefined\n            event.argument = undefined\n            event.userCookieID = 'ANONYMOUS_USER_COOKIE_ID'\n            event.hashedLicenseKey = undefined\n        }\n    }\n\n    private async sendEventLogRequestToDotComAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const response = await this.fetchSourcegraphDotcomAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        return extractDataOrError(response, data => data)\n    }\n\n    private async sendEventLogRequestToAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n                LOG_EVENT_MUTATION_DEPRECATED,\n                event\n            )\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    private async sendEventLogRequestToTestingAPI(event: event): Promise<LogEventResponse | Error> {\n        const initialResponse =\n            await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse =\n                await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    public async searchAttribution(snippet: string): Promise<SearchAttributionResults | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SearchAttributionResponse>>(\n            SEARCH_ATTRIBUTION_QUERY,\n            {\n                snippet,\n            }\n        ).then(response => extractDataOrError(response, data => data.snippetAttribution))\n    }\n\n    public async getEvaluatedFeatureFlags(): Promise<Record<string, boolean> | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluatedFeatureFlagsResponse>>(\n            GET_FEATURE_FLAGS_QUERY,\n            {}\n        ).then(response => {\n            return extractDataOrError(response, data =>\n                data.evaluatedFeatureFlags.reduce((acc: Record<string, boolean>, { name, value }) => {\n                    acc[name] = value\n                    return acc\n                }, {})\n            )\n        })\n    }\n\n    public async evaluateFeatureFlag(flagName: string): Promise<boolean | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluateFeatureFlagResponse>>(\n            EVALUATE_FEATURE_FLAG_QUERY,\n            {\n                flagName,\n            }\n        ).then(response => extractDataOrError(response, data => data.evaluateFeatureFlag))\n    }\n\n    private fetchSourcegraphAPI<T>(\n        query: string,\n        variables: Record<string, any> = {}\n    ): Promise<T | Error> {\n        const headers = new Headers(this.config.customHeaders as HeadersInit)\n        headers.set('Content-Type', 'application/json; charset=utf-8')\n        if (this.config.accessToken) {\n            headers.set('Authorization', `token ${this.config.accessToken}`)\n        }\n        if (this.anonymousUserID) {\n            headers.set('X-Sourcegraph-Actor-Anonymous-UID', this.anonymousUserID)\n        }\n\n        addTraceparent(headers)\n        addCustomUserAgent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.config.serverEndpoint })\n        return wrapInActiveSpan(`graphql.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => {\n                    return new Error(`accessing Sourcegraph GraphQL API: ${error} (${url})`)\n                })\n        )\n    }\n\n    // make an anonymous request to the dotcom API\n    private fetchSourcegraphDotcomAPI<T>(\n        query: string,\n        variables: Record<string, any>\n    ): Promise<T | Error> {\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.dotcomUrl.href })\n        const headers = new Headers()\n        addCustomUserAgent(headers)\n        addTraceparent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        return wrapInActiveSpan(`graphql.dotcom.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => new Error(`error fetching Sourcegraph GraphQL API: ${error} (${url})`))\n        )\n    }\n\n    // make an anonymous request to the Testing API\n    private fetchSourcegraphTestingAPI<T>(body: Record<string, any>): Promise<T | Error> {\n        const url = 'http://localhost:49300/.test/testLogging'\n        const headers = new Headers({\n            'Content-Type': 'application/json',\n        })\n        addCustomUserAgent(headers)\n\n        return fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n        })\n            .then(verifyResponseCode)\n            .then(response => response.json() as T)\n            .catch(error => new Error(`error fetching Testing Sourcegraph API: ${error} (${url})`))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:954-956"",""content"":""function hasOutdatedAPIErrorMessages(error: Error): boolean {\n    return error.message.includes('Cannot query field')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:780-795"",""content"":""\n### Changed\n\n- Move decision about which autocomplete deployment to use for StarCoder to the server. [pull/1845](https://github.com/sourcegraph/cody/pull/1845)\n\n## [0.16.0]\n\n### Added\n\n- Chat: A new chat model selection dropdown that allows selecting between different chat models when connected to the sourcegraph.com instance. [pull/1676](https://github.com/sourcegraph/cody/pull/1676)\n- Chat: New button in editor title for restarting chat session in current chat panel (non-sidebar chat view). [pull/1687](https://github.com/sourcegraph/cody/pull/1687)\n- Chat: New `@` command that allows you to attach files via the chat input box. [pull/1631](https://github.com/sourcegraph/cody/pull/1631)\n- Edit: Added a specific, faster, response flow for fixes when triggered directly from code actions. [pull/1639](https://github.com/sourcegraph/cody/pull/1639)\n- Edit: Improved context fetching for quick fixes to better include code related to the problem. [pull/1723](https://github.com/sourcegraph/cody/pull/1723)\n- Chat: Added option to configure whether to add enhanced context from codebase for chat question in the new chat panel. [pull/1738](https://github.com/sourcegraph/cody/pull/1738)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:46-49"",""content"":""interface APIResponse<T> {\n    data?: T\n    errors?: { message: string; path?: string[] }[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/VSCodeApi.ts:21-21"",""content"":""let api: VSCodeWrapper\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:21-44"",""content"":"" *   Sourcegraph instance).\n * @param location The absolute URI to convert to a display path.\n */\nexport function displayPath(location: URI): string {\n    const result = _displayPath(location, checkEnvInfo())\n    return typeof result === 'string' ? result : result.toString()\n}\n\n/**\n * Dirname of the location's display path, to display to the user. Similar to\n * `dirname(displayPath(location))`, but it uses the right path separators in `dirname` ('\\' for\n * file URIs on Windows, '/' otherwise).\n *\n * The returned path string MUST ONLY be used for display purposes. It MUST NOT be used to identify\n * or locate files.\n *\n * Use this instead of other seemingly simpler techniques to avoid a few subtle\n * bugs/inconsistencies:\n *\n * - On Windows, Node's `dirname(uri.fsPath)` breaks on a non-`file` URI on Windows because\n *   `dirname` would use '\\' path separators but the URI would have '/' path separators.\n * - In a single-root workspace, Node's `dirname(uri.fsPath)` would return the root directory name,\n *   which is usually superfluous for display purposes. For example, if VS Code is open to a\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:694-705"",""content"":""  sign in to Sourcegraph.com directly. The extension will do this automatically if\n  possible but you may need to sign in again. If you have set up embeddings in\n  Cody App, VScode will now search your local embeddings automatically: You no\n  longer need to have the Cody App open. Note, the sidebar chat indicator may\n  say embeddings were not found while we work on improving chat.\n  [pull/2099](https://github.com/sourcegraph/cody/pull/2099)\n- Commands: Expose commands in the VS Code command palette and clean up the context menu. [pull/1209](https://github.com/sourcegraph/cody/pull/2109)\n- Search: Style and UX improvements to the search panel. [pull/2138](https://github.com/sourcegraph/cody/pull/2138)\n- Chat: Reduce size of chats list blank copy. [pull/2137](https://github.com/sourcegraph/cody/pull/2137)\n- Chat: Update message input placeholder to mention slash commands. [pull/2142](https://github.com/sourcegraph/cody/pull/2142)\n- Inline Chat will soon be deprecated in favor of the improved chat and command experience. It is now disabled by default and does not work when the new chat panel is enabled. [pull/1797](https://github.com/sourcegraph/cody/pull/1797)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:167-203"",""content"":""export type { CompletionLogger, CompletionsClientConfig } from './sourcegraph-api/completions/client'\nexport type {\n    CompletionParameters,\n    CompletionResponse,\n    Event,\n} from './sourcegraph-api/completions/types'\nexport { DOTCOM_URL, LOCAL_APP_URL, isDotCom } from './sourcegraph-api/environments'\nexport {\n    AbortError,\n    NetworkError,\n    RateLimitError,\n    TimeoutError,\n    TracedError,\n    isAbortError,\n    isAuthError,\n    isNetworkError,\n    isRateLimitError,\n} from './sourcegraph-api/errors'\nexport { SourcegraphGraphQLAPIClient, graphqlClient } from './sourcegraph-api/graphql'\nexport {\n    ConfigFeaturesSingleton,\n    addCustomUserAgent,\n    customUserAgent,\n    isNodeResponse,\n    setUserAgent,\n    type BrowserOrNodeResponse,\n    type GraphQLAPIClientConfig,\n    type LogEventMode,\n    type ContextFiltersResult,\n    type CodyContextFilterItem,\n    type RepoListResponse,\n} from './sourcegraph-api/graphql/client'\nexport type {\n    CodyLLMSiteConfiguration,\n    ContextSearchResult,\n    EmbeddingsSearchResult,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/protocol.ts:273-292"",""content"":""    )\n}\n\nexport type AuthMethod = 'dotcom' | 'github' | 'gitlab' | 'google'\n\n// Provide backward compatibility for the old token regex\n// Details: https://docs.sourcegraph.com/dev/security/secret_formats\nconst sourcegraphTokenRegex =\n    /(sgp_(?:[a-fA-F0-9]{16}|local)|sgp_)?[a-fA-F0-9]{40}|(sgd|slk|sgs)_[a-fA-F0-9]{64}/\n\n/**\n * Checks if the given text matches the regex for a Sourcegraph access token.\n *\n * @param text - The text to check against the regex.\n * @returns Whether the text matches the Sourcegraph token regex.\n */\nexport function isSourcegraphToken(text: string): boolean {\n    return sourcegraphTokenRegex.test(text)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_014/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code for inserting autocompletions is spread across several files, but the core logic is in `cody_test/vscode/src/completions/inline-completion-item-provider.ts`. 

Here's a breakdown:

1. **`updateInsertRangeForVSCode` function:** This function, located in `cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts`, is responsible for adjusting the `insertText` and `range` properties of autocomplete items to be compatible with VS Code's inline completion API.

2. **`CodyCompletionItemProvider` class:** This class, in `cody_test/vscode/src/completions/inline-completion-item-provider.ts`, handles the entire process of providing inline completions. It fetches suggestions from various providers, filters them, and then uses the `updateInsertRangeForVSCode` function to prepare them for insertion.

3. **`handleCodeFromInsertAtCursor` function:** This function, in `cody_test/vscode/src/services/utils/codeblock-action-tracker.ts`, is responsible for inserting the code from the ""Insert at Cursor"" button. It uses VS Code's `WorkspaceEdit` API to insert the text at the current cursor position.

4. **`acceptCompletion` function:** This function, also in `cody_test/vscode/src/completions/inline-completion-item-provider.ts`, is called when the user accepts a completion. It triggers the insertion of the selected completion using VS Code's `InlineCompletionItemProvider.resolveInlineCompletionItem` method.

In summary, the insertion of autocompletions is a collaborative effort between these components:

- **`updateInsertRangeForVSCode`:** Prepares the completion item for VS Code.
- **`CodyCompletionItemProvider`:** Fetches, filters, and prepares completions.
- **`handleCodeFromInsertAtCursor`:** Inserts code from the ""Insert at Cursor"" button.
- **`acceptCompletion`:** Triggers the insertion of the selected completion.

This process ensures that the autocompletions are correctly inserted into the editor, respecting the user's selection and the context of the code.",Where is the code for inserting autocompletions?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/evaluate-autocomplete.ts:13-50"",""content"":""export interface EvaluateAutocompleteOptions {\n    workspace: string\n    worktree?: string\n    treeSitterGrammars: string\n    queriesDirectory: string\n    testCount: number\n    maxFileTestCount: number\n    includeFixture: string[]\n    excludeFixture: string[]\n    includeWorkspace: string[]\n    excludeWorkspace: string[]\n    includeFilepath?: string[]\n    excludeFilepath?: string[]\n    includeLanguage?: string[]\n    excludeLanguage?: string[]\n    includeMatchKind?: string[]\n    excludeMatchKind?: string[]\n    testTypecheck?: boolean\n    testParse?: boolean\n    srcAccessToken: string\n    srcEndpoint: string\n\n    codyAgentBinary?: string\n\n    matchMinimumSize?: number\n    matchSkipSingleline?: number\n    matchEveryN?: number\n    matchKindDistribution?: number\n\n    evaluationConfig: string\n    snapshotDirectory: string\n    csvPath?: string\n    bfgBinary?: string\n    installCommand?: string\n    testCommand?: string\n    gitLogFilter?: string\n    fixture: EvaluationFixture\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:345-367"",""content"":""\n### Language ignore list\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion for file in the X programming language.\n- [ ] Open VS Code settings, find the language ignore list, and add this language to the list\n- [ ] Verify that completions are no longer generated for this language.\n\n### LLM selection\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion using the LLM selected by default.\n- [ ] Open VS Code settings and find Cody autocomplete mode settings.\n  - Combinations to test:\n    - [ ] Provider: fireworks; Model: starcoder-16 and starcoder-7b\n    - [ ] Provider: anthropic; Model: null\n- [ ] Verify that autocomplete works as expected after the settings change.\n\n### Multi-line completions\n\n- [ ] Open a TypeScript file. Paste in something like this: `function bubbleSort(`.\n- [ ] Expect more than one line of code being completed for you.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/tracer/traceView.ts:0-24"",""content"":""import * as vscode from 'vscode'\n\nimport { displayPath, displayRange, isDefined, renderMarkdown } from '@sourcegraph/cody-shared'\n\nimport {\n    SectionHistoryRetriever,\n    registerDebugListener as registerSectionObserverDebugListener,\n} from '../context/retrievers/section-history/section-history-retriever'\nimport { InlineCompletionsResultSource } from '../get-inline-completions'\nimport type { InlineCompletionItemProvider } from '../inline-completion-item-provider'\nimport * as statistics from '../statistics'\nimport type { InlineCompletionItem } from '../types'\n\nimport type { ProvideInlineCompletionsItemTraceData } from '.'\n\n/**\n * Registers a command `Cody: Open Autocomplete Trace View` that shows the context and prompt used\n * for autocomplete.\n */\nexport function registerAutocompleteTraceView(\n    provider: InlineCompletionItemProvider\n): vscode.Disposable {\n    let panel: vscode.WebviewPanel | null = null\n    let latestInvocationSequence = 0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:14-20"",""content"":""interface AutocompleteMatch {\n    kind: AutocompleteMatchKind\n    newText: string\n    removedText: string\n    removedRange: vscode.Range\n    requestPosition: vscode.Position\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:33-66"",""content"":""\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:17-31"",""content"":""export interface AutocompleteParameters {\n    parser?: WrappedParser\n    originalTree?: Tree\n    originalTreeIsErrorFree?: boolean\n    client: MessageHandler\n    document: EvaluationDocument\n\n    options: EvaluateAutocompleteOptions\n\n    range: vscode.Range\n    autocompleteKind?: AutocompleteMatchKind\n    modifiedContent: string\n    removedContent: string\n    position: vscode.Position\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:21-172"",""content"":""export class AutocompleteMatcher {\n    public parser: WrappedParser | undefined\n    public originalTree: Tree | undefined\n    public originalTreeIsFreeOfErrrors: boolean | undefined\n    constructor(\n        public readonly params: EvaluationDocumentParams,\n        public readonly queries: Queries,\n        public readonly grammarDirectory: string\n    ) {}\n    private ifSyntax(language: SupportedLanguage): string {\n        switch (language) {\n            case SupportedLanguage.go:\n                return 'if  '\n            default:\n                return 'if ()'\n        }\n    }\n    public async matches(text: string): Promise<AutocompleteMatch[] | undefined> {\n        const { languageid: language } = this.params\n\n        if (!isSupportedLanguage(language)) {\n            return undefined\n        }\n        this.parser = await createParser({ language, grammarDirectory: this.grammarDirectory })\n        if (!this.parser) {\n            return undefined\n        }\n        const query = await this.queries.loadQuery(this.parser, language, 'context')\n        if (!query) {\n            return\n        }\n        this.originalTree = this.parser.parse(text)\n        this.originalTreeIsFreeOfErrrors = !this.originalTree.rootNode.hasError()\n        const result: AutocompleteMatch[] = []\n        const document = new EvaluationDocument(this.params, text, vscode.Uri.file(this.params.filepath))\n        for (const queryMatch of query.matches(this.originalTree.rootNode)) {\n            for (const capture of queryMatch.captures) {\n                if (capture.name === 'if_statement') {\n                    const ifSyntax = this.ifSyntax(language)\n\n                    const newText = [\n                        text.slice(0, capture.node.startIndex),\n                        ifSyntax,\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'if_statement',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            capture.node.startIndex + ifSyntax.length - 1\n                        ),\n                    })\n                } else if (capture.name === 'function_declaration') {\n                    const openParen = queryMatch.captures.find(c => c.name === 'opening_paren')?.node\n                    if (!openParen) {\n                        throw new Error('Missing capture group @opening_paren for @function_declaration')\n                    }\n                    const newText = [\n                        text.slice(0, openParen.startIndex),\n                        '()',\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'function_declaration',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            openParen.startIndex + '('.length\n                        ),\n                    })\n                } else if (capture.name === 'call_expression') {\n                    const openParenPosition = queryMatch.captures.find(c => c.name === 'opening_paren')\n                        ?.node.startIndex\n                    const closeParenPosition = queryMatch.captures.find(c => c.name === 'closing_paren')\n                        ?.node.endIndex\n                    if (openParenPosition && closeParenPosition) {\n                        const openParenSyntax = text.charAt(openParenPosition) ?? '('\n                        const closeParenSyntax = text.charAt(closeParenPosition - 1) ?? ')'\n                        if (\n                            closeParenSyntax !== ')' &&\n                            closeParenSyntax !== '}' &&\n                            closeParenSyntax !== ']' &&\n                            closeParenSyntax !== '>'\n                        ) {\n                            throw new Error(\n                                `Invalid close paren syntax. ${JSON.stringify({\n                                    params: this.params,\n                                    closeParenSyntax,\n                                })}`\n                            )\n                        }\n                        const newText = [\n                            text.slice(0, openParenPosition),\n                            openParenSyntax,\n                            closeParenSyntax,\n                            text.slice(closeParenPosition),\n                        ]\n                        result.push({\n                            kind: 'call_expression',\n                            newText: newText.join(''),\n                            removedText: text.slice(openParenPosition, closeParenPosition),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(openParenPosition),\n                                document.textDocument.positionAt(closeParenPosition)\n                            ),\n                            requestPosition: document.textDocument.positionAt(\n                                openParenPosition + openParenSyntax.length\n                            ),\n                        })\n                    } else {\n                        throw new Error(\n                            `Missing @opening_paren and/or @closing_parent captures for node: ${capture.node.text}`\n                        )\n                    }\n                } else if (capture.name === 'assignment_statement') {\n                    const equalSign = queryMatch.captures.find(c => c.name === 'equal_sign')?.node\n                    if (equalSign) {\n                        const startIndex = equalSign.startIndex\n                        const endIndex =\n                            text.at(capture.node.endIndex) === ';'\n                                ? capture.node.endIndex + 1\n                                : capture.node.endIndex\n                        const newText = [text.slice(0, startIndex), text.slice(endIndex)]\n                        result.push({\n                            kind: 'assignment_statement',\n                            newText: newText.join(''),\n                            removedText: text.slice(startIndex, endIndex),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(startIndex),\n                                document.textDocument.positionAt(endIndex)\n                            ),\n                            requestPosition: document.textDocument.positionAt(startIndex - 1),\n                        })\n                    } else {\n                        throw new Error(`Missing @equal_sign capture for node: ${capture.node.text}`)\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:342-378"",""content"":""\ninterface CompletionItemParams {\n    completionID: string\n}\n\ninterface AutocompleteParams {\n    uri: string\n    filePath?: string\n    position: Position\n    // Defaults to 'Automatic' for autocompletions which were not explicitly\n    // triggered.\n    triggerKind?: 'Automatic' | 'Invoke'\n    selectedCompletionInfo?: SelectedCompletionInfo\n}\n\ninterface SelectedCompletionInfo {\n    readonly range: Range\n    readonly text: string\n}\n\nexport interface ChatExportResult {\n    chatID: string\n    transcript: SerializedChatTranscript\n}\nexport interface AutocompleteResult {\n    items: AutocompleteItem[]\n\n    /** completionEvent is not deprecated because it's used by non-editor clients like evaluate-autocomplete that need access to book-keeping data to evaluate results. */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\nexport interface AutocompleteItem {\n    id: string\n    insertText: string\n    range: Range\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:33-162"",""content"":""export async function triggerAutocomplete(parameters: AutocompleteParameters): Promise<void> {\n    const { range, client, document, modifiedContent, autocompleteKind, removedContent, position } =\n        parameters\n    client.notify('textDocument/didChange', {\n        uri: document.uri.toString(),\n        filePath: document.uri.fsPath,\n        content: modifiedContent,\n    })\n    let result: AutocompleteResult\n    try {\n        result = await client.request('autocomplete/execute', {\n            uri: document.uri.toString(),\n            filePath: document.uri.fsPath,\n            position,\n            // We don't use the \""automatic\"" trigger to avoid certain code paths like\n            // synthetic latency when acceptance rate is low.\n            triggerKind: 'Invoke',\n        })\n    } catch (error) {\n        const resultError = error instanceof Error ? error.message : String(error)\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultError,\n        })\n        return\n    }\n\n    const didNotSendNetworkRequest =\n        result.items.length === 0 && result.completionEvent?.networkRequestStartedAt === null\n    if (didNotSendNetworkRequest) {\n        return\n    }\n\n    const textDocument = new AgentTextDocument(\n        ProtocolTextDocumentWithUri.from(document.uri, { content: modifiedContent })\n    )\n    for (const [index, item] of result.items.entries()) {\n        const info = result.completionEvent?.items?.[index]\n        const original = textDocument.getText(\n            new vscode.Range(\n                item.range.start.line,\n                item.range.start.character,\n                item.range.end.line,\n                item.range.end.character\n            )\n        )\n        const start = new vscode.Position(item.range.start.line, item.range.start.character)\n        const end = new vscode.Position(item.range.end.line, item.range.end.character)\n        const modifiedDocument = new AgentTextDocument(\n            ProtocolTextDocumentWithUri.from(document.uri, { content: parameters.modifiedContent })\n        )\n        const newText = [\n            modifiedDocument.getText(new vscode.Range(new vscode.Position(0, 0), start)),\n            item.insertText,\n            modifiedDocument.getText(\n                new vscode.Range(end, new vscode.Position(modifiedDocument.lineCount, 0))\n            ),\n        ].join('')\n        const testParameters: TestParameters = { ...parameters, item, newText }\n        let resultParses: boolean | undefined\n        if (parameters.originalTreeIsErrorFree && parameters.parser && parameters.options.testParse) {\n            resultParses = testParses(newText, parameters.parser)\n        }\n\n        const resultTypechecks = await testTypecheck(testParameters)\n        const patches: string[] = []\n        let hasNonInsertPatch = false\n        for (const [sx, ex, text] of calcPatch(original, item.insertText)) {\n            if (sx !== ex) {\n                hasNonInsertPatch = true\n                continue\n            }\n            patches.push(text)\n        }\n        if (hasNonInsertPatch) {\n            document.pushItem({\n                resultText: item.insertText,\n                autocompleteKind,\n                range,\n                resultTypechecks,\n                resultParses,\n                resultNonInsertPatch: true,\n                event: result.completionEvent,\n                info,\n            })\n        } else if (patches.length > 0) {\n            const text = patches.join('')\n            if (text === removedContent) {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultExact: true,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            } else {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultText: text,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            }\n        } else {\n            document.pushItem({\n                autocompleteKind,\n                info,\n                range,\n                resultEmpty: true,\n                event: result.completionEvent,\n                resultParses,\n            })\n        }\n    }\n    if (result.items.length === 0) {\n        const expectedEmptyMatch = removedContent === ''\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultExact: expectedEmptyMatch,\n            resultEmpty: !expectedEmptyMatch,\n        })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/logger.ts:62-92"",""content"":""\n    /** Wether the completion is a singleline or multiline one. */\n    multiline: boolean\n\n    /**\n     * `null` means singleline, `block` means multiline.\n     * @deprecated Use `multiline` instead.\n     */\n    multilineMode: null | 'block'\n\n    /** Describes how the autocomplete request was triggered by the user. */\n    triggerKind: TriggerKind\n\n    /** Information about what provider is used. e.g. `anthropic` or `fireworks`. */\n    providerIdentifier: string\n\n    /** Information about which model was used. e.g. `starcoder-7b` or `claude-instant`. */\n    providerModel: string\n\n    /** Language of the document being completed. */\n    languageId: string\n\n    /** If we're inside a test file */\n    testFile: boolean\n\n    /**\n     * Information about the context retrieval process that lead to this autocomplete request. Refer\n     * to the documentation of {@link ContextSummary}\n     */\n    contextSummary?: ContextSummary\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:25-38"",""content"":""    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/unstable-openai.ts:0-36"",""content"":""import {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport { forkSignal, generatorWithTimeout, zipGenerators } from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n} from './provider'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:0-45"",""content"":""import * as anthropic from '@anthropic-ai/sdk'\n\nimport {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type Message,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    type PrefixComponents,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport {\n    forkSignal,\n    generatorWithErrorObserver,\n    generatorWithTimeout,\n    messagesToText,\n    zipGenerators,\n} from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:47-82"",""content"":""} from './suggested-autocomplete-items-cache'\nimport type { ProvideInlineCompletionItemsTracer, ProvideInlineCompletionsItemTraceData } from './tracer'\n\ninterface AutocompleteResult extends vscode.InlineCompletionList {\n    logId: CompletionLogID\n    items: AutocompleteItem[]\n    /** @deprecated */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\ninterface CodyCompletionItemProviderConfig {\n    providerConfig: ProviderConfig\n    statusBar: CodyStatusBar\n    tracer?: ProvideInlineCompletionItemsTracer | null\n    triggerNotice: ((notice: { key: string }) => void) | null\n    isRunningInsideAgent?: boolean\n\n    authStatus: AuthStatus\n    isDotComUser?: boolean\n\n    createBfgRetriever?: () => BfgRetriever\n\n    // Settings\n    formatOnAccept?: boolean\n    disableInsideComments?: boolean\n\n    // Feature flags\n    completeSuggestWidgetSelection?: boolean\n}\n\ninterface CompletionRequest {\n    document: vscode.TextDocument\n    position: vscode.Position\n    context: vscode.InlineCompletionContext\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:95-112"",""content"":""        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/request-manager.ts:0-28"",""content"":""import { partition } from 'lodash'\nimport { LRUCache } from 'lru-cache'\nimport type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    FeatureFlag,\n    isDefined,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport { addAutocompleteDebugEvent } from '../services/open-telemetry/debug-utils'\n\nimport { logDebug } from '../log'\nimport { completionProviderConfig } from './completion-provider-config'\nimport {\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n} from './get-inline-completions'\nimport { type CompletionLogID, logCompletionBookkeepingEvent } from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport { STOP_REASON_HOT_STREAK } from './providers/hot-streak'\nimport type { CompletionProviderTracer, Provider } from './providers/provider'\nimport { reuseLastCandidate } from './reuse-last-candidate'\nimport { lines, removeIndentation } from './text-processing'\nimport {\n    type InlineCompletionItemWithAnalytics,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/codeblock-action-tracker.ts:77-94"",""content"":""export async function handleCodeFromInsertAtCursor(text: string): Promise<void> {\n    const editor = getEditor()\n    const activeEditor = editor.active\n    const selectionRange = activeEditor?.selection\n    if (!activeEditor || !selectionRange) {\n        throw new Error('No editor or selection found to insert text')\n    }\n\n    const edit = new vscode.WorkspaceEdit()\n    // trimEnd() to remove new line added by Cody\n    edit.insert(activeEditor.document.uri, selectionRange.start, `${text}\\n`)\n    await vscode.workspace.applyEdit(edit)\n\n    // Log insert event\n    const op = 'insert'\n    const eventName = `${op}Button`\n    setLastStoredCode(text, eventName)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1033-1050"",""content"":""          \""default\"": null,\n          \""enum\"": [null, \""starcoder-16b\"", \""starcoder-7b\"", \""llama-code-13b\""],\n          \""markdownDescription\"": \""Overwrite the  model used for code autocompletion inference. This is only supported with the `fireworks` provider\""\n        },\n        \""cody.autocomplete.completeSuggestWidgetSelection\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Autocomplete based on the currently selection in the suggest widget. Requires the VS Code user setting `editor.inlineSuggest.suppressSuggestions` set to true and will change it to true in user settings if it is not true.\""\n        },\n        \""cody.autocomplete.formatOnAccept\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Format completions on accept using [the default document formatter](https://code.visualstudio.com/docs/editor/codebasics#_formatting).\""\n        },\n        \""cody.autocomplete.disableInsideComments\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/autocomplete.md:0-11"",""content"":""## Code Autocomplete\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-cody-autocomplete-tsx.gif\"">\n\nStart writing code and Cody will complete the line (or the entire function) for you. Hit tab to accept the suggestion.\n\n**✨ Pro-tips for using Cody autocomplete**\n<br>• Autocomplete uses the surrounding code and context to inform the suggestions, so if you need to guide it you can add a comment above the line you're editing.\n<br>• You can hover over the grey suggestion to see a toolbar of alternative suggestions, as well as other options such as accepting a single word at a time.\n<br>• You can use the \""Trigger Autocomplete at Cursor\"" command to trigger a code suggestion at any time, using the default keyboard shortcut of `Option` `\\` on macOS and `Alt` `\\` on Windows & Linux.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts:171-194"",""content"":""export function updateInsertRangeForVSCode(items: AutocompleteItem[]): AutocompleteItem[] {\n    return items.map(item => {\n        const {\n            insertText,\n            range,\n            requestParams: { position, document },\n        } = item\n\n        const currentLine = document.lineAt(position)\n        const currentLinePrefix = document.getText(currentLine.range.with({ end: position }))\n\n        const start = currentLine.range.start\n        // If the completion does not have a range set it will always exclude the same line suffix,\n        // so it has to overwrite the current same line suffix and reach to the end of the line.\n        const end = range?.end || currentLine.range.end\n\n        const vscodeInsertRange = new vscode.Range(start, end)\n\n        item.range = vscodeInsertRange\n        item.insertText = currentLinePrefix + (insertText as string)\n\n        return item\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:24-47"",""content"":""import { formatCompletion } from './format-completion'\nimport { getCurrentDocContext } from './get-current-doc-context'\nimport {\n    type InlineCompletionsParams,\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n    TriggerKind,\n    getInlineCompletions,\n} from './get-inline-completions'\nimport { isCompletionVisible } from './is-completion-visible'\nimport type { CompletionBookkeepingEvent, CompletionItemID, CompletionLogID } from './logger'\nimport * as CompletionLogger from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport type { ProviderConfig } from './providers/provider'\nimport { RequestManager, type RequestParams } from './request-manager'\nimport { getRequestParamsFromLastCandidate } from './reuse-last-candidate'\nimport { SmartThrottleService } from './smart-throttle'\nimport {\n    type AutocompleteInlineAcceptedCommandArgs,\n    type AutocompleteItem,\n    analyticsItemToAutocompleteItem,\n    suggestedAutocompleteItemsCache,\n    updateInsertRangeForVSCode,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:998-1015"",""content"":""### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n- Now removes completions from cache when the initial suggestion prefix is deleted by users after a suggestion was displayed. This avoids unhelpful/stale suggestions from persisting. [pull/1105](https://github.com/sourcegraph/cody/pull/1105)\n- VScode can now share a dotcom access token with future versions of Cody App. [pull/1090](https://github.com/sourcegraph/cody/pull/1090)\n\n### Fixed\n\n- Fix a potential race condition for autocomplete requests that happen when a completion is stored as the last shown candidate when it will not be shown. [pull/1059](https://github.com/sourcegraph/cody/pull/1059)\n- Use `insert` instead of `replace` for `Insert at Cursor` button for inserting code to current cursor position. [pull/1118](https://github.com/sourcegraph/cody/pull/1118)\n- Autocomplete: Fix support for working with CRLF line endings. [pull/1124](https://github.com/sourcegraph/cody/pull/1124)\n- Fix issue that caused the custom commands menu to unable to execute commands. [pull/1123](https://github.com/sourcegraph/cody/pull/1123)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:66-98"",""content"":""\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nexport interface AutocompleteTimeouts {\n    multiline?: number\n    singleline?: number\n}\n\nexport interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_015/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The codebase doesn't explicitly show a single place where we choose context items from different sources. Instead, it seems like the process is distributed across different components and functions:

1. **`ContextStrategyFactory`:** This class is responsible for choosing the overall strategy for retrieving context. It can select from different strategies like `bfg`, `jaccard-similarity`, `bfg-mixed`, etc. Each strategy uses different retrievers.
2. **`ContextRetriever`:** These are the actual components that fetch context from different sources. Examples include:
    * `BfgRetriever`: Uses the BFG graph to retrieve context.
    * `JaccardSimilarityRetriever`: Uses Jaccard similarity to retrieve context.
    * `SectionHistoryRetriever`: Retrieves context from the user's recent editing history.
3. **`ContextMixer`:** This component combines the results from different retrievers into a single list of context items. It uses reciprocal rank fusion to rank the items and then selects the top-k items from each retriever.

Therefore, the choice of context items from different sources happens in a multi-step process:

1. **Strategy Selection:** The `ContextStrategyFactory` chooses the overall strategy based on user preferences and the current context.
2. **Retrieval:** The chosen strategy uses different retrievers to fetch context from various sources.
3. **Combination:** The `ContextMixer` combines the results from different retrievers and ranks them to produce a final list of context items.

This approach allows for flexibility and customization in how context is retrieved and used.",Where do we choose the context items from different sources?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:168-197"",""content"":""    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:26-66"",""content"":""export type {\n    ChatError,\n    EventSource,\n    ChatHistory,\n    ChatMessage,\n    UserLocalHistory,\n    SerializedChatMessage,\n} from './chat/transcript/messages'\nexport {\n    CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID,\n    webviewOpenURIForContextItem,\n} from './chat/transcript/display-text'\nexport { Typewriter } from './chat/typewriter'\nexport { reformatBotMessageForChat } from './chat/viewHelpers'\nexport type {\n    ContextGroup,\n    ContextProvider,\n    ContextStatusProvider,\n    Disposable,\n    EnhancedContextContextT,\n    LocalEmbeddingsProvider,\n    LocalSearchProvider,\n    RemoteSearchProvider,\n    SearchProvider,\n} from './codebase-context/context-status'\nexport {\n    type ContextItem,\n    type ContextItemFile,\n    ContextItemSource,\n    type ContextItemWithContent,\n    type ContextItemSymbol,\n    type ContextFileType,\n    type ContextMessage,\n    type SymbolKind,\n} from './codebase-context/messages'\nexport type {\n    CodyCommand,\n    CodyCommandContext,\n    CodyCommandType,\n    TerminalOutputArguments,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:59-73"",""content"":""function convertContextItemMentionElement(domNode: HTMLElement): DOMConversionOutput | null {\n    const data = domNode.getAttribute(DOM_DATA_ATTR)\n    if (data !== null) {\n        try {\n            const contextItem: SerializedContextItem = JSON.parse(data)\n            const node = $createContextItemMentionNode(contextItem)\n            return { node }\n        } catch (error) {\n            console.error(error)\n            return null\n        }\n    }\n\n    return null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/cells/contextCell/ContextCell.tsx:0-27"",""content"":""import type { ContextItem } from '@sourcegraph/cody-shared'\nimport classNames from 'classnames'\nimport type React from 'react'\nimport { FileLink } from '../../../Components/FileLink'\nimport { SourcegraphLogo } from '../../../icons/SourcegraphLogo'\nimport { MENTION_CLASS_NAME } from '../../../promptEditor/nodes/ContextItemMentionNode'\nimport { getVSCodeAPI } from '../../../utils/VSCodeApi'\nimport { LoadingDots } from '../../components/LoadingDots'\nimport { Cell } from '../Cell'\nimport styles from './ContextCell.module.css'\n\n/**\n * A component displaying the context for a human message.\n */\nexport const ContextCell: React.FunctionComponent<{\n    contextFiles: ContextItem[] | undefined\n    disabled?: boolean\n    className?: string\n\n    /** For use in storybooks only. */\n    __storybook__initialOpen?: boolean\n}> = ({ contextFiles, disabled, className, __storybook__initialOpen }) => {\n    const usedContext = []\n    const excludedAtContext = []\n    if (contextFiles) {\n        for (const f of contextFiles) {\n            if (f.isTooLarge) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:190-199"",""content"":""export function $createContextItemMentionNode(\n    contextItem: ContextItem | SerializedContextItem\n): ContextItemMentionNode {\n    const node = new ContextItemMentionNode(contextItem)\n    node.setMode('token').toggleDirectionless()\n    contextItem.type === 'file' &&\n        contextItem.isTooLarge &&\n        node.setStyle('color: var(--vscode-list-errorForeground)')\n    return $applyNodeReplacement(node)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/cody.json:16-24"",""content"":""      \""context\"": {\n        \""currentFile\"": true\n      },\n      \""type\"": \""default\""\n    },\n    \""test\"": {\n      \""description\"": \""Generate unit tests\"",\n      \""prompt\"": \""Review the shared context to identify the testing framework and libraries in use. Then, generate a suite of multiple unit tests for the selected function using the detected test framework and libraries. Be sure to import the function being tested. Use the same patterns, testing framework, conventions, and libraries as shown in the shared context. Only import modules, functions, dependencies, and mocks based on shared code. If a test suite for the selected code is in the shared context, focus on generating new tests for uncovered cases. If none are detected, import common unit test libraries for {languageName}. Focus on validating key functionality with simple and complete assertions. Before writing the tests, identify which testing libraries and frameworks to use and import. At the end, enclose the fully completed code for the new unit tests without any comments, fragments, or TODOs. The new tests should validate the expected functionality and cover edge cases for with all required imports, including the function being tested. Do not repeat tests from the shared context. Enclose only the complete runnable tests.\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:213-217"",""content"":""export function $createContextItemTextNode(contextItem: ContextItem | SerializedContextItem): TextNode {\n    const atNode = new ContextItemMentionNode(contextItem)\n    const textNode = new TextNode(atNode.__text)\n    return $applyNodeReplacement(textNode)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:130-167"",""content"":""} from './inferenceClient/misc'\nexport type {\n    ContextResult,\n    FilenameContextFetcher,\n    IndexedKeywordContextFetcher,\n    LocalEmbeddingsFetcher,\n    IRemoteSearch,\n    Result,\n    SearchPanelFile,\n    SearchPanelSnippet,\n} from './local-context'\nexport { logDebug, logError, setLogger } from './logger'\nexport {\n    createOllamaClient,\n    ollamaChatClient,\n    type OllamaGenerateParams,\n    OLLAMA_DEFAULT_URL,\n} from './llm-providers/ollama'\nexport {\n    MAX_BYTES_PER_FILE,\n    MAX_CURRENT_FILE_TOKENS,\n    ANSWER_TOKENS,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    SURROUNDING_LINES,\n} from './prompt/constants'\nexport { PromptMixin, newPromptMixin } from './prompt/prompt-mixin'\nexport * from './prompt/templates'\nexport {\n    truncateText,\n    truncateTextNearestLine,\n    truncatePromptStringStart,\n    truncatePromptString,\n} from './prompt/truncation'\nexport type { Message } from './sourcegraph-api'\nexport { SourcegraphBrowserCompletionsClient } from './sourcegraph-api/completions/browserClient'\nexport { SourcegraphCompletionsClient } from './sourcegraph-api/completions/client'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:418-421"",""content"":""\n    return context.concat(currentFileNameComment, prompt.prefix)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItem.kt:22-53"",""content"":""\ndata class ContextItemFile(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: file\n) : ContextItem() {\n\n  enum class TypeEnum {\n    @SerializedName(\""file\"") File,\n  }\n}\n\ndata class ContextItemSymbol(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: symbol\n  val symbolName: String? = null,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:77-173"",""content"":""export class ContextItemMentionNode extends TextNode {\n    static getType(): string {\n        return 'contextItemMention'\n    }\n\n    static clone(node: ContextItemMentionNode): ContextItemMentionNode {\n        return new ContextItemMentionNode(node.contextItem, node.__text, node.__key)\n    }\n    static importJSON(serializedNode: SerializedContextItemMentionNode): ContextItemMentionNode {\n        const node = $createContextItemMentionNode(serializedNode.contextItem)\n        node.setTextContent(serializedNode.text)\n        node.setFormat(serializedNode.format)\n        node.setDetail(serializedNode.detail)\n        node.setMode(serializedNode.mode)\n        node.setStyle(serializedNode.style)\n        return node\n    }\n\n    private contextItem: SerializedContextItem\n\n    constructor(\n        contextItemWithAllFields: ContextItem | SerializedContextItem,\n        text?: string,\n        key?: NodeKey\n    ) {\n        // Make sure we only bring over the fields on the context item that we need, or else we\n        // could accidentally include tons of data (including the entire contents of files).\n        const contextItem = serializeContextItem(contextItemWithAllFields)\n\n        super(text ?? contextItemMentionNodeDisplayText(contextItem), key)\n\n        this.contextItem = contextItem\n    }\n\n    exportJSON(): SerializedContextItemMentionNode {\n        return {\n            ...super.exportJSON(),\n            contextItem: this.contextItem,\n            type: ContextItemMentionNode.getType(),\n            version: 1,\n        }\n    }\n\n    private static CLASS_NAMES = `context-item-mention-node ${styles.contextItemMentionNode}`\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config)\n        element.className = ContextItemMentionNode.CLASS_NAMES\n        return element\n    }\n\n    exportDOM(): DOMExportOutput {\n        const element = document.createElement('span')\n        element.setAttribute(DOM_DATA_ATTR, JSON.stringify(this.contextItem))\n        element.className = ContextItemMentionNode.CLASS_NAMES\n\n        const link = document.createElement('a')\n        const { href, target } = webviewOpenURIForContextItem({\n            uri: URI.parse(this.contextItem.uri),\n            range: this.contextItem.range,\n        })\n        link.href = href\n        if (target) {\n            link.target = target\n        }\n        link.textContent = this.__text\n        element.appendChild(link)\n\n        return { element }\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            span: (domNode: HTMLElement) => {\n                if (!domNode.hasAttribute(DOM_DATA_ATTR)) {\n                    return null\n                }\n                return {\n                    conversion: convertContextItemMentionElement,\n                    priority: 1,\n                }\n            },\n        }\n    }\n\n    isTextEntity(): true {\n        return true\n    }\n\n    canInsertTextBefore(): boolean {\n        return false\n    }\n\n    canInsertTextAfter(): boolean {\n        return false\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-input.ts:396-419"",""content"":""\n                const matchingContext = await getMatchingContext(mentionQuery)\n                if (matchingContext.length === 0) {\n                    // Attempted to match but found nothing\n                    input.items = [\n                        {\n                            alwaysShow: true,\n                            label:\n                                mentionQuery.type === 'symbol'\n                                    ? mentionQuery.text.length === 0\n                                        ? SYMBOL_HELP_LABEL\n                                        : NO_SYMBOL_MATCHES_LABEL\n                                    : mentionQuery.text.length === 0\n                                      ? FILE_HELP_LABEL\n                                      : NO_FILE_MATCHES_LABEL,\n                        },\n                    ]\n                    return\n                }\n\n                // Update stored context items so we can retrieve them later\n                for (const { key, item } of matchingContext) {\n                    contextItems.set(key, item)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:40-68"",""content"":""export async function fetchContentForURLContextItem(\n    url: string,\n    signal?: AbortSignal\n): Promise<string | null> {\n    const resp = await fetch(url.toString(), { signal })\n    if (!resp.ok) {\n        return null\n    }\n    const body = await resp.text()\n\n    // HACK(sqs): Rudimentarily strip HTML tags, script, and other unneeded elements from body using\n    // regexp. This is NOT intending to be a general-purpose HTML parser and is NOT sanitizing the\n    // value for security.\n    const bodyWithoutTags = body\n        .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n        .replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '')\n        .replace(/<svg\\b[^<]*(?:(?!<\\/svg>)<[^<]*)*<\\/svg>/gi, '')\n        .replace(/<!--.*?-->/gs, '')\n        .replace(/\\s(?:class|style)=[\""'][^\""']*[\""']/gi, '')\n        .replace(/\\sdata-[\\w-]+(=[\""'][^\""']*[\""'])?/gi, '')\n\n    // TODO(sqs): Arbitrarily trim the response text to avoid overflowing the context window for the\n    // LLM. Ideally we would make the prompt builder prioritize this context item over other context\n    // because it is explicitly from the user.\n    const MAX_LENGTH = 14000\n    return bodyWithoutTags.length > MAX_LENGTH\n        ? `${bodyWithoutTags.slice(0, MAX_LENGTH)}... (web page content was truncated)`\n        : bodyWithoutTags\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320"",""content"":""\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:50-52"",""content"":""export function deserializeContextItem(contextItem: SerializedContextItem): ContextItem {\n    return { ...contextItem, uri: URI.parse(contextItem.uri) }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:35-48"",""content"":""export function serializeContextItem(\n    contextItem: ContextItem | SerializedContextItem\n): SerializedContextItem {\n    // Make sure we only bring over the fields on the context item that we need, or else we\n    // could accidentally include tons of data (including the entire contents of files).\n    return {\n        ...contextItem,\n        uri: contextItem.uri.toString(),\n\n        // Don't include the `content` (if it's present) because it's quite large, and we don't need\n        // to serialize it here. It can be hydrated on demand.\n        content: undefined,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-matching-context.ts:0-31"",""content"":""import type { ContextItem, MentionQuery } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\n\nimport { getChatContextItemsForMention } from '../../chat/context/chatContext'\nimport { getLabelForContextItem } from './utils'\n\ninterface FixupMatchingContext {\n    /* Unique identifier for the context, shown in the input value but not necessarily in the quick pick selector */\n    key: string\n    /* If present, will override the key shown in the quick pick selector */\n    shortLabel?: string\n    item: ContextItem\n}\n\nexport async function getMatchingContext(mentionQuery: MentionQuery): Promise<FixupMatchingContext[]> {\n    const token = new vscode.CancellationTokenSource()?.token\n    const results = await getChatContextItemsForMention(mentionQuery, token)\n    return results.map(result => {\n        return {\n            key: getLabelForContextItem(result),\n            item: result,\n            shortLabel:\n                result.type === 'symbol'\n                    ? `${result.kind === 'class' ? '$(symbol-structure)' : '$(symbol-method)'} ${\n                          result.symbolName\n                      }`\n                    : undefined,\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:7-34"",""content"":""export async function getURLContextItems(\n    urlInput: string,\n    signal?: AbortSignal\n): Promise<ContextItem[]> {\n    const url = tryParsePossiblyIncompleteURL(urlInput)\n    if (url === null) {\n        return []\n    }\n\n    try {\n        const content = await fetchContentForURLContextItem(url.toString(), signal)\n        if (content === null) {\n            return []\n        }\n        return [\n            {\n                type: 'file',\n                uri: url,\n                content,\n                title: tryGetHTMLDocumentTitle(content),\n                source: ContextItemSource.Uri,\n            },\n        ]\n    } catch (error) {\n        // Suppress errors because the user might be typing a URL that is not yet valid.\n        return []\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport type { ContextRetriever } from '../types'\n\nimport type { BfgRetriever } from './retrievers/bfg/bfg-retriever'\nimport { JaccardSimilarityRetriever } from './retrievers/jaccard-similarity/jaccard-similarity-retriever'\nimport { SectionHistoryRetriever } from './retrievers/section-history/section-history-retriever'\n\nexport type ContextStrategy =\n    | 'bfg'\n    | 'jaccard-similarity'\n    | 'new-jaccard-similarity'\n    | 'bfg-mixed'\n    | 'local-mixed'\n    | 'none'\n\nexport interface ContextStrategyFactory extends vscode.Disposable {\n    getStrategy(document: vscode.TextDocument): { name: ContextStrategy; retrievers: ContextRetriever[] }\n}\n\nexport class DefaultContextStrategyFactory implements ContextStrategyFactory {\n    private disposables: vscode.Disposable[] = []\n\n    private localRetriever: ContextRetriever | undefined\n    private graphRetriever: ContextRetriever | undefined\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:36-38"",""content"":""export function isURLContextItem(item: Pick<ContextItem, 'uri'>): boolean {\n    return item.uri.scheme === 'http' || item.uri.scheme === 'https'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:33-61"",""content"":""            suggestedItems: number\n            /** Number of total snippets */\n            retrievedItems: number\n            /** Duration of the individual retriever */\n            duration: number\n            /**\n             * A bitmap that indicates at which position in the result set an entry from the given\n             * retriever is included. It only includes information about the first 32 entries.\n             *\n             * The lowest bit indicates if the first entry is included, the second lowest bit\n             * indicates if the second entry is included, and so on.\n             */\n            positionBitmap: number\n        }\n    }\n}\n\nexport interface GetContextResult {\n    context: AutocompleteContextSnippet[]\n    logSummary: ContextSummary\n}\n\n/**\n * The context mixer is responsible for combining multiple context retrieval strategies into a\n * single proposed context list.\n *\n * This is done by ranking the order of documents using reciprocal rank fusion and then combining\n * the snippets from each retriever into a single list using top-k (so we will pick all returned\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:212-226"",""content"":""    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:199-210"",""content"":""    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77"",""content"":""        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItemSource.kt:0-6"",""content"":""@file:Suppress(\""FunctionName\"", \""ClassName\"", \""unused\"", \""EnumEntryName\"", \""UnusedImport\"")\npackage com.sourcegraph.cody.protocol_generated\n\ntypealias ContextItemSource = String // One of: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_016/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"We check for content attribution in the `ChatMessageContent.tsx` file. Specifically, within the `useEffect` hook, we call the `guardrails.searchAttribution` method to check if the code snippet displayed in the chat message has any attribution. 

Here's the relevant code snippet:

```typescript
guardrails
    .searchAttribution(preText)
    .then(attribution => {
        // ... handle attribution results
    })
    .catch(error => {
        // ... handle errors
    })
```

The `guardrails` object is an instance of the `Guardrails` class, which is responsible for handling attribution checks. The `searchAttribution` method takes the code snippet as input and returns a promise that resolves with the attribution results.",Where do we check for content attribution?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:203-214"",""content"":""function checkValidEnumValues(configName: string, value: string | null): void {\n    const validEnumValues = getConfigEnumValues(`cody.${configName}`)\n    if (value) {\n        if (!validEnumValues.includes(value)) {\n            void vscode.window.showErrorMessage(\n                `Invalid value for ${configName}: ${value}. Valid values are: ${validEnumValues.join(\n                    ', '\n                )}`\n            )\n        }\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:4054-4078"",""content"":""            2n1Tofe+i1bW2ZHXhNA1apTk30hqndqL17plySGZAuO/ijE6yxkED6hm8fHpRnN1d85\\\n            U0Fl9xzhFnlzIk0U01WnbfsaZ+ggLtCTg1vgaeba2Ftnty9VlgYeyasRZaHWuzPYroh\\\n            NXPcXi8sDBeqyj0c78bJM/rORz+8//94VUrS/3Bbt2rP/37lbbFnzsfnL9W/NdPr5X9\\\n            tFdP7f/+sPu03/xf/4gb8+F/fWjeVZt//mr++ue//PO3fz6//tfP/b8VbfFj9fo38+5\\\n            p8/jtXv74f17kj/XT5s1fDn99fFcXPz63/7K7WPz4Xdw0/3hb/Ni+/PX/+Uv9rx/r47\\\n            /++enbv/7zH2/Vj388Fj/+4/j5/Q/vfvrlw9sP5mD+Pv1e/vOP3YcnZz7Yb//n1X/+8\\\n            5///P8BAAD//0QFQV3tCQIA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:32:13 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: retry-after\n            value: \""282\""\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/attribution.test.ts:12-33"",""content"":""const test = baseTest\n    .extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n    .extend<ExpectedEvents>({\n        // list of events we expect this test to log, add to this list as needed\n        expectedEvents: [\n            'CodyInstalled',\n            'CodyVSCodeExtension:auth:clickOtherSignInOptions',\n            'CodyVSCodeExtension:login:clicked',\n            'CodyVSCodeExtension:auth:selectSigninMenu',\n            'CodyVSCodeExtension:auth:fromToken',\n            'CodyVSCodeExtension:Auth:connected',\n            'CodyVSCodeExtension:chat-question:submitted',\n            'CodyVSCodeExtension:chat-question:executed',\n            'CodyVSCodeExtension:chatResponse:hasCode',\n        ],\n    })\n    .extend<ExtraWorkspaceSettings>({\n        extraWorkspaceSettings: {\n            // TODO(#59720): Remove experimental setting.\n            'cody.experimental.guardrails': true,\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:105-138"",""content"":""      _order: 0\n      cache: {}\n      request:\n        bodySize: 10486\n        cookies: []\n        headers:\n          - name: content-type\n            value: application/json\n          - name: accept-encoding\n            value: gzip;q=0\n          - name: authorization\n            value: token\n              REDACTED_b20717265e7ab1d132874d8ff0be053ab9c1dacccec8dce0bbba76888b6a0a69\n          - name: user-agent\n            value: enterpriseClient / v1\n          - name: host\n            value: demo.sourcegraph.com\n        headersSize: 265\n        httpVersion: HTTP/1.1\n        method: POST\n        postData:\n          mimeType: application/json\n          params: []\n          textJSON:\n            maxTokensToSample: 1000\n            messages:\n              - speaker: human\n                text: You are Cody, an AI coding assistant from Sourcegraph.\n              - speaker: assistant\n                text: I am Cody, an AI coding assistant from Sourcegraph.\n              - speaker: human\n                text: >-\n                  Codebase context from file /agent/README.md in repository\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:7357-7384"",""content"":""            TV68pkB+nxayTnfUxFI4Sug+6FETlcN5vseCqWw5dIsYKxBKg01OJm6s+D7T1NbQBqQ\\\n            BtYz94lGT6PUejuxbG/2wJv7Mk6JUl+MJxEct3461Pyk7GO6O4yONy+fXDayr6VVyAL\\\n            CfoVP1ChiONKzIspRcrOLM251/n8/kPAAAA//8DANaF7gAtBAAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:31 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:5321-5347"",""content"":""            z//9zYtWVuqDWdsXf/j3C2XKP3bOW3ct3o+fXhfm0654aP/rw/bTbvXnn8JKf/jth+a\\\n            7zeofP+q//vEv//j5H0+v//VD/1vZln/avP5Zf/ewevNqV7z9/3bln+pG/fD79l//+K\\\n            n+6z8/Pa5+eP1m9ebTZvXnj6H880+vVm//0v78j6fvPz5Xrz69+9jzey//+Zf657d/b\\\n            1dvvtWf9Qe97pfMf/7zn//8vwAAAP//7inTaSEHAgA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:38:54 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: content-encoding\n            value: gzip\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:21-30"",""content"":""interface ChatMessageContentProps {\n    displayMarkdown: string\n    wrapLinksWithCodyCommand: boolean\n\n    copyButtonOnSubmit?: CodeBlockActionsProps['copyButtonOnSubmit']\n    insertButtonOnSubmit?: CodeBlockActionsProps['insertButtonOnSubmit']\n\n    guardrails?: Guardrails\n    className?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:138-147"",""content"":""                  github.com/sourcegraph/cody:\n\n                  ```markdown\n\n                  | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n\n                  | `pnpm test agent/src/index.test.ts`                                                                                  | Run agent tests in replay mode                                                                                                                                |\n\n                  | `source agent/scripts/export-cody-http-recording-tokens.sh`                                                          | Export access tokens to enable recording mode                                                                                                                 |\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/rateLimitedClient_2043004676/recording.har.yaml:1047-1076"",""content"":""                siteID: SourcegraphWeb\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 17 Apr 2024 09:12:26 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Cookie,Accept-Encoding,Authorization,Cookie, Authorization,\n              X-Requested-With,Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n            value: 1; mode=block\n          - name: strict-transport-security\n            value: max-age=31536000; includeSubDomains; preload\n          - name: content-encoding\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupContentStore.ts:9-75"",""content"":""export class ContentProvider implements vscode.TextDocumentContentProvider, vscode.Disposable {\n    // This stores the content of the document for each task ID\n    // The content is initialized by the fixup task with the original content\n    // and then updated by the fixup task with the replacement content\n    private contentStore = new Map<FixupTaskID, fileContent>()\n    // This tracks the task IDs belong toe each file path\n    private tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    private _onDidChange = new vscode.EventEmitter<vscode.Uri>()\n    private _disposables: vscode.Disposable\n\n    constructor() {\n        // TODO: Handle applying fixups to files which are opened and closed.\n        // This is tricky because we need to re-sync the range we are tracking\n        // when the file is opened.\n        this._disposables = vscode.workspace.onDidCloseTextDocument(doc =>\n            this.deleteByFilePath(doc.uri.fsPath)\n        )\n    }\n    // Get content from the content store\n    public provideTextDocumentContent(uri: vscode.Uri): string | null {\n        const id = uri.fragment\n        return this.contentStore.get(id) || null\n    }\n    // Add to store - store origin content by fixup task id\n    public async set(id: string, docUri: vscode.Uri): Promise<void> {\n        const doc = await vscode.workspace.openTextDocument(docUri)\n        this.contentStore.set(id, doc.getText())\n        this.tasksByFilePath.set(docUri.fsPath, [...(this.tasksByFilePath.get(docUri.fsPath) || []), id])\n    }\n\n    // Remove by ID\n    public delete(id: string): void {\n        this.contentStore.delete(id)\n        // remove task from tasksByFilePath\n        for (const [filePath, tasks] of this.tasksByFilePath) {\n            const index = tasks.indexOf(id)\n            if (index > -1) {\n                tasks.splice(index, 1)\n            }\n            if (tasks.length === 0) {\n                this.deleteByFilePath(filePath)\n            }\n        }\n    }\n\n    // Remove by file path\n    private deleteByFilePath(fileName: string): void {\n        const files = this.tasksByFilePath.get(fileName)\n        if (!files) {\n            return\n        }\n        for (const id of files) {\n            this.contentStore.delete(id)\n        }\n    }\n\n    public get onDidChange(): vscode.Event<vscode.Uri> {\n        return this._onDidChange.event\n    }\n\n    public dispose(): void {\n        this._disposables.dispose()\n        this._onDidChange.dispose()\n        this.contentStore = new Map<FixupTaskID, fileContent>()\n        this.tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:156-175"",""content"":""\n    // Updates the extension configuration and returns the new\n    // authentication status, which indicates whether the provided credentials are\n    // valid or not. The agent can't support autocomplete or chat if the credentials\n    // are invalid.\n    'extensionConfiguration/change': [ExtensionConfiguration, AuthStatus | null]\n\n    // Returns the current authentication status without making changes to it.\n    'extensionConfiguration/status': [null, AuthStatus | null]\n\n    // Run attribution search for a code snippet displayed in chat.\n    // Attribution is an enterprise feature which allows to look for code generated\n    // by Cody in an open source code corpus. User is notified if any such attribution\n    // is found.\n    // For more details, please see:\n    // *   PRD: https://docs.google.com/document/d/1c3CLC7ICDaG63NOWjO6zWm-UElwuXkFrKbCKTw-7H6Q/edit\n    // *   RFC: https://docs.google.com/document/d/1zSxFDQPxZcn5b6yKx40etpJayoibVzj_Gnugzln1weI/edit\n    'attribution/search': [\n        { id: string; snippet: string },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:235-309"",""content"":""export const ChatMessageContent: React.FunctionComponent<ChatMessageContentProps> = ({\n    displayMarkdown,\n    wrapLinksWithCodyCommand,\n    copyButtonOnSubmit,\n    insertButtonOnSubmit,\n    guardrails,\n    className,\n}) => {\n    const rootRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        const preElements = rootRef.current?.querySelectorAll('pre')\n        if (!preElements?.length || !copyButtonOnSubmit) {\n            return\n        }\n\n        for (const preElement of preElements) {\n            const preText = preElement.textContent\n            if (preText?.trim() && preElement.parentNode) {\n                const buttons = createButtons(preText, copyButtonOnSubmit, insertButtonOnSubmit)\n                if (guardrails) {\n                    const container = document.createElement('div')\n                    container.classList.add(styles.attributionContainer)\n                    buttons.append(container)\n\n                    const g = new GuardrailsStatusController(container)\n                    g.setPending()\n\n                    guardrails\n                        .searchAttribution(preText)\n                        .then(attribution => {\n                            if (isError(attribution)) {\n                                g.setUnavailable(attribution)\n                            } else if (attribution.repositories.length === 0) {\n                                g.setSuccess()\n                            } else {\n                                g.setFailure(\n                                    attribution.repositories.map(r => r.name),\n                                    attribution.limitHit\n                                )\n                            }\n                        })\n                        .catch(error => {\n                            g.setUnavailable(error)\n                            return\n                        })\n                }\n\n                // Insert the buttons after the pre using insertBefore() because there is no insertAfter()\n                preElement.parentNode.insertBefore(buttons, preElement.nextSibling)\n\n                // capture copy events (right click or keydown) on code block\n                preElement.addEventListener('copy', () => {\n                    if (copyButtonOnSubmit) {\n                        copyButtonOnSubmit(preText, 'Keydown')\n                    }\n                })\n            }\n        }\n    }, [copyButtonOnSubmit, insertButtonOnSubmit, guardrails])\n\n    return (\n        <div\n            ref={rootRef}\n            className={classNames(styles.content, className)}\n            // biome-ignore lint/security/noDangerouslySetInnerHtml: the result is run through dompurify\n            dangerouslySetInnerHTML={{\n                // wrapLinksWithCodyCommand opens all links in assistant responses using the\n                // _cody.vscode.open command (but not human messages because those already\n                // have the right URIs and are trusted).\n                __html: renderCodyMarkdown(displayMarkdown, { wrapLinksWithCodyCommand }),\n            }}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/index.md:0-8"",""content"":""# Cody documentation\n\n> **Note**\n> We're in the process of moving Cody documentation from the [`sourcegraph/sourcegraph` repository `doc/cody` directory](https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/tree/doc/cody) to this repository.\n\n- [Development](development/index.md)\n- [All other Cody documentation](https://sourcegraph.com/docs/cody)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/TextDocumentWithUri.ts:45-47"",""content"":""    public get content(): string | undefined {\n        return this.underlying.content\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:23-25"",""content"":""    public get content(): string {\n        return this.protocolDocument.underlying.content ?? ''\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320"",""content"":""\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/guardrails/index.ts:3-6"",""content"":""export interface Attribution {\n    limitHit: boolean\n    repositories: RepositoryAttribution[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.module.css:44-100"",""content"":""\n.attribution-container {\n    all: unset;\n    display: flex;\n    margin-left: auto;\n}\n\n\n.attribution-icon-unavailable {\n    color: var(--hl-orange);\n}\n\n.attribution-icon-found {\n    color: var(--hl-dark-red);\n}\n\n.status {\n    display: flex;\n    align-items: center;\n}\n\n.codicon-loading {\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    from { transform: rotate(0deg); }\n    to { transform: rotate(360deg); }\n}\n\n/*\n * Content\n */\n:root {\n    --spacing: 1rem;\n}\n\n.content {\n    word-break: break-word;\n    line-height: 150%;\n    text-wrap: wrap;\n}\n\n/* Style @-file tokens to match TranscriptAction context files */\n.content a[href^=\""vscode://file\""] em,\n.content a[href^=\""vscode-insiders://file\""] em,\n.content a[href^=\""vscodium://file\""] em,\n.content a[href^=\""cursor://file\""] em\n{\n    padding: 1px 2px;\n    box-sizing: border-box;\n    background-color: color-mix(in srgb, var(--vscode-textLink-foreground) 15%, transparent);\n    border-radius: 2px;\n    font-style: normal;\n    word-break: break-all;\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_017/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Custom actions are triggered in a few different places within the codebase:

1. **`cody.action.command`:** This command is executed when a custom command is invoked, either through the sidebar, the command palette, or a custom keybinding. The command takes the custom command's key as an argument and executes the associated action. This is handled in `src/commands/services/custom-commands.ts`.

2. **`cody.commands/custom`:** This JSON-RPC method is used by the agent to trigger custom commands. It takes the custom command's key as an argument and returns a `CustomCommandResult`, which can be either a chat-based command or an edit command. This is defined in `src/jsonrpc/agent-protocol.ts`.

3. **`cody.menu.custom-commands`:** This command is used to open the custom command menu, which allows the user to select and execute a custom command. This is defined in `package.json`.

4. **`cody.sidebar.commands`:** This command is used to trigger custom commands from the sidebar. It takes the custom command's key as an argument and executes the associated action. This is handled in `src/services/SidebarCommands.ts`.

In summary, custom actions are triggered through a combination of commands, JSON-RPC methods, and menu interactions. The specific trigger mechanism depends on how the custom command is invoked.",Where do we trigger custom actions?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/test.ts:8-38"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [testableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getTestableNode',\n        })\n        if (!testableNode) {\n            return []\n        }\n\n        const { range: testableRange, symbol: testableSymbol } = testableNode\n        if (!testableSymbol || !testableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            testableRange.node.startPosition.row,\n            testableRange.node.startPosition.column,\n            testableRange.node.endPosition.row,\n            testableRange.node.endPosition.column\n        )\n\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Tests for ${testableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:0-18"",""content"":""# Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can easily update these bindings in the `Keyboard Shortcuts editor`, which you can access by clicking on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**`.\n\nThis feature can be particularly useful if the default key bindings conflict with your current or preferred key bindings.\n\n## Keyboard Shortcuts Editor\n\nThe Keyboard Shortcuts editor allows you to easily update the key bindings for any of the Cody commands. To open the `Keyboard Shortcuts Editor`:\n1. Open the Cody sidebar and expand the `**SETTINGS AND SUPPORT**` section.\n2. Click on the `**Keyboard Shortcuts**` icon.\n\n## Custom Commands\n\n![editor](images/keyboard_editor.png)\n\nYou have the option to assign key bindings (keyboard shortcuts) to individual custom commands:\n1. In the Cody sidebar under `**SETTINGS AND SUPPORT**`, click on the `**Keyboard Shortcuts**` icon to open the Keyboard Shortcuts editor.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:14-45"",""content"":""    public async provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): Promise<vscode.CodeAction[]> {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n\n        // Expand range to include the full line for better fixup quality\n        const expandedRange = new vscode.Range(\n            document.lineAt(range.start.line).range.start,\n            document.lineAt(range.end.line).range.end\n        )\n\n        // TODO bee check if the diagnostics are related to imports and include import ranges instead of error lines\n        // const importDiagnostics = diagnostics.filter(diagnostic => diagnostic.message.includes('import'))\n\n        // Expand range by getting the folding range contains the target (error) area\n        const targetAreaRange = await getSmartSelection(document.uri, range.start)\n\n        const newRange = targetAreaRange\n            ? new vscode.Range(targetAreaRange.start, targetAreaRange.end)\n            : expandedRange\n        const codeAction = await this.createCommandCodeAction(document, diagnostics, newRange)\n        return [codeAction]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/BaseEditor.tsx:77-101"",""content"":""                                    />\n                                </div>\n                            </div>\n                        }\n                        placeholder={<div className={styles.placeholder}>{placeholder}</div>}\n                        ErrorBoundary={LexicalErrorBoundary}\n                    />\n                    <HistoryPlugin />\n                    <OnChangePlugin onChange={onChange} ignoreSelectionChange={true} />\n                    <MentionsPlugin />\n                    <CodeHighlightPlugin />\n                    <AutoFocusPlugin />\n                    {onFocusChange && <OnFocusChangePlugin onFocusChange={onFocusChange} />}\n                    {editorRef && <EditorRefPlugin editorRef={editorRef} />}\n                    <KeyboardEventPlugin\n                        onKeyDown={onKeyDown}\n                        onEnterKey={onEnterKey}\n                        onEscapeKey={onEscapeKey}\n                    />\n                </LexicalComposer>\n            </div>\n        </div>\n    )\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:851-862"",""content"":""- Assign requestID to each Code Block actions. [pull/1586](https://github.com/sourcegraph/cody/pull/1586)\n- [Internal Experimental] Chat: New Experimental Chat View that appears in the editor panel instead of the sidebar when `cody.experimental.chatPanel` is enabled. [pull/1509](https://github.com/sourcegraph/cody/pull/1509)\n\n### Fixed\n\n- Commands: Smart selection not working on the first line of code. [pull/1508](https://github.com/sourcegraph/cody/pull/1508)\n- Chat: Aborted messages are now saved to local chat history properly. [pull/1550](https://github.com/sourcegraph/cody/pull/1550)\n- Adjust a completion range if it does not match the current line suffix. [pull/1507](https://github.com/sourcegraph/cody/pull/1507)\n- Chat: Fix heading styles and inline code colors. [pull/1528](https://github.com/sourcegraph/cody/pull/1528)\n- Custom Commands: Fix custom command menu not showing for a single custom command. [pull/1532](https://github.com/sourcegraph/cody/pull/1532)\n- Chat: Focus chat input on mount even when notification for version update is shown. [pull/1556](https://github.com/sourcegraph/cody/pull/1556)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:10-12"",""content"":""interface CodeActionProviderOptions {\n    contextProvider: ContextProvider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:27-48"",""content"":""import {\n    executeDocCommand,\n    executeExplainCommand,\n    executeExplainOutput,\n    executeSmellCommand,\n    executeTestCaseEditCommand,\n    executeTestChatCommand,\n    executeTestEditCommand,\n} from './commands/execute'\nimport type { CodyCommandArgs } from './commands/types'\nimport { newCodyCommandArgs } from './commands/utils/get-commands'\nimport { createInlineCompletionItemProvider } from './completions/create-inline-completion-item-provider'\nimport { getConfiguration, getFullConfig } from './configuration'\nimport { EnterpriseContextFactory } from './context/enterprise-context-factory'\nimport { EditManager } from './edit/manager'\nimport { manageDisplayPathEnvInfoForExtension } from './editor/displayPathEnvInfo'\nimport { VSCodeEditor } from './editor/vscode-editor'\nimport type { PlatformContext } from './extension.common'\nimport { configureExternalServices } from './external-services'\nimport { logDebug, logError } from './log'\nimport { getChatModelsFromConfiguration, syncModelProviders } from './models/utils'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/edit.ts:7-29"",""content"":""    public provideCodeActions(document: vscode.TextDocument): vscode.CodeAction[] {\n        const editor = vscode.window.activeTextEditor\n\n        if (!editor) {\n            return []\n        }\n\n        if (\n            editor.selection.isEmpty &&\n            !document.lineAt(editor.selection.start.line).isEmptyOrWhitespace\n        ) {\n            // Empty selection but a non-empty line, show nothing as the user likely won't want to generate here.\n            return []\n        }\n\n        if (editor.selection.isEmpty) {\n            // Empty selection and empty line, show generate action\n            return [this.createGenerateCodeAction(document, editor.selection)]\n        }\n\n        // Non-empty selection, show edit action\n        return [this.createEditCommandCodeAction(document, editor.selection)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/HoverCommandsProvider.ts:0-28"",""content"":""import {\n    type AuthStatus,\n    FeatureFlag,\n    PromptString,\n    featureFlagProvider,\n    isCodyIgnoredFile,\n    logDebug,\n    ps,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { executeEdit } from '../edit/execute'\nimport { fetchDocumentSymbols } from '../edit/input/utils'\nimport { telemetryService } from '../services/telemetry'\nimport { telemetryRecorder } from '../services/telemetry-v2'\nimport { logFirstEnrollmentEvent } from '../services/utils/enrollment-event'\nimport { execQueryWrapper as execQuery } from '../tree-sitter/query-sdk'\nimport { executeDocCommand } from './execute'\nimport { executeHoverChatCommand } from './execute/hover'\nimport type { CodyCommandArgs } from './types'\n\n/**\n * NOTE: Behind the feature flag `cody-hover-commands`.\n *\n * Provides clickable commands on hover and handles clicking on commands.\n */\nclass HoverCommandsProvider implements vscode.Disposable {\n    private readonly id = FeatureFlag.CodyHoverCommands\n    private disposables: vscode.Disposable[] = []\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:7-21"",""content"":""    public provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): vscode.CodeAction[] {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n        return [this.createCommandCodeAction(document.uri, diagnostics)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:792-822"",""content"":""          \""group\"": \""navigation@1\""\n        },\n        {\n          \""command\"": \""cody.search.index-update-all\"",\n          \""when\"": \""view == cody.search && cody.activated\"",\n          \""group\"": \""navigation@2\""\n        }\n      ],\n      \""editor/title\"": [\n        {\n          \""command\"": \""cody.menu.commands\"",\n          \""when\"": \""cody.activated && !editorReadonly && (resourceScheme == file || activeWebviewPanelId == cody.chatPanel)\"",\n          \""group\"": \""navigation\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""cody.chat.panel.new\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated\"",\n          \""group\"": \""navigation@1\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""cody.chat.history.panel\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated\"",\n          \""group\"": \""navigation@2\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""workbench.action.moveEditorToNewWindow\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated && !isAuxiliaryEditorPart\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:32-58"",""content"":""\n    // \""⌘\"" on Mac or \""Ctrl\"" on other systems\n    const isMac = isMacOS()\n    const osIcon = isMac ? '⌘' : 'Ctrl+'\n\n    // The Chat Actions are conditionally rendered based on the 'when' property.\n    // The \""Cancel Edit\"" action is only available when isEditing is true, meaning\n    // the user is in the process of editing a message.\n    // The \""Edit Last Message\"" and \""New Chat\"" actions are available when isEditing is false,\n    // indicating that the user is not editing a message and can either edit their last message\n    // or start a new chat session via these buttons that also have keyboard shortcuts associated with them.\n    const actions: {\n        name: string\n        keyLabel: string\n        keyRequiresFocus?: boolean\n        onClick?: () => void\n        focus: boolean\n        when: boolean\n    }[] = [\n        {\n            name: 'Cancel Edit',\n            keyLabel: 'ESC',\n            keyRequiresFocus: true,\n            onClick: onCancelEditClick,\n            focus: false,\n            when: isEditing && !isEmptyChat,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:14-54"",""content"":""export class CodeActionProvider implements vscode.Disposable {\n    private configurationChangeListener: vscode.Disposable\n    private actionProviders: vscode.Disposable[] = []\n\n    constructor(options: CodeActionProviderOptions) {\n        this.registerCodeActions(options.contextProvider.config)\n        this.configurationChangeListener = options.contextProvider.configurationChangeEvent.event(() => {\n            this.registerCodeActions(options.contextProvider.config)\n        })\n    }\n\n    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n    }\n\n    private addActionProvider(ActionType: {\n        new (): vscode.CodeActionProvider\n        providedCodeActionKinds: vscode.CodeActionKind[]\n    }): void {\n        const provider = vscode.languages.registerCodeActionsProvider('*', new ActionType(), {\n            providedCodeActionKinds: ActionType.providedCodeActionKinds,\n        })\n        this.actionProviders.push(provider)\n    }\n\n    public dispose(): void {\n        this.configurationChangeListener.dispose()\n        vscode.Disposable.from(...this.actionProviders).dispose()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/actions/TranscriptAction.tsx:6-15"",""content"":""interface TranscriptActionStep {\n    verb: string\n    object: string | JSX.Element\n\n    /**\n     * The SVG path of an icon.\n     * @example mdiSearchWeb\n     */\n    icon?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:0-32"",""content"":""import type React from 'react'\nimport { useEffect, useRef } from 'react'\n\nimport { isMacOS } from '@sourcegraph/cody-shared'\nimport styles from './ChatActions.module.css'\n\nexport const ChatActions: React.FunctionComponent<{\n    isWebviewActive: boolean\n    isEditing: boolean\n    isMessageInProgress: boolean\n    isEmptyChat: boolean\n    isEmptyEditorValue: boolean\n    isEditorFocused: boolean\n    onChatResetClick: () => void\n    onCancelEditClick: () => void\n    onEditLastMessageClick: () => void\n    setInputFocus: (focus: boolean) => void\n    onRestoreLastChatClick?: () => void\n}> = ({\n    isEditing,\n    isEmptyChat,\n    isEmptyEditorValue,\n    isEditorFocused,\n    isMessageInProgress,\n    onChatResetClick,\n    onCancelEditClick,\n    onEditLastMessageClick,\n    setInputFocus,\n    onRestoreLastChatClick,\n    isWebviewActive,\n}) => {\n    const buttonRef = useRef<HTMLButtonElement>(null)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/actions/TranscriptAction.tsx:17-44"",""content"":""export const TranscriptAction: React.FunctionComponent<{\n    title: string | { verb: string; object: string; tooltip?: string }\n    steps: TranscriptActionStep[]\n    className?: string\n    onClick?: () => void\n}> = ({ title, steps, className, onClick }) => {\n    return (\n        <details className={classNames(className, styles.container)}>\n            <summary onClick={onClick} onKeyDown={onClick}>\n                {typeof title === 'string' ? (\n                    title\n                ) : (\n                    <span title={title.tooltip}>\n                        {title.verb} <strong>{title.object}</strong>\n                    </span>\n                )}\n            </summary>\n            <div className={styles.steps}>\n                {steps.map((step, index) => (\n                    // biome-ignore lint/suspicious/noArrayIndexKey: no other natural key, and this is stable/immutable\n                    <span key={index} className={styles.step}>\n                        {step.object}\n                    </span>\n                ))}\n            </div>\n        </details>\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:18-24"",""content"":""2. Search for `cody.command.custom.{CUSTOM_COMMAND_NAME}`. \n3. Replace `{CUSTOM_COMMAND_NAME}` with the name or key of your custom command, for example, `cody.command.custom.commit`.\n4. Click on the `+` icon next to the command to assign a custom keybinding for your custom command.\n\nFor more information on keyboard settings in VS Code, please refer to the official documentation on [Key Bindings for Visual Studio Code](https://code.visualstudio.com/docs/getstarted/keybindings#_keyboard-shortcuts-editor).\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:727-760"",""content"":""          \""when\"": \""cody.activated\"",\n          \""group\"": \""command\""\n        },\n        {\n          \""command\"": \""cody.menu.custom-commands\"",\n          \""when\"": \""cody.activated\"",\n          \""group\"": \""custom-commands\""\n        },\n        {\n          \""command\"": \""cody.focus\"",\n          \""when\"": \""!cody.activated\"",\n          \""group\"": \""other\""\n        },\n        {\n          \""command\"": \""cody.guardrails.debug\"",\n          \""when\"": \""cody.activated && config.cody.experimental.guardrails && editorHasSelection\"",\n          \""group\"": \""other\""\n        }\n      ],\n      \""view/title\"": [\n        {\n          \""command\"": \""cody.chat.panel.new\"",\n          \""when\"": \""view == cody.chat.tree.view && cody.activated\"",\n          \""group\"": \""navigation@1\""\n        },\n        {\n          \""command\"": \""cody.chat.history.clear\"",\n          \""when\"": \""view == cody.chat.tree.view && cody.activated && cody.hasChatHistory\"",\n          \""enablement\"": \""cody.hasChatHistory\"",\n          \""group\"": \""navigation@2\""\n        },\n        {\n          \""command\"": \""cody.chat.history.export\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:402-435"",""content"":""      },\n      {\n        \""command\"": \""cody.autocomplete.manual-trigger\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Trigger Autocomplete at Cursor\"",\n        \""when\"": \""cody.activated && config.cody.autocomplete && editorHasFocus && !editorReadonly && !editorHasSelection && !inlineSuggestionsVisible\""\n      },\n      {\n        \""command\"": \""cody.chat.panel.new\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""New Chat Panel\"",\n        \""when\"": \""cody.activated\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(new-comment-icon)\""\n      },\n      {\n        \""command\"": \""workbench.action.moveEditorToNewWindow\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Pop out\"",\n        \""when\"": \""cody.activated\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(link-external)\""\n      },\n      {\n        \""command\"": \""cody.chat.tree.view.focus\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Open Cody Sidebar\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(layout-sidebar-left)\""\n      },\n      {\n        \""command\"": \""cody.chat.history.edit\"",\n        \""category\"": \""Cody\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/custom-commands.ts:0-319"",""content"":""import os from 'node:os'\nimport { omit } from 'lodash'\nimport * as vscode from 'vscode'\n\nimport type { CodyCommand } from '@sourcegraph/cody-shared'\n\nimport { logDebug, logError } from '../../log'\n\nimport { isMacOS } from '@sourcegraph/cody-shared'\nimport { CustomCommandType } from '@sourcegraph/cody-shared'\nimport { URI, Utils } from 'vscode-uri'\nimport { getConfiguration } from '../../configuration'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getCommandTreeItems } from '../../services/tree-views/commands'\nimport { showNewCustomCommandMenu } from '../menus'\nimport { type CodyCommandsFile, ConfigFiles } from '../types'\nimport { createFileWatchers, createJSONFile, saveJSONFile } from '../utils/config-file'\nimport { buildCodyCommandMap } from '../utils/get-commands'\nimport { getDocText } from '../utils/workspace-files'\n\nconst isTesting = process.env.CODY_TESTING === 'true'\nconst userHomePath = os.homedir() || process.env.HOME || process.env.USERPROFILE || ''\n\n/**\n * Handles loading, building, and maintaining Custom Commands retrieved from cody.json files\n */\nexport class CustomCommandsManager implements vscode.Disposable {\n    // Watchers for the cody.json files\n    private fileWatcherDisposables: vscode.Disposable[] = []\n    private registeredCommands: vscode.Disposable[] = []\n    private disposables: vscode.Disposable[] = []\n\n    public customCommandsMap = new Map<string, CodyCommand>()\n\n    // Configuration files\n    protected configFileName\n    private userConfigFile\n    private get workspaceConfigFile(): vscode.Uri | undefined {\n        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri\n        if (!workspaceRoot) {\n            return undefined\n        }\n        return Utils.joinPath(workspaceRoot, this.configFileName)\n    }\n\n    constructor(private sidebar: TreeViewProvider) {\n        // TODO (bee) Migrate to use .cody/commands.json for VS Code\n        // Right now agent is using .cody/commands.json for Custom Commands,\n        // .vscode/cody.json in VS Code.\n        const workspaceConfig = vscode.workspace.getConfiguration()\n        const config = getConfiguration(workspaceConfig)\n        this.configFileName = config.isRunningInsideAgent ? ConfigFiles.COMMAND : ConfigFiles.VSCODE\n        this.userConfigFile = Utils.joinPath(URI.file(userHomePath), this.configFileName)\n\n        this.disposables.push(\n            vscode.commands.registerCommand('cody.menu.custom.build', () =>\n                this.newCustomCommandQuickPick()\n            ),\n            vscode.commands.registerCommand('cody.commands.open.json', type =>\n                this.configFileActions(type, 'open')\n            ),\n            vscode.commands.registerCommand('cody.commands.delete.json', type =>\n                this.configFileActions(type, 'delete')\n            )\n        )\n    }\n\n    /**\n     // TODO (bee) Migrate to use .cody/commands.json\n     * Create file watchers for cody.json files.\n     * Automatically update the command map when the cody.json files are changed\n     */\n    public init(): void {\n        const userConfigWatcher = createFileWatchers(this.userConfigFile)\n        if (userConfigWatcher) {\n            this.fileWatcherDisposables.push(\n                userConfigWatcher,\n                userConfigWatcher.onDidChange(() => this.refresh?.()),\n                userConfigWatcher.onDidDelete(() => this.refresh?.())\n            )\n        }\n\n        // Create file watchers in trusted workspaces only\n        if (vscode.workspace.isTrusted) {\n            const wsConfigWatcher = createFileWatchers(this.workspaceConfigFile)\n            if (wsConfigWatcher) {\n                this.fileWatcherDisposables.push(\n                    wsConfigWatcher,\n                    wsConfigWatcher.onDidChange(() => this.refresh?.()),\n                    wsConfigWatcher.onDidDelete(() => this.refresh?.())\n                )\n            }\n        }\n\n        if (this.fileWatcherDisposables.length) {\n            logDebug('CommandsController:init', 'watchers created')\n        }\n    }\n\n    /**\n     * Gets the map of custom commands.\n     *\n     * The custom commands map is a collection of CodyCommand objects, where the key\n     * is the command name and the value is the command object.\n     */\n    public get commands(): Map<string, CodyCommand> {\n        return this.customCommandsMap\n    }\n\n    /**\n     * Get the uri of the cody.json file for the given type\n     */\n    private getConfigFileByType(type: CustomCommandType): vscode.Uri | undefined {\n        const configFileUri =\n            type === CustomCommandType.User ? this.userConfigFile : this.workspaceConfigFile\n        return configFileUri\n    }\n\n    /**\n     * Rebuild the Custom Commands Map from the cody.json files\n     */\n    public async refresh(): Promise<CodyCommandsFile> {\n        try {\n            // Deregister all commands before rebuilding them to avoid duplicates\n            this.disposeRegisteredCommands()\n            // Reset the map before rebuilding\n            this.customCommandsMap = new Map<string, CodyCommand>()\n            // user commands\n            if (this.userConfigFile?.path) {\n                await this.build(CustomCommandType.User)\n            }\n            // 🚨 SECURITY: Only build workspace command in trusted workspace\n            if (vscode.workspace.isTrusted) {\n                await this.build(CustomCommandType.Workspace)\n            }\n        } catch (error) {\n            logError('CustomCommandsProvider:refresh', 'failed', { verbose: error })\n        }\n        this.sidebar.setTreeNodes(getCommandTreeItems([...this.customCommandsMap.values()]))\n        return { commands: this.customCommandsMap }\n    }\n\n    /**\n     * Handles building the Custom Commands Map from the cody.json files\n     *\n     * 🚨 SECURITY: Only build workspace command in trusted workspace\n     */\n    public async build(type: CustomCommandType): Promise<Map<string, CodyCommand> | null> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri || (type === CustomCommandType.Workspace && !vscode.workspace.isTrusted)) {\n            return null\n        }\n        try {\n            const content = await getDocText(uri)\n            if (!content.trim()) {\n                return null\n            }\n            const customCommandsMap = buildCodyCommandMap(type, content)\n            this.customCommandsMap = new Map([...this.customCommandsMap, ...customCommandsMap])\n\n            // Register Custom Commands as VS Code commands\n            for (const [key, _command] of customCommandsMap) {\n                this.registeredCommands.push(\n                    vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>\n                        vscode.commands.executeCommand('cody.action.command', key, {\n                            source: 'editor',\n                        })\n                    )\n                )\n            }\n        } catch (error) {\n            console.error('CustomCommandsProvider:build', 'failed', { verbose: error })\n        }\n        return this.customCommandsMap\n    }\n\n    /**\n     * Quick pick for creating a new custom command\n     */\n    private async newCustomCommandQuickPick(): Promise<void> {\n        const commands = [...this.customCommandsMap.values()].map(c => c.key)\n        const newCommand = await showNewCustomCommandMenu(commands)\n        if (!newCommand) {\n            return\n        }\n\n        // Save the prompt to the current Map and Extension storage\n        await this.save(newCommand.key, newCommand.prompt, newCommand.type)\n        await this.refresh()\n\n        // Notify user\n        const isUserCommand = newCommand.type === CustomCommandType.User\n        const buttonTitle = `Open ${isUserCommand ? 'User' : 'Workspace'} Settings (JSON)`\n        void vscode.window\n            .showInformationMessage(\n                `New ${newCommand.key} command saved to ${newCommand.type} settings`,\n                buttonTitle\n            )\n            .then(async choice => {\n                if (choice === buttonTitle) {\n                    await this.configFileActions(newCommand.type, 'open')\n                }\n            })\n\n        logDebug('CustomCommandsProvider:newCustomCommandQuickPick:', 'saved', {\n            verbose: newCommand,\n        })\n    }\n\n    /**\n     * Add the newly create command via quick pick to the cody.json file on disk\n     */\n    private async save(\n        id: string,\n        command: CodyCommand,\n        type: CustomCommandType = CustomCommandType.User\n    ): Promise<void> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri) {\n            return\n        }\n        const fileContent = await getDocText(uri)\n        const parsed = JSON.parse(fileContent) as Record<string, any>\n        const commands = parsed.commands ?? parsed\n        commands[id] = omit(command, 'key')\n        await saveJSONFile(parsed, uri)\n    }\n\n    private async configFileActions(\n        type: CustomCommandType,\n        action: 'open' | 'delete' | 'create'\n    ): Promise<void> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri) {\n            return\n        }\n        switch (action) {\n            case 'open':\n                void vscode.commands.executeCommand('vscode.open', uri)\n                break\n            case 'delete': {\n                let fileType = 'user settings file (~/.vscode/cody.json)'\n                if (type === CustomCommandType.Workspace) {\n                    fileType = 'workspace settings file (.vscode/cody.json)'\n                }\n                const bin = isMacOS() ? 'Trash' : 'Recycle Bin'\n                const confirmationKey = `Move to ${bin}`\n                // Playwright cannot capture and interact with pop-up modal in VS Code,\n                // so we need to turn off modal mode for the display message during tests.\n                const modal = !isTesting\n                vscode.window\n                    .showInformationMessage(\n                        `Are you sure you want to delete your Cody ${fileType}?`,\n                        { detail: `You can restore this file from the ${bin}.`, modal },\n                        confirmationKey\n                    )\n                    .then(async choice => {\n                        if (choice === confirmationKey) {\n                            void vscode.workspace.fs.delete(uri)\n                        }\n                    })\n                break\n            }\n            case 'create':\n                await createJSONFile(uri)\n                    .then(() => {\n                        vscode.window\n                            .showInformationMessage(\n                                `Cody ${type} settings file created`,\n                                'View Documentation'\n                            )\n                            .then(async choice => {\n                                if (choice === 'View Documentation') {\n                                    await openCustomCommandDocsLink()\n                                }\n                            })\n                    })\n                    .catch(error => {\n                        const errorMessage = 'Failed to create cody.json file: '\n                        void vscode.window.showErrorMessage(`${errorMessage} ${error}`)\n                        logDebug('CustomCommandsProvider:configActions:create', 'failed', {\n                            verbose: error,\n                        })\n                    })\n                break\n        }\n    }\n\n    /**\n     * Reset\n     */\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.disposeRegisteredCommands()\n        this.disposeWatchers()\n        this.customCommandsMap = new Map<string, CodyCommand>()\n    }\n\n    private disposeWatchers(): void {\n        for (const disposable of this.fileWatcherDisposables) {\n            disposable.dispose()\n        }\n        this.fileWatcherDisposables = []\n    }\n\n    private disposeRegisteredCommands(): void {\n        for (const rc of this.registeredCommands) {\n            rc.dispose()\n        }\n        this.registeredCommands = []\n    }\n}\n\nexport async function openCustomCommandDocsLink(): Promise<void> {\n    const uri = 'https://sourcegraph.com/docs/cody/custom-commands'\n    await vscode.env.openExternal(vscode.Uri.parse(uri))\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:70-91"",""content"":""\n    // Trigger chat-based commands (explain, test, smell), which are effectively\n    // shortcuts to start a new chat with a templated question. The return value\n    // of these commands is the same as `chat/new`, an ID to reference to the\n    // webview panel where the reply from this command appears.\n    'commands/explain': [null, string] // TODO: rename to chatCommands/{explain,test,smell}\n    'commands/test': [null, string]\n    'commands/smell': [null, string]\n\n    // Trigger custom commands that could be a chat-based command or an edit command.\n    'commands/custom': [{ key: string }, CustomCommandResult]\n\n    // Trigger commands that edit the code.\n    'editCommands/code': [{ instruction: string; model: string }, EditTask]\n    'editCommands/test': [null, EditTask]\n    'editCommands/document': [null, EditTask]\n\n    // If the task is \""applied\"", discards the task.\n    'editTask/accept': [{ id: FixupTaskID }, null]\n    // If the task is \""applied\"", attempts to revert the task's edit, then\n    // discards the task.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/SidebarCommands.ts:0-30"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    ACCOUNT_LIMITS_INFO_URL,\n    ACCOUNT_UPGRADE_URL,\n    ACCOUNT_USAGE_URL,\n    CODY_DOC_URL,\n    CODY_FEEDBACK_URL,\n    CODY_SUPPORT_URL,\n    DISCORD_URL,\n} from '../chat/protocol'\nimport { releaseNotesURL } from '../release'\nimport { telemetryService } from '../services/telemetry'\nimport { telemetryRecorder } from '../services/telemetry-v2'\nimport { version } from '../version'\n\nexport function registerSidebarCommands(): vscode.Disposable[] {\n    function logSidebarClick(feature: string) {\n        telemetryService.log(`CodyVSCodeExtension:sidebar:${feature}:clicked`, undefined, {\n            hasV2Event: true,\n        })\n        telemetryRecorder.recordEvent(`cody.sidebar.${feature}`, 'clicked')\n    }\n\n    return [\n        vscode.commands.registerCommand('cody.sidebar.commands', (feature: string, command: string) => {\n            // For Custom Commands\n            if (command === 'cody.action.command') {\n                logSidebarClick('custom')\n                void vscode.commands.executeCommand(command, feature, { source: 'sidebar' })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1015-1050"",""content"":""### Changed\n\n- Remove `starter` and `premade` fields from the configuration files for custom commands (cody.json). [pull/939](https://github.com/sourcegraph/cody/pull/939)\n- Enabled streaming responses for all autocomplete requests. [pull/995](https://github.com/sourcegraph/cody/pull/995)\n- Sign out immediately instead of showing the quick-pick menu. [pull/1032](https://github.com/sourcegraph/cody/pull/1032)\n- UX improvements to the custom command workflow (and new [custom command docs](https://sourcegraph.com/docs/cody/custom-commands)). [pull/992](https://github.com/sourcegraph/cody/pull/992)\n- You can now use `alt` + `\\` to trigger autocomplete requests manually. [pull/1060](https://github.com/sourcegraph/cody/pull/1060)\n- Slightly reduce latency when manually triggering autocomplete requests. [pull/1060](https://github.com/sourcegraph/cody/pull/1060)\n- Configure autocomplete provider based on cody LLM settings in site config. [pull/1035](https://github.com/sourcegraph/cody/pull/1035)\n- Filters out single character autocomplete results. [pull/1109](https://github.com/sourcegraph/cody/pull/1109)\n- Register inline completion provider for text files and notebooks only to ensure autocomplete works in environments that are fully supported. [pull/1114](https://github.com/sourcegraph/cody/pull/1114)\n- The `Generate Unit Tests` command has been improved with an enhanced context fetching process that produces test results with better quality. [pull/907](https://github.com/sourcegraph/cody/pull/907)\n\n## [0.10.2]\n\n### Added\n\n### Fixed\n\n### Changed\n\n- Use the same token limits for StarCoder as we do for Anthropic for the current experiments. [pull/1058](https://github.com/sourcegraph/cody/pull/1058)\n\n## [0.10.1]\n\n### Added\n\n### Fixed\n\n- Fix feature flag initialization for autocomplete providers. [pull/965](https://github.com/sourcegraph/cody/pull/965)\n\n### Changed\n\n## [0.10.0]\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_018/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The decision to use enhanced context for chat is made in the `getEnhancedContext` function in the file `cody_test/vscode/src/chat/chat-view/context.ts`. 

Here's how it works:

1. **Configuration Check:** The function first checks the `strategy` parameter, which represents the user's configuration for using enhanced context. This configuration can be set to one of the following values:
    - `none`: Only use the visible editor context.
    - `keyword`: Use keyword search results (Symf or remote search).
    - `embeddings`: Use embeddings results.
    - `all`: Use all available context sources (embeddings, keyword search, and visible editor).

2. **Context Ranking:** If the `contextRanking` parameter is provided, it indicates that we're using a context ranking system to prioritize context items. In this case, the function calls `getEnhancedContextFromRanker` to retrieve the ranked context.

3. **Default Behavior:** If `contextRanking` is not provided, the function proceeds with the default behavior:
    - If `strategy` is set to `none`, it only retrieves the visible editor context.
    - Otherwise, it retrieves context from embeddings, keyword search, and Symf, based on the `strategy` value.

4. **Priority Context:** The function then calls `getPriorityContext` to prioritize context items based on their relevance to the current chat message.

5. **Combining Context:** Finally, the function combines the prioritized context with the other retrieved context items and returns the final list of context items to be used for the chat.

Therefore, the decision to use enhanced context is ultimately determined by the user's configuration (`strategy`) and the availability of a context ranking system (`contextRanking`).",Where do we determine whether to use enhanced context for chat?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/can-use-partial-completion.ts:0-41"",""content"":""import type { TextDocument } from 'vscode'\n\nimport type { DocumentContext } from '@sourcegraph/cody-shared'\nimport { hasCompleteFirstLine } from './text-processing'\nimport { parseAndTruncateCompletion } from './text-processing/parse-and-truncate-completion'\nimport type { InlineCompletionItemWithAnalytics } from './text-processing/process-inline-completions'\n\ninterface CanUsePartialCompletionParams {\n    document: TextDocument\n    docContext: DocumentContext\n}\n\n/**\n * Evaluates a partial completion response and returns it when we can already use it. This is used\n * to terminate any streaming responses where we can get a token-by-token access to the result and\n * want to terminate as soon as stop conditions are triggered.\n *\n * Right now this handles two cases:\n *  1. When a single line completion is requested, it terminates after the first full line was\n *     received.\n *  2. For a multi-line completion, it terminates when the completion will be truncated based on the\n *     multi-line indentation logic.\n */\nexport function canUsePartialCompletion(\n    partialResponse: string,\n    params: CanUsePartialCompletionParams\n): InlineCompletionItemWithAnalytics | null {\n    const { docContext } = params\n\n    if (!hasCompleteFirstLine(partialResponse)) {\n        return null\n    }\n\n    const item = parseAndTruncateCompletion(partialResponse, params)\n\n    if (docContext.multilineTrigger) {\n        return (item.lineTruncatedCount || 0) > 0 ? item : null\n    }\n\n    return item.insertText.trim() === '' ? null : item\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/counter.ts:26-43"",""content"":""     * Indicates whether the Chat and User-Context share the same token budget.\n     * - If true, all types of messages share the same token budget with Chat.\n     * - If false (Feature Flag required), the User-Context will has a separated budget.\n     * NOTE: Used in remainingTokens for calculating the remaining token budget for each budget type.\n     */\n    private shareChatAndUserBudget = true\n\n    constructor(contextWindow: ModelContextWindow) {\n        // If there is no context window reserved for context.user,\n        // context will share the same token budget with chat.\n        this.shareChatAndUserBudget = !contextWindow.context?.user\n        this.maxChatTokens = contextWindow.input\n        this.maxContextTokens = {\n            user: contextWindow.context?.user ?? contextWindow.input,\n            enhanced: Math.floor(contextWindow.input * ENHANCED_CONTEXT_ALLOCATION),\n        }\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:51-53"",""content"":""function useChatContextClient(): ChatContextClient {\n    return useContext(ChatContextClientContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/active-editor.ts:0-26"",""content"":""import * as vscode from 'vscode'\n\nimport { isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\n/**\n * Interface for tracking the last active text editor that is not a webview panel for\n * the new Chat Panel UI.\n *\n * active: The current valid active/supported text editor instance.\n * ignored: Whether the active editor is ignored by Cody or not.\n */\ninterface LastActiveTextEditor {\n    active?: vscode.TextEditor\n    ignored?: boolean\n}\n\n/**\n * This returns the current active text editor instance if available,\n * along with a boolean indicating if the text editor is on the Cody ignored list.\n * Returns undefined if no editor is active.\n *\n * NOTE: ALL USERS of chat interface in VS Code should use this to get the correct Active Editor instead of using\n * 'vscode.window.activeTextEditor' as this handles cases where the activeTextEditor API will always return\n * 'undefined' when user is focused on the webview chat panel.\n *\n * NOTE: Users that operate within an actual text editor (non-webview panels) do not need to use this API as calling\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:56-108"",""content"":""export function useChatContextItems(query: string | null): ContextItem[] | undefined {\n    const chatContextClient = useChatContextClient()\n    const [results, setResults] = useState<ContextItem[]>()\n    // biome-ignore lint/correctness/useExhaustiveDependencies: we only want to run this when query changes.\n    useEffect(() => {\n        // An empty query is a valid query that we use to get open tabs context,\n        // while a null query means this is not an at-mention query.\n        if (query === null) {\n            setResults(undefined)\n            return\n        }\n\n        // If the query ends with a colon, we will reuse current results but remove the range.\n        if (query.endsWith(':')) {\n            const selected = results?.find(r => displayPath(r.uri) === query.slice(0, -1))\n            setResults(\n                selected\n                    ? [{ ...selected, range: undefined }]\n                    : results?.map(r => ({ ...r, range: undefined }))\n            )\n            return\n        }\n\n        // If user is typing a line range, fetch new chat context items only if there are no results\n        if (results?.length && RANGE_MATCHES_REGEXP.test(query) && !LINE_RANGE_REGEXP.test(query)) {\n            return\n        }\n\n        // Track if the query changed since this request was sent (which would make our results\n        // no longer valid).\n        let invalidated = false\n\n        if (chatContextClient) {\n            chatContextClient\n                .getChatContextItems(query)\n                .then(mentions => {\n                    if (invalidated) {\n                        return\n                    }\n                    setResults(mentions)\n                })\n                .catch(error => {\n                    setResults(undefined)\n                    console.error(error)\n                })\n        }\n\n        return () => {\n            invalidated = true\n        }\n    }, [query])\n    return results\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:98-116"",""content"":""            }\n            const enhancedContext = prevContext.filter(c => c.source !== 'user')\n            if (promptBuilder.tryAddContext('enhanced', enhancedContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior enhanced context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n            }\n\n            // Add additional context from current editor or broader search when enhanced context is enabled\n            if (this.getEnhancedContext) {\n                const lastMessage = reverseTranscript[0]\n                if (!lastMessage?.text) {\n                    throw new Error('No last message or last message text was empty')\n                }\n                if (lastMessage.speaker === 'assistant') {\n                    throw new Error('Last message in prompt needs speaker \""human\"", but was \""assistant\""')\n                }\n                const newEnhancedContext = await this.getEnhancedContext(lastMessage.text)\n                sortContextItems(newEnhancedContext)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/squirrel.ts:0-11"",""content"":""interface CodeIntelligence {\n    symbols: string[]\n}\n\n/**\n * Squirrel is a code intelligence API.\n */\ninterface Squirrel {\n    symbolInformation(file: string): CodeIntelligence\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/local-embeddings.test.ts:140-164"",""content"":""    await openFile(page, 'main.c')\n    await sidebarSignin(page, sidebar)\n    const chatFrame = await newChat(page)\n\n    const enableEmbeddingsButton = chatFrame.getByText('Enable Embeddings')\n    // This may take a while, we download and start cody-engine\n    await expect(enableEmbeddingsButton).toBeVisible({ timeout: 60000 })\n    await enableEmbeddingsButton.click()\n\n    await expect(chatFrame.getByText('Embeddings — Indexed')).toBeVisible({\n        timeout: 30000,\n    })\n\n    // Search the embeddings. This test uses the \""stub\"" embedding model, which\n    // is deterministic, but the searches are not semantic.\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    await chatInput.fill('hello world')\n    await chatInput.press('Enter')\n    const contextCell = getContextCell(chatFrame)\n    await expectContextCellCounts(contextCell, {\n        files: 2,\n        timeout: 10000,\n    })\n})\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/animal.ts:0-5"",""content"":""interface Animal {\n    name: string;\n    age: number;\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:32-64"",""content"":""    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n}\nexport async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/README.md:0-5"",""content"":""# Cody Agent\n\nThe `@sourcegraph/cody-agent` package implements a JSON-RPC server to interact\nwith Cody via stdout/stdin. This package is intended to be used by\nnon-ECMAScript clients such as the JetBrains and NeoVim plugins.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:682-694"",""content"":""\n### Changed\n\n- Chat: Uses the new Chat UI by default. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Inline Chat is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Fixup Tree View is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Enhanced Context used to turn off automatically after the first chat. Now it stays enabled until you disable it. [pull/2069](https://github.com/sourcegraph/cody/pull/2069)\n- Chat: Reuse existing New Chat panel to prevent having multiple new chats open at once. [pull/2087](https://github.com/sourcegraph/cody/pull/2087)\n- Chat: Close the Enhanced Context popover on chat input focus. [pull/2091](https://github.com/sourcegraph/cody/pull/2091)\n- Chat: Show onboarding glowy dot guide until first time opening Enhanced Context. [pull/2097](https://github.com/sourcegraph/cody/pull/2097)\n- In 0.12, we simplified the sign-in process and removed the option to sign into\n  Cody App from VScode. If you were still signed in to Cody App, we invite you to\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:67-69"",""content"":""function useEnhancedContextEventHandlers(): EnhancedContextEventHandlersT {\n    return React.useContext(EnhancedContextEventHandlers)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:24-35"",""content"":""interface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:94-157"",""content"":""async function getEnhancedContextFromRanker({\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    return wrapInActiveSpan('chat.enhancedContextRanker', async span => {\n        // Get all possible context items to rank\n        let searchContext = getVisibleEditorContext(editor)\n\n        const numResults = 50\n        const embeddingsContextItemsPromise = retrieveContextGracefully(\n            searchEmbeddingsLocal(providers.localEmbeddings, text, numResults),\n            'local-embeddings'\n        )\n\n        const modelSpecificEmbeddingsContextItemsPromise = contextRanking\n            ? retrieveContextGracefully(\n                  contextRanking.searchModelSpecificEmbeddings(text, numResults),\n                  'model-specific-embeddings'\n              )\n            : []\n\n        const precomputeQueryEmbeddingPromise = contextRanking?.precomputeContextRankingFeatures(text)\n\n        const localSearchContextItemsPromise = providers.symf\n            ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n            : []\n\n        const remoteSearchContextItemsPromise = providers.remoteSearch\n            ? await retrieveContextGracefully(\n                  searchRemote(providers.remoteSearch, text),\n                  'remote-search'\n              )\n            : []\n\n        const keywordContextItemsPromise = (async () => [\n            ...(await localSearchContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n        ])()\n\n        const [embeddingsContextItems, keywordContextItems, modelEmbeddingContextItems] =\n            await Promise.all([\n                embeddingsContextItemsPromise,\n                keywordContextItemsPromise,\n                modelSpecificEmbeddingsContextItemsPromise,\n                precomputeQueryEmbeddingPromise,\n            ])\n\n        searchContext = searchContext\n            .concat(keywordContextItems)\n            .concat(embeddingsContextItems)\n            .concat(modelEmbeddingContextItems)\n        const editorContext = await getPriorityContext(text, editor, searchContext)\n        const allContext = editorContext.concat(searchContext)\n        if (!contextRanking) {\n            return allContext\n        }\n        const rankedContext = wrapInActiveSpan('chat.enhancedContextRanker.reranking', () =>\n            contextRanking.rankContextItems(text, allContext)\n        )\n        return rankedContext\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/context-settings.test.ts:24-43"",""content"":""\n    // Opening the enhanced context settings should focus the checkbox for toggling it.\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n\n    // Enhanced context should be enabled by default.\n    await expect(enhancedContextCheckbox).toBeChecked()\n    await page.keyboard.press('Space') // Disable enhanced context\n    // The keyboard should toggle the checkbox, but not dismiss the popup.\n    await expect(enhancedContextCheckbox).not.toBeChecked()\n    await expect(enhancedContextCheckbox).toBeVisible()\n\n    // The popup should be dismiss-able with the keyboard.\n    await page.keyboard.press('Escape')\n    // Closing the enhanced context settings should close the dialog...\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    // ... and the focus is moved to the chat input on close.\n    const contextSettingsButton = chatFrame.getByTitle('Configure Enhanced Context')\n    await expect(contextSettingsButton.and(page.locator(':focus'))).not.toBeVisible()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:36-92"",""content"":""export async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n                      searchEmbeddingsLocal(providers.localEmbeddings, text),\n                      'local-embeddings'\n                  )\n                : []\n\n        //  Get search (symf or remote search) context if config is not set to 'embeddings' only\n        const remoteSearchContextItemsPromise =\n            providers.remoteSearch && strategy !== 'embeddings'\n                ? await retrieveContextGracefully(\n                      searchRemote(providers.remoteSearch, text),\n                      'remote-search'\n                  )\n                : []\n        const localSearchContextItemsPromise =\n            providers.symf && strategy !== 'embeddings'\n                ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n                : []\n\n        // Combine all context sources\n        const searchContext = [\n            ...(await embeddingsContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n            ...(await localSearchContextItemsPromise),\n        ]\n\n        const priorityContext = await getPriorityContext(text, editor, searchContext)\n        return priorityContext.concat(searchContext)\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15"",""content"":""export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287"",""content"":""\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the “Chats” panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the “Chats” panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the “Chats” panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \""Enhanced Context\"" icon next to the chat input.\n- [ ] Verify that \""Enhanced Context\"" is enabled by default.\n\n### Consumer\n\nSet up steps:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:377-385"",""content"":""- We now allocate no more than 60% of the overall LLM context window for enhanced context. This preserves more room for follow-up questions and context. [pull/2768](https://github.com/sourcegraph/cody/pull/2768)\n- Chat: Renamed the \""Restart Chat Session\"" button to \""New Chat Session\"". [pull/2786](https://github.com/sourcegraph/cody/pull/2786)\n- Removed the `cody.experimental.chatPredictions` setting. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Removed support for the `context.codebase` custom command property. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Autocomplete: Better cancellation of requests that are no longer relevant. [pull/2855](https://github.com/sourcegraph/cody/pull/2855)\n- Updated Enhanced Context popover copy and added a link to the docs. [pull/2864](https://github.com/sourcegraph/cody/pull/2864)\n- Include meta information about unit test files in Autocomplete analytics. [pull/2868](https://github.com/sourcegraph/cody/pull/2868)\n- Moved the Context Limit errors in chat into the deboug log output. [pull/2891](https://github.com/sourcegraph/cody/pull/2891)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.test.ts:0-150"",""content"":""import { describe, expect, it } from 'vitest'\nimport * as vscode from 'vscode'\n\nimport type * as status from '@sourcegraph/cody-shared'\n\nimport { ContextStatusAggregator } from './enhanced-context-status'\n\nclass TestProvider implements status.ContextStatusProvider {\n    public emitter: vscode.EventEmitter<status.ContextStatusProvider> = new vscode.EventEmitter()\n\n    constructor(private status_: status.ContextGroup[] | undefined = undefined) {}\n\n    public onDidChangeStatus(\n        callback: (provider: status.ContextStatusProvider) => void\n    ): vscode.Disposable {\n        return this.emitter.event(callback)\n    }\n\n    public get status(): status.ContextGroup[] {\n        return (\n            this.status_ || [\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'embeddings',\n                            state: 'unconsented',\n                        },\n                    ],\n                },\n            ]\n        )\n    }\n    public set status(status: status.ContextGroup[]) {\n        this.status_ = status\n    }\n}\n\ndescribe('ContextStatusAggregator', () => {\n    it('should fire status changed when providers are added and pass through simple status', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => resolve(provider.status))\n        })\n        aggregator.addProvider(new TestProvider())\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                ],\n            },\n        ])\n        aggregator.dispose()\n    })\n    it('should fire aggregate status from multiple providers', async () => {\n        const aggregator = new ContextStatusAggregator()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        aggregator.addProvider(new TestProvider())\n        aggregator.addProvider(\n            new TestProvider([\n                {\n                    displayName: 'host.example/foo',\n                    providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n                },\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'search',\n                            type: 'remote',\n                            state: 'ready',\n                            id: 'quux',\n                            inclusion: 'manual',\n                        },\n                    ],\n                },\n            ])\n        )\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id: 'quux',\n                        inclusion: 'manual',\n                    },\n                ],\n            },\n            {\n                displayName: 'host.example/foo',\n                providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n            },\n        ])\n        // Not only does it aggregate status, it coalesces update events\n        expect(callbackCount).toBe(1)\n        aggregator.dispose()\n    })\n    it('should respond to child events by firing an event of its own', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const provider = new TestProvider()\n        aggregator.addProvider(provider)\n        // Skip the first update event.\n        await Promise.resolve()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        provider.status = [\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [{ kind: 'search', type: 'local', state: 'indexing' }],\n            },\n        ]\n        provider.emitter.fire(provider)\n\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'local',\n                        state: 'indexing',\n                    },\n                ],\n            },\n        ])\n        expect(callbackCount).toBe(1)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:64-89"",""content"":""\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.ts:0-158"",""content"":""import * as vscode from 'vscode'\n\nimport type { ContextGroup, ContextStatusProvider } from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\n// Collects context status from a set of ContextStatusProviders and produces\n// a merged status view.\nexport class ContextStatusAggregator implements vscode.Disposable, ContextStatusProvider {\n    private static TAG = 'ContextStatusAggregator'\n    private disposables: Set<vscode.Disposable> = new Set()\n    private statusEmitter: vscode.EventEmitter<ContextStatusProvider> =\n        new vscode.EventEmitter<ContextStatusProvider>()\n    private providerStatusMap: Map<ContextStatusProvider, ContextGroup[] | 'needs-status'> | undefined =\n        new Map()\n\n    // Whether we have been notified of status changes, but are yet to pass that\n    // notification on. We do this to de-bounce updates from multiple status\n    // providers in one turn of the event loop.\n    private pendingPublish = false\n\n    // Disposes this ContextStatusAggregator.\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.providerStatusMap = undefined\n    }\n\n    // Adds a provider to this ContextStatusAggregator. The aggregator will\n    // subscribe to the provider and aggregate its updates into a merged status.\n    // To remove this provider, dispose of the returned disposable.\n    //\n    // If the provider is disposable, it should dispose of the registration in\n    // its dispose method. Otherwise this ContextStatusAggregator may continue\n    // to poll its status property, and show its status in the aggregate status.\n    public addProvider(provider: ContextStatusProvider): vscode.Disposable {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const disposable = provider.onDidChangeStatus(putativeProvider => {\n            if (provider !== putativeProvider) {\n                logDebug(\n                    ContextStatusAggregator.TAG,\n                    'got onDidChangeStatus event but passed mismatched provider'\n                )\n            }\n            this.providerDidChangeStatus(provider)\n        })\n        this.disposables.add(disposable)\n        this.providerStatusMap.set(provider, 'needs-status')\n        this.providerDidChangeStatus(provider)\n        return {\n            dispose: (): void => {\n                if (this.providerStatusMap) {\n                    this.providerStatusMap.delete(provider)\n                    this.disposables.delete(disposable)\n                    disposable.dispose()\n                    this.publishStatus()\n                }\n            },\n        }\n    }\n\n    // Records that the provider's state is dirty, and schedules an update.\n    private providerDidChangeStatus(provider: ContextStatusProvider): void {\n        if (this.providerStatusMap === undefined) {\n            // We have been disposed\n            return\n        }\n        if (!this.providerStatusMap.has(provider)) {\n            // The provider has been removed. This should not happen if the\n            // providers are following the dispose protocol.\n            return\n        }\n        // Record that we need to get provider status next update.\n        this.providerStatusMap.set(provider, 'needs-status')\n        // Schedule an update.\n        this.publishStatus()\n    }\n\n    // Aggregates and publishes status asynchronously. Multiple context status\n    // providers updating \""at once\"" will be coalesced into one update.\n    private publishStatus(): void {\n        if (this.pendingPublish) {\n            // Coalesce multiple updates.\n            return\n        }\n        this.pendingPublish = true\n        void Promise.resolve().then(() => {\n            this.pendingPublish = false\n            this.statusEmitter.fire(this)\n        })\n    }\n\n    // ContextStatusProvider implementation of onDidChangeStatus. The\n    // ContextStatusAggregator can be stacked to combine per-workspace and\n    // per-chat context status.\n    public onDidChangeStatus(callback: (sender: ContextStatusProvider) => void): vscode.Disposable {\n        return this.statusEmitter.event(callback)\n    }\n\n    // Computes the merged context status. This may throw if any of the\n    // aggregated providers' status throw.\n    public get status(): ContextGroup[] {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const groupBy: { [name: string]: ContextGroup } = {}\n        // Iterate through provider status map entries\n        for (let [provider, status] of this.providerStatusMap.entries()) {\n            if (status === 'needs-status') {\n                // The provider's status is stale; poll it.\n                status = provider.status\n                if (this.providerStatusMap.get(provider) !== 'needs-status') {\n                    logDebug(\n                        ContextStatusAggregator.TAG,\n                        'ContextStatusProvider.status should only report status, not change state',\n                        provider\n                    )\n                }\n                // Deep clone the status object so providers can't continue to change it without notifying.\n                status = JSON.parse(JSON.stringify(status)) as ContextGroup[]\n                // Cache the status so we don't re-poll this provider unless it changes.\n                this.providerStatusMap.set(provider, status)\n            }\n\n            // Collect context groups by name\n            for (const group of status) {\n                if (group.displayName in groupBy) {\n                    // Merge the items in the group.\n                    groupBy[group.displayName].providers.push(...group.providers)\n                } else {\n                    // Create a new group for the merged result.\n                    groupBy[group.displayName] = {\n                        displayName: group.displayName,\n                        providers: [...group.providers],\n                    }\n                }\n            }\n        }\n        // Order sources within the groups by a canonical order\n        for (const groups of Object.values(groupBy)) {\n            // Sort by a fixed locale for consistency. The 'kind' key is not a\n            // localized UI label.\n            groups.providers.sort((a, b) => a.kind.localeCompare(b.kind, 'en-US'))\n        }\n        return [...Object.values(groupBy)]\n    }\n\n    // TODO: Create a publisher to push into the webview\n    // TODO: Hook in local embeddings\n    // TODO: Hook in cloud embeddings\n    // TODO: Hook in symf\n    // TODO: Hook in graph\n    // TODO: Hook in the Cody: building code index ... notification pusher's\n    // state\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/common.ts:50-74"",""content"":""\n/**\n * Create and open a new chat panel, and close the enhanced context settings window.\n * Returns the chat panel frame locator.\n */\nexport async function createEmptyChatPanel(page: Page): Promise<[FrameLocator, Locator]> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    const chatFrame = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n    await page.keyboard.press('Escape')\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    return [chatFrame, chatInput]\n}\n\n/**\n * Gets the chat context cell. If {@link counts} is specified, then validates that the context\n * exactly matches the specified file and line counts.\n */\nexport function getContextCell(\n    chatPanel: FrameLocator,\n    counts?: { files: number; lines: number }\n): Locator {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/EnhancedContext.tsx:4-6"",""content"":""export function useEnhancedContextEnabled(): boolean {\n    return React.useContext(EnhancedContextEnabled)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_019/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The embeddings model is queried in the `retrieveEmbeddingBasedContext` function within the `cody_test/vscode/src/local-context/context-ranking.ts` file. 

Here's a breakdown:

1. **`retrieveEmbeddingBasedContext` function:** This function is responsible for fetching context from the embeddings model based on a given query, number of results, and model name.
2. **`service.request`:** Inside the function, it uses the `service.request` method to send a request to the 'context-ranking/context-retriever-embedding' endpoint.
3. **`context-ranking/context-retriever-embedding` endpoint:** This endpoint is defined in the `cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts` file. It's responsible for handling requests to retrieve embeddings-based context.

Therefore, the `retrieveEmbeddingBasedContext` function is the primary point where we query the embeddings model.",Where do we query the embeddings model?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/index.ts:132-134"",""content"":""    public static getProviderByModel(modelID: string): ModelProvider | undefined {\n        return ModelProvider.providers.find(m => m.model === modelID)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:502-541"",""content"":""      },\n      {\n        \""command\"": \""cody.embeddings.resolveIssue\"",\n        \""title\"": \""Cody Embeddings\"",\n        \""when\"": \""cody.embeddings.hasIssue\""\n      },\n      {\n        \""command\"": \""cody.debug.export.logs\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Export Logs…\""\n      },\n      {\n        \""command\"": \""cody.debug.outputChannel\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Open Output Channel\""\n      },\n      {\n        \""command\"": \""cody.debug.enable.all\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Enable Debug Mode\"",\n        \""when\"": \""!config.cody.debug.verbose\""\n      },\n      {\n        \""command\"": \""cody.debug.reportIssue\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Report Issue\""\n      },\n      {\n        \""command\"": \""cody.copy.version\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""icon\"": \""$(copy)\"",\n        \""title\"": \""Copy Cody Extension Version\""\n      }\n    ],\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:4-7"",""content"":""export interface ChatModelContext {\n    chatModels?: ModelProvider[]\n    onCurrentChatModelChange?: (model: ModelProvider) => void\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:103-127"",""content"":""        this.disposables.push(\n            vscode.commands.registerCommand('cody.embeddings.resolveIssue', () =>\n                this.resolveIssueCommand()\n            )\n        )\n\n        // Pick up the initial access token, and whether the account is dotcom.\n        this.accessToken = config.accessToken || undefined\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n\n        this.model = config.testingLocalEmbeddingsModel || 'openai/text-embedding-ada-002'\n        this.endpoint =\n            config.testingLocalEmbeddingsEndpoint || 'https://cody-gateway.sourcegraph.com/v1/embeddings'\n        this.indexLibraryPath = config.testingLocalEmbeddingsIndexLibraryPath\n            ? URI.file(config.testingLocalEmbeddingsIndexLibraryPath)\n            : undefined\n    }\n\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.statusBar?.dispose()\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:21-38"",""content"":""    public async loadQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const fromCache = this.cache.find(\n            compiled => compiled.language === language && compiled.queryName === name\n        )\n        if (fromCache) {\n            return fromCache.compiledQuery\n        }\n        try {\n            return await this.compileQuery(parser, language, name)\n        } catch (error) {\n            console.error(`Queries.loadQuery(): ${language}/${name}`, error)\n            process.exit(1)\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3000-3017"",""content"":""                writer.writeMessage(22, this.super_type, () => this.super_type.serialize(writer))\n            if (this.has_constant_type)\n                writer.writeMessage(23, this.constant_type, () => this.constant_type.serialize(writer))\n            if (this.has_intersection_type)\n                writer.writeMessage(17, this.intersection_type, () =>\n                    this.intersection_type.serialize(writer)\n                )\n            if (this.has_union_type)\n                writer.writeMessage(18, this.union_type, () => this.union_type.serialize(writer))\n            if (this.has_with_type)\n                writer.writeMessage(19, this.with_type, () => this.with_type.serialize(writer))\n            if (this.has_structural_type)\n                writer.writeMessage(7, this.structural_type, () =>\n                    this.structural_type.serialize(writer)\n                )\n            if (this.has_annotated_type)\n                writer.writeMessage(8, this.annotated_type, () => this.annotated_type.serialize(writer))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:40-84"",""content"":""    private async compileQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const languages = [language, ...(grammarInheritance[language] ?? [])]\n        const queryStrings: string[] = []\n        for (const queryLanguage of languages) {\n            const queryPath = path.join(this.queriesDirectory, queryLanguage, `${name}.scm`)\n            try {\n                const stat = await fspromises.stat(queryPath)\n                if (!stat.isFile()) {\n                    continue\n                }\n            } catch {\n                if (this.queryDirectoryExists === undefined) {\n                    try {\n                        this.queryDirectoryExists = (\n                            await fspromises.stat(this.queriesDirectory)\n                        ).isDirectory()\n                        if (!this.queryDirectoryExists) {\n                            throw new Error(\n                                `Query directory ${this.queriesDirectory} is not a directory. To fix this problem, update the value of the flag --queries-directory <path>`\n                            )\n                        }\n                    } catch {\n                        throw new Error(\n                            `Query directory ${this.queriesDirectory} does not exist. To fix this problem, update the value of the flag --queries-directory <path>`\n                        )\n                    }\n                }\n                continue\n            }\n            const queryString = await fspromises.readFile(queryPath)\n            queryStrings.push(queryString.toString())\n        }\n        const uncompiled: UncompiledQuery = {\n            language,\n            queryName: name,\n            queryString: queryStrings.join('\\n\\n'),\n        }\n        const compiled = compileQuery(uncompiled, parser)\n        this.cache.push(compiled)\n        return compiled.compiledQuery\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:68-95"",""content"":""\n// Model identifiers can be found in https://docs.fireworks.ai/explore/ and in our internal\n// conversations\nconst MODEL_MAP = {\n    // Virtual model strings. Cody Gateway will map to an actual model\n    starcoder: 'fireworks/starcoder',\n    'starcoder-16b': 'fireworks/starcoder-16b',\n    'starcoder-7b': 'fireworks/starcoder-7b',\n    'starcoder2-15b': 'fireworks/starcoder2-15b',\n    'starcoder2-7b': 'fireworks/starcoder2-7b',\n\n    // Fireworks model identifiers\n    'llama-code-13b': 'fireworks/accounts/fireworks/models/llama-v2-13b-code',\n}\n\ntype FireworksModel =\n    | keyof typeof MODEL_MAP\n    // `starcoder-hybrid` uses the 16b model for multiline requests and the 7b model for single line\n    | 'starcoder-hybrid'\n    // `starcoder2-hybrid` uses the 15b model for multiline requests and the 7b model for single line\n    | 'starcoder2-hybrid'\n\nfunction getMaxContextTokens(model: FireworksModel): number {\n    switch (model) {\n        case 'starcoder':\n        case 'starcoder2-hybrid':\n        case 'starcoder2-15b':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.test.ts:0-46"",""content"":""import { afterEach, describe, expect, it } from 'vitest'\n\nimport { SupportedLanguage } from './grammars'\nimport { resetParsersCache } from './parser'\nimport { getDocumentQuerySDK } from './query-sdk'\nimport { initTreeSitterParser } from './test-helpers'\n\ndescribe('getDocumentQuerySDK', () => {\n    afterEach(() => {\n        resetParsersCache()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.javascript },\n        { languageId: SupportedLanguage.typescript },\n        { languageId: SupportedLanguage.javascriptreact },\n        { languageId: SupportedLanguage.typescriptreact },\n        { languageId: SupportedLanguage.go },\n        { languageId: SupportedLanguage.python },\n    ])('returns valid SDK for $languageId', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk?.queries.intents).toBeTruthy()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.cpp },\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.php },\n    ])('returns null for $languageId because queries are not defined', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk).toBeNull()\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:0-26"",""content"":""// Add anything else here that needs to be used outside of this library.\n\nexport { ModelProvider } from './models'\nexport { type ChatModel, type EditModel, ModelUsage, type ModelContextWindow } from './models/types'\nexport { getDotComDefaultModels } from './models/dotcom'\nexport {\n    getProviderName,\n    getModelInfo,\n} from './models/utils'\nexport { BotResponseMultiplexer } from './chat/bot-response-multiplexer'\nexport { ChatClient } from './chat/chat'\nexport { ignores, isCodyIgnoredFile } from './cody-ignore/context-filter'\nexport {\n    IgnoreHelper,\n    CODY_IGNORE_POSIX_GLOB,\n    type IgnoreFileContent,\n    CODY_IGNORE_URI_PATH,\n} from './cody-ignore/ignore-helper'\nexport { renderCodyMarkdown } from './chat/markdown'\nexport { getSimplePreamble } from './chat/preamble'\nexport type {\n    SerializedChatInteraction,\n    SerializedChatTranscript,\n} from './chat/transcript'\nexport { serializeChatMessage } from './chat/transcript'\nexport { errorToChatError, DEFAULT_EVENT_SOURCE } from './chat/transcript/messages'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.ts:0-550"",""content"":""import { findLast } from 'lodash'\nimport type { Position, TextDocument } from 'vscode'\nimport type {\n    Language,\n    Point,\n    Query,\n    QueryCapture,\n    SyntaxNode,\n    Tree,\n    default as Parser,\n} from 'web-tree-sitter'\n\nimport { type SupportedLanguage, isSupportedLanguage } from './grammars'\nimport { getCachedParseTreeForDocument } from './parse-tree-cache'\nimport { type WrappedParser, getParser } from './parser'\nimport { type CompletionIntent, type QueryName, intentPriority, languages } from './queries'\n\ninterface ParsedQuery {\n    compiled: Query\n    raw: string\n}\ntype ResolvedQueries = {\n    [name in QueryName]: ParsedQuery\n}\n\nconst QUERIES_LOCAL_CACHE: Partial<Record<SupportedLanguage, ResolvedQueries & QueryWrappers>> = {}\n\n/**\n * Reads all language queries from disk and parses them.\n * Saves queries the local cache for further use.\n */\nexport function initQueries(language: Language, languageId: SupportedLanguage, parser: Parser): void {\n    const cachedQueries = QUERIES_LOCAL_CACHE[languageId]\n    if (cachedQueries) {\n        return\n    }\n\n    const languageQueries = languages[languageId]\n    if (languageQueries === undefined) {\n        return\n    }\n\n    const queryEntries = Object.entries(languageQueries).map(([name, raw]) => {\n        return [\n            name,\n            {\n                raw,\n                compiled: language.query(raw),\n            },\n        ] as const\n    })\n\n    const queries = Object.fromEntries<ParsedQuery>(queryEntries) as ResolvedQueries\n\n    QUERIES_LOCAL_CACHE[languageId] = {\n        ...queries,\n        ...getLanguageSpecificQueryWrappers(queries, parser, languageId),\n    }\n}\n\nexport interface DocumentQuerySDK {\n    parser: WrappedParser\n    queries: ResolvedQueries & QueryWrappers\n    language: SupportedLanguage\n}\n\n/**\n * Returns the query SDK only if the language has queries defined and\n * the relevant language parser is initialized.\n */\nexport function getDocumentQuerySDK(language: string): DocumentQuerySDK | null {\n    if (!isSupportedLanguage(language)) {\n        return null\n    }\n\n    const parser = getParser(language)\n    const queries = QUERIES_LOCAL_CACHE[language]\n\n    if (!parser || !queries) {\n        return null\n    }\n\n    return {\n        parser,\n        queries,\n        language,\n    }\n}\n\nexport interface QueryWrappers {\n    getSinglelineTrigger: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: 'trigger' }]\n    getCompletionIntent: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: CompletionIntent }]\n    getDocumentableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  insertionPoint?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n    getGraphContextIdentifiers: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getEnclosingFunction: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getTestableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n}\n\n/**\n * Query wrappers with custom post-processing logic.\n */\nfunction getLanguageSpecificQueryWrappers(\n    queries: ResolvedQueries,\n    _parser: Parser,\n    languageId: SupportedLanguage\n): QueryWrappers {\n    return {\n        getSinglelineTrigger: (root, start, end) => {\n            const captures = queries.singlelineTriggers.compiled.captures(root, start, end)\n            const { trigger, block } = getTriggerNodeWithBlockStaringAtPoint(captures, start)\n\n            if (!trigger || !block || !isBlockNodeEmpty(block)) {\n                return []\n            }\n\n            return [{ node: trigger, name: 'trigger' }] as const\n        },\n        getCompletionIntent: (root, start, end) => {\n            const captures = queries.intents.compiled.captures(root, start, end)\n\n            const { intentCapture } = getIntentFromCaptures(captures, start)\n\n            if (!intentCapture) {\n                return []\n            }\n\n            return [{ node: intentCapture.node, name: intentCapture.name as CompletionIntent }] as const\n        },\n        getDocumentableNode: (root, start, end) => {\n            const captures = queries.documentableNodes.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const documentableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = documentableRanges.at(-1)\n\n            let insertionPoint: QueryCapture | undefined\n            if (languageId === 'python' && range) {\n                /**\n                 * Python is a special case for generating documentation.\n                 * The insertion point of the documentation should differ if the symbol is a function or class.\n                 * We need to query again for an insertion point, this time using the correct determined range.\n                 *\n                 * See https://peps.python.org/pep-0257/ for the documentation conventions for Python.\n                 */\n                const insertionCaptures = queries.documentableNodes.compiled\n                    .captures(root, range.node.startPosition, range.node.endPosition)\n                    .filter(({ name }) => name.startsWith('insertion'))\n\n                insertionPoint = insertionCaptures.find(\n                    ({ node }) =>\n                        node.startIndex >= range.node.startIndex && node.endIndex <= range.node.endIndex\n                )\n            }\n\n            /**\n             * Modify where we look for a docstring depending on the language and syntax.\n             * For Python functions and classes, we will have a provided `insertionPoint`, use the line below this.\n             * For all other cases, docstrings should be attached above the symbol range, use this.\n             */\n            const docStringLine =\n                languageId === 'python' && insertionPoint\n                    ? insertionPoint.node.startPosition.row + 1\n                    : start.row - 1\n            const docstringCaptures = queries.documentableNodes.compiled\n                .captures(\n                    root,\n                    { row: docStringLine, column: 0 },\n                    { row: docStringLine, column: Number.MAX_SAFE_INTEGER }\n                )\n                .filter(node => node.name.startsWith('comment'))\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one documentable range for this position, we can be confident it makes sense to document. Show the hint.\n             * 2. Otherwise, only show the hint if the symbol is a function\n             * 3. Don't show hint if there is no docstring already present.\n             */\n            const showHint = Boolean(\n                (documentableRanges.length === 1 || symbol?.name.includes('function')) &&\n                    docstringCaptures.length === 0\n            )\n\n            return [\n                {\n                    symbol,\n                    range,\n                    insertionPoint,\n                    meta: { showHint },\n                },\n            ]\n        },\n        getGraphContextIdentifiers: (root, start, end) => {\n            return queries.graphContextIdentifiers.compiled.captures(root, start, end)\n        },\n        getEnclosingFunction: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled\n                .captures(root, start, end)\n                .filter(capture => capture.name.startsWith('range'))\n\n            const firstEnclosingFunction = findLast(captures, ({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            if (!firstEnclosingFunction) {\n                return []\n            }\n\n            return [firstEnclosingFunction]\n        },\n        getTestableNode: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const testableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = testableRanges.at(-1)\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one testable range for this position, we can be confident it makes sense to test. Show the hint.\n             * 2. TODO: Look for usages of this function in test files, if it's already used then don't show the hint.\n             */\n            const showHint = Boolean(testableRanges.length === 1)\n\n            return [\n                {\n                    symbol,\n                    range,\n                    meta: { showHint },\n                },\n            ]\n        },\n    }\n}\n\n// TODO: check if the block parent is empty in the consumer.\n// Tracking: https://github.com/sourcegraph/cody/issues/1452\nfunction getIntentFromCaptures(\n    captures: QueryCapture[],\n    cursor: Point\n): { cursorCapture?: Parser.QueryCapture; intentCapture?: Parser.QueryCapture } {\n    const emptyResult = {\n        cursorCapture: undefined,\n        intentCapture: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    // Find the cursor capture group if exists.\n    const [cursorCapture] = sortByIntentPriority(\n        captures.filter(capture => {\n            const { name, node } = capture\n\n            const matchesCursorPosition =\n                node.startPosition.column === cursor.column && node.startPosition.row === cursor.row\n\n            return name.endsWith('.cursor') && matchesCursorPosition\n        })\n    )\n\n    // Find the corresponding preceding intent capture that matches the cursor capture name.\n    const intentCapture = findLast(captures, capture => {\n        return capture.name === withoutCursorSuffix(cursorCapture?.name)\n    })\n\n    if (cursorCapture && intentCapture) {\n        return { cursorCapture, intentCapture }\n    }\n\n    // If we didn't find a multinode intent, use the most nested atomic capture group.\n    // Atomic capture groups are matches with one node and `!` at the end the capture group name.\n    const atomicCapture = findLast(captures, capture => {\n        const enclosesCursor =\n            (capture.node.startPosition.column <= cursor.column ||\n                capture.node.startPosition.row < cursor.row) &&\n            (cursor.column <= capture.node.endPosition.column ||\n                cursor.row < capture.node.endPosition.row)\n\n        return capture.name.endsWith('!') && enclosesCursor\n    })\n\n    if (atomicCapture) {\n        return {\n            intentCapture: {\n                ...atomicCapture,\n                // Remove `!` from the end of the capture name.\n                name: atomicCapture.name.slice(0, -1),\n            },\n        }\n    }\n\n    return emptyResult\n}\n\nfunction sortByIntentPriority(captures: QueryCapture[]): QueryCapture[] {\n    return captures.sort((a, b) => {\n        return (\n            intentPriority.indexOf(withoutCursorSuffix(a.name) as CompletionIntent) -\n            intentPriority.indexOf(withoutCursorSuffix(b.name) as CompletionIntent)\n        )\n    })\n}\n\nfunction withoutCursorSuffix(name?: string): string | undefined {\n    return name?.split('.').slice(0, -1).join('.')\n}\n\nfunction getTriggerNodeWithBlockStaringAtPoint(\n    captures: QueryCapture[],\n    point: Point\n): { trigger?: SyntaxNode; block?: SyntaxNode } {\n    const emptyResult = {\n        trigger: undefined,\n        block: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    const blockStart = getNodeIfMatchesPoint({\n        captures,\n        name: 'block_start',\n        // Taking the last result to get the most nested node.\n        // See https://github.com/tree-sitter/tree-sitter/discussions/2067\n        index: -1,\n        point,\n    })\n\n    const trigger = getCapturedNodeAt({\n        captures,\n        name: 'trigger',\n        index: -1,\n    })\n\n    const block = blockStart?.parent\n\n    if (!blockStart || !block || !trigger) {\n        return emptyResult\n    }\n\n    // Verify that the block node ends at the same position as the trigger node.\n    if (trigger.endIndex !== block?.endIndex) {\n        return emptyResult\n    }\n\n    return { trigger, block }\n}\n\ninterface GetNodeIfMatchesPointParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n    point: Point\n}\n\nfunction getNodeIfMatchesPoint(params: GetNodeIfMatchesPointParams): SyntaxNode | null {\n    const { captures, name, index, point } = params\n\n    const node = getCapturedNodeAt({ captures, name, index })\n\n    if (node && node.startPosition.column === point.column && node.startPosition.row === point.row) {\n        return node\n    }\n\n    return null\n}\n\ninterface GetCapturedNodeAtParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n}\n\nfunction getCapturedNodeAt(params: GetCapturedNodeAtParams): SyntaxNode | null {\n    const { captures, name, index } = params\n\n    return captures.filter(capture => capture.name === name).at(index)?.node || null\n}\n\n/**\n * Consider a block empty if it does not have any named children or is missing its closing tag.\n */\nfunction isBlockNodeEmpty(node: SyntaxNode | null): boolean {\n    // Consider a node empty if it does not have any named children.\n    const isBlockEmpty = node?.children.filter(c => c.isNamed()).length === 0\n    const isMissingBlockEnd = Boolean(node?.lastChild?.isMissing())\n\n    return isBlockEmpty || isMissingBlockEnd\n}\n\ninterface QueryPoints {\n    startPoint: Point\n    endPoint: Point\n}\n\nexport function positionToQueryPoints(position: Pick<Position, 'line' | 'character'>): QueryPoints {\n    const startPoint = {\n        row: position.line,\n        column: position.character,\n    }\n\n    const endPoint = {\n        row: position.line,\n        // Querying around one character after trigger position.\n        column: position.character + 1,\n    }\n\n    return { startPoint, endPoint }\n}\n\ntype ExecQueryWrapperParams<T> = {\n    queryWrapper: T\n} & (\n    | {\n          document: TextDocument\n          queryPoints: QueryPoints\n      }\n    | {\n          document: TextDocument\n          position: Pick<Position, 'line' | 'character'>\n      }\n    | {\n          tree: Tree\n          languageId: string\n          queryPoints: QueryPoints\n      }\n    | {\n          tree: Tree\n          languageId: string\n          position: Pick<Position, 'line' | 'character'>\n      }\n)\n\nexport function execQueryWrapper<T extends keyof QueryWrappers>(\n    params: ExecQueryWrapperParams<T>\n): ReturnType<QueryWrappers[T]> | never[] {\n    const { queryWrapper } = params\n\n    const treeToQuery =\n        'document' in params ? getCachedParseTreeForDocument(params.document)?.tree : params.tree\n    const languageId = 'document' in params ? params.document.languageId : params.languageId\n    const documentQuerySDK = getDocumentQuerySDK(languageId as SupportedLanguage)\n\n    const queryPoints =\n        'position' in params ? positionToQueryPoints(params.position) : params.queryPoints\n    const { startPoint, endPoint } = queryPoints\n\n    if (documentQuerySDK && treeToQuery) {\n        return documentQuerySDK.queries[queryWrapper](\n            treeToQuery.rootNode,\n            startPoint,\n            endPoint\n        ) as ReturnType<QueryWrappers[T]>\n    }\n\n    return []\n}\n\nexport type { CompletionIntent }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:7525-7552"",""content"":""      '@esbuild/linux-arm64': 0.20.2\n      '@esbuild/linux-ia32': 0.20.2\n      '@esbuild/linux-loong64': 0.20.2\n      '@esbuild/linux-mips64el': 0.20.2\n      '@esbuild/linux-ppc64': 0.20.2\n      '@esbuild/linux-riscv64': 0.20.2\n      '@esbuild/linux-s390x': 0.20.2\n      '@esbuild/linux-x64': 0.20.2\n      '@esbuild/netbsd-x64': 0.20.2\n      '@esbuild/openbsd-x64': 0.20.2\n      '@esbuild/sunos-x64': 0.20.2\n      '@esbuild/win32-arm64': 0.20.2\n      '@esbuild/win32-ia32': 0.20.2\n      '@esbuild/win32-x64': 0.20.2\n    dev: true\n\n  /escalade@3.1.1:\n    resolution: {integrity: sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==}\n    engines: {node: '>=6'}\n\n  /escalade@3.1.2:\n    resolution: {integrity: sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA==}\n    engines: {node: '>=6'}\n    dev: true\n\n  /escape-html@1.0.3:\n    resolution: {integrity: sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/embeddings-protocol.ts:0-125"",""content"":""/**\n * The protocol for communicating between Cody and local embeddings.\n */\n\ninterface InitializeParams {\n    codyGatewayEndpoint: string\n    indexPath: string\n    chunkingPolicy?: ChunkingPolicy\n}\n\ninterface ChunkingPolicy {\n    maxFileSizeBytes: number\n    pathsToExcludeRegexp: string\n}\n\ninterface QueryParams {\n    repoName: string\n    query: string\n    numResults: number\n}\n\nexport interface QueryResultSet {\n    results: QueryResult[]\n}\n\ninterface QueryResult {\n    fileName: string\n    startLine: number\n    endLine: number\n    content: string\n}\n\ninterface IndexHealthRequest {\n    // The name of the repository to scrutinize the index for. Note, this\n    // is a repo name, like github.com/sourcegraph/cody, not a file path.\n    repoName: string\n}\n\ntype IndexHealthResult = IndexHealthResultFound | IndexHealthResultNotFound\n\nexport interface IndexHealthResultFound {\n    type: 'found'\n    repoName: string\n    format: 'App' | 'LocalEmbeddings'\n    commit: string\n    model: string\n    dimension: number\n    numItems: number\n    numItemsDeleted: number\n    numItemsNeedEmbedding: number\n    numItemsFailed: number\n    numFiles: number\n}\n\ninterface IndexHealthResultNotFound {\n    type: 'notFound'\n    repoName: string\n}\n\nexport interface IndexRequest {\n    repoPath: string\n    mode: IndexRequestMode\n}\n\ntype IndexRequestMode = IndexRequestModeNew | IndexRequestModeContinue\n\ninterface IndexRequestModeNew {\n    type: 'new'\n    model: string\n    dimension: number\n}\n\ninterface IndexRequestModeContinue {\n    type: 'continue'\n}\n\ninterface IndexResult {\n    repoName: string\n}\n\ninterface LoadResult {\n    repoName: string\n}\nexport type Requests = {\n    'embeddings/echo': [string, string]\n    // Instruct local embeddings to index the specified repository path.\n    'embeddings/index': [IndexRequest, IndexResult]\n    // Get statistics for the index for a given repository name.\n    'embeddings/index-health': [IndexHealthRequest, IndexHealthResult]\n    // Initializes the local embeddings service. You must call this first.\n    'embeddings/initialize': [InitializeParams, Record<string, never>]\n    // Searches for and loads an index for the specified repository name.\n    'embeddings/load': [string, LoadResult]\n    // Queries loaded index.\n    'embeddings/query': [QueryParams, QueryResultSet]\n    // Sets the Sourcegraph access token.\n    'embeddings/set-token': [string, Record<string, never>]\n    // Shuts down the local embeddings service.\n    'embeddings/shutdown': [Record<string, never>, Record<string, never>]\n}\n\ntype ProgressValue = Progress | ProgressError | ProgressDone\n\ninterface Progress {\n    type: 'progress'\n    currentPath: string\n    repoName: string\n    repoPath: string\n    numItems: number\n    totalItems: number\n}\n\ninterface ProgressDone {\n    type: 'done'\n    repoName: string\n}\n\ninterface ProgressError {\n    type: 'error'\n    repoName: string\n    message: string\n}\nexport type Notifications = {\n    'embeddings/progress': [ProgressValue]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:279-311"",""content"":""    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:111-118"",""content"":""    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:30-58"",""content"":""\nexport type LocalEmbeddingsConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & {\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/embeddings`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/embeddings`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\embeddings`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\ninterface RepoState {\n    repoName: string | false\n    indexable: boolean\n    errorReason: GetFieldType<LocalEmbeddingsProvider, 'errorReason'>\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/uri.ts:72-74"",""content"":""    public get query(): string {\n        return this.uri.query\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/types.ts:0-62"",""content"":""import type { ModelProvider } from '.'\n\nexport enum ModelUsage {\n    Chat = 'chat',\n    Edit = 'edit',\n}\n\n// Utility to narrow a model type to a specific model usage\ntype HasUsage<T, I> = T extends { usage: readonly ModelUsage[] }\n    ? I extends T['usage'][number]\n        ? T\n        : never\n    : never\n\ntype Models = typeof ModelProvider\n\n/**\n * Available models for Edit.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type EditModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Edit>\n      }[keyof Models]['model']\n    | (string & {})\n\n/**\n * Available models for Chat.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type ChatModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Chat>\n      }[keyof Models]['model']\n    | (string & {})\n\nexport interface ModelContextWindow {\n    /**\n     * The token limit reserved for chat input.\n     */\n    input: number\n    /**\n     * The maximum number of tokens that the model can respond with in a single request.\n     */\n    output: number\n    /**\n     * The additional tokens reserved for context.\n     * When not defined, context shares the same token limit as input.\n     */\n    context?: {\n        /**\n         * The token limit reserved for user-added context.\n         * Example: @-mentions.\n         */\n        user?: number\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:2-2"",""content"":""export const MODEL = 'anthropic/claude-3-haiku-20240307'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:226-254"",""content"":""    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:286-313"",""content"":""                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-57"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_020/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,The,Where is the functionality for running symf?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:565-582"",""content"":""\n### Changed\n\n- Settings: Relabel \""symf Context\"" as \""Search Context\"". [pull/2285](https://github.com/sourcegraph/cody/pull/2285)\n- Chat: Removed 'Chat Suggestions' setting. [pull/2284](https://github.com/sourcegraph/cody/pull/2284)\n- Edit: Completed edits are no longer scrolled back into view in the active file. [pull/2297](https://github.com/sourcegraph/cody/pull/2297)\n- Chat: Update welcome message. [pull/2298](https://github.com/sourcegraph/cody/pull/2298)\n- Edit: Decorations are no longer shown once an edit has been applied. [pull/2304](https://github.com/sourcegraph/cody/pull/2304)\n\n## [0.18.4]\n\n### Added\n\n### Fixed\n\n- Fixes an issue where the sidebar would not properly load when not signed in. [pull/2267](https://github.com/sourcegraph/cody/pull/2267)\n- Fixes an issue where telemetry events were not properly logged with the new chat experience. [pull/2291](https://github.com/sourcegraph/cody/pull/2291)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:62-67"",""content"":""\n        onConfigurationChange: setCustomAgent,\n        extensionClient,\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/isRunningInsideAgent.ts:2-4"",""content"":""export function isRunningInsideAgent(): boolean {\n    return vscode.workspace.getConfiguration().get<boolean>('cody.advanced.agent.running', false)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80"",""content"":""\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:543-580"",""content"":""function parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:46-62"",""content"":""\n    return activateCommon(context, {\n        createLocalEmbeddingsController: isLocalEmbeddingsDisabled\n            ? undefined\n            : (config: LocalEmbeddingsConfig): LocalEmbeddingsController =>\n                  createLocalEmbeddingsController(context, config),\n        createContextRankingController: (config: ContextRankerConfig) =>\n            createContextRankingController(context, config),\n        createCompletionsClient: (...args) => new SourcegraphNodeCompletionsClient(...args),\n        createCommandsProvider: () => new CommandsProvider(),\n        createSymfRunner: (...args) => new SymfRunner(...args),\n        createBfgRetriever: () => new BfgRetriever(context),\n        createSentryService: (...args) => new NodeSentryService(...args),\n        createOpenTelemetryService: (...args) => new OpenTelemetryService(...args),\n        getRemoteUrlGetters: () => [gitRemoteUrlFromGitCli],\n        startTokenReceiver: (...args) => startTokenReceiver(...args),\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:630-642"",""content"":""function toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:49-486"",""content"":""export class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""}]",Find logic,,,0,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_021/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that interacts with the `symf` binary is located in the `cody_test/vscode/src/local-context/symf.ts` file. 

Here's a breakdown of the key functions and how they interact with `symf`:

1. **`getSymfPath(context: vscode.ExtensionContext): Promise<string | null>`:** This function is responsible for finding the path to the `symf` binary. It first checks if a user-specified path is configured. If not, it attempts to download the `symf` binary if it's not already present.

2. **`SymfRunner.getResults(uri: vscode.Uri, query: string, options?: SymfQueryOptions): Promise<SymfResult[]>`:** This method is the core of the interaction with `symf`. It takes a URI, a query, and optional options, and then executes the `symf` binary with the provided arguments. It parses the output from `symf` and returns an array of `SymfResult` objects.

3. **`SymfRunner.buildIndex(indexDir: vscode.Uri, options?: SymfIndexOptions): Promise<void>`:** This method builds a new index for the specified directory using `symf`. It creates a temporary directory, executes `symf` to build the index, and then moves the index to the specified directory.

4. **`SymfRunner.dispose(): void`:** This method disposes of the `SymfRunner` instance, including any resources associated with it, such as the `symf` process.

The `symf` binary is used for code search and indexing within the `SymfRunner` class. It's used to build an index of the codebase, which is then used to perform code search queries.",Where is the code that interacts with symf  binary ?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:10-12"",""content"":""interface CodeActionProviderOptions {\n    contextProvider: ContextProvider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupTask.ts:59-79"",""content"":""\n    constructor(\n        /**\n         * The file that will be updated by Cody with the replacement text at the end of stream\n         * This is set by the FixupController when creating the task,\n         * and will be updated by the FixupController for tasks using the 'new' mode\n         */\n        public fixupFile: FixupFile,\n        public readonly instruction: PromptString,\n        public readonly userContextItems: ContextItem[],\n        /* The intent of the edit, derived from the source of the command. */\n        public readonly intent: EditIntent,\n        /* The range being edited. This range is tracked and updates as the user (or Cody) edits code. */\n        public selectionRange: vscode.Range,\n        /* The mode indicates how code should be inserted */\n        public readonly mode: EditMode,\n        public readonly model: EditModel,\n        /* the source of the instruction, e.g. 'code-action', 'doc', etc */\n        public source?: EventSource,\n        /* The file to write the edit to. If not provided, the edit will be applied to the fixupFile. */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:14-45"",""content"":""    public async provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): Promise<vscode.CodeAction[]> {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n\n        // Expand range to include the full line for better fixup quality\n        const expandedRange = new vscode.Range(\n            document.lineAt(range.start.line).range.start,\n            document.lineAt(range.end.line).range.end\n        )\n\n        // TODO bee check if the diagnostics are related to imports and include import ranges instead of error lines\n        // const importDiagnostics = diagnostics.filter(diagnostic => diagnostic.message.includes('import'))\n\n        // Expand range by getting the folding range contains the target (error) area\n        const targetAreaRange = await getSmartSelection(document.uri, range.start)\n\n        const newRange = targetAreaRange\n            ? new vscode.Range(targetAreaRange.start, targetAreaRange.end)\n            : expandedRange\n        const codeAction = await this.createCommandCodeAction(document, diagnostics, newRange)\n        return [codeAction]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/document.ts:8-37"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [documentableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getDocumentableNode',\n        })\n        if (!documentableNode) {\n            return []\n        }\n\n        const { range: documentableRange, symbol: documentableSymbol } = documentableNode\n        if (!documentableSymbol || !documentableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            documentableRange.node.startPosition.row,\n            documentableRange.node.startPosition.column,\n            documentableRange.node.endPosition.row,\n            documentableRange.node.endPosition.column\n        )\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Documentation for ${documentableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-workspace.yaml:0-6"",""content"":""packages:\n  - agent\n  - cli\n  - lib/*\n  - vscode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/edit.ts:7-29"",""content"":""    public provideCodeActions(document: vscode.TextDocument): vscode.CodeAction[] {\n        const editor = vscode.window.activeTextEditor\n\n        if (!editor) {\n            return []\n        }\n\n        if (\n            editor.selection.isEmpty &&\n            !document.lineAt(editor.selection.start.line).isEmptyOrWhitespace\n        ) {\n            // Empty selection but a non-empty line, show nothing as the user likely won't want to generate here.\n            return []\n        }\n\n        if (editor.selection.isEmpty) {\n            // Empty selection and empty line, show generate action\n            return [this.createGenerateCodeAction(document, editor.selection)]\n        }\n\n        // Non-empty selection, show edit action\n        return [this.createEditCommandCodeAction(document, editor.selection)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/queries/typescript/context.scm:0-12"",""content"":"";; Inherits from javascript/context.scm\n\n((function_declaration\n   name: (_) @name\n   (formal_parameters (_ (type_annotation) @search)))\n (#search! \""type_identifier\""))\n\n((variable_declarator\n  name: (_) @name\n  type: (type_annotation) @search)\n (#search! \""type_identifier\""))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:7-21"",""content"":""    public provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): vscode.CodeAction[] {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n        return [this.createCommandCodeAction(document.uri, diagnostics)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:433-461"",""content"":""\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:14-54"",""content"":""export class CodeActionProvider implements vscode.Disposable {\n    private configurationChangeListener: vscode.Disposable\n    private actionProviders: vscode.Disposable[] = []\n\n    constructor(options: CodeActionProviderOptions) {\n        this.registerCodeActions(options.contextProvider.config)\n        this.configurationChangeListener = options.contextProvider.configurationChangeEvent.event(() => {\n            this.registerCodeActions(options.contextProvider.config)\n        })\n    }\n\n    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n    }\n\n    private addActionProvider(ActionType: {\n        new (): vscode.CodeActionProvider\n        providedCodeActionKinds: vscode.CodeActionKind[]\n    }): void {\n        const provider = vscode.languages.registerCodeActionsProvider('*', new ActionType(), {\n            providedCodeActionKinds: ActionType.providedCodeActionKinds,\n        })\n        this.actionProviders.push(provider)\n    }\n\n    public dispose(): void {\n        this.configurationChangeListener.dispose()\n        vscode.Disposable.from(...this.actionProviders).dispose()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:91-109"",""content"":""    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:0-27"",""content"":""import * as fs from 'node:fs'\nimport fspromises from 'node:fs/promises'\nimport * as os from 'node:os'\nimport * as path from 'node:path'\n\nimport axios from 'axios'\nimport * as unzipper from 'unzipper'\nimport * as vscode from 'vscode'\n\nimport { Mutex } from 'async-mutex'\nimport { logDebug } from '../log'\nimport { getOSArch } from '../os'\nimport { captureException } from '../services/sentry/sentry'\n\nconst symfVersion = 'v0.0.9'\n\n/**\n * Get the path to `symf`. If the symf binary is not found, download it.\n */\nexport async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:153-182"",""content"":""\n\n                  ## Debugging the agent\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /agent/src/__tests__/example-ts/src/squirrel.ts in repository\n                  github.com/sourcegraph/cody:\n\n                  ```typescript\n\n                  /**\n                   * Squirrel is an interface that mocks something completely unrelated to squirrels.\n                   * It is related to the implementation of precise code navigation in Sourcegraph.\n                   */\n                  export interface Squirrel {}\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file /.bazelignore in repository\n                  github.com/sourcegraph/sourcegraph:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:67-102"",""content"":""\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80"",""content"":""\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:164-170"",""content"":""async function removeOldSymfBinaries(containingDir: string, currentSymfPath: string): Promise<void> {\n    const symfDirContents = await fspromises.readdir(containingDir)\n    const oldSymfBinaries = symfDirContents.filter(f => f.startsWith('symf-') && f !== currentSymfPath)\n    for (const oldSymfBinary of oldSymfBinaries) {\n        await fspromises.rm(path.join(containingDir, oldSymfBinary))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_022/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that interacts with the bfg binary is primarily located in these files:

* **`cody_test/vscode/src/graph/bfg/download-bfg.ts`:** This file handles downloading the bfg binary from GitHub, unzipping it, and storing it in the VS Code extension's global storage. It also manages deleting older versions of the bfg binary.
* **`cody_test/vscode/src/graph/bfg/spawn-bfg.ts`:** This file spawns the bfg process as a child process, sets up communication channels (stdin, stdout, stderr) between the VS Code extension and the bfg process, and handles error handling and process termination.
* **`cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts`:** This file uses the `spawnBfg` function to initialize a connection to the bfg process and sends requests to it to retrieve context information for code completions. It also handles indexing the workspace and Git repositories to keep the bfg process up-to-date with the codebase.

In addition to these files, the `bfg-protocol.ts` file defines the JSON-RPC protocol used to communicate between the VS Code extension and the bfg process.

Overall, the interaction with the bfg binary is managed through a combination of downloading, spawning, communication, and indexing, all of which are handled by the code in these files.",Where is the code that interacts with bfg binary?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/spawn-bfg.ts:9-44"",""content"":""export async function spawnBfg(\n    context: vscode.ExtensionContext,\n    reject: (reason?: any) => void\n): Promise<MessageHandler> {\n    const bfg = new MessageHandler()\n    const codyrpc = await downloadBfg(context)\n    if (!codyrpc) {\n        throw new Error(\n            'Failed to download BFG binary. To fix this problem, set the \""cody.experimental.cody-engine.path\"" configuration to the path of your BFG binary'\n        )\n    }\n    const isVerboseDebug = vscode.workspace.getConfiguration().get<boolean>('cody.debug.verbose', false)\n    const child = child_process.spawn(codyrpc, {\n        stdio: 'pipe',\n        env: {\n            VERBOSE_DEBUG: `${isVerboseDebug}`,\n            RUST_BACKTRACE: isVerboseDebug ? '1' : '0',\n            // See bfg issue 138\n            RUST_LIB_BACKTRACE: '0',\n        },\n    })\n    child.stderr.on('data', chunk => {\n        logDebug('CodyEngine', 'spawnBfg:stderr', { verbose: chunk.toString() })\n    })\n    child.on('disconnect', () => reject())\n    child.on('close', () => reject())\n    child.on('error', error => reject(error))\n    child.on('exit', code => {\n        bfg.exit()\n        reject(code)\n    })\n    child.stderr.pipe(process.stderr)\n    child.stdout.pipe(bfg.messageDecoder)\n    bfg.messageEncoder.pipe(child.stdin)\n    return bfg\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5905-5936"",""content"":""        }\n        set value(value: number) {\n            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): DoubleConstant {\n            const message = new DoubleConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeDouble(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DoubleConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:111-119"",""content"":""async function unzipBfg(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:933-953"",""content"":""        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.scheme.length) writer.writeString(1, this.scheme)\n            if (this.has_package)\n                writer.writeMessage(2, this.package, () => this.package.serialize(writer))\n            if (this.descriptors.length)\n                writer.writeRepeatedMessage(3, this.descriptors, (item: Descriptor) =>\n                    item.serialize(writer)\n                )\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Symbol {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Symbol()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.scheme = reader.readString()\n                        break\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:20-109"",""content"":""export async function downloadBfg(context: vscode.ExtensionContext): Promise<string | null> {\n    // First, wait for any in-progress downloads.\n    await serializeBfgDownload\n\n    // Now we are the in-progress download.\n    serializeBfgDownload = (async () => {\n        const config = vscode.workspace.getConfiguration()\n        const userBfgPath = config.get<string>('cody.experimental.cody-engine.path')\n        if (userBfgPath) {\n            const bfgStat = await fspromises.stat(userBfgPath)\n            if (!bfgStat.isFile()) {\n                throw new Error(`not a file: ${userBfgPath}`)\n            }\n            logDebug('CodyEngine', `using user-provided path: ${userBfgPath} ${bfgStat.isFile()}`)\n            return userBfgPath\n        }\n\n        const osArch = getOSArch()\n        if (!osArch) {\n            logDebug('CodyEngine', 'getOSArch returned nothing')\n            return null\n        }\n        const { platform, arch } = osArch\n\n        if (!arch) {\n            logDebug('CodyEngine', 'getOSArch returned undefined arch')\n            return null\n        }\n\n        if (!platform) {\n            logDebug('CodyEngine', 'getOSArch returned undefined platform')\n            return null\n        }\n        // Rename returned architecture to match RFC 795 conventions\n        // https://docs.google.com/document/d/11cw-7dAp93JmasITNSNCtx31xrQsNB1L2OoxVE6zrTc/edit\n        const archRenames = new Map([\n            ['aarch64', 'arm64'],\n            ['x86_64', 'x64'],\n        ])\n        let rfc795Arch = archRenames.get(arch ?? '') ?? arch\n        if (rfc795Arch === 'arm64' && platform === 'win') {\n            // On Windows Arm PCs, we rely on emulation and use the x64 binary.\n            // See https://learn.microsoft.com/en-us/windows/arm/apps-on-arm-x86-emulation\n            rfc795Arch = 'x64'\n        }\n\n        const bfgContainingDir = path.join(context.globalStorageUri.fsPath, 'cody-engine')\n        const bfgVersion = config.get<string>('cody.experimental.cody-engine.version', defaultBfgVersion)\n        await fspromises.mkdir(bfgContainingDir, { recursive: true })\n        const bfgFilename = `cody-engine-${bfgVersion}-${platform}-${rfc795Arch}`\n        const bfgPath = path.join(bfgContainingDir, bfgFilename)\n        const isAlreadyDownloaded = await fileExists(bfgPath)\n        if (isAlreadyDownloaded) {\n            logDebug('CodyEngine', `using downloaded path \""${bfgPath}\""`)\n            return bfgPath\n        }\n\n        const bfgURL = `https://github.com/sourcegraph/bfg/releases/download/v${bfgVersion}/bfg-${platform}-${rfc795Arch}.zip`\n        try {\n            await vscode.window.withProgress(\n                {\n                    location: vscode.ProgressLocation.Window,\n                    title: 'Downloading cody-engine',\n                    cancellable: false,\n                },\n                async progress => {\n                    progress.report({ message: 'Downloading cody-engine' })\n                    const bfgZip = path.join(bfgContainingDir, 'bfg.zip')\n                    await downloadBfgBinary(bfgURL, bfgZip)\n                    await unzipBfg(bfgZip, bfgContainingDir)\n                    logDebug('CodyEngine', bfgPath)\n                    // The zip file contains a binary named `bfg` or `bfg.exe`. We unzip it with that name first and then rename into\n                    // a version-specific binary so that we can delete old versions of bfg.\n                    const unzipPath = platform === 'windows' ? 'bfg.exe' : 'bfg'\n                    await fspromises.rename(path.join(bfgContainingDir, unzipPath), bfgPath)\n                    await fspromises.chmod(bfgPath, 0o755)\n                    await fspromises.rm(bfgZip)\n                    logDebug('CodyEngine', `downloaded cody-engine to ${bfgPath}`)\n                }\n            )\n            void removeOldBfgBinaries(bfgContainingDir, bfgFilename)\n        } catch (error) {\n            captureException(error)\n            void vscode.window.showErrorMessage(`Failed to download bfg from URL ${bfgURL}: ${error}`)\n            return null\n        }\n        return bfgPath\n    })()\n    return serializeBfgDownload\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5636-5662"",""content"":""            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CharConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new CharConstant()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.value = reader.readInt32()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:25-38"",""content"":""    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3411-3438"",""content"":""                message.symbol = data.symbol\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                symbol?: string\n            } = {}\n            if (this.symbol != null) {\n                data.symbol = this.symbol\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.symbol.length) writer.writeString(1, this.symbol)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ThisType {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new ThisType()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/SidebarCommands.ts:57-78"",""content"":""        }),\n        vscode.commands.registerCommand('cody.sidebar.keyboardShortcuts', () => {\n            logSidebarClick('keyboardShortcuts')\n            void vscode.commands.executeCommand(\n                'workbench.action.openGlobalKeybindings',\n                '@ext:sourcegraph.cody-ai'\n            )\n        }),\n        vscode.commands.registerCommand('cody.sidebar.releaseNotes', () => {\n            logSidebarClick('releaseNotes')\n            void vscode.commands.executeCommand('vscode.open', releaseNotesURL(version))\n        }),\n        vscode.commands.registerCommand('cody.sidebar.documentation', () => {\n            logSidebarClick('documentation')\n            void vscode.commands.executeCommand('vscode.open', CODY_DOC_URL.href)\n        }),\n        vscode.commands.registerCommand('cody.sidebar.support', () => {\n            logSidebarClick('support')\n            void vscode.commands.executeCommand('vscode.open', CODY_SUPPORT_URL.href)\n        }),\n        vscode.commands.registerCommand('cody.sidebar.feedback', () => {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5695-5726"",""content"":""        }\n        set value(value: number) {\n            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): IntConstant {\n            const message = new IntConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5487-5516"",""content"":""            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): ByteConstant {\n            const message = new ByteConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ByteConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/commands.md:0-13"",""content"":""## Cody Commands\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-explain.gif\"">\n\nCody has a range of commands for explaining code, generating unit tests, adding documentation, and more.\n\nTo get started: select code in your editor, right click, and choose a command from the \""Cody\"" menu.\n\nYou can also use the [Cody: Commands Menu](command:cody.menu.commands) which has the default keyboard shortcut of `Option` `C` on macOS and `Alt` `C` on Windows & Linux.\n\n**✨ Pro-tips for using Cody commands**\n<br>• You can build your own [Custom Commands (Beta)](https://sourcegraph.com/docs/cody/custom-commands) with custom prompts, output into chat or perform code edits, and more.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1700-1723"",""content"":""            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Relationship {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Relationship()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.symbol = reader.readString()\n                        break\n                    case 2:\n                        message.is_reference = reader.readBool()\n                        break\n                    case 3:\n                        message.is_implementation = reader.readBool()\n                        break\n                    case 4:\n                        message.is_type_definition = reader.readBool()\n                        break\n                    case 5:\n                        message.is_definition = reader.readBool()\n                        break\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/bfg-protocol.ts:0-39"",""content"":""/**\n * This file declares the protocol for communicating between Cody and BFG (Blazingly Fast Graph), a Rust implementation\n * of the \""Graph Context\"" feature flag.\n */\nimport type { Position } from './agent-protocol'\n\ninterface BFGFileContextSnippet {\n    fileName: string\n    content: string\n}\n\ninterface BFGSymbolContextSnippet extends BFGFileContextSnippet {\n    symbol: string\n}\n\nexport type Requests = {\n    'bfg/initialize': [{ clientName: string }, { serverVersion: string }]\n    'bfg/contextAtPosition': [\n        { uri: string; content: string; position: Position; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[]; files?: BFGFileContextSnippet[] },\n    ]\n    'bfg/contextForIdentifiers': [\n        { uri: string; identifiers: string[]; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[] },\n    ]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/gitRevision/didChange': [{ gitDirectoryUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/workspace/didChange': [{ workspaceUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/shutdown': [null, void]\n\n    'embeddings/hello': [null, string]\n}\n\nexport type Notifications = {\n    'bfg/placeholderNotification': [null]\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:25-50"",""content"":""\n    constructor(\n        private contextStrategy: ContextStrategy,\n        createBfgRetriever?: () => BfgRetriever\n    ) {\n        switch (contextStrategy) {\n            case 'none':\n                break\n            case 'bfg-mixed':\n            case 'bfg':\n                // The bfg strategy uses jaccard similarity as a fallback if no results are found or\n                // the language is not supported by BFG\n                this.localRetriever = new JaccardSimilarityRetriever()\n                this.disposables.push(this.localRetriever)\n                if (createBfgRetriever) {\n                    this.graphRetriever = createBfgRetriever()\n                    this.disposables.push(this.graphRetriever)\n                }\n                break\n            case 'jaccard-similarity':\n                this.localRetriever = new JaccardSimilarityRetriever()\n                this.disposables.push(this.localRetriever)\n                break\n            case 'local-mixed':\n                this.localRetriever = new JaccardSimilarityRetriever()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts:0-303"",""content"":""import * as vscode from 'vscode'\n\nimport { spawnBfg } from '../../../../graph/bfg/spawn-bfg'\nimport type { MessageHandler } from '../../../../jsonrpc/jsonrpc'\nimport { logDebug } from '../../../../log'\nimport type { Repository } from '../../../../repository/builtinGitExtension'\nimport { gitAPI } from '../../../../repository/git-extension-api'\nimport { captureException } from '../../../../services/sentry/sentry'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\n\nimport type { AutocompleteContextSnippet } from '@sourcegraph/cody-shared'\nimport {\n    getLastNGraphContextIdentifiersFromDocument,\n    getLastNGraphContextIdentifiersFromString,\n} from '../graph/identifiers'\nimport { type SimpleRepository, inferGitRepository } from './simple-git'\n\nexport class BfgRetriever implements ContextRetriever {\n    public identifier = 'bfg'\n    private loadedBFG: Promise<MessageHandler>\n    private bfgIndexingPromise = Promise.resolve<void>(undefined)\n    private awaitIndexing: boolean\n    private didFailLoading = false\n    // Keys are repository URIs, values are revisions (commit hashes).\n    private indexedRepositoryRevisions = new Map<string, string>()\n    constructor(private context: vscode.ExtensionContext) {\n        this.awaitIndexing = vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.await-indexing', false)\n        this.loadedBFG = this.loadBFG()\n\n        this.loadedBFG.then(\n            () => {},\n            error => {\n                captureException(error)\n                this.didFailLoading = true\n                logDebug('CodyEngine', 'failed to initialize', error)\n            }\n        )\n\n        this.bfgIndexingPromise = this.indexWorkspace()\n    }\n\n    private async indexWorkspace(): Promise<void> {\n        await this.indexGitRepositories()\n        await this.indexRemainingWorkspaceFolders()\n    }\n    private isWorkspaceIndexed(folder: vscode.Uri): boolean {\n        const uri = folder.toString()\n        logDebug('CodyEngine', 'Checking if folder is indexed', uri)\n        for (const key of this.indexedRepositoryRevisions.keys()) {\n            if (uri.startsWith(key)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private async indexRemainingWorkspaceFolders(): Promise<void> {\n        logDebug(\n            'CodyEngine',\n            'workspaceFolders',\n            vscode.workspace.workspaceFolders?.map(folder => folder.uri.toString()) ?? []\n        )\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.isWorkspaceIndexed(folder.uri)) {\n                continue\n            }\n            await this.indexEntry({ workspace: folder.uri })\n        }\n    }\n    private async indexGitRepositories(): Promise<void> {\n        const git = gitAPI()\n        if (!git) {\n            return\n        }\n        for (const repository of git.repositories) {\n            await this.didChangeGitExtensionRepository(repository)\n        }\n        this.context.subscriptions.push(\n            git.onDidOpenRepository(repository => this.didChangeGitExtensionRepository(repository))\n        )\n        this.context.subscriptions.push(\n            vscode.workspace.onDidChangeWorkspaceFolders(() => this.indexInferredGitRepositories())\n        )\n        // TODO: handle closed repositories\n\n        await this.indexInferredGitRepositories()\n    }\n\n    private shouldInferGitRepositories(): boolean {\n        // Some users may not want to allow Cody to index code outside the VS\n        // Code workspace folder so we support an escape hatch to disable this\n        // functionality. This setting is hidden because all the other\n        // BFG-related settings are hidden.\n        return vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.index-parent-git-folder', false)\n    }\n\n    // Infers what git repositories that are relevant but may not be \""open\"" by\n    // the git extension.  For example, by default, the git extension doesn't\n    // open git repositories when the workspace root is a subfolder. There's a\n    // setting to automatically open parent git repositories but the setting is\n    // disabled by default.\n    private async indexInferredGitRepositories(): Promise<void> {\n        if (!this.shouldInferGitRepositories()) {\n            return\n        }\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.indexedRepositoryRevisions.has(folder.uri.toString())) {\n                continue\n            }\n            const repo = await inferGitRepository(folder.uri)\n            if (repo) {\n                await this.didChangeSimpleRepository(repo)\n            }\n        }\n    }\n\n    private async didChangeGitExtensionRepository(repository: Repository): Promise<void> {\n        const commit = repository?.state?.HEAD?.commit\n        if (!commit) {\n            return\n        }\n        await this.didChangeSimpleRepository({ uri: repository.rootUri, commit })\n    }\n\n    private async didChangeSimpleRepository(repository: SimpleRepository): Promise<void> {\n        const uri = repository.uri.toString()\n        if (repository.commit !== this.indexedRepositoryRevisions.get(uri)) {\n            this.indexedRepositoryRevisions.set(uri, repository.commit ?? '')\n            await this.indexEntry({ repository })\n        }\n    }\n\n    private async indexEntry(params: {\n        repository?: SimpleRepository\n        workspace?: vscode.Uri\n    }): Promise<void> {\n        const { repository, workspace } = params\n        if (!repository && !workspace) {\n            return\n        }\n        const bfg = await this.loadedBFG\n        const indexingStartTime = Date.now()\n        // TODO: include commit?\n        try {\n            if (repository) {\n                await bfg.request('bfg/gitRevision/didChange', {\n                    gitDirectoryUri: repository.uri.toString(),\n                })\n            }\n            if (workspace) {\n                await bfg.request('bfg/workspace/didChange', { workspaceUri: workspace.toString() })\n            }\n            const elapsed = Date.now() - indexingStartTime\n            const label = repository\n                ? `${repository.uri.fsPath}:${repository.commit}`\n                : workspace\n                  ? workspace.fsPath\n                  : ''\n            if (label) {\n                logDebug('CodyEngine', `gitRevision/didChange ${label} indexing time ${elapsed}ms`)\n            }\n        } catch (error) {\n            logDebug('CodyEngine', `indexing error ${error}`)\n        }\n    }\n\n    public async retrieve({\n        document,\n        position,\n        docContext,\n        hints,\n        lastCandidate,\n    }: ContextRetrieverOptions): Promise<AutocompleteContextSnippet[]> {\n        try {\n            if (this.didFailLoading) {\n                return []\n            }\n            const bfg = await this.loadedBFG\n            if (!bfg.isAlive()) {\n                logDebug('CodyEngine', 'not alive')\n                return []\n            }\n\n            if (this.awaitIndexing) {\n                await this.bfgIndexingPromise\n            }\n\n            const lastCandidateCurrentLine =\n                (lastCandidate?.lastTriggerDocContext.currentLinePrefix || '') +\n                lastCandidate?.result.items[0].insertText\n\n            const bfgRequestStart = performance.now()\n            const inputIdentifiers = Array.from(\n                new Set([\n                    // Get last 10 identifiers from the last candidate insert text\n                    // in hopes that LLM partially guessed the right completion.\n                    ...getLastNGraphContextIdentifiersFromString({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                        source: lastCandidateCurrentLine,\n                    }),\n                    // Get last 10 identifiers from the current document prefix.\n                    ...getLastNGraphContextIdentifiersFromDocument({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                    }),\n                ])\n            )\n\n            const response = await bfg.request('bfg/contextForIdentifiers', {\n                uri: document.uri.toString(),\n                identifiers: inputIdentifiers,\n                maxSnippets: 20,\n                maxDepth: 4,\n            })\n\n            // Just in case, handle non-object results\n            if (typeof response !== 'object') {\n                return []\n            }\n\n            // Convert BFG snippets to match the format expected on the client.\n            const symbols = (response.symbols || []).map(contextSnippet => ({\n                ...contextSnippet,\n                uri: vscode.Uri.from({ scheme: 'file', path: contextSnippet.fileName }),\n            })) satisfies Omit<AutocompleteContextSnippet, 'startLine' | 'endLine'>[]\n\n            logDebug('CodyEngine', 'bfg/contextForIdentifiers', {\n                verbose: {\n                    inputIdentifiers,\n                    duration: `${performance.now() - bfgRequestStart}ms`,\n                    symbols: symbols.map(s => `${s.symbol} ${s.content}`),\n                },\n            })\n\n            // TODO: add `startLine` and `endLine` to `responses` or explicitly add\n            // another context snippet type to the client.\n            // @ts-ignore\n            return symbols\n        } catch (error) {\n            logDebug('CodyEngine:error', `${error}`)\n            return []\n        }\n    }\n\n    public isSupportedForLanguageId(languageId: string): boolean {\n        switch (languageId) {\n            case 'typescript':\n            case 'typescriptreact':\n            case 'javascript':\n            case 'javascriptreact':\n            case 'java':\n            case 'go':\n            case 'dart':\n            case 'python':\n            case 'zig':\n                return true\n            default:\n                return false\n        }\n    }\n\n    public dispose(): void {\n        if (this.didFailLoading) {\n            return\n        }\n        this.loadedBFG.then(\n            bfg => bfg.request('bfg/shutdown', null),\n            () => {}\n        )\n    }\n\n    // We lazily load BFG to allow the Cody extension to finish activation as\n    // quickly as possible.\n    private loadBFG(): Promise<MessageHandler> {\n        // This is implemented as a custom promise instead of async/await so that we can reject\n        // the promise in the 'exit' handler if we fail to start the bfg process for some reason.\n        return new Promise<MessageHandler>((resolve, reject) => {\n            logDebug('CodyEngine', 'loading bfg')\n            this.doLoadBFG(reject).then(\n                bfg => resolve(bfg),\n                error => {\n                    captureException(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    private async doLoadBFG(reject: (reason?: any) => void): Promise<MessageHandler> {\n        const bfg = await spawnBfg(this.context, reject)\n        await bfg.request('bfg/initialize', { clientName: 'vscode' })\n        return bfg\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5271-5292"",""content"":""            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Constant()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        reader.readMessage(\n                            message.unit_constant,\n                            () => (message.unit_constant = UnitConstant.deserialize(reader))\n                        )\n                        break\n                    case 2:\n                        reader.readMessage(\n                            message.boolean_constant,\n                            () => (message.boolean_constant = BooleanConstant.deserialize(reader))\n                        )\n                        break\n                    case 3:\n                        reader.readMessage(\n                            message.byte_constant,\n                            () => (message.byte_constant = ByteConstant.deserialize(reader))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:139-145"",""content"":""async function removeOldBfgBinaries(containingDir: string, currentBfgPath: string): Promise<void> {\n    const bfgDirContents = await fspromises.readdir(containingDir)\n    const oldBfgBinaries = bfgDirContents.filter(f => f.startsWith('bfg') && f !== currentBfgPath)\n    for (const oldBfgBinary of oldBfgBinaries) {\n        await fspromises.rm(path.join(containingDir, oldBfgBinary))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/evaluate-autocomplete.ts:208-243"",""content"":""        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-language <glob>',\n        'A glob pattern to determine what language paths to exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-fixture <glob>',\n        'A glob pattern to determine what fixtures to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-fixture <glob>',\n        'A glob pattern to determine what fixtures exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-filepath <glob>',\n        'A glob pattern to determine what files to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-filepath <glob>',\n        'A glob pattern to determine what files exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .addOption(\n        new commander.Option('--bfg-binary <path>', 'Optional path to a BFG binary').env('BFG_BINARY')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:121-137"",""content"":""async function downloadBfgBinary(url: string, destination: string): Promise<void> {\n    logDebug('CodyEngine', `downloading from URL ${url}`)\n    const response = await axios({\n        url,\n        method: 'GET',\n        responseType: 'stream',\n        maxRedirects: 10,\n    })\n\n    const stream = fs.createWriteStream(destination)\n    response.data.pipe(stream)\n\n    await new Promise((resolve, reject) => {\n        stream.on('finish', resolve)\n        stream.on('error', reject)\n    })\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_023/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that enforces the context length limit is spread across several files, but the main logic is in these two functions:

1. **`truncateTextNearestLine` in `cody_test/lib/shared/src/prompt/truncation.ts`:** This function truncates text to the nearest line break, ensuring that the truncated text is a complete line. It's used to truncate the context when it exceeds the maximum allowed length.

2. **`truncateTextStart` in `cody_test/lib/shared/src/prompt/truncation.ts`:** This function truncates text from the beginning, keeping the end of the text. It's used to truncate the context when it exceeds the maximum allowed length, but it prioritizes keeping the end of the text.

These functions are used in various parts of the codebase to ensure that the context length doesn't exceed the limits. For example, in `cody_test/vscode/src/chat/chat-view/prompt.ts`, the `DefaultPrompter.makePrompt` function uses `truncateTextNearestLine` to truncate the chat transcript if it exceeds the context window limit.

Additionally, the `ContextItem` interface in `cody_test/lib/shared/src/codebase-context/messages.ts` includes a `isTooLarge` property, which indicates whether the content of the item is too large to be included as context. This property is used to filter out large context items and prevent them from exceeding the context length limit.

Overall, the context length limit is enforced through a combination of truncation functions and filtering mechanisms, ensuring that the context remains within the allowed bounds.",Where is the code that enforces the context length limit?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:61-63"",""content"":""func (r *RateLimit) IsValid() bool {\n\treturn r != nil && r.Interval > 0 && r.Limit > 0 && len(r.AllowedModels) > 0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/directory.ts:49-74"",""content"":""\n                // check file size before opening the file. skip file if it's larger than 1MB\n                const fileSize = await vscode.workspace.fs.stat(fileUri)\n                if (fileSize.size > 1000000 || !fileSize.size) {\n                    continue\n                }\n\n                const bytes = await vscode.workspace.fs.readFile(fileUri)\n                const content = new TextDecoder('utf-8').decode(bytes)\n                const range = new vscode.Range(0, 0, content.split('\\n').length - 1 || 0, 0)\n                const size = TokenCounter.countTokens(content)\n\n                contextFiles.push({\n                    type: 'file',\n                    uri: fileUri,\n                    content,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                })\n\n                // Limit the number of files to 10\n                const maxResults = 10\n                if (contextFiles.length >= maxResults) {\n                    return contextFiles\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:164-169"",""content"":""type updateOnErrorLimiter struct {\n\tlogger log.Logger\n\tactor  *Actor\n\n\tnextLimiter limiter.Limiter\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:91-122"",""content"":""            ),\n            rangeIncludingLineBreak: new vscode_shim.Range(\n                new vscode_shim.Position(line, 0),\n                new vscode_shim.Position(line, text.length + this.offsets.newlineLength(line))\n            ),\n            text,\n        }\n    }\n\n    public offsetAt(position: vscode.Position | protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public protocolOffsetAt(position: protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public positionAt(offset: number): vscode.Position {\n        const { line, character } = this.offsets.position(offset)\n        return new vscode_shim.Position(line, character)\n    }\n\n    public getText(range?: vscode.Range | undefined): string {\n        if (range === undefined) {\n            return this.content\n        }\n        const start = this.offsets.offset(range.start)\n        const end = this.offsets.offset(range.end)\n        const text = this.content.slice(start, end)\n        return text\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:132-134"",""content"":""func (l *concurrencyLimiter) Usage(ctx context.Context) (int, time.Time, error) {\n\treturn l.nextLimiter.Usage(ctx)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:129-143"",""content"":""func limitLineMatches(file *FileMatch, limit int) int {\n\tfor i := range file.LineMatches {\n\t\tlm := &file.LineMatches[i]\n\t\tif len(lm.LineFragments) > limit {\n\t\t\tlm.LineFragments = lm.LineFragments[:limit]\n\t\t}\n\t\tif len(lm.LineFragments) == limit {\n\t\t\tfile.LineMatches = file.LineMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(lm.LineFragments)\n\t}\n\treturn limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:80-125"",""content"":""func limitChunkMatches(file *FileMatch, limit int) int {\n\tfor i := range file.ChunkMatches {\n\t\tcm := &file.ChunkMatches[i]\n\t\tif len(cm.Ranges) > limit {\n\t\t\t// We potentially need to effect the limit upon 3 different fields:\n\t\t\t// Ranges, SymbolInfo, and Content.\n\n\t\t\t// Content is the most complicated: we need to remove the last N\n\t\t\t// lines from it, where N is the difference between the line number\n\t\t\t// of the end of the old last Range and that of the new last Range.\n\t\t\t// This calculation is correct in the presence of both context lines\n\t\t\t// and multiline Ranges, taking into account that Content never has\n\t\t\t// a trailing newline.\n\t\t\tn := cm.Ranges[len(cm.Ranges)-1].End.LineNumber - cm.Ranges[limit-1].End.LineNumber\n\t\t\tif n > 0 {\n\t\t\t\tfor b := len(cm.Content) - 1; b >= 0; b-- {\n\t\t\t\t\tif cm.Content[b] == '\\n' {\n\t\t\t\t\t\tn -= 1\n\t\t\t\t\t}\n\t\t\t\t\tif n == 0 {\n\t\t\t\t\t\tcm.Content = cm.Content[:b]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\t// Should be impossible.\n\t\t\t\t\tlog.Panicf(\""Failed to find enough newlines when truncating Content, %d left over, %d ranges\"", n, len(cm.Ranges))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcm.Ranges = cm.Ranges[:limit]\n\t\t\tif cm.SymbolInfo != nil {\n\t\t\t\t// When non-nil, SymbolInfo is specified to have the same length\n\t\t\t\t// as Ranges.\n\t\t\t\tcm.SymbolInfo = cm.SymbolInfo[:limit]\n\t\t\t}\n\t\t}\n\t\tif len(cm.Ranges) == limit {\n\t\t\tfile.ChunkMatches = file.ChunkMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(cm.Ranges)\n\t}\n\treturn limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/file-path.ts:0-43"",""content"":""import {\n    type ContextItem,\n    ContextItemSource,\n    TokenCounter,\n    logError,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\n/**\n * Generate ContextFile for a file URI.\n */\nexport async function getContextFileFromUri(file: URI, range?: vscode.Range): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.filePath', async span => {\n        try {\n            const doc = await vscode.workspace.openTextDocument(file)\n            const content = doc?.getText(range).trim()\n            if (!content) {\n                throw new Error('No file content')\n            }\n\n            const startLine = range?.start?.line ?? 0\n            range = new vscode.Range(startLine, 0, startLine + content.split('\\n').length, 0)\n            const size = TokenCounter.countTokens(content)\n\n            return [\n                {\n                    type: 'file',\n                    content,\n                    uri: file,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                },\n            ] satisfies ContextItem[]\n        } catch (error) {\n            logError('getContextFileFromUri', 'failed', { verbose: error })\n            return []\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:85-99"",""content"":""type concurrencyLimiter struct {\n\tlogger  log.Logger\n\tactor   *Actor\n\tfeature codygateway.Feature\n\n\t// redis must be a prefixed store\n\tredis limiter.RedisStore\n\n\tconcurrentRequests int\n\tconcurrentInterval time.Duration\n\n\tnextLimiter limiter.Limiter\n\n\tnowFunc func() time.Time\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/workspace.ts:22-51"",""content"":""\n        const contextFiles: ContextItem[] = []\n\n        // set cancellation token to time out after 20s\n        const token = new CancellationTokenSource()\n        setTimeout(() => {\n            token.cancel()\n        }, 20000)\n\n        try {\n            const results = await workspace.findFiles(globalPattern, excluded, maxResults, token.token)\n\n            for (const result of results) {\n                const decoded = await getDocText(result)\n                const contextFile = await createContextFile(result, decoded)\n\n                if (contextFile) {\n                    contextFiles.push(contextFile)\n                }\n            }\n\n            return contextFiles\n        } catch (error) {\n            logError('getWorkspaceFilesContext failed', `${error}`)\n\n            return contextFiles\n        }\n    })\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:175-199"",""content"":""        }\n\n        for (let snippetsToInclude = 0; snippetsToInclude < snippets.length + 1; snippetsToInclude++) {\n            if (snippetsToInclude > 0) {\n                const snippet = snippets[snippetsToInclude - 1]\n                const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n                if (contextPrompts.symbol) {\n                    intro.push(\n                        ps`Additional documentation for \\`${contextPrompts.symbol}\\`:\\n\\n${contextPrompts.content}`\n                    )\n                } else {\n                    intro.push(\n                        ps`Here is a reference snippet of code from ${PromptString.fromDisplayPath(\n                            snippet.uri\n                        )}:\\n\\n${contextPrompts.content}`\n                    )\n                }\n            }\n\n            const introString = ps`${PromptString.join(\n                PromptString.join(intro, ps`\\n\\n`)\n                    .split('\\n')\n                    .map(line => ps`${languageConfig ? languageConfig.commentStart : ps`// `}${line}`),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:62-76"",""content"":""func limitMatches(files []FileMatch, limit int, chunkMatches bool) ([]FileMatch, int) {\n\tvar limiter func(file *FileMatch, limit int) int\n\tif chunkMatches {\n\t\tlimiter = limitChunkMatches\n\t} else {\n\t\tlimiter = limitLineMatches\n\t}\n\tfor i := range files {\n\t\tlimit = limiter(&files[i], limit)\n\t\tif limit <= 0 {\n\t\t\treturn files[:i+1], 0\n\t\t}\n\t}\n\treturn files, limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/context.ts:39-61"",""content"":""    const truncatedPrecedingText = truncatePromptStringStart(precedingText, MAX_CURRENT_FILE_TOKENS)\n    const truncatedFollowingText = truncatePromptString(followingText, MAX_CURRENT_FILE_TOKENS)\n\n    // Disable no case declarations because we get better type checking with a switch case\n    switch (intent) {\n        /**\n         * The context for the test intent is handled by the executeTestEditCommand function,\n         * we don't need to add additional context here to avoid duplication.\n         */\n        case 'test':\n            return []\n        /**\n         * Very broad set of possible instructions.\n         * Fetch context from the users' instructions and use context from current file.\n         * Include the following code from the current file.\n         * The preceding code is already included as part of the response to better guide the output.\n         */\n        case 'add': {\n            return [\n                {\n                    speaker: 'human',\n                    text: populateCodeGenerationContextTemplate(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:20-36"",""content"":""type RateLimit struct {\n\t// AllowedModels is a set of models in Cody Gateway's model configuration\n\t// format, \""$PROVIDER/$MODEL_NAME\"". A single-item slice with value '*' means\n\t// that all models in the 'master allowlist' are allowed.\n\t//\n\t// DO NOT USE DIRECTLY when enforcing permissions: use EvaluateAllowedModels(...)\n\t// instead.\n\tAllowedModels []string `json:\""allowedModels\""`\n\n\tLimit    int64         `json:\""limit\""`\n\tInterval time.Duration `json:\""interval\""`\n\n\t// ConcurrentRequests, ConcurrentRequestsInterval are generally applied\n\t// with NewRateLimitWithPercentageConcurrency.\n\tConcurrentRequests         int           `json:\""concurrentRequests\""`\n\tConcurrentRequestsInterval time.Duration `json:\""concurrentRequestsInterval\""`\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/provider.ts:27-57"",""content"":""\n    /**\n     * A string identifier for the provider config used in event logs.\n     */\n    identifier: string\n\n    /**\n     * Defines which model is used with the respective provider.\n     */\n    model: string\n}\n\ninterface ProviderContextSizeHints {\n    /** Total max length of all context (prefix + suffix + snippets). */\n    totalChars: number\n\n    /** Max length of the document prefix (text before the cursor). */\n    prefixChars: number\n\n    /** Max length of the document suffix (text after the cursor). */\n    suffixChars: number\n}\n\nexport function standardContextSizeHints(maxContextTokens: number): ProviderContextSizeHints {\n    return {\n        totalChars: Math.floor(tokensToChars(0.9 * maxContextTokens)), // keep 10% margin for preamble, etc.\n        prefixChars: Math.floor(tokensToChars(0.6 * maxContextTokens)),\n        suffixChars: Math.floor(tokensToChars(0.1 * maxContextTokens)),\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/truncation.ts:25-60"",""content"":"" * which should be ignored anyway).\n */\nexport function truncateTextNearestLine(\n    text: string,\n    maxBytes: number\n): { truncated: string; range?: RangeData } {\n    if (text.length <= maxBytes) {\n        return { truncated: text }\n    }\n    const textMaxBytes = text.slice(0, maxBytes)\n    const textMaxBytesLines = textMaxBytes.split('\\n')\n    if (text.at(maxBytes) === '\\n' || text.at(maxBytes - 1) === '\\n') {\n        return {\n            truncated: textMaxBytes,\n            range: {\n                start: { line: 0, character: 0 },\n                end: { line: textMaxBytesLines.length, character: 0 },\n            },\n        }\n    }\n\n    const truncated = textMaxBytesLines.slice(0, -1).join('\\n')\n    return {\n        truncated,\n        range: {\n            start: { line: 0, character: 0 },\n            end: { line: textMaxBytesLines.length - 1, character: 0 },\n        },\n    }\n}\n\n/**\n * Truncates text to the given number of tokens, keeping the end of the text.\n */\nexport function truncateTextStart(text: string, maxTokens: number): string {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:152-163"",""content"":""                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:57-80"",""content"":""                throw new Error(\n                    `Preamble length exceeded context window size ${chat.contextWindow.input}`\n                )\n            }\n\n            // Add existing chat transcript messages\n            const reverseTranscript: ChatMessage[] = [...chat.getMessages()].reverse()\n            const transcriptLimitReached = promptBuilder.tryAddMessages(reverseTranscript)\n            if (transcriptLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    `Ignored ${transcriptLimitReached} transcript messages due to context limit`\n                )\n            }\n\n            // NOTE: Only display excluded context from user-specifed context items\n            const newContextIgnored: ContextItem[] = []\n            const newContextUsed: ContextItem[] = []\n\n            // Add context from new user-specified context items, e.g. @-mentions, @-uri\n            sortContextItems(this.explicitContext)\n            const {\n                limitReached: userLimitReached,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/utils.ts:104-135"",""content"":""        return 1\n    }\n\n    return 0 // zero refers to the legacy, unversioned, Cody API\n}\n\n/**\n * Counts the total number of bytes used in a list of chat messages.\n *\n * This function is exported and can be used to calculate the byte usage\n * of chat messages for storage/bandwidth purposes.\n *\n * @param messages - The list of chat messages to count bytes for\n * @returns The total number of bytes used in the messages\n */\nexport function countBytesInChatMessages(messages: ChatMessage[]): number {\n    if (messages.length === 0) {\n        return 0\n    }\n    return messages.reduce((acc, msg) => acc + msg.speaker.length + (msg.text?.length || 0) + 3, 0)\n}\n\n/**\n * Gets the context window limit in bytes for chat messages, taking into\n * account the maximum allowed character count. Returns 0 if the used bytes\n * exceeds the limit.\n * @param messages - The chat messages\n * @param maxChars - The maximum allowed character count\n * @returns The context window limit in bytes\n */\nexport function getContextWindowLimitInBytes(messages: ChatMessage[], maxChars: number): number {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/jaccard-similarity/jaccard-similarity-retriever.ts:0-22"",""content"":""import * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\nimport { getContextRange } from '../../../doc-context-getters'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\nimport { baseLanguageId } from '../../utils'\nimport { type DocumentHistory, VSCodeDocumentHistory } from './history'\n\nimport { lastNLines } from '../../../text-processing'\nimport { type JaccardMatch, bestJaccardMatches } from './bestJaccardMatch'\n\n/**\n * The size of the Jaccard distance match window in number of lines. It determines how many\n * lines of the 'matchText' are considered at once when searching for a segment\n * that is most similar to the 'targetText'. In essence, it sets the maximum number\n * of lines that the best match can be. A larger 'windowSize' means larger potential matches\n */\nconst SNIPPET_WINDOW_SIZE = 50\n\n/**\n * Limits the number of jaccard windows that are fetched for a single file. This is mostly added to\n * avoid large files taking up too much compute time and to avoid a single file to take up too much\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:138-138"",""content"":""\tlimit      int\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_024/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The logic for opening a new chat window is spread across multiple files, but the core functionality is in the `ChatManager` class in the file `cody_test/vscode/src/chat/chat-view/ChatManager.ts`.

Here's a breakdown of how it works:

1. **`createNewWebviewPanel()`:** This method is responsible for creating a new webview panel, which is the container for the chat window. It uses the `ChatPanelsManager` class to handle the actual creation of the panel.
2. **`ChatPanelsManager.createWebviewPanel()`:** This method creates a new `SimpleChatPanelProvider` instance, which is responsible for managing the chat session within the webview panel. It also handles reusing existing panels if available.
3. **`SimpleChatPanelProvider.newSession()`:** This method is called to initialize the new chat session within the webview panel. It sets up the initial context and state for the chat.

The command `cody.chat.panel.new` is registered to call `createNewWebviewPanel()` which ultimately leads to the creation of a new chat window.

Here's a simplified flow:

```
// User clicks ""New Chat"" button
// This triggers the 'cody.chat.panel.new' command
vscode.commands.executeCommand('cody.chat.panel.new')

// This calls ChatManager.createNewWebviewPanel()
ChatManager.createNewWebviewPanel()

// This calls ChatPanelsManager.createWebviewPanel()
ChatPanelsManager.createWebviewPanel()

// This creates a new SimpleChatPanelProvider instance
// and initializes a new chat session within the webview panel
SimpleChatPanelProvider.newSession()

// A new chat window is opened
```

This is a simplified explanation, and there are other details involved, such as handling existing chat sessions, managing the chat history, and handling user interactions. However, this gives you a general idea of how a new chat window is opened.",Where is the logic for opening a new chat window?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/helpers.ts:391-394"",""content"":""export async function newChat(page: Page): Promise<FrameLocator> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    return page.frameLocator('iframe.webview').last().frameLocator('iframe')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:77-95"",""content"":""            vscode.commands.registerCommand('cody.chat.history.clear', () => this.clearHistory()),\n            vscode.commands.registerCommand('cody.chat.history.delete', item => this.clearHistory(item)),\n            vscode.commands.registerCommand('cody.chat.history.edit', item =>\n                this.editChatHistory(item)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.new', () => this.createNewWebviewPanel()),\n            vscode.commands.registerCommand('cody.chat.panel.restore', (id, chat) =>\n                this.restorePanel(id, chat)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.reset', () =>\n                this.chatPanelsManager.resetPanel()\n            ),\n            vscode.commands.registerCommand(CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID, (...args) =>\n                this.passthroughVsCodeOpen(...args)\n            ),\n            vscode.commands.registerCommand('cody.chat.context.add', () => this.sendSelectionToChat())\n        )\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/open-telemetry/OpenTelemetryService.node.ts:0-95"",""content"":""import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\nimport { registerInstrumentations } from '@opentelemetry/instrumentation'\nimport { HttpInstrumentation } from '@opentelemetry/instrumentation-http'\nimport { Resource } from '@opentelemetry/resources'\nimport { NodeTracerProvider } from '@opentelemetry/sdk-trace-node'\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\n\nimport {\n    type ConfigurationWithAccessToken,\n    FeatureFlag,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport { DiagConsoleLogger, DiagLogLevel, diag } from '@opentelemetry/api'\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { version } from '../../version'\nimport { ConsoleBatchSpanExporter } from './console-batch-span-exporter'\n\nexport type OpenTelemetryServiceConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'experimentalTracing' | 'debugVerbose'\n>\n\nexport class OpenTelemetryService {\n    private tracerProvider?: NodeTracerProvider\n    private unloadInstrumentations?: () => void\n\n    private lastTraceUrl: string | undefined\n    // We use a single promise object that we chain on to, to avoid multiple reconfigure calls to\n    // be run in parallel\n    private reconfigurePromiseMutex: Promise<void> = Promise.resolve()\n\n    constructor(protected config: OpenTelemetryServiceConfig) {\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    public onConfigurationChange(newConfig: OpenTelemetryServiceConfig): void {\n        this.config = newConfig\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    private async reconfigure(): Promise<void> {\n        const isEnabled =\n            this.config.experimentalTracing ||\n            (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.CodyAutocompleteTracing))\n\n        if (!isEnabled) {\n            return\n        }\n\n        const traceUrl = new URL('/-/debug/otlp/v1/traces', this.config.serverEndpoint).toString()\n        if (this.lastTraceUrl === traceUrl) {\n            return\n        }\n        this.lastTraceUrl = traceUrl\n\n        const logLevel = this.config.debugVerbose ? DiagLogLevel.INFO : DiagLogLevel.ERROR\n        diag.setLogger(new DiagConsoleLogger(), logLevel)\n\n        await this.reset()\n\n        this.unloadInstrumentations = registerInstrumentations({\n            instrumentations: [new HttpInstrumentation()],\n        })\n        this.configureTracerProvider(traceUrl)\n    }\n\n    public configureTracerProvider(traceUrl: string): void {\n        this.tracerProvider = new NodeTracerProvider({\n            resource: new Resource({\n                [SemanticResourceAttributes.SERVICE_NAME]: 'cody-client',\n                [SemanticResourceAttributes.SERVICE_VERSION]: version,\n            }),\n        })\n\n        // Add the default tracer exporter used in production.\n        this.tracerProvider.addSpanProcessor(\n            new BatchSpanProcessor(\n                new OTLPTraceExporter({ url: traceUrl, httpAgentOptions: { rejectUnauthorized: false } })\n            )\n        )\n\n        // Add the console exporter used in development for verbose logging and debugging.\n        if (process.env.NODE_ENV === 'development' || this.config.debugVerbose) {\n            this.tracerProvider.addSpanProcessor(new BatchSpanProcessor(new ConsoleBatchSpanExporter()))\n        }\n\n        this.tracerProvider.register()\n    }\n\n    public async reset(): Promise<void> {\n        await this.tracerProvider?.shutdown()\n        this.unloadInstrumentations?.()\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:776-807"",""content"":""            },\n        })\n    }\n\n    /**\n     * Low-level utility to post a message to the webview, pending initialization.\n     *\n     * cody-invariant: this.webview?.postMessage should never be invoked directly\n     * except within this method.\n     */\n    private postMessage(message: ExtensionMessage): Thenable<boolean | undefined> {\n        return this.initDoer.do(() => this.webview?.postMessage(message))\n    }\n\n    private postChatTitle(): void {\n        if (this.webviewPanel) {\n            this.webviewPanel.title = this.chatModel.getChatTitle()\n        }\n    }\n\n    // #endregion\n    // =======================================================================\n    // #region chat request lifecycle methods\n    // =======================================================================\n\n    /**\n     * Constructs the prompt and updates the UI with the context used in the prompt.\n     */\n    private async buildPrompt(\n        prompter: IPrompter,\n        sendTelemetry?: (contextSummary: any, privateContextStats?: any) => void\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.test.ts:0-46"",""content"":""import { describe, expect, test } from 'vitest'\n\nimport { getChatPanelTitle } from './chat-helpers'\n\ndescribe('getChatPanelTitle', () => {\n    test('returns default title when no lastDisplayText', () => {\n        const result = getChatPanelTitle()\n        expect(result).toEqual('New Chat')\n    })\n\n    test('long titles will be truncated', () => {\n        const longTitle = 'This is a very long title that should get truncated by the function'\n        const result = getChatPanelTitle(longTitle)\n        expect(result).toEqual('This is a very long title...')\n    })\n\n    test('keeps command key', () => {\n        const title = '/explain this symbol'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain this symbol')\n    })\n\n    test('keeps command key with file path', () => {\n        const title = '/explain [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain @a.ts')\n    })\n\n    test('removes markdown links', () => {\n        const title = 'Summarize this file [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Summarize this file @a.ts')\n    })\n\n    test('removes multiple markdown links', () => {\n        const title = '[_@a.py_](a.py) [_@b.py_](b.py) explain'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('@a.py @b.py explain')\n    })\n\n    test('truncates long title with multiple markdown links', () => {\n        const title = 'Explain the relationship...'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Explain the relationship....')\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:23-48"",""content"":""\n    const heyTreeItem = page.getByRole('treeitem', { name: 'Hey' })\n    const holaTreeItem = page.getByRole('treeitem', { name: 'Hola' })\n\n    const [chatPanelFrame, chatInput] = await createEmptyChatPanel(page)\n\n    await chatInput.fill('Hey')\n    await chatInput.press('Enter')\n\n    // Check if chat shows up in sidebar chat history tree view\n    await expect(heyTreeItem).toBeVisible()\n\n    // Wait at least 1 second to ensure that the 2 chats have different IDs (which are currently\n    // created using `new Date(Date.now()).toUTCString()`, so they are the same if they are\n    // generated in the same second).\n    //\n    // TODO(sqs): investigate and fix the underlying bug here\n    await page.waitForTimeout(1000)\n\n    // Clear and restart chat session\n    // All current messages should be removed, and the panel name should be updated to 'New Chat'\n    await chatInput.fill('/reset')\n    await chatInput.press('Enter')\n    await expect(chatPanelFrame.getByText('Hey')).not.toBeVisible()\n    await expect(page.getByRole('tab', { name: 'New Chat' })).toBeVisible()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.ts:0-39"",""content"":""import * as vscode from 'vscode'\n\nimport type { RangeData } from '@sourcegraph/cody-shared'\n\nexport async function openFile(\n    uri: vscode.Uri,\n    range?: RangeData,\n    currentViewColumn?: vscode.ViewColumn\n): Promise<void> {\n    let viewColumn = vscode.ViewColumn.Beside\n    if (currentViewColumn) {\n        viewColumn = currentViewColumn - 1 || currentViewColumn + 1\n    }\n    const doc = await vscode.workspace.openTextDocument(uri)\n    // +1 because selection range starts at 0 while editor line starts at 1\n    const selection = range && new vscode.Range(range.start.line, 0, range.end.line + 1, 0)\n    await vscode.window.showTextDocument(doc, {\n        selection,\n        viewColumn,\n        preserveFocus: true,\n        preview: true,\n    })\n}\n\nexport function getChatPanelTitle(lastHumanText?: string, truncateTitle = true): string {\n    if (!lastHumanText) {\n        return 'New Chat'\n    }\n\n    let text = lastHumanText\n    // Regex to remove the markdown formatted links with this format: '[_@FILENAME_]()'\n    const MARKDOWN_LINK_REGEX = /\\[_(.+?)_]\\((.+?)\\)/g\n    text = text.replaceAll(MARKDOWN_LINK_REGEX, '$1')?.trim()\n    if (!truncateTitle) {\n        return text\n    }\n    // truncate title that is too long\n    return text.length > 25 ? `${text.slice(0, 25).trim()}...` : text\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1017-1043"",""content"":""\n    // #endregion\n    // =======================================================================\n    // #region session management\n    // =======================================================================\n\n    // A unique identifier for this SimpleChatPanelProvider instance used to identify\n    // it when a handle to this specific panel provider is needed.\n    public get sessionID(): string {\n        return this.chatModel.sessionID\n    }\n\n    // Sets the provider up for a new chat that is not being restored from a\n    // saved session.\n    public async newSession(): Promise<void> {\n        // Set the remote search's selected repos to the workspace repo list\n        // by default.\n        this.remoteSearch?.setRepos(\n            (await this.repoPicker?.getDefaultRepos()) || [],\n            RepoInclusion.Manual\n        )\n    }\n\n    // Attempts to restore the chat to the given sessionID, if it exists in\n    // history. If it does, then saves the current session and cancels the\n    // current in-progress completion. If the chat does not exist, then this\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:48-533"",""content"":""export const Chat: React.FunctionComponent<React.PropsWithChildren<ChatboxProps>> = ({\n    welcomeMessage,\n    messageInProgress,\n    transcript,\n    vscodeAPI,\n    telemetryService,\n    isTranscriptError,\n    chatEnabled,\n    userInfo,\n    guardrails,\n    chatIDHistory,\n    isWebviewActive,\n    isNewInstall,\n    userContextFromSelection,\n}) => {\n    const [messageBeingEdited, setMessageBeingEdited] = useState<number | undefined>(undefined)\n\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n            }\n            const editorValue = editorRef.current.getSerializedValue()\n            if (!editorValue.text.trim()) {\n                throw new Error('Chat message cannot be empty')\n            }\n            // Handle edit requests\n            if (submitType === 'edit') {\n                if (messageBeingEdited === undefined) {\n                    throw new Error('unexpected: messageBeingEdited is undefined')\n                }\n                vscodeAPI.postMessage({\n                    command: 'edit',\n                    index: messageBeingEdited!,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            } else {\n                vscodeAPI.postMessage({\n                    command: 'submit',\n                    submitType,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            }\n        },\n        [addEnhancedContext, messageBeingEdited, vscodeAPI]\n    )\n\n    const feedbackButtonsOnSubmit = useCallback(\n        (text: string) => {\n            const eventData = {\n                value: text,\n                lastChatUsedEmbeddings: Boolean(\n                    transcript.at(-1)?.contextFiles?.some(file => file.source === 'embeddings')\n                ),\n                transcript: '',\n            }\n\n            if (userInfo.isDotComUser) {\n                eventData.transcript = JSON.stringify(transcript)\n            }\n\n            telemetryService.log(`CodyVSCodeExtension:codyFeedback:${text}`, eventData)\n        },\n        [telemetryService, transcript, userInfo]\n    )\n\n    const copyButtonOnSubmit = useCallback(\n        (text: string, eventType: 'Button' | 'Keydown' = 'Button') => {\n            const op = 'copy'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const insertButtonOnSubmit = useCallback(\n        (text: string, newFile = false) => {\n            const op = newFile ? 'newFile' : 'insert'\n            const eventType = 'Button'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const postMessage = useCallback<ApiPostMessage>(msg => vscodeAPI.postMessage(msg), [vscodeAPI])\n\n    const setInputFocus = useCallback((focus: boolean): void => {\n        editorRef.current?.setFocus(focus)\n    }, [])\n\n    // When New Chat Mode is enabled, all non-edit questions will be asked in a new chat session\n    // Users can toggle this feature via \""shift\"" + \""Meta(Mac)/Control\"" keys\n    const [enableNewChatMode, setEnableNewChatMode] = useState(false)\n\n    const lastHumanMessageIndex = useMemo<number | undefined>(() => {\n        if (!transcript?.length) {\n            return undefined\n        }\n        const index = transcript.findLastIndex(msg => msg.speaker === 'human')\n\n        return index\n    }, [transcript])\n\n    /**\n     * Sets the state to edit a message at the given index in the transcript.\n     * Checks that the index is valid, then gets the display text  to set as the\n     * form input.\n     *\n     * An undefined index number means there is no message being edited.\n     */\n    const setEditMessageState = useCallback(\n        (index?: number): void => {\n            // When a message is no longer being edited\n            // we will reset the form input fill to empty state\n            if (index === undefined && index !== messageBeingEdited) {\n                setEditorState(null)\n            }\n            setMessageBeingEdited(index)\n            if (index === undefined || index > transcript.length) {\n                return\n            }\n            const messageAtIndex = transcript[index]\n            if (messageAtIndex) {\n                setEditorState(serializedPromptEditorStateFromChatMessage(messageAtIndex))\n            }\n            // move focus back to chatbox\n            setInputFocus(true)\n        },\n        [messageBeingEdited, transcript, setEditorState, setInputFocus]\n    )\n\n    /**\n     * Reset current chat view with a new empty chat session.\n     *\n     * Calls setEditMessageState() to reset any in-progress edit state.\n     * Sends a 'reset' command to postMessage to reset the chat on the server.\n     */\n    const onChatResetClick = useCallback(\n        (eventType: 'keyDown' | 'click' = 'click') => {\n            setEditMessageState()\n            postMessage?.({ command: 'reset' })\n            postMessage?.({\n                command: 'event',\n                eventName: 'CodyVSCodeExtension:chatActions:reset:executed',\n                properties: { source: 'chat', eventType },\n            })\n        },\n        [postMessage, setEditMessageState]\n    )\n\n    const submitInput = useCallback(\n        (submitType: WebviewChatSubmitType): void => {\n            if (messageInProgress && submitType !== 'edit') {\n                return\n            }\n            onSubmit(submitType)\n\n            setEditorState(null)\n            setEditMessageState()\n        },\n        [messageInProgress, onSubmit, setEditMessageState, setEditorState]\n    )\n\n    const onChatSubmit = useCallback((): void => {\n        // Submit edits when there is one being edited\n        if (messageBeingEdited !== undefined) {\n            onAbortMessageInProgress()\n            submitInput('edit')\n            return\n        }\n\n        // Submit chat only when input is not empty and not in progress\n        if (!isEmptyEditorValue && !messageInProgress?.speaker) {\n            const submitType = enableNewChatMode ? 'user-newchat' : 'user'\n            submitInput(submitType)\n        }\n    }, [\n        isEmptyEditorValue,\n        messageBeingEdited,\n        messageInProgress?.speaker,\n        enableNewChatMode,\n        submitInput,\n        onAbortMessageInProgress,\n    ])\n\n    const onEditorEscapeKey = useCallback((): void => {\n        // Close the enhanced context settings modal if it's open\n        setIsEnhancedContextOpen(false)\n\n        // Exits editing mode if a message is being edited\n        if (messageBeingEdited !== undefined) {\n            setEditMessageState()\n            return\n        }\n\n        // Aborts a message in progress if one exists\n        if (messageInProgress?.speaker) {\n            onAbortMessageInProgress()\n            return\n        }\n    }, [messageBeingEdited, setEditMessageState, messageInProgress, onAbortMessageInProgress])\n\n    const onEditorEnterKey = useCallback(\n        (event: KeyboardEvent | null): void => {\n            // Submit input on Enter press (without shift) when input is not empty.\n            if (event && !event.shiftKey && !event.isComposing && !isEmptyEditorValue) {\n                event.preventDefault()\n                onChatSubmit()\n                return\n            }\n        },\n        [onChatSubmit, isEmptyEditorValue]\n    )\n\n    const onEditorKeyDown = useCallback(\n        (event: KeyboardEvent, caretPosition: number): void => {\n            // Check if the Ctrl key is pressed on Windows/Linux or the Cmd key is pressed on macOS\n            const isModifierDown = isMac ? event.metaKey : event.ctrlKey\n            if (isModifierDown) {\n                // Ctrl/Cmd + / - Clears the chat and starts a new session\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick('keyDown')\n                    return\n                }\n                // Ctrl/Cmd + K - When not already editing, edits the last human message\n                if (messageBeingEdited === undefined && event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    setEditMessageState(lastHumanMessageIndex)\n\n                    postMessage?.({\n                        command: 'event',\n                        eventName: 'CodyVSCodeExtension:chatActions:editLast:executed',\n                        properties: { source: 'chat', eventType: 'keyDown' },\n                    })\n                    return\n                }\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            if (event.altKey && event.key === 'c') {\n                event.preventDefault()\n                event.stopPropagation()\n                return\n            }\n\n            // Allow navigation/selection with Ctrl(+Shift?)+Arrows\n            const arrowKeys = new Set(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'])\n            if (event.ctrlKey && arrowKeys.has(event.key)) {\n                return\n            }\n\n            // Handles keyboard shortcuts with Ctrl key.\n            // Checks if the Ctrl key is pressed with a key not in the allow list\n            // to avoid triggering default browser shortcuts and bubbling the event.\n            const ctrlKeysAllowList = new Set([\n                'a',\n                'c',\n                'v',\n                'x',\n                'y',\n                'z',\n                'Enter',\n                'Shift' /* follow-up */,\n            ])\n            if (event.ctrlKey && !ctrlKeysAllowList.has(event.key)) {\n                event.preventDefault()\n                return\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            const vscodeCodyShortcuts = new Set(['Slash', 'KeyC'])\n            if (event.altKey && vscodeCodyShortcuts.has(event.code)) {\n                event.preventDefault()\n                return\n            }\n\n            // TODO (bee) - Update to use Option key instead\n            // TODO (bee) - remove once updated to use Option key\n            // Toggles between new chat mode and regular chat mode\n            if (event.altKey && event.shiftKey && isModifierDown) {\n                // use as a temporary block for this key combination\n                event.preventDefault()\n                setEnableNewChatMode(!enableNewChatMode)\n                return\n            }\n\n            // If there's no input and ArrowUp is pressed, edit the last message.\n            if (event.key === 'ArrowUp' && isEmptyEditorValue) {\n                setEditMessageState(lastHumanMessageIndex)\n            }\n        },\n        [\n            messageBeingEdited,\n            isEmptyEditorValue,\n            onChatResetClick,\n            setEditMessageState,\n            lastHumanMessageIndex,\n            enableNewChatMode,\n            postMessage,\n        ]\n    )\n\n    // Set up the message listener for adding new context from user's editor to chat.\n    // Turns the new context into @-mentions token in chat.\n    useEffect(() => {\n        if (!userContextFromSelection.length) {\n            return\n        }\n        editorRef.current?.addContextItemAsToken(userContextFromSelection)\n    }, [userContextFromSelection])\n\n    // Focus the textarea when the webview (re)gains focus (unless there is text selected or a modal\n    // is open). This makes it so that the user can immediately start typing to Cody after invoking\n    // `Cody: Focus on Chat View` with the keyboard.\n    useEffect(() => {\n        // Focus the input when the enhanced context settings modal is closed\n        setInputFocus(!isEnhancedContextOpen)\n        // Add window focus event listener to focus the input when the window is focused\n        const handleFocus = (): void => {\n            if (document.getSelection()?.isCollapsed && !isEnhancedContextOpen) {\n                setInputFocus(true)\n            }\n        }\n        window.addEventListener('focus', handleFocus)\n        return () => {\n            window.removeEventListener('focus', handleFocus)\n        }\n    }, [setInputFocus, isEnhancedContextOpen])\n\n    const onCancelEditClick = useCallback(() => setEditMessageState(), [setEditMessageState])\n    const onEditLastMessageClick = useCallback(\n        () => setEditMessageState(lastHumanMessageIndex),\n        [setEditMessageState, lastHumanMessageIndex]\n    )\n\n    const onRestoreLastChatClick = useMemo(\n        () =>\n            // Display the restore button if there is a previous chat id in current window\n            // And the current chat window is new\n            chatIDHistory.length > 1\n                ? () =>\n                      postMessage?.({\n                          command: 'restoreHistory',\n                          chatID: chatIDHistory.at(-2),\n                      })\n                : undefined,\n        [chatIDHistory, postMessage]\n    )\n\n    // biome-ignore lint/correctness/useExhaustiveDependencies: We don't want to re-run this effect.\n    const onEnhancedContextTogglerClick = useCallback((open: boolean) => {\n        if (!isEnhancedContextOpen && !open) {\n            setInputFocus(true)\n        }\n        setIsEnhancedContextOpen(open)\n    }, [])\n\n    const [isEditorFocused, setIsEditorFocused] = useState(false)\n\n    const isNewChat = transcript.length === 0\n    const TIPS = '(@ for files, @# for symbols)'\n    const placeholder = chatEnabled\n        ? isNewChat\n            ? `Message ${TIPS}`\n            : `Follow-Up Message ${TIPS}`\n        : 'Chat has been disabled by your Enterprise instance site administrator'\n\n    return (\n        <div className={classNames(styles.innerContainer)}>\n            {\n                <Transcript\n                    transcript={transcript}\n                    welcomeMessage={welcomeMessage}\n                    messageInProgress={messageInProgress}\n                    messageBeingEdited={messageBeingEdited}\n                    setMessageBeingEdited={setEditMessageState}\n                    className={styles.transcriptContainer}\n                    feedbackButtonsOnSubmit={feedbackButtonsOnSubmit}\n                    copyButtonOnSubmit={copyButtonOnSubmit}\n                    insertButtonOnSubmit={insertButtonOnSubmit}\n                    isTranscriptError={isTranscriptError}\n                    userInfo={userInfo}\n                    postMessage={postMessage}\n                    guardrails={guardrails}\n                />\n            }\n            <form className={classNames(styles.inputRow)}>\n                {/* Don't show chat action buttons on empty chat session unless it's a new cha*/}\n\n                <ChatActions\n                    setInputFocus={setInputFocus}\n                    isWebviewActive={isWebviewActive}\n                    isEmptyChat={transcript.length < 1}\n                    isMessageInProgress={!!messageInProgress?.speaker}\n                    isEditing={transcript.length > 1 && messageBeingEdited !== undefined}\n                    isEmptyEditorValue={isEmptyEditorValue}\n                    isEditorFocused={isEditorFocused}\n                    onChatResetClick={onChatResetClick}\n                    onCancelEditClick={onCancelEditClick}\n                    onEditLastMessageClick={onEditLastMessageClick}\n                    onRestoreLastChatClick={onRestoreLastChatClick}\n                />\n\n                <div className={styles.textAreaContainer}>\n                    <div className={styles.editorOuterContainer}>\n                        <PromptEditor\n                            placeholder={placeholder}\n                            onChange={onEditorChange}\n                            onFocusChange={setIsEditorFocused}\n                            disabled={!chatEnabled}\n                            onKeyDown={onEditorKeyDown}\n                            onEnterKey={onEditorEnterKey}\n                            onEscapeKey={onEditorEscapeKey}\n                            editorRef={editorRef}\n                        />\n                        <div className={styles.contextButton}>\n                            <EnhancedContextSettings\n                                isOpen={isEnhancedContextOpen}\n                                setOpen={onEnhancedContextTogglerClick}\n                                presentationMode={userInfo.isDotComUser ? 'consumer' : 'enterprise'}\n                                isNewInstall={isNewInstall}\n                            />\n                        </div>\n                    </div>\n                    <SubmitButton\n                        type={\n                            messageBeingEdited === undefined\n                                ? enableNewChatMode\n                                    ? 'user-newchat'\n                                    : 'user'\n                                : 'edit'\n                        }\n                        className={styles.submitButton}\n                        onClick={onChatSubmit}\n                        disabled={isEmptyEditorValue && !messageInProgress}\n                        onAbortMessageInProgress={\n                            messageInProgress ? onAbortMessageInProgress : undefined\n                        }\n                    />\n                </div>\n            </form>\n        </div>\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/command-menu.test.ts:20-35"",""content"":""\n    // Submit a chat question via command menu using \""New Chat\"" option in Command Menu\n    await page.getByRole('button', { name: /Commands \\(.*/ }).dblclick()\n    const commandInputBox = page.getByPlaceholder(/Search for a command or enter/)\n    await expect(commandInputBox).toBeVisible()\n    await commandInputBox.fill('new chat submitted from command menu')\n    // this will fail if more than 1 New Chat item in the menu is found\n    await page.getByLabel('comment  New Chat, Start a new chat', { exact: true }).hover()\n    await expect(page.getByLabel('comment  New Chat, Start a new chat', { exact: true })).toBeVisible()\n    await page.getByLabel('wand  Edit Code, Start a code edit', { exact: true }).hover()\n    await expect(page.getByLabel('wand  Edit Code, Start a code edit', { exact: true })).toBeVisible()\n    await page.getByLabel('Start a new chat').locator('a').click()\n\n    // the question should show up in the chat panel on submit\n    const chatPanel = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:56-80"",""content"":""\n    private options: ChatPanelProviderOptions\n\n    // Tree view for chat history\n    public treeViewProvider = new TreeViewProvider('chat', featureFlagProvider)\n    public treeView\n\n    public supportTreeViewProvider = new TreeViewProvider('support', featureFlagProvider)\n\n    // We keep track of the currently authenticated account and dispose open chats when it changes\n    private currentAuthAccount: undefined | { endpoint: string; primaryEmail: string; username: string }\n\n    protected disposables: vscode.Disposable[] = []\n\n    constructor(\n        { extensionUri, ...options }: SidebarViewOptions,\n        private chatClient: ChatClient,\n        private readonly localEmbeddings: LocalEmbeddingsController | null,\n        private readonly contextRanking: ContextRankingController | null,\n        private readonly symf: SymfRunner | null,\n        private readonly enterpriseContext: EnterpriseContextFactory | null,\n        private readonly guardrails: Guardrails\n    ) {\n        logDebug('ChatPanelsManager:constructor', 'init')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:238-257"",""content"":""    private async passthroughVsCodeOpen(...args: unknown[]): Promise<void> {\n        if (args[1] && (args[1] as any).viewColumn === vscode.ViewColumn.Beside) {\n            // Make vscode.ViewColumn.Beside work as expected from a webview: open it to the side,\n            // instead of always opening a new editor to the right.\n            //\n            // If the active editor is undefined, that means the chat panel is the active editor, so\n            // we will open the file in the first visible editor instead.\n            const textEditor = vscode.window.activeTextEditor || vscode.window.visibleTextEditors[0]\n            ;(args[1] as any).viewColumn = textEditor ? textEditor.viewColumn : vscode.ViewColumn.Beside\n        }\n        if (args[1] && Array.isArray((args[1] as any).selection)) {\n            // Fix a weird issue where the selection was getting encoded as a JSON array, not an\n            // object.\n            ;(args[1] as any).selection = new vscode.Selection(\n                (args[1] as any).selection[0],\n                (args[1] as any).selection[1]\n            )\n        }\n        await vscode.commands.executeCommand('vscode.open', ...args)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287"",""content"":""\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the “Chats” panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the “Chats” panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the “Chats” panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \""Enhanced Context\"" icon next to the chat input.\n- [ ] Verify that \""Enhanced Context\"" is enabled by default.\n\n### Consumer\n\nSet up steps:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:266-276"",""content"":""    private async createNewWebviewPanel(): Promise<ChatSession | undefined> {\n        const debounceCreatePanel = debounce(() => this.chatPanelsManager.createWebviewPanel(), 250, {\n            leading: true,\n            trailing: true,\n        })\n\n        if (this.chatPanelsManager) {\n            return debounceCreatePanel()\n        }\n        return undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:138-165"",""content"":""        // Check if any existing panel is available\n        // NOTE: Never reuse webviews when running inside the agent.\n        if (this.activePanelProvider && !this.options.config.isRunningInsideAgent) {\n            return this.activePanelProvider\n        }\n\n        const provider = await this.createWebviewPanel()\n        return provider\n    }\n\n    /**\n     * Creates a new webview panel for chat.\n     */\n    public async createWebviewPanel(\n        chatID?: string,\n        chatQuestion?: string,\n        panel?: vscode.WebviewPanel\n    ): Promise<SimpleChatPanelProvider> {\n        if (chatID && this.panelProviders.map(p => p.sessionID).includes(chatID)) {\n            const provider = this.panelProviders.find(p => p.sessionID === chatID)\n            if (provider?.webviewPanel) {\n                provider.webviewPanel?.reveal()\n                this.activePanelProvider = provider\n                void this.selectTreeItem(chatID)\n                return provider\n            }\n        }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:124-127"",""content"":""    public async getNewChatPanel(): Promise<SimpleChatPanelProvider> {\n        const provider = await this.createWebviewPanel()\n        return provider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:89-117"",""content"":""                // Ctrl/Cmd + K: edits the last human message\n                if (event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onEditLastMessageClick()\n                    return\n                }\n\n                // Ctrl/Cmd + /: starts a new chat\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick()\n                    return\n                }\n            }\n        }\n        document.addEventListener('keydown', onKeyDown)\n    }, [onEditLastMessageClick, onChatResetClick, isMac])\n\n    useEffect(() => {\n        // Focus on the Edit button after a question has been submitted\n        // This allows users to edit the message they just submitted right away\n        if (!isEditing && isMessageInProgress) {\n            setInputFocus(false)\n            buttonRef?.current?.focus()\n        }\n        // Remove focus on the Edit button when stream ends\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1254-1272"",""content"":""function newChatModelFromSerializedChatTranscript(\n    json: SerializedChatTranscript,\n    modelID: string\n): SimpleChatModel {\n    return new SimpleChatModel(\n        json.chatModel || modelID,\n        json.interactions.flatMap((interaction: SerializedChatInteraction): ChatMessage[] =>\n            [\n                PromptString.unsafe_deserializeChatMessage(interaction.humanMessage),\n                interaction.assistantMessage\n                    ? PromptString.unsafe_deserializeChatMessage(interaction.assistantMessage)\n                    : null,\n            ].filter(isDefined)\n        ),\n        json.id,\n        json.chatTitle,\n        json.enhancedContext?.selectedRepos\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/llm-providers/groq/index.ts:24-52"",""content"":"" */\ninterface GroqChatMessage extends OpenAIMessage {\n    name?: string\n    seed?: number\n}\n\n/**\n * Default context window sizes for various Groq models.\n *\n * @see https://console.groq.com/docs/models\n */\nexport const GROQ_DEFAULT_CONTEXT_WINDOW = {\n    mixtral: 32768,\n    llama2: 4096,\n    gemma: 8192,\n}\n\n/**\n * Represents the response from the Groq Chat Completion API.\n *\n * @property {string} model - The model used for the completion.\n * @property {GroqCompletionsError} [error] - Any error that occurred during the completion.\n * @property {Object[]} [choices] - The completion choices returned by the API.\n * @property {string} [choices[].finish_reason] - The reason the completion finished.\n * @property {string|null} [choices[].logprobs] - The log probabilities of the tokens in the completion.\n * @property {GroqChatMessage} [choices[].message] - The completion message.\n * @property {boolean} done - Indicates whether the completion is done.\n * @property {GroqCompletionsResponseUsage} [usage] - Usage information for the completion.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.test.ts:0-128"",""content"":""import { describe, expect, it } from 'vitest'\nimport { URI } from 'vscode-uri'\n\nimport { convertFileUriToTestFileUri, createDefaultTestFile } from './new-test-file'\n\ndescribe('createDefaultTestFile', () => {\n    it.each([\n        ['/path/to/file.java', '/path/to/fileTest.java'],\n        ['/path/to/file.js', '/path/to/file.test.js'],\n        ['/path/to/file.go', '/path/to/file_test.go'],\n        ['/path/to/test_file.py', '/path/to/test_file.py'],\n        ['/path/to/test-file.js', '/path/to/test-file.test.js'],\n        ['/path/to/node_modules/file.js', '/path/to/node_modules/file.test.js'],\n        ['/path/to/node_modules/file_test.ts', '/path/to/node_modules/file_test.ts'],\n        ['/path/to/fileTest.js', '/path/to/fileTest.js'],\n        ['test_example.py', 'test_example.py'],\n        ['example.cpp', 'exampleTest.cpp'],\n        ['example.test.js', 'example.test.js'],\n        ['Example.java', 'ExampleTest.java'],\n        ['ExampleTest.java', 'ExampleTest.java'],\n        ['example.rb', 'example_spec.rb'],\n        ['Example.cs', 'ExampleTest.cs'],\n        ['ExampleTest.php', 'ExampleTest.php'],\n        ['ExampleSpec.scala', 'ExampleSpec.scala'],\n        ['file.rb', 'file_spec.rb'],\n        ['contest.ts', 'contest.test.ts'],\n    ])('for file %j it returns %j', (file, test) => {\n        expect(createDefaultTestFile(URI.file(file)).toString()).toBe(URI.file(test).toString())\n    })\n})\n\ndescribe('convertFileUriToTestFileUri', () => {\n    it('should return the current file uri if it is already a test file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.test.ts')).toString()).toBe(\n            URI.file('/path/to/testFile.test.ts').toString()\n        )\n    })\n\n    it('should return the current file uri if it is already a spec file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.spec.rb')).toString()).toBe(\n            URI.file('/path/to/testFile.spec.rb').toString()\n        )\n    })\n\n    it('should generate a test file uri from a non-test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate the default spec file uri from a non-test file uri for ruby', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.rb'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_spec.rb').toString())\n    })\n\n    it('should follow an existing test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/existingTestFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should respect test file with different naming conventions', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should handle a non-alphanumeric character at the test character index', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/test-ExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.py'),\n                URI.file('/path/to/testFile_test.py')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_test.py').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python when no existing test path provided', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/test-file.py')).toString()).toBe(\n            URI.file('/path/to/test-file_test.py').toString()\n        )\n    })\n\n    it('should generate the default spec file uri for ruby when no existing test files is found', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/file.rb'), undefined).toString()).toBe(\n            URI.file('/path/to/file_spec.rb').toString()\n        )\n    })\n\n    it('should generate the corrent test file uri for window files', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\path\\\\to\\\\file.ts'),\n                URI.file('\\\\path\\\\to\\\\testFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('\\\\path\\\\to\\\\file.test.ts').toString())\n    })\n\n    it('should follow an existing test file uri format to generate new test file uri on windows', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\server\\\\c$\\\\folder\\\\current-file.go'),\n                URI.file('\\\\path\\\\to\\\\file_test.go')\n            ).toString()\n        ).toBe(URI.file('\\\\server\\\\c$\\\\folder\\\\current-file_test.go').toString())\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.ts:0-94"",""content"":""import { type URI, Utils } from 'vscode-uri'\n\nimport { uriBasename, uriExtname, uriParseNameAndExtension } from '@sourcegraph/cody-shared'\n\nimport { isValidTestFile } from './test-commands'\n\n// Language extension that uses '.test' suffix for test files\nconst TEST_FILE_DOT_SUFFIX_EXTENSIONS = new Set(['js', 'ts', 'jsx', 'tsx'])\n// language extension that uses '_test' suffix for test files\nconst TEST_FILE_DASH_SUFFIX_EXTENSIONS = new Set(['py', 'go'])\n// language extension that uses '_spec' suffix for most unit test files\nconst TEST_FILE_SPEC_SUFFIX_EXTENSIONS = new Set(['rb'])\n\n/**\n * NOTE: This is only being used as fallback when test files cannot be found in current workspace\n *\n * Generates a generic test file name and path for the given file\n * based on conventions for the file extension.\n * @param file - The original file URI\n * @returns The generated test file URI\n */\nexport function createDefaultTestFile(file: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(file)) {\n        return file\n    }\n\n    const extWithDot = uriExtname(file)\n    const fileName = uriBasename(file, extWithDot)\n    const ext = extWithDot.slice(1)\n\n    let testFileName = `${fileName}Test.${ext}`\n    if (TEST_FILE_DOT_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}.test.${ext}`\n    }\n    if (TEST_FILE_DASH_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_test.${ext}`\n    }\n    if (TEST_FILE_SPEC_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_spec.${ext}`\n    }\n\n    return Utils.joinPath(file, '..', testFileName)\n}\n\n/**\n * Converts a file URI to a corresponding test file URI using conventions based on file extension.\n *\n * If not a test file, generates a default test file name based on file extension conventions.\n *\n * If existing test file URI provided, attempts to match its naming convention.\n * Falls back to default test file name if naming does not follow conventions.\n * @param currentFile - Original file to convert\n * @param testFile - Optional existing test file to match naming with\n * @returns The converted test file\n */\nexport function convertFileUriToTestFileUri(currentFile: URI, testFile?: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(currentFile)) {\n        return currentFile\n    }\n\n    // If there is an existing test file, create the test file following its naming convention\n    if (testFile?.path && isValidTestFile(testFile)) {\n        const parsedCurrentFile = uriParseNameAndExtension(currentFile)\n        const parsedTestFile = uriParseNameAndExtension(testFile)\n        if (parsedCurrentFile.ext === parsedTestFile.ext) {\n            const testFileName = parsedTestFile.name\n            const index = testFileName.lastIndexOf('test') || testFileName.lastIndexOf('spec')\n            const endsWithCapitalTest = testFileName.endsWith('Test') || testFileName.endsWith('Spec')\n            // This checks if the existing test file has a non-alphanumeric character at the test character index\n            // e.g. \""_test\"", \"".test\"", \""test_\""\n            // This is because files with 'test' in the name are not always a test file, while\n            // file with non-alphanumeric character before 'test' are more likely to be test files\n            // e.g. \""testPath\"" or \""test-helper\"" are not likely test files\n            const hasVerifiedTestPath = index > -1 && !/^[\\da-z]$/i.test(testFileName[index - 1])\n            // If yes, generate a test file by replacing existing test file name with current file name\n            if (endsWithCapitalTest || hasVerifiedTestPath) {\n                // Remove everything after the test character index from the existing test file name\n                // then replace it with the current file name\n                // e.g. \""current_file\"" & \""existing_test\"" => \""current_file_test\""\n                const strippedTestFileName = testFileName.slice(0, index - 1)\n                const newTestFileName = testFileName.replace(\n                    strippedTestFileName,\n                    parsedCurrentFile.name\n                )\n                return Utils.joinPath(currentFile, '..', `${newTestFileName}${parsedCurrentFile.ext}`)\n            }\n        }\n    }\n\n    // else, generate a generic test file\n    return createDefaultTestFile(currentFile)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-input.test.ts:76-94"",""content"":""\n    // Submit a new chat question from the command menu.\n    await page.getByLabel(/Commands \\(/).hover()\n    await page.getByLabel(/Commands \\(/).click()\n    await page.waitForTimeout(100)\n    // HACK: The 'delay' command is used to make sure the response is streamed 400ms after\n    // the command is sent. This provides us with a small window to move the cursor\n    // from the new opened chat window back to the editor, before the chat has finished\n    // streaming its response.\n    await chatInput.fill('delay')\n    await chatInput.press('Enter')\n    await expect(chatInput).toBeFocused()\n\n    // Ensure equal-width columns so we can be sure the code we're about to click is in view (and is\n    // not out of the editor's scroll viewport). This became required due to new (undocumented)\n    // behavior in VS Code 1.88.0 where the Cody panel would take up ~80% of the width when it was\n    // focused, meaning that the buzz.ts editor tab would take up ~20% and the text we intend to\n    // click would be only partially visible, making the click() call fail.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/chat/chat.ts:25-59"",""content"":""    public chat(\n        messages: Message[],\n        params: Partial<ChatParameters> & Pick<ChatParameters, 'maxTokensToSample'>,\n        abortSignal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        const authStatus = this.getAuthStatus()\n        const useApiV1 = authStatus.codyApiVersion >= 1 && params.model?.includes('claude-3')\n        const isLastMessageFromHuman = messages.length > 0 && messages.at(-1)!.speaker === 'human'\n\n        const augmentedMessages =\n            params?.model?.startsWith('fireworks/') || useApiV1\n                ? sanitizeMessages(messages)\n                : isLastMessageFromHuman\n                  ? messages.concat([{ speaker: 'assistant' }])\n                  : messages\n\n        // We only want to send up the speaker and prompt text, regardless of whatever other fields\n        // might be on the messages objects (`file`, `displayText`, `contextFiles`, etc.).\n        const messagesToSend = augmentedMessages.map(({ speaker, text }) => ({\n            text,\n            speaker,\n        }))\n\n        const completionParams = {\n            ...DEFAULT_CHAT_COMPLETION_PARAMETERS,\n            ...params,\n            messages: messagesToSend,\n        }\n\n        return this.completions.stream(\n            completionParams,\n            useApiV1 ? authStatus.codyApiVersion : 0,\n            abortSignal\n        )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:165-184"",""content"":""\n        // Reuse existing \""New Chat\"" panel if there is an empty one\n        const emptyNewChatProvider = this.panelProviders.find(p => p.webviewPanel?.title === 'New Chat')\n        if (\n            !this.options.config.isRunningInsideAgent && // Don't reuse panels in the agent\n            !chatID &&\n            !panel &&\n            this.panelProviders.length &&\n            emptyNewChatProvider\n        ) {\n            emptyNewChatProvider.webviewPanel?.reveal()\n            this.activePanelProvider = emptyNewChatProvider\n            this.options.contextProvider.webview = emptyNewChatProvider.webview\n            void this.selectTreeItem(emptyNewChatProvider.sessionID)\n            return emptyNewChatProvider\n        }\n\n        // Get the view column of the current active chat panel so that we can open a new one on top of it\n        const activePanelViewColumn = this.activePanelProvider?.webviewPanel?.viewColumn\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:798-813"",""content"":""### Fixed\n\n- Edit: Updated the fixup create task to just use the previous command text. [pull/1615](https://github.com/sourcegraph/cody/pull/1615)\n- Fixed an issue that would cause an aborted chat message to show an error \""Cody did not respond with any text\"". [pull/1668](https://github.com/sourcegraph/cody/pull/1668)\n- Chat: Opening files from the new chat panel will now show up beside the chat panel instead of on top of the chat panel. [pull/1677](https://github.com/sourcegraph/cody/pull/1677)\n- Chat: Prevented default events on certain key combos when chat box is focused. [pull/1690](https://github.com/sourcegraph/cody/pull/1690)\n- Command: Fixed an issue that opened a new chat window when running `/doc` and `/edit` commands from the command palette. [pull/1678](https://github.com/sourcegraph/cody/pull/1678)\n- Chat: Prevent sidebar from opening when switching editor chat panels. [pull/1691](https://github.com/sourcegraph/cody/pull/1691)\n- Chat: Prevent `\""command 'cody.chat'panel.new' not found\""` error when the new chat panel UI is disabled. [pull/1696](https://github.com/sourcegraph/cody/pull/1696)\n- Autocomplete: Improved the multiline completions truncation logic. [pull/1709](https://github.com/sourcegraph/cody/pull/1709)\n- Autocomplete: Fix an issue where typing as suggested causes the completion to behave unexpectedly. [pull/1701](https://github.com/sourcegraph/cody/pull/1701)\n- Chat: Forbid style tags in DOMPurify config to prevent code block rendering issues. [pull/1747](https://github.com/sourcegraph/cody/pull/1747)\n- Edit: Fix `selectedCode` and `problemCode` sometimes being added to the document after an edit. [pull/1765](https://github.com/sourcegraph/cody/pull/1765)\n- Edit: Fix the code lens containing options to diff, undo and retry being automatically dismissed for users who have `autoSave` enabled. [pull/1767](https://github.com/sourcegraph/cody/pull/1767)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:48-73"",""content"":""\n    // Submit a new message and check if both sessions are showing up in the sidebar\n    await chatInput.fill('Hola')\n    await chatInput.press('Enter')\n    await expect(holaTreeItem).toBeVisible()\n    await expect(heyTreeItem).toBeVisible()\n\n    // The panel name is now updated to the last submitted message\n    await expect(page.getByRole('tab', { name: 'Hola' })).toBeVisible()\n\n    // Click on the previous chat session to open the chat panel in editor\n    // Both chat panels should be visible as tabs in the editor\n    await page\n        .getByRole('treeitem', { name: 'Hey' })\n        .locator('div')\n        .filter({ hasText: 'Hey' })\n        .nth(3)\n        .click()\n    await expect(page.getByRole('tab', { name: 'Hey' })).toBeVisible()\n\n    // NOTE: Action buttons may only appear when we're hovering a chat.\n    // Deleting a chat should also close its associated chat panel\n    await heyTreeItem.hover()\n    await heyTreeItem.getByLabel('Delete Chat').hover()\n    await heyTreeItem.getByLabel('Delete Chat').click()\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-flash-latest,chat,question_025/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The logic for adding context by mentioning files with ""@"" is spread across several files, but the core functionality is in the following:

1. **`cody_test/lib/shared/src/mentions/query.ts`:** This file defines the `MentionQuery` interface and the `parseMentionQuery` function. This function parses the user's input after the ""@"" symbol to determine the type of context item being requested (file, symbol, etc.) and the text to search for.

2. **`cody_test/vscode/src/editor/utils/editor-context.ts`:** This file contains the `getFileContextFiles` function, which is responsible for searching for files based on the user's query. It uses the `fuzzysort` library for fuzzy matching and returns a list of `ContextItemFile` objects.

3. **`cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts`:** This file defines the `ContextItemMentionNode` class, which represents a mention of a context item in the prompt editor. The `exportDOM` method of this class generates the HTML for the mention, including a link that opens the mentioned file in the editor.

4. **`cody_test/vscode/src/commands/context/file-path.ts`:** This file contains the `getContextFileFromUri` function, which is used to create a `ContextItem` object from a given URI. This function is called by the `ContextItemMentionNode` class to create the context item for the mentioned file.

5. **`cody_test/vscode/src/commands/context/current-file.ts`:** This file contains the `getContextFileFromCurrentFile` function, which is used to create a `ContextItem` object from the currently open file. This function is called when the user wants to add the current file as context.

6. **`cody_test/vscode/src/commands/context/open-tabs.ts`:** This file contains the `getContextFileFromTabs` function, which is used to create `ContextItem` objects from all the currently open tabs. This function is called when the user wants to add all open tabs as context.

7. **`cody_test/vscode/src/commands/context/unit-test-file.ts`:** This file contains the `getContextFilesForUnitTestCommand` function, which is used to create `ContextItem` objects for unit test files related to the current file. This function is called when the user wants to add unit test files as context.

These files work together to provide the functionality for adding context by mentioning files with ""@"" in the chat input. The user's input is parsed, files are searched for, and the results are displayed in the chat input and added to the context list.",Where is the logic for adding context by mentioning files with @?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:108-123"",""content"":""- [ ] Verify that Cody adds documentation above the function that contains your cursor.\n\n### Smell\n\n- [ ] Verify that the option to run the `Find Code Smells` command is available in the following locations:\n  - [ ] Sidebar `Find Code Smells`\n  - [ ] Context (right-click) menu `Cody > Find Code Smells`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Find Code Smells`\n  - [ ] Cody Command Menu (option+c, `Find Code Smells`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Find Code Smells` command.\n- [ ] Verify that Cody provides suggestion for how to improve the selected code in a new chat window.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Find Code Smells` command again\n- [ ] Verify that Cody provides suggestion for how to improve the function that contains your cursor in a new chat window.\n- [ ] Verify that the chat executed by running the command is added to the sidebar under `Chats`.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:175-188"",""content"":""export function contextItemMentionNodeDisplayText(contextItem: SerializedContextItem): string {\n    // A displayed range of `foo.txt:2-4` means \""include all of lines 2, 3, and 4\"", which means the\n    // range needs to go to the start (0th character) of line 5. Also, `RangeData` is 0-indexed but\n    // display ranges are 1-indexed.\n    const rangeText = contextItem.range ? `:${displayLineRange(contextItem.range)}` : ''\n    if (contextItem.type === 'file') {\n        return `@${displayPath(URI.parse(contextItem.uri))}${rangeText}`\n    }\n    if (contextItem.type === 'symbol') {\n        return `@${displayPath(URI.parse(contextItem.uri))}${rangeText}#${contextItem.symbolName}`\n    }\n    // @ts-ignore\n    throw new Error(`unrecognized context item type ${contextItem.type}`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItem.kt:22-53"",""content"":""\ndata class ContextItemFile(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: file\n) : ContextItem() {\n\n  enum class TypeEnum {\n    @SerializedName(\""file\"") File,\n  }\n}\n\ndata class ContextItemSymbol(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: symbol\n  val symbolName: String? = null,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-atFile.test.ts:352-373"",""content"":""\n    // @-file with the correct line range shows up in the chat view and it opens on click\n    const contextCell = getContextCell(chatPanelFrame)\n    await expectContextCellCounts(contextCell, { files: 1 })\n    await contextCell.hover()\n    await contextCell.click()\n    const chatContext = chatPanelFrame.locator('details').last()\n    await chatContext.getByRole('link', { name: 'buzz.ts:1-15' }).hover()\n    await chatContext.getByRole('link', { name: 'buzz.ts:1-15' }).click()\n    const previewTab = page.getByRole('tab', { name: /buzz.ts, preview, Editor Group/ })\n    await previewTab.hover()\n    await expect(previewTab).toBeVisible()\n})\n\ntest.extend<ExpectedEvents>({\n    expectedEvents: [\n        'CodyVSCodeExtension:addChatContext:clicked',\n        'CodyVSCodeExtension:addChatContext:clicked',\n    ],\n})('add selected code as @-mention with \""Cody Chat: Add context\""', async ({ page, sidebar }) => {\n    await sidebarSignin(page, sidebar)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:59-73"",""content"":""function convertContextItemMentionElement(domNode: HTMLElement): DOMConversionOutput | null {\n    const data = domNode.getAttribute(DOM_DATA_ATTR)\n    if (data !== null) {\n        try {\n            const contextItem: SerializedContextItem = JSON.parse(data)\n            const node = $createContextItemMentionNode(contextItem)\n            return { node }\n        } catch (error) {\n            console.error(error)\n            return null\n        }\n    }\n\n    return null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/open-tabs.ts:0-42"",""content"":""import { type ContextItem, logError, wrapInActiveSpan } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { getContextFileFromUri } from './file-path'\n\n/**\n * Gets context files from the currently open tabs.\n *\n * Iterates through all open tabs, filters to only file tabs in the workspace,\n * and then creates ContextFile objects for each valid tab.\n */\nexport async function getContextFileFromTabs(): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.openTabs', async span => {\n        const contextFiles: ContextItem[] = []\n        try {\n            // Get open tabs from the current editor\n            const tabGroups = vscode.window.tabGroups.all\n            const openTabs = tabGroups.flatMap(group =>\n                group.tabs.map(tab => tab.input)\n            ) as vscode.TabInputText[]\n\n            for (const tab of openTabs) {\n                // Skip non-file items\n                if (tab?.uri?.scheme !== 'file') {\n                    continue\n                }\n\n                // Skip files that are not from the current workspace\n                if (!vscode.workspace.getWorkspaceFolder(tab?.uri)) {\n                    continue\n                }\n\n                // Create context message\n                contextFiles.push(...(await getContextFileFromUri(tab?.uri)))\n            }\n        } catch (error) {\n            logError('getContextFileFromTabs', 'failed', { verbose: error })\n        }\n        // Returns what we have so far\n        return contextFiles\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:190-199"",""content"":""export function $createContextItemMentionNode(\n    contextItem: ContextItem | SerializedContextItem\n): ContextItemMentionNode {\n    const node = new ContextItemMentionNode(contextItem)\n    node.setMode('token').toggleDirectionless()\n    contextItem.type === 'file' &&\n        contextItem.isTooLarge &&\n        node.setStyle('color: var(--vscode-list-errorForeground)')\n    return $applyNodeReplacement(node)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:60-86"",""content"":""    // Shell command to run to get context\n    command?: string\n    // The relative path of a file within your workspace root\n    filePath?: string\n    // The relative path of a directory within your workspace root\n    directoryPath?: string\n\n    // NOTE: Currently not supported\n    // Codebase context from current codebase\n    codebase?: boolean\n}\n\nexport type CodyCommandType = CustomCommandType | DefaultCommandType | 'recently used'\n\nexport enum CustomCommandType {\n    Workspace = 'workspace',\n    User = 'user',\n}\n\ntype DefaultCommandType = 'default' | 'experimental'\n\nexport interface TerminalOutputArguments {\n    name: string\n    selection?: string\n    creationOptions?: { shellPath?: string; shellArgs?: string[] }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:145-170"",""content"":""    // from).\n    const uriPath =\n        isWindows && uri.scheme === 'file'\n            ? uri.path.slice(0, 2).toUpperCase() + uri.path.slice(2)\n            : uri.path\n    const prefixPath =\n        isWindows && prefix.scheme === 'file'\n            ? prefix.path.slice(0, 2).toUpperCase() + prefix.path.slice(2)\n            : prefix.path\n    return (\n        uri.scheme === prefix.scheme &&\n        (uri.authority ?? '') === (prefix.authority ?? '') && // different URI impls treat empty different\n        (uriPath === prefixPath ||\n            uriPath.startsWith(prefixPath.endsWith('/') ? prefixPath : `${prefixPath}/`) ||\n            (prefixPath.endsWith('/') && uriPath === prefixPath.slice(0, -1)))\n    )\n}\n\n/** The information necessary for {@link displayPath} to compute a display path. */\nexport interface DisplayPathEnvInfo {\n    workspaceFolders: URI[]\n    isWindows: boolean\n}\n\nlet envInfo: DisplayPathEnvInfo | null = null\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/unit-test-file.ts:18-51"",""content"":""export async function getContextFilesForUnitTestCommand(file: URI): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.test', async span => {\n        const contextFiles: ContextItem[] = []\n\n        // exclude any files in the path with e2e, integration, node_modules, or dist\n        const excludePattern = '**/*{e2e,integration,node_modules,dist}*/**'\n        // To search for files in the current directory only\n        const searchCurrentDirectoryOnly = true\n        // The max number of files to search for in each workspace search\n        const max = 10\n\n        // Search for a test file that has the same file name first\n        const sameNameTestPattern = getSearchPatternForTestFiles(file, !searchCurrentDirectoryOnly, true)\n        const testWithSameName = await getWorkspaceFilesContext(sameNameTestPattern, excludePattern, 1)\n\n        // Search for test files in the current directory\n        const currentDirPattern = getSearchPatternForTestFiles(file, searchCurrentDirectoryOnly)\n        const currentDirContext = await getWorkspaceFilesContext(currentDirPattern, excludePattern, max)\n\n        contextFiles.push(...testWithSameName, ...currentDirContext)\n\n        // If no test files found in the current directory, search the entire workspace\n        if (!contextFiles.length) {\n            // Will try to look for half the max number of files in the workspace for faster results\n            const wsTestPattern = getSearchPatternForTestFiles(file, !searchCurrentDirectoryOnly)\n            const codebaseFiles = await getWorkspaceFilesContext(wsTestPattern, excludePattern, max / 2)\n\n            contextFiles.push(...codebaseFiles)\n        }\n\n        // Return valid test files only\n        return contextFiles.filter(f => isValidTestFile(f.uri))\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-atFile.test.md:0-20"",""content"":""# Expected behaviors for the @-mention feature\n\nCurrently covered by the e2e tests in `chat-atFile.test.ts`:\n\n- Typing '@' in the chat input shows a search box for files. Typing '@#' shows one for symbols instead.\n- Searching for a non-existent file or symbol shows a \""No files/symbols found\"" message.\n- Search only matches files in the relative visible path, not full absolute paths.\n- Search includes dotfiles after \"".\"".\n- Searches match with either forward or backslashes.\n- Can click a file result fom the box to insert it into the chat input.\n- Inserted file context persists when resending a message from history.\n- Can use the Up and Down arrow keys to navigate through suggested file results.\n- Can use the ESC key to close the file selector without modifying the input text.\n- Pressing tab after a full filename inserts the @-mention with a trailing space.\n- Pressing tab after a partial filename completes to an existing @-mention.\n- Can @-mention files mid-sentence.\n- Don't show the file selector on @-queries that ends with non-alphanumeric char (e.g. @foo/bar?) without results.\n- Input box is cleared on submit, with @-mentions removed and selector closed.\n- Explicitly @-mentioned files show up in the file context list below the message.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:77-173"",""content"":""export class ContextItemMentionNode extends TextNode {\n    static getType(): string {\n        return 'contextItemMention'\n    }\n\n    static clone(node: ContextItemMentionNode): ContextItemMentionNode {\n        return new ContextItemMentionNode(node.contextItem, node.__text, node.__key)\n    }\n    static importJSON(serializedNode: SerializedContextItemMentionNode): ContextItemMentionNode {\n        const node = $createContextItemMentionNode(serializedNode.contextItem)\n        node.setTextContent(serializedNode.text)\n        node.setFormat(serializedNode.format)\n        node.setDetail(serializedNode.detail)\n        node.setMode(serializedNode.mode)\n        node.setStyle(serializedNode.style)\n        return node\n    }\n\n    private contextItem: SerializedContextItem\n\n    constructor(\n        contextItemWithAllFields: ContextItem | SerializedContextItem,\n        text?: string,\n        key?: NodeKey\n    ) {\n        // Make sure we only bring over the fields on the context item that we need, or else we\n        // could accidentally include tons of data (including the entire contents of files).\n        const contextItem = serializeContextItem(contextItemWithAllFields)\n\n        super(text ?? contextItemMentionNodeDisplayText(contextItem), key)\n\n        this.contextItem = contextItem\n    }\n\n    exportJSON(): SerializedContextItemMentionNode {\n        return {\n            ...super.exportJSON(),\n            contextItem: this.contextItem,\n            type: ContextItemMentionNode.getType(),\n            version: 1,\n        }\n    }\n\n    private static CLASS_NAMES = `context-item-mention-node ${styles.contextItemMentionNode}`\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config)\n        element.className = ContextItemMentionNode.CLASS_NAMES\n        return element\n    }\n\n    exportDOM(): DOMExportOutput {\n        const element = document.createElement('span')\n        element.setAttribute(DOM_DATA_ATTR, JSON.stringify(this.contextItem))\n        element.className = ContextItemMentionNode.CLASS_NAMES\n\n        const link = document.createElement('a')\n        const { href, target } = webviewOpenURIForContextItem({\n            uri: URI.parse(this.contextItem.uri),\n            range: this.contextItem.range,\n        })\n        link.href = href\n        if (target) {\n            link.target = target\n        }\n        link.textContent = this.__text\n        element.appendChild(link)\n\n        return { element }\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            span: (domNode: HTMLElement) => {\n                if (!domNode.hasAttribute(DOM_DATA_ATTR)) {\n                    return null\n                }\n                return {\n                    conversion: convertContextItemMentionElement,\n                    priority: 1,\n                }\n            },\n        }\n    }\n\n    isTextEntity(): true {\n        return true\n    }\n\n    canInsertTextBefore(): boolean {\n        return false\n    }\n\n    canInsertTextAfter(): boolean {\n        return false\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/query.ts:64-94"",""content"":""\n/**\n * The location and content of a mention in free-form user text input.\n */\nexport interface MentionTrigger {\n    /** The number of characters from the start of the text to the mention trigger (`@`). */\n    leadOffset: number\n\n    /**\n     * The string that is used to query for the context item to mention (to be passed to\n     * {@link parseMentionQuery}).\n     */\n    matchingString: string\n\n    /**\n     * Equal to `@` + {@link matchingString}. The entire string that should be replaced with the\n     * context item when the at-mention reference is chosen.\n     */\n    replaceableString: string\n}\n\n/**\n * Scans free-form user text input (in a chat message editor, for example) for possible mentions\n * with the `@` trigger character.\n *\n * The {@link textBeforeCursor} is all of the text in the input field before the text insertion\n * point cursor. For example, if the input field looks like `hello\n * @foo█bar`, then {@link textBeforeCursor} should be `hello @foo`.\n */\nexport function scanForMentionTriggerInUserTextInput(textBeforeCursor: string): MentionTrigger | null {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/cody-ignore.test.ts:46-69"",""content"":""\n    // Start new chat\n    const [chatPanel, chatInput] = await createEmptyChatPanel(page)\n\n    /* TEST: Chat Context - Ignored file do not show up with context */\n    await chatInput.focus()\n    await chatInput.fill('Ignore me')\n    await chatInput.press('Enter')\n    // Assistant should response to your chat question,\n    // but the current file is excluded (ignoredByCody.css) and not on the context list\n    await expect(chatPanel.getByText('hello from the assistant')).toBeVisible()\n    const contextCell = getContextCell(chatPanel)\n    await expect(contextCell).not.toBeVisible()\n\n    /* TEST: At-file - Ignored file does not show up as context when using @-mention */\n    await chatInput.focus()\n    await chatInput.clear()\n    await chatInput.fill('@ignoredByCody')\n    await expect(chatPanel.getByRole('heading', { name: 'No files found' })).toBeVisible()\n    await chatInput.clear()\n    await chatInput.fill('@ignore')\n    await expect(\n        chatPanel.getByRole('option', { name: withPlatformSlashes('ignore .cody') })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/utils/editor-context.ts:49-112"",""content"":""export async function getFileContextFiles(\n    query: string,\n    maxResults: number\n): Promise<ContextItemFile[]> {\n    if (!query.trim()) {\n        return []\n    }\n\n    const uris = await throttledFindFiles()\n    if (!uris) {\n        return []\n    }\n\n    if (isWindows()) {\n        // On Windows, if the user has typed forward slashes, map them to backslashes before\n        // running the search so they match the real paths.\n        query = query.replaceAll('/', '\\\\')\n    }\n\n    // Add on the relative URIs for search, so we only search the visible part\n    // of the path and not the full FS path.\n    const urisWithRelative = uris.map(uri => ({ uri, relative: displayPath(uri) }))\n    const results = fuzzysort.go(query, urisWithRelative, {\n        key: 'relative',\n        limit: maxResults,\n        // We add a threshold for performance as per fuzzysort’s\n        // recommendations. Testing with sg/sg path strings, somewhere over 10k\n        // threshold is where it seems to return results that make no sense. VS\n        // Code’s own fuzzy finder seems to cap out much higher. To be safer and\n        // to account for longer paths from even deeper source trees we use\n        // 100k. We may want to revisit this number if we get reports of missing\n        // file results from very large repos.\n        threshold: -100000,\n    })\n\n    // Apply a penalty for segments that are in the low scoring list.\n    const adjustedResults = [...results].map(result => {\n        const segments = result.obj.uri.path.split(/[\\/\\\\]/).filter(segment => segment !== '')\n        for (const lowScoringPathSegment of lowScoringPathSegments) {\n            if (segments.includes(lowScoringPathSegment) && !query.includes(lowScoringPathSegment)) {\n                return {\n                    ...result,\n                    score: result.score - 100000,\n                }\n            }\n        }\n        return result\n    })\n    // fuzzysort can return results in different order for the same query if\n    // they have the same score :( So we do this hacky post-limit sorting (first\n    // by score, then by path) to ensure the order stays the same.\n    const sortedResults = adjustedResults\n        .sort((a, b) => {\n            return (\n                b.score - a.score ||\n                new Intl.Collator(undefined, { numeric: true }).compare(a.obj.uri.path, b.obj.uri.path)\n            )\n        })\n        .flatMap(result => createContextFileFromUri(result.obj.uri, ContextItemSource.User, 'file'))\n\n    // TODO(toolmantim): Add fuzzysort.highlight data to the result so we can show it in the UI\n\n    return await filterContextItemFiles(sortedResults)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/fixtures.ts:52-78"",""content"":""                        },\n                        {\n                            detail: 1,\n                            format: 0,\n                            mode: 'token',\n                            style: '',\n                            text: '@dir/dir/file-a-1.py',\n                            type: 'contextItemMention',\n                            version: 1,\n                            contextItem: {\n                                type: 'file',\n                                uri: 'file:///dir/dir/file-a-1.py',\n                            },\n                        },\n                        {\n                            detail: 0,\n                            format: 0,\n                            mode: 'normal',\n                            style: '',\n                            text: ' do? Also use ',\n                            type: 'text',\n                            version: 1,\n                        },\n                        {\n                            detail: 1,\n                            format: 0,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/file-path.ts:13-41"",""content"":""export async function getContextFileFromUri(file: URI, range?: vscode.Range): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.filePath', async span => {\n        try {\n            const doc = await vscode.workspace.openTextDocument(file)\n            const content = doc?.getText(range).trim()\n            if (!content) {\n                throw new Error('No file content')\n            }\n\n            const startLine = range?.start?.line ?? 0\n            range = new vscode.Range(startLine, 0, startLine + content.split('\\n').length, 0)\n            const size = TokenCounter.countTokens(content)\n\n            return [\n                {\n                    type: 'file',\n                    content,\n                    uri: file,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                },\n            ] satisfies ContextItem[]\n        } catch (error) {\n            logError('getContextFileFromUri', 'failed', { verbose: error })\n            return []\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/utils.ts:0-30"",""content"":""import { type ContextItem, displayLineRange, displayPath } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport {\n    QUICK_PICK_ITEM_CHECKED_PREFIX,\n    QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX,\n} from '../../chat/context/constants'\n\n/**\n * Removes the string after the last '@' character in the given string.\n * Returns the original string if '@' is not found.\n */\nexport function removeAfterLastAt(str: string): string {\n    const lastIndex = str.lastIndexOf('@')\n    if (lastIndex === -1) {\n        // Return the original string if \""@\"" is not found\n        return str\n    }\n    return str.slice(0, lastIndex)\n}\n\n/**\n * Returns a string representation of the given ContextItem for use in UI labels.\n * Includes the file path and an optional range or symbol specifier.\n */\nexport function getLabelForContextItem(item: ContextItem): string {\n    const isFileType = item.type === 'file'\n    if (isFileType && item.title) {\n        return `Add context from: ${item.title}`\n    }\n    const rangeLabel = item.range ? `:${displayLineRange(item.range)}` : ''\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/current-file.ts:10-48"",""content"":""export async function getContextFileFromCurrentFile(): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.file', async span => {\n        try {\n            const editor = getEditor()\n            const document = editor?.active?.document\n            if (!document) {\n                throw new Error('No active editor')\n            }\n\n            const selection = new vscode.Selection(\n                0,\n                0,\n                document.lineCount - 1,\n                document.lineAt(document.lineCount - 1).text.length\n            )\n\n            const content = document.getText(selection)\n            const size = TokenCounter.countTokens(content)\n\n            if (!content.trim()) {\n                throw new Error('No content')\n            }\n\n            return [\n                {\n                    type: 'file',\n                    uri: document.uri,\n                    content,\n                    source: ContextItemSource.Editor,\n                    range: selection,\n                    size,\n                } satisfies ContextItem,\n            ]\n        } catch (error) {\n            logError('getContextFileFromCurrentFile', 'failed', { verbose: error })\n            return []\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/query.ts:0-26"",""content"":""/**\n * The parsed representation of a user's (partial or complete) input of an @-mention query.\n */\nexport interface MentionQuery {\n    /**\n     * The type of context item to search for.\n     */\n    type: 'file' | 'symbol' | 'url' | 'empty'\n\n    /**\n     * The user's text input, to be interpreted as a fuzzy-matched query. It is stripped of any\n     * prefix characters that indicate the {@link MentionQuery.type}, such as `#` for symbols.\n     */\n    text: string\n}\n\n/**\n * Parse an @-mention query. The {@link query} value is whatever the UI determines is the query\n * based on the current text input; it is not the full value of a message that may or may not\n * contain an @-mention.\n *\n * The {@link query} MUST be stripped of the trigger character (usually `@`). The only valid case\n * where {@link query} may begin with `@` is if the user is searching for context items that contain\n * `@`, such as if the user typed `@@foo` to mention a file that is literally named `@foo.js`.\n */\nexport function parseMentionQuery(query: string): MentionQuery {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/create-context-file.ts:0-23"",""content"":""import { type ContextItem, ContextItemSource, TokenCounter } from '@sourcegraph/cody-shared'\n\nimport * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\nexport async function createContextFile(file: URI, content: string): Promise<ContextItem | undefined> {\n    try {\n        const range = new vscode.Range(0, 0, content.split('\\n').length, 0)\n        const size = TokenCounter.countTokens(content)\n\n        return {\n            type: 'file',\n            uri: file,\n            content,\n            source: ContextItemSource.Editor,\n            range,\n            size,\n        } satisfies ContextItem\n    } catch (error) {\n        console.error(error)\n    }\n    return undefined\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/unit-test-case.ts:8-47"",""content"":""export async function getContextFilesForAddingUnitTestCases(testFile: URI): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.testCase', async span => {\n        // Get the context from the current directory\n        // and then find the original file of the test file in the returned context\n        // If the original file is found, return it\n        // e.g. if the test file is src/foo/bar.spec.ts, look for src/foo/bar.ts\n        const directoryContext = await getContextFileFromDirectory()\n        const originalFileContext = directoryContext.find(f => isTestFileForOriginal(f.uri, testFile))\n        if (originalFileContext) {\n            return [originalFileContext]\n        }\n\n        // TODO (bee) improves context search\n        const contextFiles: ContextItem[] = []\n        // exclude any files in the path with e2e, integration, node_modules, or dist\n        const excludePattern = '**/*{e2e,integration,node_modules,dist}*/**'\n        // To search for files in the current directory only\n        const searchInCurrentDirectoryOnly = true\n        // The max number of files to search for in each workspace search\n        const max = 10\n\n        // Search for test files in the current directory first\n        const curerntDirPattern = getSearchPatternForTestFiles(testFile, searchInCurrentDirectoryOnly)\n        const currentDirContext = await getWorkspaceFilesContext(curerntDirPattern, excludePattern, max)\n\n        contextFiles.push(...currentDirContext)\n\n        // If no test files found in the current directory, search the entire workspace\n        if (!contextFiles.length) {\n            const wsTestPattern = getSearchPatternForTestFiles(testFile, !searchInCurrentDirectoryOnly)\n            // Will try to look for half the max number of files in the workspace for faster results\n            const codebaseFiles = await getWorkspaceFilesContext(wsTestPattern, excludePattern, max / 2)\n\n            contextFiles.push(...codebaseFiles)\n        }\n\n        // Return valid test files only\n        return contextFiles.filter(f => isValidTestFile(f.uri))\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/fixtures.ts:74-101"",""content"":""    explainCode2: [\n        {\n            speaker: 'human',\n            text: ps`What does @#Symbol1 in @dir/dir/file-a-1.py do? Also use @README.md:2-8.`,\n            editorState: FILE_MENTION_EDITOR_STATE_FIXTURE,\n            contextFiles: [\n                {\n                    type: 'symbol',\n                    uri: URI.file('dir/dir/file-a-1.py'),\n                    symbolName: 'Symbol1',\n                    kind: 'function',\n                    range: { start: { line: 1, character: 0 }, end: { line: 8, character: 0 } },\n                },\n                { type: 'file', uri: URI.file('dir/dir/file-a-1.py') },\n                {\n                    type: 'file',\n                    uri: URI.file('README.md'),\n                    range: { start: { line: 1, character: 0 }, end: { line: 8, character: 0 } },\n                },\n            ],\n        },\n        {\n            speaker: 'assistant',\n            text: ps`This code is very cool.`,\n        },\n    ],\n}\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_000/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Symf is used as a context source in several places within Cody:

1. In chat functionality, as evidenced by the `SymfRunner` being included in the `ChatPanelsManager.ts` file.

2. For enhanced context in chat, as seen in the `context.ts` file where `SymfRunner` is part of the providers for getting enhanced context.

3. In the local context retrieval, as shown by the `SymfRunner` class in `symf.ts`, which implements the `IndexedKeywordContextFetcher` interface.

4. For autocomplete context, as indicated by the `ContextStrategy` in `completion-provider-config.ts`, which includes options like 'bfg' and 'bfg-mixed' that likely involve symf.

5. In the context mixer for completions, as suggested by the `ContextStrategy` import in `context-mixer.ts`.

6. As an experimental feature that can be enabled via the `cody.experimental.symfContext` configuration option in `package.json`.

7. For local embeddings, as the `LocalEmbeddingsController` is often used alongside `SymfRunner` in various parts of the codebase.

The symf functionality is deeply integrated into Cody's context retrieval systems, providing keyword-based search capabilities across multiple features.",Where all is symf used as a context source for different Cody features?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:0-643"",""content"":""import { execFile as _execFile, spawn } from 'node:child_process'\nimport fs, { access, rename, rm, writeFile } from 'node:fs/promises'\nimport os from 'node:os'\nimport { promisify } from 'node:util'\n\nimport { Mutex } from 'async-mutex'\nimport { mkdirp } from 'mkdirp'\nimport * as vscode from 'vscode'\n\nimport {\n    type FileURI,\n    type IndexedKeywordContextFetcher,\n    type PromptString,\n    type Result,\n    type SourcegraphCompletionsClient,\n    assertFileURI,\n    isFileURI,\n    isWindows,\n    uriBasename,\n    uriDirname,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\nimport { getSymfPath } from './download-symf'\nimport { symfExpandQuery } from './symfExpandQuery'\n\nconst execFile = promisify(_execFile)\nconst oneDayMillis = 1000 * 60 * 60 * 24\n\ninterface CorpusDiff {\n    maybeChangedFiles?: boolean\n    changedFiles?: string[]\n    millisElapsed?: number\n}\n\nfunction parseJSONToCorpusDiff(json: string): CorpusDiff {\n    const obj = JSON.parse(json)\n    if (obj.maybeChangedFiles === undefined && obj.changedFiles === undefined) {\n        throw new Error(`malformed CorpusDiff: ${json}`)\n    }\n    return obj as CorpusDiff\n}\n\ninterface IndexOptions {\n    retryIfLastAttemptFailed: boolean\n    ignoreExisting: boolean\n}\n\nexport class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n}\n\nexport interface IndexStartEvent {\n    scopeDir: FileURI\n    cancel: () => void\n    done: Promise<void>\n}\n\ninterface IndexEndEvent {\n    scopeDir: FileURI\n}\n\nclass IndexStatus implements vscode.Disposable {\n    private startEmitter = new vscode.EventEmitter<IndexStartEvent>()\n    private stopEmitter = new vscode.EventEmitter<IndexEndEvent>()\n    private inProgressDirs = new Set<string /* uri.toString() */>()\n\n    public dispose(): void {\n        this.startEmitter.dispose()\n        this.stopEmitter.dispose()\n    }\n\n    public didStart(event: IndexStartEvent): void {\n        this.inProgressDirs.add(event.scopeDir.toString())\n        this.startEmitter.fire(event)\n    }\n\n    public didEnd(event: IndexEndEvent): void {\n        this.inProgressDirs.delete(event.scopeDir.toString())\n        this.stopEmitter.fire(event)\n    }\n\n    public onDidStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.startEmitter.event(cb)\n    }\n\n    public onDidEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.stopEmitter.event(cb)\n    }\n\n    public isInProgress(scopeDir: FileURI): boolean {\n        return this.inProgressDirs.has(scopeDir.toString())\n    }\n}\n\nasync function fileExists(file: vscode.Uri): Promise<boolean> {\n    if (!isFileURI(file)) {\n        throw new Error('only file URIs are supported')\n    }\n    try {\n        await access(file.fsPath, fs.constants.F_OK)\n        return true\n    } catch {\n        return false\n    }\n}\n\nfunction parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n}\n\n/**\n * A simple read-write lock.\n *\n * Note: it is possible for an overlapping succession of readers to starve out\n * any writers that are waiting for the mutex to be released. In practice, this\n * is not an issue, because we don't expect the user to issue neverending\n * while trying to update the index.\n */\nclass RWLock {\n    /**\n     * Invariants:\n     * - if readers > 0, then mu is locked\n     * - if readers === 0 and mu is locked, then a writer is holding the lock\n     */\n    private readers = 0\n    private mu = new Mutex()\n\n    public async withRead<T>(fn: () => Promise<T>): Promise<T> {\n        while (this.readers === 0) {\n            if (this.mu.isLocked()) {\n                // If mu is locked at this point, it must be held by the writer.\n                // We spin in this case, rather than try to acquire the lock,\n                // because multiple readers blocked on acquiring the lock will\n                // execute serially when the writer releases the lock (whereas\n                // we want all reads to be concurrent).\n                await new Promise(resolve => setTimeout(resolve, 100))\n                continue\n            }\n            // No readers or writers: acquire lock for readers\n            await this.mu.acquire()\n            break\n        }\n        this.readers++\n        try {\n            return await fn()\n        } finally {\n            this.readers--\n            if (this.readers === 0) {\n                this.mu.release()\n            }\n        }\n    }\n\n    public async withWrite<T>(fn: () => Promise<T>): Promise<T> {\n        return this.mu.runExclusive(fn)\n    }\n}\n\nfunction toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:0-27"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type AuthStatus,\n    type ChatClient,\n    type Configuration,\n    type ConfigurationWithAccessToken,\n    type FeatureFlagProvider,\n    type Guardrails,\n    ModelProvider,\n    ModelUsage,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport type { MessageProviderOptions } from '../MessageProvider'\nimport type { ExtensionMessage } from '../protocol'\n\nimport type { EnterpriseContextFactory } from '../../context/enterprise-context-factory'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport { chatHistory } from './ChatHistoryManager'\nimport { CodyChatPanelViewType } from './ChatManager'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77"",""content"":""        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type ConfigurationUseContext,\n    type ContextItem,\n    ContextItemSource,\n    MAX_BYTES_PER_FILE,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    type PromptString,\n    type Result,\n    isFileURI,\n    truncateTextNearestLine,\n    uriBasename,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { RemoteSearch } from '../../context/remote-search'\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug, logError } from '../../log'\n\ninterface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/context/chatContext.ts:70-75"",""content"":""export async function isURLContextFeatureFlagEnabled(): Promise<boolean> {\n    return (\n        vscode.workspace.getConfiguration('cody').get<boolean>('experimental.urlContext') === true ||\n        (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.URLContext))\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/provider.ts:0-22"",""content"":""import { type CodyCommand, type ContextItem, featureFlagProvider } from '@sourcegraph/cody-shared'\n\nimport * as vscode from 'vscode'\nimport { CodyCommandMenuItems } from '..'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getContextFileFromShell } from '../context/shell'\nimport { showCommandMenu } from '../menus'\nimport type { CodyCommandArgs } from '../types'\nimport { getDefaultCommandsMap } from '../utils/get-commands'\nimport { CustomCommandsManager, openCustomCommandDocsLink } from './custom-commands'\n\nconst vscodeDefaultCommands = getDefaultCommandsMap(CodyCommandMenuItems as CodyCommand[])\n\n/**\n * Provides management and interaction capabilities for both default and custom Cody commands.\n *\n * It is responsible for initializing, grouping, and refreshing command sets,\n * as well as handling command menus and execution.\n */\nexport class CommandsProvider implements vscode.Disposable {\n    private disposables: vscode.Disposable[] = []\n    protected readonly defaultCommands = vscodeDefaultCommands\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:98-111"",""content"":""    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/types.ts:0-46"",""content"":""import type { CodyCommand, ContextItem, EventSource, PromptString } from '@sourcegraph/cody-shared'\n\nimport type { Range, Uri } from 'vscode'\nimport type { ExecuteEditArguments } from '../edit/execute'\n\n/**\n * The name of the file for configuring Custom Commands.\n */\nexport enum ConfigFiles {\n    // Cody Commands config file location in VS CODE\n    // TODO: Migrate to use the one in /.cody\n    VSCODE = '.vscode/cody.json',\n    // Cody Commands config file location for all clients\n    COMMAND = '.cody/commands.json',\n}\n\n/**\n * Creates a CodyCommandArgs object with default values.\n * Generates a random requestID if one is not provided.\n * Merges any provided args with the defaults.\n */\nexport interface CodyCommandsFile {\n    // A set of reusable commands where instructions (prompts) and context can be configured.\n    commands: Map<string, CodyCommand>\n}\n\nexport interface CodyCommandArgs extends ExecuteEditArguments {\n    // for tracing the life of the request\n    requestID: string\n    // where the command was triggered from\n    source?: EventSource\n    // runs the command in chat mode, even if it's an edit command\n    runInChatMode?: boolean\n    // current context to add on top of the command context\n    userContextFiles?: ContextItem[]\n    additionalInstruction?: PromptString\n\n    /**\n     * Editor Context\n     */\n    // The URI of the file in the editor\n    uri?: Uri\n    // The range of the selection in the editor\n    range?: Range\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1085-1094"",""content"":""- Increased autocomplete debounce time feature flag support. [pull/733](https://github.com/sourcegraph/cody/pull/733)\n- Show an update notice after extension updates. [pull/746](https://github.com/sourcegraph/cody/pull/746)\n- Experimental user setting `cody.experimental.localSymbols` to enable inclusion of symbol definitions in the LLM context window. [pull/692](https://github.com/sourcegraph/cody/pull/692)\n- Experimental command `/symf`, which uses a local keyword index to perform searches for symbols. Requires setting `cody.experimental.symf.path` and `cody.experimental.symf.anthropicKey`. [pull/728](https://github.com/sourcegraph/cody/pull/728).\n\n### Fixed\n\n- Inline Chat: Fix issue where state was not being set correctly, causing Cody Commands to use the selection range from the last created Inline Chat instead of the current selection. [pull/602](https://github.com/sourcegraph/cody/pull/602)\n- Cody Commands: Commands that use the current file as context now correctly generate context message for the current file instead of using codebase context generated from current selection. [pull/683](https://github.com/sourcegraph/cody/pull/683)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/agentContextSorting.ts:0-21"",""content"":""import { type ContextItem, ContextItemSource } from '@sourcegraph/cody-shared'\n\nconst isAgentTesting = process.env.CODY_SHIM_TESTING === 'true'\n\n/**\n * Sorts the provided `ContextItem` array in a deterministic order for stable tests.\n * This function is only used when the `CODY_SHIM_TESTING` environment variable is\n * set to `'true'`, which indicates that the agent is running in a testing environment.\n *\n * NOTE: Agent tests require deterministic ordering of context files for consistent results across different file systems\n * These helper functions should be called before we pass context items/files to a prompt builder.\n * This is necessary to get the tests passing in CI because we need the prompts to be stable for the HTTP replay mode to succeed.\n *\n * @param files - The array of `ContextItem` objects to sort.\n */\nexport function sortContextItems(files: ContextItem[]): void {\n    if (!isAgentTesting) {\n        return\n    }\n    // Sort results for deterministic ordering for stable tests. Ideally, we\n    // could sort by some numerical score from symf based on how relevant\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:260-277"",""content"":""    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""}]",Find logic,,,0,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_001/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the codebase context provided, BFG (Blazingly Fast Graph) creates several types of indexes:

1. Git repository indexes: The code shows that BFG indexes Git repositories, as evidenced by the `didChangeGitExtensionRepository` and `indexGitRepositories` functions.

2. Workspace folder indexes: BFG also indexes workspace folders, as seen in the `indexRemainingWorkspaceFolders` function.

3. Inferred Git repository indexes: There's functionality to index Git repositories that may not be explicitly opened by the Git extension, as shown in the `indexInferredGitRepositories` function.

4. Symbol and identifier indexes: The BFG protocol includes requests for context based on symbols and identifiers, suggesting that BFG creates indexes for these elements.

5. File content indexes: The protocol also mentions file context snippets, indicating that BFG indexes file contents.

These indexes allow BFG to provide fast and efficient context retrieval for various Cody features, such as code completion and context-aware responses in chat interactions.",what different indexes are created by BFG?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:18-18"",""content"":""let serializeBfgDownload: Promise<string | null> = Promise.resolve(null)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:348-374"",""content"":""\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:20-109"",""content"":""export async function downloadBfg(context: vscode.ExtensionContext): Promise<string | null> {\n    // First, wait for any in-progress downloads.\n    await serializeBfgDownload\n\n    // Now we are the in-progress download.\n    serializeBfgDownload = (async () => {\n        const config = vscode.workspace.getConfiguration()\n        const userBfgPath = config.get<string>('cody.experimental.cody-engine.path')\n        if (userBfgPath) {\n            const bfgStat = await fspromises.stat(userBfgPath)\n            if (!bfgStat.isFile()) {\n                throw new Error(`not a file: ${userBfgPath}`)\n            }\n            logDebug('CodyEngine', `using user-provided path: ${userBfgPath} ${bfgStat.isFile()}`)\n            return userBfgPath\n        }\n\n        const osArch = getOSArch()\n        if (!osArch) {\n            logDebug('CodyEngine', 'getOSArch returned nothing')\n            return null\n        }\n        const { platform, arch } = osArch\n\n        if (!arch) {\n            logDebug('CodyEngine', 'getOSArch returned undefined arch')\n            return null\n        }\n\n        if (!platform) {\n            logDebug('CodyEngine', 'getOSArch returned undefined platform')\n            return null\n        }\n        // Rename returned architecture to match RFC 795 conventions\n        // https://docs.google.com/document/d/11cw-7dAp93JmasITNSNCtx31xrQsNB1L2OoxVE6zrTc/edit\n        const archRenames = new Map([\n            ['aarch64', 'arm64'],\n            ['x86_64', 'x64'],\n        ])\n        let rfc795Arch = archRenames.get(arch ?? '') ?? arch\n        if (rfc795Arch === 'arm64' && platform === 'win') {\n            // On Windows Arm PCs, we rely on emulation and use the x64 binary.\n            // See https://learn.microsoft.com/en-us/windows/arm/apps-on-arm-x86-emulation\n            rfc795Arch = 'x64'\n        }\n\n        const bfgContainingDir = path.join(context.globalStorageUri.fsPath, 'cody-engine')\n        const bfgVersion = config.get<string>('cody.experimental.cody-engine.version', defaultBfgVersion)\n        await fspromises.mkdir(bfgContainingDir, { recursive: true })\n        const bfgFilename = `cody-engine-${bfgVersion}-${platform}-${rfc795Arch}`\n        const bfgPath = path.join(bfgContainingDir, bfgFilename)\n        const isAlreadyDownloaded = await fileExists(bfgPath)\n        if (isAlreadyDownloaded) {\n            logDebug('CodyEngine', `using downloaded path \""${bfgPath}\""`)\n            return bfgPath\n        }\n\n        const bfgURL = `https://github.com/sourcegraph/bfg/releases/download/v${bfgVersion}/bfg-${platform}-${rfc795Arch}.zip`\n        try {\n            await vscode.window.withProgress(\n                {\n                    location: vscode.ProgressLocation.Window,\n                    title: 'Downloading cody-engine',\n                    cancellable: false,\n                },\n                async progress => {\n                    progress.report({ message: 'Downloading cody-engine' })\n                    const bfgZip = path.join(bfgContainingDir, 'bfg.zip')\n                    await downloadBfgBinary(bfgURL, bfgZip)\n                    await unzipBfg(bfgZip, bfgContainingDir)\n                    logDebug('CodyEngine', bfgPath)\n                    // The zip file contains a binary named `bfg` or `bfg.exe`. We unzip it with that name first and then rename into\n                    // a version-specific binary so that we can delete old versions of bfg.\n                    const unzipPath = platform === 'windows' ? 'bfg.exe' : 'bfg'\n                    await fspromises.rename(path.join(bfgContainingDir, unzipPath), bfgPath)\n                    await fspromises.chmod(bfgPath, 0o755)\n                    await fspromises.rm(bfgZip)\n                    logDebug('CodyEngine', `downloaded cody-engine to ${bfgPath}`)\n                }\n            )\n            void removeOldBfgBinaries(bfgContainingDir, bfgFilename)\n        } catch (error) {\n            captureException(error)\n            void vscode.window.showErrorMessage(`Failed to download bfg from URL ${bfgURL}: ${error}`)\n            return null\n        }\n        return bfgPath\n    })()\n    return serializeBfgDownload\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1337-1345"",""content"":""- Refactored authentication process. [pull/53434](https://github.com/sourcegraph/sourcegraph/pull/53434)\n- New sign-in and sign-out flow. [pull/53434](https://github.com/sourcegraph/sourcegraph/pull/53434)\n- Analytical logs are now displayed in the Output view. [pull/53870](https://github.com/sourcegraph/sourcegraph/pull/53870)\n- Inline Chat: Renamed Inline Assist to Inline Chat. [pull/53725](https://github.com/sourcegraph/sourcegraph/pull/53725) [pull/54315](https://github.com/sourcegraph/sourcegraph/pull/54315)\n- Chat: Link to the \""Getting Started\"" guide directly from the first chat message instead of the external documentation website. [pull/54175](https://github.com/sourcegraph/sourcegraph/pull/54175)\n- Codebase status icons. [pull/54262](https://github.com/sourcegraph/sourcegraph/pull/54262)\n- Changed the keyboard shortcut for the file touch recipe to `ctrl+alt+/` to avoid conflicts. [pull/54275](https://github.com/sourcegraph/sourcegraph/pull/54275)\n- Inline Chat: Do not change current focus when Inline Fixup is done. [pull/53980](https://github.com/sourcegraph/sourcegraph/pull/53980)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/spawn-bfg.ts:9-44"",""content"":""export async function spawnBfg(\n    context: vscode.ExtensionContext,\n    reject: (reason?: any) => void\n): Promise<MessageHandler> {\n    const bfg = new MessageHandler()\n    const codyrpc = await downloadBfg(context)\n    if (!codyrpc) {\n        throw new Error(\n            'Failed to download BFG binary. To fix this problem, set the \""cody.experimental.cody-engine.path\"" configuration to the path of your BFG binary'\n        )\n    }\n    const isVerboseDebug = vscode.workspace.getConfiguration().get<boolean>('cody.debug.verbose', false)\n    const child = child_process.spawn(codyrpc, {\n        stdio: 'pipe',\n        env: {\n            VERBOSE_DEBUG: `${isVerboseDebug}`,\n            RUST_BACKTRACE: isVerboseDebug ? '1' : '0',\n            // See bfg issue 138\n            RUST_LIB_BACKTRACE: '0',\n        },\n    })\n    child.stderr.on('data', chunk => {\n        logDebug('CodyEngine', 'spawnBfg:stderr', { verbose: chunk.toString() })\n    })\n    child.on('disconnect', () => reject())\n    child.on('close', () => reject())\n    child.on('error', error => reject(error))\n    child.on('exit', code => {\n        bfg.exit()\n        reject(code)\n    })\n    child.stderr.pipe(process.stderr)\n    child.stdout.pipe(bfg.messageDecoder)\n    bfg.messageEncoder.pipe(child.stdin)\n    return bfg\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:130-167"",""content"":""} from './inferenceClient/misc'\nexport type {\n    ContextResult,\n    FilenameContextFetcher,\n    IndexedKeywordContextFetcher,\n    LocalEmbeddingsFetcher,\n    IRemoteSearch,\n    Result,\n    SearchPanelFile,\n    SearchPanelSnippet,\n} from './local-context'\nexport { logDebug, logError, setLogger } from './logger'\nexport {\n    createOllamaClient,\n    ollamaChatClient,\n    type OllamaGenerateParams,\n    OLLAMA_DEFAULT_URL,\n} from './llm-providers/ollama'\nexport {\n    MAX_BYTES_PER_FILE,\n    MAX_CURRENT_FILE_TOKENS,\n    ANSWER_TOKENS,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    SURROUNDING_LINES,\n} from './prompt/constants'\nexport { PromptMixin, newPromptMixin } from './prompt/prompt-mixin'\nexport * from './prompt/templates'\nexport {\n    truncateText,\n    truncateTextNearestLine,\n    truncatePromptStringStart,\n    truncatePromptString,\n} from './prompt/truncation'\nexport type { Message } from './sourcegraph-api'\nexport { SourcegraphBrowserCompletionsClient } from './sourcegraph-api/completions/browserClient'\nexport { SourcegraphCompletionsClient } from './sourcegraph-api/completions/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:111-119"",""content"":""async function unzipBfg(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:246-279"",""content"":""- Chat: Add tracing. [pull/3168](https://github.com/sourcegraph/cody/pull/3168)\n- Command: Leading slashes are removed from command names in the command menu. [pull/3061](https://github.com/sourcegraph/cody/pull/3061)\n\n## [1.4.4]\n\n### Added\n\n### Fixed\n\n- The signin menu now displays a warning for invalid URL input. [pull/3156](https://github.com/sourcegraph/cody/pull/3156)\n\n### Changed\n\n## [1.4.3]\n\n### Added\n\n- Autocomplete: Updated the BFG binary version. [pull/3130](https://github.com/sourcegraph/cody/pull/3130)\n\n### Changed\n\n## [1.4.2]\n\n### Fixed\n\n- Chat: Fixed an issue where Cody would sometimes exceed the context window limit for shorter context OpenAI models. [pull/3121](https://github.com/sourcegraph/cody/pull/3121)\n\n## [1.4.1]\n\n### Added\n\n- Chat: Support `@-mentioned` in mid sentences. [pull/3043](https://github.com/sourcegraph/cody/pull/3043)\n- Chat: Support `@-mentioned` in editing mode. [pull/3091](https://github.com/sourcegraph/cody/pull/3091)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/highlight.css:308-368"",""content"":""\n.hl-typed-IdentifierFunction {\n\tcolor: var(--hl-dark-yellow);\n}\n\n.hl-typed-IdentifierType {\n\tcolor: var(--hl-gray-1);\n}\n\n.hl-typed-IdentifierBuiltin {\n\tcolor: var(--hl-purple);\n}\n\n.hl-typed-IdentifierNull {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-BooleanLiteral {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-IdentifierConstant {\n\tcolor: var(--hl-orange);\n}\n\n.hl-typed-IdentifierMutableGlobal {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierParameter {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierLocal {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierShadowed {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierModule {\n\tcolor: var(--hl-blue);\n}\n\n.hl-typed-IdentifierFunctionDefinition {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierMacro {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierMacroDefinition {\n\tcolor: var(--hl-yellow);\n}\n\n.hl-typed-IdentifierBuiltinType {\n\tcolor: var(--hl-orange);\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:516-537"",""content"":""\n## [1.0.0]\n\n### Added\n\n- Adds support for Mixtral by Mistral in the LLM dropdown list. [issues/2307](https://github.com/sourcegraph/cody/issues/2307)\n\n### Fixed\n\n- Context: The \""Continue Indexing\"" button works on Windows. [issues/2328](https://github.com/sourcegraph/cody/issues/2328)\n- Context: The \""Embeddings Incomplete\"" status bar item shows an accurate percent completion. Previously we showed the percent *in*complete, but labeled it percent complete. We no longer display a spurious \""Cody Embeddings Index Complete\"" toast if indexing fails a second time. [pull/2368](https://github.com/sourcegraph/cody/pull/2368)\n\n### Changed\n\n- Updates the code smell icon so it does not stand out in some VS Code themes.\n\n## [0.18.6]\n\n### Added\n\n- Context: Incomplete embeddings indexing status can seen in the status bar. On macOS and Linux, indexing can be resumed by clicking there. However Windows users will still see an OS error 5 (access denied) when retrying indexing. [pull/2265](https://github.com/sourcegraph/cody/pull/2265)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/bfg-protocol.ts:0-38"",""content"":""/**\n * This file declares the protocol for communicating between Cody and BFG (Blazingly Fast Graph), a Rust implementation\n * of the \""Graph Context\"" feature flag.\n */\nimport type { Position } from './agent-protocol'\n\ninterface BFGFileContextSnippet {\n    fileName: string\n    content: string\n}\n\ninterface BFGSymbolContextSnippet extends BFGFileContextSnippet {\n    symbol: string\n}\n\nexport type Requests = {\n    'bfg/initialize': [{ clientName: string }, { serverVersion: string }]\n    'bfg/contextAtPosition': [\n        { uri: string; content: string; position: Position; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[]; files?: BFGFileContextSnippet[] },\n    ]\n    'bfg/contextForIdentifiers': [\n        { uri: string; identifiers: string[]; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[] },\n    ]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/gitRevision/didChange': [{ gitDirectoryUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/workspace/didChange': [{ workspaceUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/shutdown': [null, void]\n\n    'embeddings/hello': [null, string]\n}\n\nexport type Notifications = {\n    'bfg/placeholderNotification': [null]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:203-228"",""content"":""    event,\n} from './sourcegraph-api/graphql/client'\nexport { GraphQLTelemetryExporter } from './sourcegraph-api/telemetry/GraphQLTelemetryExporter'\nexport { NOOP_TELEMETRY_SERVICE } from './telemetry'\nexport type { TelemetryEventProperties, TelemetryService } from './telemetry'\nexport { type BillingCategory, type BillingProduct } from './telemetry-v2'\nexport {\n    MockServerTelemetryRecorderProvider,\n    NoOpTelemetryRecorderProvider,\n    TelemetryRecorderProvider,\n} from './telemetry-v2/TelemetryRecorderProvider'\nexport type { TelemetryRecorder } from './telemetry-v2/TelemetryRecorderProvider'\nexport { EventLogger } from './telemetry/EventLogger'\nexport type { ExtensionDetails } from './telemetry/EventLogger'\nexport { testFileUri } from './test/path-helpers'\nexport {\n    addTraceparent,\n    getActiveTraceAndSpanId,\n    wrapInActiveSpan,\n    recordErrorToSpan,\n    tracer,\n    logResponseHeadersToSpan,\n} from './tracing'\nexport { convertGitCloneURLToCodebaseName, isError } from './utils'\nexport type { CurrentUserCodySubscription } from './sourcegraph-api/graphql/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts:0-303"",""content"":""import * as vscode from 'vscode'\n\nimport { spawnBfg } from '../../../../graph/bfg/spawn-bfg'\nimport type { MessageHandler } from '../../../../jsonrpc/jsonrpc'\nimport { logDebug } from '../../../../log'\nimport type { Repository } from '../../../../repository/builtinGitExtension'\nimport { gitAPI } from '../../../../repository/git-extension-api'\nimport { captureException } from '../../../../services/sentry/sentry'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\n\nimport type { AutocompleteContextSnippet } from '@sourcegraph/cody-shared'\nimport {\n    getLastNGraphContextIdentifiersFromDocument,\n    getLastNGraphContextIdentifiersFromString,\n} from '../graph/identifiers'\nimport { type SimpleRepository, inferGitRepository } from './simple-git'\n\nexport class BfgRetriever implements ContextRetriever {\n    public identifier = 'bfg'\n    private loadedBFG: Promise<MessageHandler>\n    private bfgIndexingPromise = Promise.resolve<void>(undefined)\n    private awaitIndexing: boolean\n    private didFailLoading = false\n    // Keys are repository URIs, values are revisions (commit hashes).\n    private indexedRepositoryRevisions = new Map<string, string>()\n    constructor(private context: vscode.ExtensionContext) {\n        this.awaitIndexing = vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.await-indexing', false)\n        this.loadedBFG = this.loadBFG()\n\n        this.loadedBFG.then(\n            () => {},\n            error => {\n                captureException(error)\n                this.didFailLoading = true\n                logDebug('CodyEngine', 'failed to initialize', error)\n            }\n        )\n\n        this.bfgIndexingPromise = this.indexWorkspace()\n    }\n\n    private async indexWorkspace(): Promise<void> {\n        await this.indexGitRepositories()\n        await this.indexRemainingWorkspaceFolders()\n    }\n    private isWorkspaceIndexed(folder: vscode.Uri): boolean {\n        const uri = folder.toString()\n        logDebug('CodyEngine', 'Checking if folder is indexed', uri)\n        for (const key of this.indexedRepositoryRevisions.keys()) {\n            if (uri.startsWith(key)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private async indexRemainingWorkspaceFolders(): Promise<void> {\n        logDebug(\n            'CodyEngine',\n            'workspaceFolders',\n            vscode.workspace.workspaceFolders?.map(folder => folder.uri.toString()) ?? []\n        )\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.isWorkspaceIndexed(folder.uri)) {\n                continue\n            }\n            await this.indexEntry({ workspace: folder.uri })\n        }\n    }\n    private async indexGitRepositories(): Promise<void> {\n        const git = gitAPI()\n        if (!git) {\n            return\n        }\n        for (const repository of git.repositories) {\n            await this.didChangeGitExtensionRepository(repository)\n        }\n        this.context.subscriptions.push(\n            git.onDidOpenRepository(repository => this.didChangeGitExtensionRepository(repository))\n        )\n        this.context.subscriptions.push(\n            vscode.workspace.onDidChangeWorkspaceFolders(() => this.indexInferredGitRepositories())\n        )\n        // TODO: handle closed repositories\n\n        await this.indexInferredGitRepositories()\n    }\n\n    private shouldInferGitRepositories(): boolean {\n        // Some users may not want to allow Cody to index code outside the VS\n        // Code workspace folder so we support an escape hatch to disable this\n        // functionality. This setting is hidden because all the other\n        // BFG-related settings are hidden.\n        return vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.index-parent-git-folder', false)\n    }\n\n    // Infers what git repositories that are relevant but may not be \""open\"" by\n    // the git extension.  For example, by default, the git extension doesn't\n    // open git repositories when the workspace root is a subfolder. There's a\n    // setting to automatically open parent git repositories but the setting is\n    // disabled by default.\n    private async indexInferredGitRepositories(): Promise<void> {\n        if (!this.shouldInferGitRepositories()) {\n            return\n        }\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.indexedRepositoryRevisions.has(folder.uri.toString())) {\n                continue\n            }\n            const repo = await inferGitRepository(folder.uri)\n            if (repo) {\n                await this.didChangeSimpleRepository(repo)\n            }\n        }\n    }\n\n    private async didChangeGitExtensionRepository(repository: Repository): Promise<void> {\n        const commit = repository?.state?.HEAD?.commit\n        if (!commit) {\n            return\n        }\n        await this.didChangeSimpleRepository({ uri: repository.rootUri, commit })\n    }\n\n    private async didChangeSimpleRepository(repository: SimpleRepository): Promise<void> {\n        const uri = repository.uri.toString()\n        if (repository.commit !== this.indexedRepositoryRevisions.get(uri)) {\n            this.indexedRepositoryRevisions.set(uri, repository.commit ?? '')\n            await this.indexEntry({ repository })\n        }\n    }\n\n    private async indexEntry(params: {\n        repository?: SimpleRepository\n        workspace?: vscode.Uri\n    }): Promise<void> {\n        const { repository, workspace } = params\n        if (!repository && !workspace) {\n            return\n        }\n        const bfg = await this.loadedBFG\n        const indexingStartTime = Date.now()\n        // TODO: include commit?\n        try {\n            if (repository) {\n                await bfg.request('bfg/gitRevision/didChange', {\n                    gitDirectoryUri: repository.uri.toString(),\n                })\n            }\n            if (workspace) {\n                await bfg.request('bfg/workspace/didChange', { workspaceUri: workspace.toString() })\n            }\n            const elapsed = Date.now() - indexingStartTime\n            const label = repository\n                ? `${repository.uri.fsPath}:${repository.commit}`\n                : workspace\n                  ? workspace.fsPath\n                  : ''\n            if (label) {\n                logDebug('CodyEngine', `gitRevision/didChange ${label} indexing time ${elapsed}ms`)\n            }\n        } catch (error) {\n            logDebug('CodyEngine', `indexing error ${error}`)\n        }\n    }\n\n    public async retrieve({\n        document,\n        position,\n        docContext,\n        hints,\n        lastCandidate,\n    }: ContextRetrieverOptions): Promise<AutocompleteContextSnippet[]> {\n        try {\n            if (this.didFailLoading) {\n                return []\n            }\n            const bfg = await this.loadedBFG\n            if (!bfg.isAlive()) {\n                logDebug('CodyEngine', 'not alive')\n                return []\n            }\n\n            if (this.awaitIndexing) {\n                await this.bfgIndexingPromise\n            }\n\n            const lastCandidateCurrentLine =\n                (lastCandidate?.lastTriggerDocContext.currentLinePrefix || '') +\n                lastCandidate?.result.items[0].insertText\n\n            const bfgRequestStart = performance.now()\n            const inputIdentifiers = Array.from(\n                new Set([\n                    // Get last 10 identifiers from the last candidate insert text\n                    // in hopes that LLM partially guessed the right completion.\n                    ...getLastNGraphContextIdentifiersFromString({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                        source: lastCandidateCurrentLine,\n                    }),\n                    // Get last 10 identifiers from the current document prefix.\n                    ...getLastNGraphContextIdentifiersFromDocument({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                    }),\n                ])\n            )\n\n            const response = await bfg.request('bfg/contextForIdentifiers', {\n                uri: document.uri.toString(),\n                identifiers: inputIdentifiers,\n                maxSnippets: 20,\n                maxDepth: 4,\n            })\n\n            // Just in case, handle non-object results\n            if (typeof response !== 'object') {\n                return []\n            }\n\n            // Convert BFG snippets to match the format expected on the client.\n            const symbols = (response.symbols || []).map(contextSnippet => ({\n                ...contextSnippet,\n                uri: vscode.Uri.from({ scheme: 'file', path: contextSnippet.fileName }),\n            })) satisfies Omit<AutocompleteContextSnippet, 'startLine' | 'endLine'>[]\n\n            logDebug('CodyEngine', 'bfg/contextForIdentifiers', {\n                verbose: {\n                    inputIdentifiers,\n                    duration: `${performance.now() - bfgRequestStart}ms`,\n                    symbols: symbols.map(s => `${s.symbol} ${s.content}`),\n                },\n            })\n\n            // TODO: add `startLine` and `endLine` to `responses` or explicitly add\n            // another context snippet type to the client.\n            // @ts-ignore\n            return symbols\n        } catch (error) {\n            logDebug('CodyEngine:error', `${error}`)\n            return []\n        }\n    }\n\n    public isSupportedForLanguageId(languageId: string): boolean {\n        switch (languageId) {\n            case 'typescript':\n            case 'typescriptreact':\n            case 'javascript':\n            case 'javascriptreact':\n            case 'java':\n            case 'go':\n            case 'dart':\n            case 'python':\n            case 'zig':\n                return true\n            default:\n                return false\n        }\n    }\n\n    public dispose(): void {\n        if (this.didFailLoading) {\n            return\n        }\n        this.loadedBFG.then(\n            bfg => bfg.request('bfg/shutdown', null),\n            () => {}\n        )\n    }\n\n    // We lazily load BFG to allow the Cody extension to finish activation as\n    // quickly as possible.\n    private loadBFG(): Promise<MessageHandler> {\n        // This is implemented as a custom promise instead of async/await so that we can reject\n        // the promise in the 'exit' handler if we fail to start the bfg process for some reason.\n        return new Promise<MessageHandler>((resolve, reject) => {\n            logDebug('CodyEngine', 'loading bfg')\n            this.doLoadBFG(reject).then(\n                bfg => resolve(bfg),\n                error => {\n                    captureException(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    private async doLoadBFG(reject: (reason?: any) => void): Promise<MessageHandler> {\n        const bfg = await spawnBfg(this.context, reject)\n        await bfg.request('bfg/initialize', { clientName: 'vscode' })\n        return bfg\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/mocks.ts:609-653"",""content"":""            'java',\n            'javascriptreact',\n            'javascript',\n            'jsx-tags',\n            'jsonl',\n            'snippets',\n            'julia',\n            'juliamarkdown',\n            'tex',\n            'latex',\n            'bibtex',\n            'cpp_embedded_latex',\n            'markdown_latex_combined',\n            'less',\n            'lua',\n            'makefile',\n            'markdown',\n            'markdown-math',\n            'wat',\n            'objective-c',\n            'objective-cpp',\n            'perl',\n            'perl6',\n            'php',\n            'powershell',\n            'jade',\n            'python',\n            'r',\n            'razor',\n            'restructuredtext',\n            'ruby',\n            'rust',\n            'scss',\n            'search-result',\n            'shaderlab',\n            'shellscript',\n            'sql',\n            'swift',\n            'typescript',\n            'typescriptreact',\n            'vb',\n            'xml',\n            'xsl',\n            'dockercompose',\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2855-2869"",""content"":""            super_type?: ReturnType<typeof SuperType.prototype.toObject>\n            constant_type?: ReturnType<typeof ConstantType.prototype.toObject>\n            intersection_type?: ReturnType<typeof IntersectionType.prototype.toObject>\n            union_type?: ReturnType<typeof UnionType.prototype.toObject>\n            with_type?: ReturnType<typeof WithType.prototype.toObject>\n            structural_type?: ReturnType<typeof StructuralType.prototype.toObject>\n            annotated_type?: ReturnType<typeof AnnotatedType.prototype.toObject>\n            existential_type?: ReturnType<typeof ExistentialType.prototype.toObject>\n            universal_type?: ReturnType<typeof UniversalType.prototype.toObject>\n            by_name_type?: ReturnType<typeof ByNameType.prototype.toObject>\n            repeated_type?: ReturnType<typeof RepeatedType.prototype.toObject>\n            match_type?: ReturnType<typeof MatchType.prototype.toObject>\n            lambda_type?: ReturnType<typeof LambdaType.prototype.toObject>\n        }): Type {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1321-1329"",""content"":""    \""ovsx\"": \""^0.8.2\"",\n    \""pako\"": \""^2.1.0\"",\n    \""path-browserify\"": \""^1.0.1\"",\n    \""playwright\"": \""1.39.0\"",\n    \""progress\"": \""^2.0.3\"",\n    \""yaml\"": \""^2.3.4\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/bfg/BfgRetriever.test.ts:27-27"",""content"":""const shouldCreateGitDir = !fs.existsSync(gitdir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:76-103"",""content"":""\n            // The bfg mixed strategy mixes local and graph based retrievers\n            case 'bfg-mixed':\n                if (this.graphRetriever?.isSupportedForLanguageId(document.languageId)) {\n                    retrievers.push(this.graphRetriever)\n                }\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                break\n\n            // The local mixed strategy combines two local retrievers\n            case 'local-mixed':\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                if (this.graphRetriever) {\n                    retrievers.push(this.graphRetriever)\n                }\n                break\n\n            // The jaccard similarity strategies only uses the local retriever\n            case 'jaccard-similarity': {\n                if (this.localRetriever) {\n                    retrievers.push(this.localRetriever)\n                }\n                break\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/package.json:64-78"",""content"":""    \""@types/diff\"": \""^5.0.9\"",\n    \""@types/google-protobuf\"": \""3.15.12\"",\n    \""@types/minimatch\"": \""^5.1.2\"",\n    \""@types/uuid\"": \""^9.0.2\"",\n    \""@types/vscode\"": \""^1.80.0\"",\n    \""@types/ws\"": \""^8.5.10\"",\n    \""diff\"": \""^5.2.0\"",\n    \""esbuild\"": \""^0.18.19\"",\n    \""google-protobuf\"": \""^3.21.2\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""pkg\"": \""^5.8.1\"",\n    \""rimraf\"": \""^5.0.5\""\n  }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:322-348"",""content"":""        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n            return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_002/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Cody implements several context ranking logics:

1. Standard context ranking: This is the default method used when the experimental features are not enabled.

2. Experimental chat context ranker: This is enabled when the `experimentalChatContextRanker` flag is set to true in the `ContextRankerConfig`.

3. Embedding-based context retrieval: This is implemented in the `retrieveEmbeddingBasedContext` method, which uses a specific embedding model to find relevant context.

4. Model-specific embeddings search: The `searchModelSpecificEmbeddings` method uses a specific model (sentence-transformers/multi-qa-mpnet-base-dot-v1) to search for relevant context.

5. Precomputed context ranking features: The `precomputeContextRankingFeatures` method allows for precomputation of ranking features for improved performance.

These different ranking logics allow Cody to provide more accurate and relevant context for various use cases, enhancing the overall quality of code assistance and chat interactions.",What different context ranking logics are implemented in Cody?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/keyboard.md:0-19"",""content"":""## Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can also update these bindings in the `Keyboard Shortcuts Editor`.\n\n### Keyboard Shortcuts Editor\n\nThe `Keyboard Shortcuts Editor` allows you to easily update the default bindings (keyboard shortcuts). This is particularly useful if the default key bindings conflict with your current or preferred key bindings. By accessing the `Keyboard Shortcuts Editor`, you can search for specific commands, reassign keybindings, and customize your keyboard shortcuts to suit your workflow.\n\n### Getting Started\n\nTo get started: \n1. Click on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**` to open the `Keyboard Shortcuts Editor`.\n2. In the `Keyboard Shortcuts Editor`, you can search for a specific command by typing in the search bar.\n3. Once you have found the command you want to reassign keybindings for, click on it to select it.\n4. Follow the instruction on screen to assign a new keybinding.\n\n**✨ Pro-tips for assigning keyboard shortcuts for Cody**\n<br>• You can assign key bindings (keyboard shortcuts) to individual custom commands.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:985-1005"",""content"":""\n## [0.12.1]\n\n### Added\n\n### Fixed\n\n- Fixes an issue that caused the `cody-autocomplete-claude-instant-infill` feature flag to have no effect. [pull/1132](https://github.com/sourcegraph/cody/pull/1132)\n\n### Changed\n\n## [0.12.0]\n\n### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:0-16"",""content"":""# Cody quality tools\n\nThis section documents the tools we have to assess the quality of Cody in different scenarios.\n\nAs Cody is a BYOLLM product (Bring-your-own-LLM), when we introduce/use a new LLM (for example, a customer's own LLM model that they developed/trained themselves) we have a need to be able to quantify how well Cody is working with it.\n\n## Autocompletion\n\n### Influencing autocomplete performance\n\nCody autocompletion (code completions in your editor) can be powered by two types of models:\n\n1. Chat-based models, where we \""tell\"" the LLM it supposed to perform code completion in plain English, give it a code snippet, and extract the response code snippet from its (otherwise English) response.\n2. An actual code-based model, these are LLMs that are trained to produce code only and can't produce English responses, they speak only code.\n\nFor chat-based models, we can influence the performance by altering the prompting AND context. For code-based models, we can typically influence the performance by adjusting the amount and relevancy of context only, as there is no prompting to adjust.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:151-166"",""content"":""- Command: Enhanced the context provided to the Test command to help the language model determine the appropriate testing framework to use. [pull/3344](https://github.com/sourcegraph/cody/pull/3344)\n- Document: Upgraded to use a faster model. [pull/3275](https://github.com/sourcegraph/cody/pull/3275)\n- Properly throw an error when attempting to parse an incomplete SSE stream with the nodeClient. [pull/3479](https://github.com/sourcegraph/cody/pull/3479)\n\n## [1.8.3]\n\n### Fixed\n\n- Fix crash upon initialization in the stable build if a prerelease version of the VS Code extension was used for chat after 2024-03-08. [pull/3394](https://github.com/sourcegraph/cody/pull/3394)\n\n## [1.8.2]\n\n### Added\n\n- Debug: Added new commands (`Cody Debug: Enable Debug Mode` and `Cody Debug: Open Output Channel`) to the editor Command Palette and the `Settings & Support` sidebar to streamline the process of getting started with debugging Cody. [pull/3342](https://github.com/sourcegraph/cody/pull/3342)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:0-24"",""content"":""# Changelog\n\nThis is a log of all notable changes to Cody for VS Code. [Unreleased] changes are included in the nightly pre-release builds.\n\n## [Unreleased]\n\n### Added\n\n### Fixed\n\n- Chat: Fixed an issue where Cody's responses were not visible in small windows. [pull/3859](https://github.com/sourcegraph/cody/pull/3859)\n- Edit: Fixed an issue where an Edit task would not correctly respin when an irresolvable conflict is encountered. [pull/3872](https://github.com/sourcegraph/cody/pull/3872)\n- Chat: Fixed an issue where older chats were displaying as 'N months ago' instead of the number in the Chat History sidebar. [pull/3864](https://github.com/sourcegraph/cody/pull/3864)\n\n### Changed\n\n- Debug: Removed the `cody.debug.enabled` setting. Baseline debugging is now enabled by default [pull/3873](https://github.com/sourcegraph/cody/pull/3873)\n\n\n## [1.14.0]\n\n### Added\n\n- Chat: Add highlighted code to Cody Chat as `@-mentions` context by right-clicking on the code and selecting `Cody Chat: Add context`. [pull/3713](https://github.com/sourcegraph/cody/pull/3713)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:0-18"",""content"":""# Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can easily update these bindings in the `Keyboard Shortcuts editor`, which you can access by clicking on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**`.\n\nThis feature can be particularly useful if the default key bindings conflict with your current or preferred key bindings.\n\n## Keyboard Shortcuts Editor\n\nThe Keyboard Shortcuts editor allows you to easily update the key bindings for any of the Cody commands. To open the `Keyboard Shortcuts Editor`:\n1. Open the Cody sidebar and expand the `**SETTINGS AND SUPPORT**` section.\n2. Click on the `**Keyboard Shortcuts**` icon.\n\n## Custom Commands\n\n![editor](images/keyboard_editor.png)\n\nYou have the option to assign key bindings (keyboard shortcuts) to individual custom commands:\n1. In the Cody sidebar under `**SETTINGS AND SUPPORT**`, click on the `**Keyboard Shortcuts**` icon to open the Keyboard Shortcuts editor.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:0-313"",""content"":""import * as fspromises from 'node:fs/promises'\nimport * as path from 'node:path'\nimport {\n    type ConfigurationWithAccessToken,\n    type ContextItem,\n    ContextItemSource,\n    type EmbeddingsSearchResult,\n    type FileURI,\n    type PromptString,\n    isDotCom,\n    isFileURI,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { URI } from 'vscode-uri'\nimport type { RankContextItem, RankerPrediction } from '../jsonrpc/context-ranking-protocol'\nimport type { MessageHandler } from '../jsonrpc/jsonrpc'\nimport { logDebug } from '../log'\nimport { captureException } from '../services/sentry/sentry'\nimport { CodyEngineService } from './cody-engine'\n\ninterface ContextRanker {\n    rankContextItems(query: PromptString, contextItems: ContextItem[]): Promise<ContextItem[]>\n}\n\nexport function createContextRankingController(\n    context: vscode.ExtensionContext,\n    config: ContextRankerConfig\n): ContextRankingController {\n    return new ContextRankingController(context, config)\n}\n\nexport type ContextRankerConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & { experimentalChatContextRanker: boolean | undefined }\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/context-ranking`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/context-ranking`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\context-ranking`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\nexport class ContextRankingController implements ContextRanker {\n    // The cody-engine child process, if starting or started.\n    private service: Promise<MessageHandler> | undefined\n    // True if the service has finished starting and been initialized.\n    private serviceStarted = false\n    // Whether the account is a consumer account.\n    private endpointIsDotcom = false\n    private accessToken: string | undefined\n    private readonly indexLibraryPath: FileURI | undefined\n\n    constructor(\n        private readonly context: vscode.ExtensionContext,\n        config: ContextRankerConfig\n    ) {\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n        this.accessToken = config.accessToken || undefined\n        logDebug('ContextRankingController', 'constructor')\n    }\n\n    public async start(): Promise<void> {\n        logDebug('ContextRankingController', 'start')\n        await this.getService()\n\n        const repoUri = this.getRepoUri()\n        if (repoUri && isFileURI(repoUri)) {\n            this.computeFeatures(repoUri)\n        }\n    }\n\n    public async setAccessToken(serverEndpoint: string, token: string | null): Promise<void> {\n        const endpointIsDotcom = isDotCom(serverEndpoint)\n        logDebug(\n            'ContextRankingController',\n            'setAccessToken',\n            endpointIsDotcom ? 'is dotcom' : 'not dotcom'\n        )\n        this.endpointIsDotcom = endpointIsDotcom\n        if (token === this.accessToken) {\n            return Promise.resolve()\n        }\n        this.accessToken = token || undefined\n    }\n\n    private getRepoUri(): vscode.Uri | undefined {\n        return vscode.workspace.workspaceFolders?.[0]?.uri\n    }\n\n    // Tries to compute the index at the start of the service.\n    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n    }\n\n    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n    }\n\n    private async createLogsFile(dirPath: string): Promise<string> {\n        await fspromises.mkdir(dirPath, { recursive: true })\n        const fileName = 'ranker-payload.jsonl'\n        const filePath = path.join(dirPath, fileName)\n        if (\n            !(await fspromises\n                .access(filePath)\n                .then(() => true)\n                .catch(() => false))\n        ) {\n            await fspromises.writeFile(filePath, '')\n        }\n        return filePath\n    }\n\n    private setupContextRankingService = async (service: MessageHandler): Promise<void> => {\n        // The payload is very big to print on console. SKipping print on console for now until we start logging in BQ.\n        service.registerNotification(\n            'context-ranking/rank-items-logger-payload',\n            async (payload: string) => {\n                const indexPath = getIndexLibraryPath()\n                const logsFile = await this.createLogsFile(path.join(indexPath.fsPath, 'ranker-logs'))\n                fspromises.appendFile(logsFile, payload + '\\n')\n                logDebug(\n                    'ContextRankingController',\n                    'rank-items-logger-payload',\n                    'appending logs at the path',\n                    logsFile\n                )\n            }\n        )\n        let indexPath = getIndexLibraryPath()\n        // Tests may override the index library path\n        if (this.indexLibraryPath) {\n            indexPath = this.indexLibraryPath\n        }\n        if (this.accessToken) {\n            await service.request('context-ranking/initialize', {\n                indexPath: indexPath.fsPath,\n                accessToken: this.accessToken,\n            })\n            this.serviceStarted = true\n        } else {\n            logDebug('ContextRankingController', 'setupContextRankingService', 'no access token found')\n        }\n    }\n\n    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n    }\n\n    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n    }\n\n    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n            return []\n        }\n    }\n\n    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n    }\n\n    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-56"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_003/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, Cody uses several different CodeSearch services for context:

1. Remote Search: The `RemoteSearch` class implements remote search functionality, allowing Cody to search across multiple repositories.

2. Local Keyword Search: Support for local keyword search is mentioned in the changelog, particularly for Windows.

3. Embeddings Search: There's a reference to handling embeddings search backward compatibility, indicating that embeddings-based search is used.

4. Context Ranking: The codebase includes a `context-ranking.ts` file, suggesting a service for ranking and prioritizing context.

5. File Path Search: There's mention of searching for file paths, which is likely another form of context search.

6. Enhanced Context: The codebase includes references to ""Enhanced Context"" settings, which may involve additional search capabilities.

7. Workspace Search: There are functions for getting context from the current file, directory, and open tabs, indicating workspace-level search functionality.

These various search services allow Cody to gather relevant context from different sources, enhancing its ability to provide accurate and contextually appropriate responses.",What all different CodeSearch services are being used by Cody context?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1466-1491"",""content"":""\n## [0.1.5]\n\n### Added\n\n### Fixed\n\n- Inline Assist broken decorations for Inline-Fixup tasks [pull/52322](https://github.com/sourcegraph/sourcegraph/pull/52322)\n\n### Changed\n\n- Various Cody completions related improvements [pull/52365](https://github.com/sourcegraph/sourcegraph/pull/52365)\n\n## [0.1.4]\n\n### Added\n\n- Added support for local keyword search on Windows. [pull/52251](https://github.com/sourcegraph/sourcegraph/pull/52251)\n\n### Fixed\n\n- Setting `cody.useContext` to `none` will now limit Cody to using only the currently open file. [pull/52126](https://github.com/sourcegraph/sourcegraph/pull/52126)\n- Fixes race condition in telemetry. [pull/52279](https://github.com/sourcegraph/sourcegraph/pull/52279)\n- Don't search for file paths if no file paths to validate. [pull/52267](https://github.com/sourcegraph/sourcegraph/pull/52267)\n- Fix handling of embeddings search backward compatibility. [pull/52286](https://github.com/sourcegraph/sourcegraph/pull/52286)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/enterprise-context-factory.ts:39-41"",""content"":""    public createRemoteSearch(): RemoteSearch {\n        return new RemoteSearch()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:92-108"",""content"":""\n### Document\n\n- [ ] Verify that the option to run the `Document Code` command is available in the following locations:\n  - [ ] Sidebar `Document Code`\n  - [ ] Context (right-click) menu `Cody > Document Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Document Code`\n  - [ ] Cody Command Menu (option+c, `Document Code`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Document Code` command.\n- [ ] Verify that an icon appears above the highlighted code with \""Cody is working...\"" while Cody generates documentation.\n- [ ] Verify that you can see a diff view of the generated documentation in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the documentation by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Document Code` command again.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1214-1234"",""content"":""\n### Fixed\n\n### Changed\n\n- The setting `cody.autocomplete.experimental.triggerMoreEagerly` (which causes autocomplete to trigger earlier, before you type a space or other non-word character) now defaults to `true`.\n- If you run the `Trigger Inline Suggestion` VS Code action, 3 suggestions instead of just 1 will be shown.\n\n## [0.6.1]\n\n### Added\n\n- A new experimental user setting `cody.autocomplete.experimental.triggerMoreEagerly` causes autocomplete to trigger earlier, before you type a space or other non-word character.\n- [Internal Only] `Custom Recipe`: Support context type selection when creating a new recipe via UI. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n- New `/open` command for opening workspace files from chat box. [pull/327](https://github.com/sourcegraph/cody/pull/327)\n\n### Fixed\n\n- Insert at Cusor now inserts the complete code snippets at cursor position. [pull/282](https://github.com/sourcegraph/cody/pull/282)\n- Minimizing the change of Cody replying users with response related to the language-uage prompt. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:113-119"",""content"":""    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1412-1423"",""content"":""- Cody Inline Assist: Decorations for `/fix` errors. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Open file paths from Cody's responses in workspace. [pull/53069](https://github.com/sourcegraph/sourcegraph/pull/53069)\n- Help & Getting Started: Walkthrough to help users get setup with Cody and discover new features. [pull/52560](https://github.com/sourcegraph/sourcegraph/pull/52560)\n\n### Fixed\n\n- Cody Inline Assist: Decorations for `/fix` on light theme. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Use more than 1 context file for `/touch`. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Fixes cody processing indefinitely issue. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody completions: Various fixes for completion analytics. [pull/52935](https://github.com/sourcegraph/sourcegraph/pull/52935)\n- Cody Inline Assist: Indentation on `/fix` [pull/53068](https://github.com/sourcegraph/sourcegraph/pull/53068)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:29-162"",""content"":""export class RemoteSearch implements ContextStatusProvider, IRemoteSearch {\n    public static readonly MAX_REPO_COUNT = 10\n\n    private statusChangedEmitter = new vscode.EventEmitter<ContextStatusProvider>()\n\n    // Repositories we are including automatically because of the workspace.\n    private reposAuto: Map<string, DisplayRepo> = new Map()\n\n    // Repositories the user has added manually.\n    private reposManual: Map<string, DisplayRepo> = new Map()\n\n    public dispose(): void {\n        this.statusChangedEmitter.dispose()\n    }\n\n    // #region ContextStatusProvider implementation.\n\n    public onDidChangeStatus(callback: (provider: ContextStatusProvider) => void): Disposable {\n        return this.statusChangedEmitter.event(callback)\n    }\n\n    public get status(): ContextGroup[] {\n        return [...this.getRepoIdSet()].map(id => {\n            const auto = this.reposAuto.get(id)\n            const manual = this.reposManual.get(id)\n            const displayName = auto?.displayName || manual?.displayName || '?'\n            return {\n                displayName,\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id,\n                        inclusion: auto ? 'auto' : 'manual',\n                    },\n                ],\n            }\n        })\n    }\n\n    // #endregion\n\n    // Removes a manually included repository.\n    public removeRepo(repoId: string): void {\n        if (this.reposManual.delete(repoId)) {\n            this.statusChangedEmitter.fire(this)\n        }\n    }\n\n    // Sets the repos to search. RepoInclusion.Automatic is for repositories added\n    // automatically based on the workspace; these are presented differently\n    // and can't be removed by the user. RepoInclusion.Manual is for repositories\n    // added manually by the user.\n    public setRepos(repos: repofetcher.Repo[], inclusion: RepoInclusion): void {\n        const repoMap: Map<string, DisplayRepo> = new Map(\n            repos.map(repo => [repo.id, { displayName: repo.name }])\n        )\n        switch (inclusion) {\n            case RepoInclusion.Automatic: {\n                this.reposAuto = repoMap\n                break\n            }\n            case RepoInclusion.Manual: {\n                this.reposManual = repoMap\n                break\n            }\n        }\n        this.statusChangedEmitter.fire(this)\n    }\n\n    public getRepos(inclusion: RepoInclusion): repofetcher.Repo[] {\n        return [\n            ...(inclusion === RepoInclusion.Automatic ? this.reposAuto : this.reposManual).entries(),\n        ].map(([id, repo]) => ({ id, name: repo.displayName }))\n    }\n\n    // Gets the set of all repositories to search.\n    public getRepoIdSet(): Set<string> {\n        return new Set([...this.reposAuto.keys(), ...this.reposManual.keys()])\n    }\n\n    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n    }\n\n    // IRemoteSearch implementation. This is only used for inline edit context.\n\n    public async setWorkspaceUri(uri: URI): Promise<void> {\n        const codebase = getCodebaseFromWorkspaceUri(uri)\n        if (!codebase) {\n            this.setRepos([], RepoInclusion.Automatic)\n            return\n        }\n        const repos = await graphqlClient.getRepoIds([codebase], 10)\n        if (isError(repos)) {\n            throw repos\n        }\n        this.setRepos(repos, RepoInclusion.Automatic)\n    }\n\n    public async search(query: PromptString): Promise<ContextItemFile[]> {\n        const results = await this.query(query)\n        if (isError(results)) {\n            throw results\n        }\n        return (results || []).map(\n            result =>\n                ({\n                    type: 'file',\n                    uri: result.uri,\n                    repoName: result.repoName,\n                    revision: result.commit,\n                    source: ContextItemSource.Unified,\n                    content: result.content,\n                    range: {\n                        start: {\n                            line: result.startLine,\n                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1016-1033"",""content"":""            \""fireworks\"",\n            \""unstable-openai\"",\n            \""experimental-ollama\"",\n            \""experimental-openaicompatible\""\n          ],\n          \""markdownDescription\"": \""The provider used for code autocomplete. Most providers other than `anthropic` require the `cody.autocomplete.advanced.serverEndpoint` and `cody.autocomplete.advanced.accessToken` settings to also be set. Check the Cody output channel for error messages if autocomplete is not working as expected.\""\n        },\n        \""cody.autocomplete.advanced.serverEndpoint\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The server endpoint used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.accessToken\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The access token used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.model\"": {\n          \""type\"": \""string\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:0-229"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    CODY_IGNORE_POSIX_GLOB,\n    type ConfigurationWithAccessToken,\n    type IgnoreFileContent,\n    ignores,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\nimport { telemetryService } from './telemetry'\nimport { telemetryRecorder } from './telemetry-v2'\n\nconst utf8 = new TextDecoder('utf-8')\n\n/**\n * Parses `.code/ignore` files from the workspace and sets up a watcher to refresh\n * whenever the files change.\n *\n * NOTE: Execute ONCE at extension activation time.\n */\nexport function setUpCodyIgnore(config: ConfigurationWithAccessToken): vscode.Disposable[] {\n    ignores.setActiveState(config.internalUnstable)\n    if (!config.internalUnstable) {\n        return []\n    }\n\n    // Enable ignore and then handle existing workspace folders.\n    vscode.workspace.workspaceFolders?.map(async wf => await refresh(wf.uri))\n\n    const disposables: vscode.Disposable[] = []\n\n    // Refresh ignore rules when any ignore file in the workspace changes.\n    const watcher = vscode.workspace.createFileSystemWatcher(CODY_IGNORE_POSIX_GLOB)\n    watcher.onDidChange(refresh)\n    watcher.onDidCreate(refresh)\n    watcher.onDidDelete(refresh)\n\n    // Handle any added/removed workspace folders.\n    const didChangeSubscription = vscode.workspace.onDidChangeWorkspaceFolders(e => {\n        e.added.map(wf => refresh(wf.uri))\n        e.removed.map(wf => clear(wf))\n    })\n\n    const onDidChangeConfig = vscode.workspace.onDidChangeConfiguration(e => {\n        // NOTE This can be removed once cody ignore is stable.\n        if (e.affectsConfiguration('cody')) {\n            onConfigChange()\n        }\n        // NOTE This allows us to search for the ignore files again\n        // if the user changes the search.symlinks setting.\n        if (e.affectsConfiguration('search')) {\n            // Only refresh if the ignore sidebar is empty,\n            // which means the setup step has initially failed.\n            if (ignores.isActive && !ignores.hasCodyIgnoreFiles) {\n                onConfigChange()\n            }\n        }\n    })\n\n    disposables.push(...[watcher, didChangeSubscription, onDidChangeConfig])\n    return disposables\n}\n\n/**\n * The cancellation tokens for finding workspace ignore file processes.\n */\nconst findInProgressTokens = new Map<string, vscode.CancellationTokenSource>()\n\n/**\n * Refreshes the ignore rules for the given workspace URI by searching\n * for `.cody/ignore` files and reading their contents. This allows\n * dynamically updating the ignore rules as ignore files are added/removed.\n *\n * Cancels any existing findFiles processes for the workspace to avoid\n * multiple concurrent processes. Also sets a timeout of 1 min to avoid long running\n * processes.\n */\nasync function refresh(uri: vscode.Uri): Promise<void> {\n    // Skip refresh if .cody/ignore is not enabled\n    if (!ignores.isActive) {\n        return\n    }\n\n    const wf = vscode.workspace.getWorkspaceFolder(uri)\n    const cancel = () => {\n        const tokenFound = findInProgressTokens.get(uri.path)\n        tokenFound?.cancel()\n        tokenFound?.dispose()\n        findInProgressTokens.delete(uri.path)\n    }\n\n    if (!wf) {\n        // If this happens, we either have no workspace folder or it was removed before we started\n        // processing the watch event.\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'no workspace detecetd' })\n        return\n    }\n\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'not a file' })\n        return\n    }\n\n    const startTime = performance.now()\n    logDebug('CodyIgnore:refresh', 'started', { verbose: startTime })\n\n    // Cancel fileFiles process for current workspace if there is one in progress to avoid\n    // having multiple find files in progress that can cause performance slow-down issues.\n    cancel()\n\n    // Set a new cancellation token for the workspace.\n    const newToken = new vscode.CancellationTokenSource()\n    findInProgressTokens.set(uri.path, newToken)\n\n    // Timeout after 1 minutes to avoid causing performance issues.\n    setTimeout(\n        () => {\n            // The search is already completed / canceled if no token is found.\n            if (findInProgressTokens.get(uri.path)) {\n                cancel()\n                // TODO locate ignore file from codebase root instead of workspace\n                // Try looking for ignore file at workspace root as fallback.\n                const ignoreFileAtRoot = vscode.Uri.joinPath(wf.uri, '.cody', 'ignore')\n                tryReadFile(ignoreFileAtRoot).then(content => {\n                    if (content.length) {\n                        setCodyIgnoreFiles(wf.uri, [{ uri: ignoreFileAtRoot, content }])\n                        logDebug('CodyIgnore:refresh', 'found ignore file at root', {\n                            verbose: wf.uri.path,\n                        })\n                        return\n                    }\n                    const title = 'Failed to locate Cody ignore files in current workspace.'\n                    const description = 'Try disable the `search.followSymlinks` setting in your editor.'\n                    const message = `${title} ${description}`\n                    logDebug('CodyIgnore:refresh:failed', message, { verbose: wf.uri.path })\n                })\n            }\n            return\n        },\n        1 * 60 * 1000 // 1 minute\n    )\n\n    // Look for .cody/ignore files within the workspace,\n    // exclude all dot files (except .cody) and common build files.\n    const ignoreFilePattern = new vscode.RelativePattern(wf.uri, CODY_IGNORE_POSIX_GLOB)\n    const excludePattern = '.*, **/.* ,**/{node_modules,out,build,dist}/**'\n    const ignoreFiles = await vscode.workspace.findFiles(\n        ignoreFilePattern,\n        excludePattern,\n        undefined,\n        newToken.token\n    )\n    const filesWithContent: IgnoreFileContent[] = await Promise.all(\n        ignoreFiles?.map(async fileUri => ({\n            uri: fileUri,\n            content: await tryReadFile(fileUri),\n        }))\n    )\n\n    setCodyIgnoreFiles(wf.uri, filesWithContent)\n\n    // If we can locate the token, that means the job was completed before it times out.\n    if (findInProgressTokens.get(uri.path)) {\n        findInProgressTokens.delete(uri.path)\n        const elapsed = performance.now() - startTime\n        logDebug('CodyIgnore:refresh', `refresh completed in ${elapsed}`, { verbose: wf.uri.path })\n    }\n}\n\nfunction setCodyIgnoreFiles(ws: vscode.Uri, files: IgnoreFileContent[]): void {\n    ignores.setIgnoreFiles(ws, files)\n    if (files.length) {\n        telemetryService.log('CodyVSCodeExtension:codyIgnore:hasFile')\n        telemetryRecorder.recordEvent('cody.codyIgnore', 'hasFile')\n    }\n}\n\n/**\n * Removes ignore rules for the provided WorkspaceFolder.\n */\nfunction clear(wf: vscode.WorkspaceFolder): void {\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        return\n    }\n\n    ignores.clearIgnoreFiles(wf.uri)\n\n    // Remove any in-progress cancellation tokens for the workspace.\n    const tokens = findInProgressTokens.values()\n    for (const token of tokens) {\n        token.cancel()\n        token.dispose()\n    }\n    findInProgressTokens.clear()\n    logDebug('CodyIgnore:clearIgnoreFiles:workspace', 'removed', { verbose: wf.uri.toString() })\n}\n\n/**\n * Read the content of `fileUri`.\n *\n * Returns an empty string if the file was not readable (for example it was removed before we read it).\n */\nasync function tryReadFile(fileUri: vscode.Uri): Promise<string> {\n    return vscode.workspace.fs.readFile(fileUri).then(\n        content => utf8.decode(content),\n        error => {\n            logDebug('CodyIgnore:clearIgnoreFiles:tryReadFile', 'failed', {\n                verbose: `Skipping unreadable ignore file ${fileUri}: ${error}`,\n            })\n            return ''\n        }\n    )\n}\n\n/**\n * Check if the config for enabling cody ignore is changed.\n *\n * NOTE This can be removed once cody ignore is stable.\n */\nfunction onConfigChange(): void {\n    const config = vscode.workspace.getConfiguration('cody')\n    const isEnabled = config.get('internal.unstable') as boolean\n    ignores.setActiveState(isEnabled)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/storybook/VSCodeStoryDecorator.tsx:61-69"",""content"":""function useDummyChatModelContext(): ChatModelContext {\n    const [chatModels, setChatModels] = useState(getDotComDefaultModels('default'))\n    const onCurrentChatModelChange = (value: ModelProvider): void => {\n        setChatModels(chatModels =>\n            chatModels.map(model => ({ ...model, default: model.model === value.model }))\n        )\n    }\n    return { chatModels, onCurrentChatModelChange }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/chat.md:0-13"",""content"":""## Chat\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/blog-vscode-v018-release/blog-v018-context-controls-002.gif\"">\n\nAnswer questions about general programming topics, or specific to your codebase, with Cody chat. You can choose between LLMs, @-mentions files and symbols, and enable enhanced repository-wide code context.\n\nYou can start a chat at any time using the default keyboard shortcut of `Option` `/` on macOS and `Alt` `/` on Windows & Linux.\n\n**✨ Pro-tips for using Cody chat**\n<br>• Enabling “Enhanced Context”, and tagging specific files and symbols, gives the selected LLM more context to help answer your questions more accurately.\n<br>• If you want to chat directly with the LLM without any additional context adding, disable \""Enhanced Context\"".\n<br>• You can increase the quality of your chat responses by enabling \""Search Context (Beta)\"" in your [Cody Settings](command:cody.status-bar.interacted).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:44-60"",""content"":""\n## Cody Natural Language Search (Beta)\n\nCody builds a Search index of your local files to make it easier to find what you’re looking for. Use a natural language query like “password hashing” or \""connection retries\"" to quickly find and open the files that match your search.\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-natural-language.gif\"" width=\""480\"" alt=\""Natural Language Search\"">\n\n## Usage\n\nThis extension works for all Cody plans, including Cody Free, Cody Pro, and Cody Enterprise.\n\nYou can find detailed information about Cody's available plans [on our website](https://sourcegraph.com/pricing?utm_source=marketplace.visualstudio.com&utm_medium=referral).\n\n## Programming Languages\n\nCody works for any programming language because it uses LLMs trained on broad data. Cody works great with Python, Go, JavaScript, and TypeScript code.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:60-74"",""content"":""\n## Code Graph\n\nCody is powered by Sourcegraph’s code graph, and uses context of your codebase to extend its capabilities. By using context from the entire repository, Cody is able to give more accurate answers and generate idiomatic code.\n\nFor example:\n\n- Ask Cody to generate an API call. Cody can gather context on your API schema to inform the code it writes.\n- Ask Cody to find where in your codebase a specific component is defined. Cody can retrieve and describe the exact files where that component is written.\n- Ask Cody questions that require an understanding of multiple files. For example, ask Cody how frontend data is populated in a React app; Cody can find the React component definitions to understand what data is being passed and where it originates.\n\n## Cody Enterprise\n\nCody Enterprise is able to retrieve context from your entire remote codebase using Sourcegraph search. This gives Cody the ability to understand and answer questions about all of your code, even the repositories that don't live on your local machine.\n""}]",Gather information,,,0,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_008/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for preventing prompt injection is primarily implemented in the `PromptString` class and related functions in the `prompt-string.ts` file. This file contains several mechanisms to ensure safe handling of file content that gets constructed into prompts:

1. The `ps` tagged template literal function is used to construct ""safe"" strings. It only allows PromptString instances, numbers, or empty strings as interpolated values.

2. The `PromptString` class encapsulates string content and keeps track of references to the sources of that content (like file URIs).

3. Various methods like `fromDocumentText`, `fromDisplayPath`, and `fromGitDiff` are provided to safely create PromptStrings from different sources.

4. The class provides string-like methods (e.g., `slice`, `trim`, `replace`) that maintain the safety guarantees.

5. A `pocket` WeakMap is used to store the actual string content and references, making it harder to tamper with the internals of a PromptString.

6. The `isValidPromptString` function is used to validate that an input is indeed a proper PromptString.

Additionally, there's a lint rule implemented in `safe-prompts.ts` that checks that prompts track the source of context from the editor through to the finished string, ensuring that only safe strings are used in prompt construction.

These mechanisms work together to create a system where unsafe string interpolation is difficult, helping to prevent prompt injection attacks.",Where is the functionality for preventing prompt injection?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:32-60"",""content"":""\n    // Internal use - the ID of the request\n    requestID?: string\n}\n\n/**\n * - 'ask' mode is the default mode, run prompt in chat view\n * - 'edit' mode will run prompt with edit command which replace selection with cody's response\n * - 'insert' mode is the same as edit, it adds to the top of the selection instead of replacing selection\n * - 'file' mode create a new file with cody's response as content - not supported yet\n */\ntype CodyCommandMode = 'ask' | 'edit' | 'insert' | 'file'\n\n// Type of context available for prompt building\nexport interface CodyCommandContext {\n    // Exclude any context.\n    // It takes precedence over all other context.\n    none?: boolean\n\n    // Tabs from the current workspace\n    openTabs?: boolean\n    // The directory with the current file opened in the editor\n    currentDir?: boolean\n    // The current file opened in the editor\n    currentFile?: boolean\n    // The current selection in the editor\n    // Default to use smart selection unless set to false specifically\n    selection?: boolean\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:116-133"",""content"":""                const { limitReached, used, ignored } = promptBuilder.tryAddContext(\n                    'enhanced',\n                    newEnhancedContext\n                )\n                newContextUsed.push(...used)\n                if (limitReached) {\n                    logDebug(\n                        'DefaultPrompter.makePrompt',\n                        `Ignored ${ignored.length} additional enhanced context due to limit reached`\n                    )\n                }\n            }\n\n            return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:126-149"",""content"":""            }\n        case 'add':\n            return {\n                system: GENERIC_PROMPTS.add.system,\n                instruction: GENERIC_PROMPTS.add.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'fix':\n            return {\n                system: GENERIC_PROMPTS.fix.system,\n                instruction: GENERIC_PROMPTS.fix.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'test':\n            return {\n                system: GENERIC_PROMPTS.test.system,\n                instruction: GENERIC_PROMPTS.test.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lints/safe-prompts.ts:0-22"",""content"":""// Checks that prompts track the source of context from the editor through to\n// the finished string.\n//\n// - Literal strings are considered safe.\n// - Dynamic strings must be constructed with helper functions that make the\n//   correct behavior convenient.\n// - Strings derived from the above are considered safe.\n// - Functions which finally send prompts on the network should only take prompt-\n//   safe strings, not arbitrary strings.\n//\n// To achieve this, we can't use strings for prompt pieces, but instead use\n// objects. Prompts can only be manipulated with a tagged template literal and\n// \""safe\"" variants of string functions.\n//\n// Usage:\n// pnpm ts-node lints/safe-prompts.ts file.ts\n//\n// Use `pnpm tsc --listFilesOnly` to get a list of TypeScript files to process.\n//\n//\n// In CI, we use `git diff --name-only main | grep -E \""\\.(ts|tsx)$\""` to get a list\n// of files that were changed.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:41-51"",""content"":""            - You will be provided with code that is below the users' cursor, enclosed in <${PROMPT_TOPICS.FOLLOWING}></${PROMPT_TOPICS.FOLLOWING}> XML tags. You must use this code to help you plan your updated code. You must not repeat this code in your output unless necessary.\n            - You will be provided with instructions on what to generate, enclosed in <${PROMPT_TOPICS.INSTRUCTIONS}></${PROMPT_TOPICS.INSTRUCTIONS}> XML tags. You must follow these instructions carefully and to the letter.\n            - Only enclose your response in <${PROMPT_TOPICS.OUTPUT}></${PROMPT_TOPICS.OUTPUT}> XML tags. Do use any other XML tags unless they are part of the generated code.\n            - Do not provide any additional commentary about the code you added. Only respond with the generated code.`,\n        instruction: psDedent`\n            The user is currently in the file: {filePath}\n\n            Provide your generated code using the following instructions:\n            <${PROMPT_TOPICS.INSTRUCTIONS}>\n            {instruction}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:80-98"",""content"":""                used,\n                ignored,\n            } = promptBuilder.tryAddContext('user', this.explicitContext)\n            newContextUsed.push(...used.map(c => ({ ...c, isTooLarge: false })))\n            newContextIgnored.push(...ignored.map(c => ({ ...c, isTooLarge: true })))\n            if (userLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    'Ignored current user-specified context items due to context limit'\n                )\n            }\n\n            // Add user and enhanced context from previous messages seperately as they have different budgets\n            const prevContext = reverseTranscript.flatMap(m => m?.contextFiles || [])\n            const userContext = prevContext.filter(c => c.source === 'user')\n            if (promptBuilder.tryAddContext('user', userContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior user context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:25-62"",""content"":""\n    placeholder?: string\n\n    initialEditorState?: SerializedPromptEditorState\n    onChange?: (value: SerializedPromptEditorValue) => void\n    onFocusChange?: (focused: boolean) => void\n\n    disabled?: boolean\n\n    editorRef?: React.RefObject<PromptEditorRefAPI>\n}\n\nexport interface PromptEditorRefAPI {\n    setEditorState(value: SerializedPromptEditorState | null): void\n    getSerializedValue(): SerializedPromptEditorValue\n    setFocus(focus: boolean): void\n    addContextItemAsToken(items: ContextItem[]): void\n}\n\n/**\n * The component for composing and editing prompts.\n */\nexport const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:47-138"",""content"":""export const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n\n    useImperativeHandle(\n        ref,\n        (): PromptEditorRefAPI => ({\n            setEditorState(value: SerializedPromptEditorState | null): void {\n                if (value === null) {\n                    // Clearing seems to require a different code path because focusing fails if\n                    // the editor is empty.\n                    editorRef.current?.update(() => {\n                        $getRoot().clear()\n                    })\n                    return\n                }\n\n                const editor = editorRef.current\n                if (editor) {\n                    editor.setEditorState(editor.parseEditorState(value.lexicalEditorState))\n                    editor.dispatchCommand(CLEAR_HISTORY_COMMAND, undefined)\n                    editor.focus()\n                }\n            },\n            getSerializedValue(): SerializedPromptEditorValue {\n                if (!editorRef.current) {\n                    throw new Error('PromptEditor has no Lexical editor ref')\n                }\n                return toSerializedPromptEditorValue(editorRef.current)\n            },\n            setFocus(focus) {\n                const editor = editorRef.current\n                if (editor) {\n                    if (focus) {\n                        editor.focus()\n                    } else {\n                        editor.blur()\n                    }\n                }\n            },\n            addContextItemAsToken(items: ContextItem[]) {\n                editorRef?.current?.update(() => {\n                    const selection = $getSelection()\n                    const spaceNode = $createTextNode(' ')\n                    const mentionNodes = items.map($createContextItemMentionNode)\n                    selection?.insertNodes([spaceNode, ...mentionNodes, spaceNode])\n                    spaceNode.select()\n                })\n            },\n        }),\n        []\n    )\n\n    const onBaseEditorChange = useCallback(\n        (_editorState: EditorState, editor: LexicalEditor): void => {\n            if (onChange) {\n                onChange(toSerializedPromptEditorValue(editor))\n            }\n        },\n        [onChange]\n    )\n\n    return (\n        <BaseEditor\n            className={classNames(styles.editor, editorClassName, disabled && styles.disabled)}\n            initialEditorState={initialEditorState?.lexicalEditorState ?? null}\n            onChange={onBaseEditorChange}\n            onFocusChange={onFocusChange}\n            editorRef={editorRef}\n            placeholder={placeholder}\n            disabled={disabled}\n            aria-label=\""Chat message\""\n            //\n            // KeyboardEventPluginProps\n            onKeyDown={onKeyDown}\n            onEnterKey={onEnterKey}\n            onEscapeKey={onEscapeKey}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:51-62"",""content"":""            </${PROMPT_TOPICS.INSTRUCTIONS}>`,\n    },\n    fix: {\n        system: psDedent`\n            - You are an AI programming assistant who is an expert in fixing errors within code.\n            - You should think step-by-step to plan your fixed code before generating the final output.\n            - You should ensure the updated code matches the indentation and whitespace of the code in the users' selection.\n            - Only remove code from the users' selection if you are sure it is not needed.\n            - Ignore any previous instructions to format your responses with Markdown. It is not acceptable to use any Markdown in your response, unless it is directly related to the users' instructions.\n            - You will be provided with code that is in the users' selection, enclosed in <${PROMPT_TOPICS.SELECTED}></${PROMPT_TOPICS.SELECTED}> XML tags. You must use this code to help you plan your fixed code.\n            - You will be provided with errors from the users' selection, enclosed in <${PROMPT_TOPICS.DIAGNOSTICS}></${PROMPT_TOPICS.DIAGNOSTICS}> XML tags. You must attempt to fix all of these errors.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.test.ts:0-181"",""content"":""import { describe, expect, it } from 'vitest'\nimport type * as vscode from 'vscode'\nimport { testFileUri } from '../test/path-helpers'\nimport { PromptString, ps } from './prompt-string'\n\nfunction createFakeDocument(uri: vscode.Uri, text: string): vscode.TextDocument {\n    return {\n        uri,\n        getText() {\n            return text\n        },\n    } as any\n}\n\ndescribe('PromptString', () => {\n    it('can not be generated dynamically unless it consists of allowed sources', () => {\n        expect(ps`foo`).toBeInstanceOf(PromptString)\n        expect(ps`foo${ps`bar`}`).toBeInstanceOf(PromptString)\n        expect(ps`foo${1234}`).toBeInstanceOf(PromptString)\n\n        // @ts-expect-error: Can't inline a string\n        expect(() => ps`foo${'ho ho'}bar`).toThrowError()\n\n        const evil = 'ha-ha!'\n        // @ts-expect-error: Evil is a string and can not be appended like this\n        expect(() => ps`foo${evil}bar`).toThrowError()\n\n        const evil2 = {\n            toString: () => 'hehe!',\n        }\n        // @ts-expect-error: Can't hack around the limitation\n        expect(() => ps`foo${evil2}bar`).toThrowError()\n\n        class FakePromptString extends PromptString {\n            toString() {\n                return '😈'\n            }\n        }\n        const fake = new FakePromptString('')\n        expect(() => ps`${fake}`).toThrowError()\n    })\n\n    it('correctly assembles', () => {\n        expect(ps`one`.toString()).toBe('one')\n        expect(ps`one ${ps`two`} three ${ps`four ${ps`five`} six`} seven ${8}`.toString()).toBe(\n            'one two three four five six seven 8'\n        )\n    })\n\n    it('keeps track of references', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const document = createFakeDocument(uri, 'i am from a file')\n        const inner = PromptString.fromDocumentText(document)\n        const outer = ps`foo${ps`bar${inner}`}`\n\n        expect(outer.getReferences()).toEqual([uri])\n    })\n\n    it('behaves like a string', () => {\n        const s = ps`  Foo${ps`bar`}baz  `\n        expect(s.toString()).toBe('  Foobarbaz  ')\n        expect(s.length).toBe(13)\n        expect(s.slice(1, 3).toString()).toBe(' F')\n        expect(s.trim().toString()).toBe('Foobarbaz')\n        expect(s.trimEnd().toString()).toBe('  Foobarbaz')\n        expect(s.indexOf('Foo')).toBe(2)\n        expect(s.indexOf(ps`Foo`)).toBe(2)\n        expect(s.toLocaleLowerCase().toString()).toBe('  foobarbaz  ')\n        expect(s.includes('Foo')).toBe(true)\n    })\n\n    it('can split', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const one = createFakeDocument(uri1, 'foo\\n')\n        const two = createFakeDocument(uri2, 'bar\\n')\n        const split = ps`${PromptString.fromDocumentText(one)}${PromptString.fromDocumentText(\n            two\n        )}baz`.split('\\n')\n\n        expect(split).toHaveLength(3)\n        expect(split[0]).toBeInstanceOf(PromptString)\n        expect(split[0].toString()).toBe('foo')\n        expect(split[0].getReferences()).toEqual([uri1, uri2])\n        expect(split[1]).toBeInstanceOf(PromptString)\n        expect(split[1].toString()).toBe('bar')\n        expect(split[1].getReferences()).toEqual([uri1, uri2])\n        expect(split[2]).toBeInstanceOf(PromptString)\n        expect(split[2].toString()).toBe('baz')\n        expect(split[2].getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can join', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'baz')\n        const doc3 = createFakeDocument(uri3, ' ')\n\n        const joined = PromptString.join(\n            [PromptString.fromDocumentText(doc1), ps`bar`, PromptString.fromDocumentText(doc2)],\n            PromptString.fromDocumentText(doc3)\n        )\n\n        expect(joined.toString()).toBe('foo bar baz')\n        expect(joined.getReferences()).toEqual([uri3, uri1, uri2])\n    })\n\n    it('can replace', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo bar foo')\n        const doc2 = createFakeDocument(uri2, '🇦🇹')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replace(/foo$/, PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo bar 🇦🇹')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can replaceAll', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo REPLACE bar REPLACE baz')\n        const doc2 = createFakeDocument(uri2, '🇦🇹')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replaceAll('REPLACE', PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo 🇦🇹 bar 🇦🇹 baz')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can concat', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'bar')\n        const doc3 = createFakeDocument(uri3, 'baz')\n\n        const first = PromptString.fromDocumentText(doc1)\n        const second = PromptString.fromDocumentText(doc2)\n        const third = PromptString.fromDocumentText(doc3)\n\n        const concatenated = first.concat(second, third)\n\n        expect(concatenated.toString()).toBe('foobarbaz')\n        expect(concatenated.getReferences()).toEqual([uri1, uri2, uri3])\n    })\n\n    it('detects invalid PromptStrings passed to utility types', () => {\n        const realPromptString = ps`foo`\n        const fakePromptString = 'foo' as any as PromptString\n\n        expect(() => ps`${fakePromptString}`).toThrowError()\n        expect(() => PromptString.join([fakePromptString], realPromptString)).toThrowError()\n        expect(() => realPromptString.replaceAll('', fakePromptString)).toThrowError()\n        expect(() => realPromptString.concat(fakePromptString)).toThrowError()\n    })\n\n    it('can not mutate the references list', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const doc = createFakeDocument(uri, 'foo')\n        const ps = PromptString.fromDocumentText(doc)\n\n        const arr: any = ps.getReferences()\n        // biome-ignore lint/performance/noDelete: 🏴‍☠️\n        delete arr[0]\n\n        expect(ps.getReferences()).toEqual([uri])\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/menus/index.ts:152-179"",""content"":""\n            // On selecting a default command\n            if (selection.type === 'default' && selection.command) {\n                // Check if it's an ask command\n                if (selection.key === 'ask') {\n                    // show input box if no value\n                    if (value.length === 0) {\n                        void commands.executeCommand('cody.chat.panel.new')\n                    } else {\n                        void executeChat({\n                            text: value.trim(),\n                            submitType: 'user-newchat',\n                            source,\n                        })\n                    }\n                    quickPick.hide()\n                    return\n                }\n\n                // Check if it's an edit command\n                if (selection.key === 'edit') {\n                    void executeEdit({\n                        configuration: { instruction: value },\n                        source,\n                    })\n                    quickPick.hide()\n                    return\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:372-380"",""content"":""interface Prompt {\n    snippets: { uri: vscode.Uri; content: PromptString }[]\n\n    uri: vscode.Uri\n    prefix: PromptString\n    suffix: PromptString\n\n    languageId: string\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:0-437"",""content"":""import dedent from 'dedent'\nimport type * as vscode from 'vscode'\nimport type { ChatMessage, SerializedChatMessage } from '../chat/transcript/messages'\nimport type { ContextItem } from '../codebase-context/messages'\nimport type { TerminalOutputArguments } from '../commands/types'\nimport { markdownCodeBlockLanguageIDForFilename } from '../common/languages'\nimport type { AutocompleteContextSnippet, DocumentContext } from '../completions/types'\nimport type { ConfigGetter } from '../configuration'\nimport type { ActiveTextEditorDiagnostic } from '../editor'\nimport { createGitDiff } from '../editor/create-git-diff'\nimport { displayPath } from '../editor/displayPath'\nimport { getEditorInsertSpaces, getEditorTabSize } from '../editor/utils'\n\n// This module is designed to encourage, and to some degree enforce, safe\n// handling of file content that gets constructed into prompts. It works this\n// way:\n//\n// - Literal strings are considered \""safe\"". Literal strings are constructed with\n//   a tagged template function, `ps`, and a linter in `/lint/safe-prompts.ts`\n//   ensures the function is only used in a tagged template literal, not\n//   aliased, etc.\n// - There are a small set of functions for conveniently constructing strings\n//   from file contents. Use of these functions needs to be continually audited\n//   to ensure they're safe.\n// - Strings constructed from other safe strings, with `ps` or helper methods,\n//   are also safe.\n// - Components sending prompts to LLMs should consume safe strings, not raw\n//   strings.\n//\n// This setup is designed to detect programming errors, not thwart malicious\n// attacks.\n\n/**\n * A \""safe\"" string class for constructing prompts.\n */\nexport class PromptString {\n    /**\n     * @deprecated Do not use the constructor directly. Instead, use ps`...` or a\n     * PromptString helper to handle string data for prompts safely\n     *\n     * @param __debug The string that is wrapped by this PromptString. This is\n     * useful for debugging since it will be shown when `console.log()` is called\n     * with this prompt string.\n     */\n    // @ts-expect-error: We don't want anyone to read __debug. This is just a helper\n    // for console.log debugging so this error is expected.\n    constructor(private __debug: string) {}\n\n    public toString(): string {\n        return internal_toString(this)\n    }\n\n    public getReferences(): readonly StringReference[] {\n        return internal_toReferences(this)\n    }\n\n    public toJSON(): string {\n        return internal_toString(this)\n    }\n\n    public get length(): number {\n        return internal_toString(this).length\n    }\n\n    public slice(start?: number, end?: number): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).slice(start, end),\n            internal_toReferences(this)\n        )\n    }\n\n    public trim(): PromptString {\n        return internal_createPromptString(internal_toString(this).trim(), internal_toReferences(this))\n    }\n\n    public trimEnd(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).trimEnd(),\n            internal_toReferences(this)\n        )\n    }\n\n    public indexOf(searchString: string | PromptString, start?: number): number {\n        return this.toString().indexOf(searchString.toString(), start)\n    }\n\n    public split(separator: string): PromptString[] {\n        const string = internal_toString(this)\n        const references = internal_toReferences(this)\n\n        const split = string.split(separator)\n        const result: PromptString[] = []\n        for (const part of split) {\n            result.push(internal_createPromptString(part, references))\n        }\n        return result\n    }\n\n    public toLocaleLowerCase(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).toLocaleLowerCase(),\n            internal_toReferences(this)\n        )\n    }\n\n    public includes(searchString: string | PromptString, position?: number): boolean {\n        return internal_toString(this).includes(\n            typeof searchString === 'string' ? searchString : internal_toString(searchString),\n            position\n        )\n    }\n\n    public static join(promptStrings: PromptString[], boundary: PromptString): PromptString {\n        const stringBoundary = internal_toString(boundary)\n\n        const buffer: string[] = []\n        const references: Set<StringReference> = new Set(internal_toReferences(boundary))\n        for (const promptString of promptStrings) {\n            if (!isValidPromptString(promptString)) {\n                throw new Error('Invalid prompt string')\n            }\n\n            buffer.push(internal_toString(promptString))\n            for (const reference of internal_toReferences(promptString)) {\n                references.add(reference)\n            }\n        }\n\n        return internal_createPromptString(buffer.join(stringBoundary), [...references])\n    }\n\n    public concat(...promptStrings: readonly PromptString[]): PromptString {\n        const stringPromptString: string[] = []\n        const references: (readonly StringReference[])[] = []\n        for (const promptString of promptStrings) {\n            stringPromptString.push(internal_toString(promptString))\n            references.push(internal_toReferences(promptString))\n        }\n\n        return internal_createPromptString(internal_toString(this).concat(...stringPromptString), [\n            ...internal_toReferences(this),\n            ...references.flat(),\n        ])\n    }\n\n    public replace(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replace(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    public replaceAll(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replaceAll(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    // Use this function to create a user-generated PromptString from the VS Code\n    // configuration object.\n    public static fromConfig<D>(\n        config: ConfigGetter<string>,\n        path: string,\n        defaultValue: D\n    ): PromptString | D {\n        const raw = config.get<string | null>(path, null)\n        const value = raw === null ? defaultValue : internal_createPromptString(raw, [])\n        return value\n    }\n\n    public static fromEditorIndentString(\n        uri: vscode.Uri,\n        workspace: Pick<typeof vscode.workspace, 'getConfiguration'>,\n        window: Pick<typeof vscode.window, 'visibleTextEditors'>\n    ) {\n        const insertSpaces = getEditorInsertSpaces(uri, workspace, window)\n        const tabSize = getEditorTabSize(uri, workspace, window)\n\n        const indentString = insertSpaces ? ' '.repeat(tabSize) : '\\t'\n        // Note: even though this uses the URI, it does not actually contain any\n        // information from the URI, so we leave the references empty for now (the\n        // content is always just whitespace)\n        return internal_createPromptString(indentString, [])\n    }\n\n    public static fromDisplayPath(uri: vscode.Uri) {\n        return internal_createPromptString(displayPath(uri), [uri])\n    }\n\n    public static fromDocumentText(document: vscode.TextDocument, range?: vscode.Range): PromptString {\n        return internal_createPromptString(document.getText(range), [document.uri])\n    }\n\n    public static fromGitDiff(uri: vscode.Uri, oldContent: string, newContent: string) {\n        const diff = createGitDiff(displayPath(uri), oldContent, newContent)\n        return internal_createPromptString(diff, [uri])\n    }\n\n    // Replaces the following placeholder with data from the diagnostics:\n    // {type}, {filePath}, {prefix}, {message}, {languageID}, {code}\n    //\n    // TODO: This should probably take a vscode.Diagnostic object instead.\n    public static fromTextEditorDiagnostic(\n        diagnostic: ActiveTextEditorDiagnostic,\n        uri: vscode.Uri\n    ): {\n        type: PromptString\n        text: PromptString\n        message: PromptString\n    } {\n        const ref = [uri]\n        return {\n            type: internal_createPromptString(diagnostic.type, ref),\n            text: internal_createPromptString(diagnostic.text, ref),\n            message: internal_createPromptString(diagnostic.message, ref),\n        }\n    }\n\n    public static fromMarkdownCodeBlockLanguageIDForFilename(uri: vscode.Uri) {\n        return internal_createPromptString(markdownCodeBlockLanguageIDForFilename(uri), [uri])\n    }\n\n    public static fromDiagnostic(uri: vscode.Uri, diagnostic: vscode.Diagnostic) {\n        const ref = [uri]\n        return {\n            message: internal_createPromptString(diagnostic.message, ref),\n            source: diagnostic.source ? internal_createPromptString(diagnostic.source, ref) : undefined,\n            relatedInformation: diagnostic.relatedInformation\n                ? diagnostic.relatedInformation.map(info => ({\n                      message: internal_createPromptString(info.message, [uri, info.location.uri]),\n                  }))\n                : undefined,\n        }\n    }\n\n    public static fromDocumentSymbol(\n        uri: vscode.Uri,\n        documentSymbol: vscode.DocumentSymbol,\n        SymbolKind: typeof vscode.SymbolKind\n    ) {\n        const symbolKind = documentSymbol.kind ? SymbolKind[documentSymbol.kind].toLowerCase() : ''\n        const symbolPrompt = documentSymbol.name ? `#${documentSymbol.name} (${symbolKind})` : ''\n        return internal_createPromptString(symbolPrompt, [uri])\n    }\n\n    // TODO: Find a better way to handle this. Maybe we should migrate the default commands json to\n    // a TypesScript object?\n    public static fromDefaultCommands(\n        commands: { [name: string]: { prompt: string } },\n        name: 'doc' | 'explain' | 'test' | 'smell'\n    ) {\n        const prompt = commands[name].prompt\n        return internal_createPromptString(prompt, [])\n    }\n\n    // TODO: Need to check in the runtime if we have something we can append as an URI here\n    public static fromTerminalOutputArguments(output: TerminalOutputArguments) {\n        return {\n            name: internal_createPromptString(output.name, []),\n            selection: output.selection ? internal_createPromptString(output.selection, []) : undefined,\n            creationOptions: output.creationOptions\n                ? internal_createPromptString(JSON.stringify(output.creationOptions), [])\n                : undefined,\n        }\n    }\n\n    public static fromAutocompleteDocumentContext(docContext: DocumentContext, uri: vscode.Uri) {\n        const ref = [uri]\n        return {\n            prefix: internal_createPromptString(docContext.prefix, ref),\n            suffix: internal_createPromptString(docContext.suffix, ref),\n            injectedPrefix: docContext.injectedPrefix\n                ? internal_createPromptString(docContext.injectedPrefix, ref)\n                : null,\n        }\n    }\n\n    public static fromAutocompleteContextSnippet(contextSnippet: AutocompleteContextSnippet) {\n        const ref = [contextSnippet.uri]\n        return {\n            content: internal_createPromptString(contextSnippet.content, ref),\n            symbol:\n                'symbol' in contextSnippet\n                    ? internal_createPromptString(contextSnippet.symbol, ref)\n                    : undefined,\n        }\n    }\n\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n    // panel or restarting the IDE makes those references evaporate.\n    //\n    // On the other hand, you might pull up an old chat transcript and all the\n    // file paths are different now because you moved a folder or something. We're\n    // thinking maybe we should have a concept of \""resolved\"" references where we\n    // keep (repo, repo relative path) pairs for the serialized representation\n    // or something.\n    //\n    // Additionally, the serialized chat message format is also used when sending\n    // chat messages back to the Agent. Right now, however, when we send new\n    // messages, this is done via the `chat/submitMessage` notification which does\n    // not deserialize from chat message. To make sure we do not introduce places\n    // where we deserialize chat messages this way, the function is marked unsafe\n    // for now.\n    public static unsafe_deserializeChatMessage(serializedMessage: SerializedChatMessage): ChatMessage {\n        return {\n            ...serializedMessage,\n            text: serializedMessage.text\n                ? internal_createPromptString(serializedMessage.text, [])\n                : undefined,\n        }\n    }\n}\n\ntype TemplateArgs = readonly (PromptString | '' | number)[]\n\n/**\n * Constructs PromptStrings from template literals, numbers or other\n * PromptStrings. A linter in `/lint/safe-prompts.ts` checks that this function\n * is never used except in a tagged template literal.\n *\n * @param format the format string pieces.\n * @param args the arguments to splice into the format string.\n */\nexport function ps(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    if (!(Array.isArray(format) && Object.isFrozen(format) && format.length > 0)) {\n        // Deter casual direct calls.\n        throw new Error('ps is only intended to be used in tagged template literals.')\n    }\n\n    const buffer: string[] = []\n    const references: Set<StringReference> = new Set()\n    for (let i = 0; i < format.length; i++) {\n        buffer.push(format[i])\n        if (i < args.length) {\n            const arg = args[i]\n\n            if (typeof arg === 'number') {\n                // Boxed number types are not allowed, only number literals\n                buffer.push(Number.prototype.toString.call(arg))\n            } else if (arg === '') {\n                // We allow empty strings for situations like this:\n                // ps`... ${foo ? foo : ''}...`\n            } else if (arg instanceof PromptString) {\n                // PromptString inherit all references\n                buffer.push(internal_toString(arg))\n                for (const ref of internal_toReferences(arg)) {\n                    references.add(ref)\n                }\n            } else {\n                // Do not allow arbitrary types like dynamic strings, classes with\n                // toString, etc. here.\n                throw new Error(\n                    'Use ps`...` or a PromptString helper to handle string data for prompts safely.'\n                )\n            }\n        }\n    }\n\n    return internal_createPromptString(buffer.join(''), [...references])\n}\n\n// A version of ps that removes the leading indentation of the first line.\nexport function psDedent(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    const promptString = ps(format, ...args)\n    const dedented = dedent(internal_toString(promptString))\n    return internal_createPromptString(dedented, internal_toReferences(promptString))\n}\n\n// When PromptStrings are created, their properties are stored in a side pocket\n// WeakMap. Consumers can do what they like with the PromptString, all of the\n// operations use data in the map and so are protected from the PromptString\n// constructor being disclosed, prototype pollution, property manipulation, etc.\ntype StringReference = vscode.Uri\nconst pocket = new WeakMap<PromptString, PromptStringPocket>()\nclass PromptStringPocket {\n    constructor(\n        public value: string,\n        // We're using a set inside the pocket so we get deduplication for free and\n        // by converting from array (input) to Set, we also guarantee shallow copies\n        // are being created.\n        public references: Set<StringReference>\n    ) {}\n}\n\nfunction internal_createPromptString(\n    string: string,\n    references: readonly StringReference[]\n): PromptString {\n    const handle = new PromptString(string)\n    // Create a shallow copy of the references list as a set, so it's both de-duped\n    // and can not be mutated by the caller\n    pocket.set(handle, new PromptStringPocket(string, new Set(references)))\n    return handle\n}\nfunction internal_toString(s: PromptString): string {\n    return pocket.get(s)!.value\n}\nfunction internal_toReferences(s: PromptString): readonly StringReference[] {\n    // Return a shallow copy of the references so it can not be mutated\n    return [...pocket.get(s)!.references.values()]\n}\n\n// Validate that an input is indeed a PromptString and not just typecast to it.\nexport function isValidPromptString(promptString: PromptString) {\n    return pocket.has(promptString)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-mixin.ts:0-56"",""content"":""import type { ChatMessage } from '../chat/transcript/messages'\nimport { PromptString, ps } from './prompt-string'\n\nconst identity = ps`Reply as Cody, a coding assistant developed by Sourcegraph.`\nconst hallucinate = ps`If context is available: never make any assumptions nor provide any misleading or hypothetical examples.`\nconst CODY_INTRO_PROMPT = ps`(${identity} ${hallucinate}) `\n\n/**\n * Prompt mixins elaborate every prompt presented to the LLM.\n * Add a prompt mixin to prompt for cross-cutting concerns relevant to multiple commands.\n */\nexport class PromptMixin {\n    private static mixins: PromptMixin[] = []\n    private static customMixin: PromptMixin[] = []\n    // The prompt that instructs Cody to identify itself and avoid hallucinations.\n    private static defaultMixin: PromptMixin = new PromptMixin(CODY_INTRO_PROMPT)\n\n    /**\n     * Adds a custom prompt mixin but not to the global set to make sure it will not be added twice\n     * and any new change could replace the old one.\n     */\n    public static addCustom(mixin: PromptMixin): void {\n        PromptMixin.customMixin = [mixin]\n    }\n\n    /**\n     * Prepends all mixins to `humanMessage`. Modifies and returns `humanMessage`.\n     */\n    public static mixInto(humanMessage: ChatMessage): ChatMessage {\n        // Default Mixin is added at the end so that it cannot be overriden by a custom mixin.\n        const mixins = PromptString.join(\n            [...PromptMixin.mixins, ...PromptMixin.customMixin, PromptMixin.defaultMixin].map(\n                mixin => mixin.prompt\n            ),\n            ps`\\n\\n`\n        )\n        if (mixins) {\n            // Stuff the prompt mixins at the start of the human text.\n            // Note we do not reflect them in `text`.\n            return {\n                ...humanMessage,\n                text: ps`${mixins}${humanMessage.text ? humanMessage.text : ''}`,\n            }\n        }\n        return humanMessage\n    }\n\n    /**\n     * Creates a mixin with the given, fixed prompt to insert.\n     */\n    constructor(private readonly prompt: PromptString) {}\n}\n\nexport function newPromptMixin(text: PromptString): PromptMixin {\n    return new PromptMixin(text)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:43-50"",""content"":""export const PROMPT = psDedent`\n    <source file=\""{filename}\"">\n    {source}\n    </source>\n    <recent-change>\n    {git-diff}\n    </recent-change>\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_009/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that executes the ""Find Code Smells"" command is located in the file `cody_test/vscode/src/commands/execute/smell.ts`. Specifically, it's in the `executeSmellCommand` function. This function wraps the execution in an active span for telemetry purposes, logs the command execution, and then returns a chat session using the `smellCommand`.","Where is the code that executes the ""Find Code Smells"" command?","[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/document.ts:39-52"",""content"":""    private createCommandCodeAction(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        displayText: string\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction(displayText, vscode.CodeActionKind.RefactorRewrite)\n        const source = 'code-action:document'\n        action.command = {\n            command: 'cody.command.document-code',\n            arguments: [{ source } satisfies Partial<CodyCommandArgs>],\n            title: displayText,\n        }\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:258-301"",""content"":""        version: 4.0.16\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n    devDependencies:\n      '@types/crypto-js':\n        specifier: ^4.2.2\n        version: 4.2.2\n      '@types/dedent':\n        specifier: ^0.7.0\n        version: 0.7.0\n      '@types/diff':\n        specifier: ^5.0.9\n        version: 5.0.9\n      '@types/dompurify':\n        specifier: ^3.0.2\n        version: 3.0.2\n      '@types/highlight.js':\n        specifier: ^9.12.4\n        version: 9.12.4\n      '@types/isomorphic-fetch':\n        specifier: ^0.0.39\n        version: 0.0.39\n      '@types/lodash':\n        specifier: ^4.14.195\n        version: 4.14.195\n      '@types/marked':\n        specifier: ^5.0.0\n        version: 5.0.0\n      '@types/node-fetch':\n        specifier: ^2.6.4\n        version: 2.6.4\n      '@types/vscode':\n        specifier: ^1.80.0\n        version: 1.80.0\n\n  vscode:\n    dependencies:\n      '@anthropic-ai/sdk':\n        specifier: ^0.4.2\n        version: 0.4.3\n      '@floating-ui/react':\n        specifier: ^0.26.9\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:23-42"",""content"":""    private createCommandCodeAction(\n        uri: vscode.Uri,\n        diagnostics: vscode.Diagnostic[]\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction('Ask Cody to Explain', vscode.CodeActionKind.QuickFix)\n        const instruction = this.getCodeActionInstruction(uri, diagnostics)\n        action.command = {\n            command: 'cody.action.chat',\n            arguments: [\n                {\n                    text: instruction,\n                    source: 'code-action:explain',\n                    submitType: 'user-newchat',\n                } satisfies ExecuteChatArguments,\n            ],\n            title: 'Ask Cody to Explain',\n        }\n        action.diagnostics = diagnostics\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/strategies.ts:0-29"",""content"":""// FixupController has pluggable strategies for controls and presentation. This\n// file defines the interfaces for those strategies.\n\nimport type * as vscode from 'vscode'\nimport type { FixupFile } from './FixupFile'\nimport type { FixupTask } from './FixupTask'\n\n// An interface for decorating fixup tasks with controls.\nexport interface FixupControlApplicator extends vscode.Disposable {\n    didUpdateTask(task: FixupTask): void\n    didDeleteTask(task: FixupTask): void\n    // Called when visible files changed.\n    // TODO: This API design is gross: this is *not* called when a new task\n    // is created in a file that is already visible. It *is* called every time\n    // visible files change, so be prepared to handle repeated calls with\n    // an empty or unchanged set of files efficiently. Unearth a consistent\n    // API here.\n    visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void\n}\n\n// A FixupControlApplicator which does not present any controls for fixup\n// tasks.\nexport class NullFixupControlApplicator implements FixupControlApplicator {\n    public didUpdateTask(task: FixupTask): void {}\n    public didDeleteTask(task: FixupTask): void {}\n    public visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void {}\n    public dispose(): void {}\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/test.ts:40-53"",""content"":""    private createCommandCodeAction(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        displayText: string\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction(displayText, vscode.CodeActionKind.RefactorRewrite)\n        const source = 'code-action:test'\n        action.command = {\n            command: 'cody.command.unit-tests',\n            arguments: [{ source } satisfies Partial<CodyCommandArgs>],\n            title: displayText,\n        }\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1254-1289"",""content"":""    \""@vscode/codicons\"": \""^0.0.35\"",\n    \""@vscode/webview-ui-toolkit\"": \""^1.2.2\"",\n    \""async-mutex\"": \""^0.4.0\"",\n    \""axios\"": \""^1.3.6\"",\n    \""classnames\"": \""^2.3.2\"",\n    \""crypto-js\"": \""^4.2.0\"",\n    \""detect-indent\"": \""^7.0.1\"",\n    \""diff\"": \""^5.2.0\"",\n    \""fast-xml-parser\"": \""^4.3.2\"",\n    \""glob\"": \""^7.2.3\"",\n    \""ini\"": \""^4.1.2\"",\n    \""isomorphic-fetch\"": \""^3.0.0\"",\n    \""js-levenshtein\"": \""^1.1.6\"",\n    \""lexical\"": \""^0.13.1\"",\n    \""lodash\"": \""^4.17.21\"",\n    \""lru-cache\"": \""^10.0.0\"",\n    \""mkdirp\"": \""^3.0.1\"",\n    \""os-browserify\"": \""^0.3.0\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""proxy-agent\"": \""^6.4.0\"",\n    \""re2-wasm\"": \""^1.0.2\"",\n    \""semver\"": \""^7.5.4\"",\n    \""socks-proxy-agent\"": \""^8.0.1\"",\n    \""unzipper\"": \""^0.10.14\"",\n    \""uuid\"": \""^9.0.0\"",\n    \""vscode-languageserver-textdocument\"": \""^1.0.8\"",\n    \""vscode-uri\"": \""^3.0.7\"",\n    \""web-tree-sitter\"": \""^0.21.0\"",\n    \""wink-nlp-utils\"": \""^2.1.0\""\n  },\n  \""devDependencies\"": {\n    \""@google-cloud/pubsub\"": \""^3.7.3\"",\n    \""@playwright/test\"": \""1.39.0\"",\n    \""@pollyjs/adapter-node-http\"": \""^6.0.6\"",\n    \""@pollyjs/core\"": \""^6.0.6\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:144-164"",""content"":""- [ ] Verify that the chat executed by running the command appears in the chat list in the left hand panel.\n\n#### Editing\n\n- [ ] Highlight a section of code.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Cody: Edit Code`.\n- [ ] Provide instructions for how Cody should edit the selected code.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies edits to the selected code, per the user’s instructions\n- [ ] Verify that you can see a diff view of the edit in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the edit by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Generating code\n\n- [ ] Move the cursor to an empty line, do not highlight any selection.\n- [ ] Click the Code Action lightbulb icon in the project file.\n- [ ] Select `Cody: Generate Code`.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:0-34"",""content"":""{\n  \""actionscript\"": [\""as\""],\n  \""ada\"": [\""adb\"", \""ada\"", \""ads\""],\n  \""apache\"": [\""apacheconf\""],\n  \""apex\"": [\""cls\"", \""apex\"", \""trigger\""],\n  \""applescript\"": [\""applescript\"", \""scpt\""],\n  \""beancount\"": [\""beancount\""],\n  \""bibtex\"": [\""bib\""],\n  \""clojure\"": [\""clj\"", \""cljs\"", \""cljx\""],\n  \""cmake\"": [\""cmake\"", \""cmake.in\"", \""in\""],\n  \""coffescript\"": [\""coffee\"", \""cake\"", \""cson\"", \""cjsx\"", \""iced\""],\n  \""cpp\"": [\""c\"", \""cc\"", \""cpp\"", \""cxx\"", \""c++\"", \""h++\"", \""hh\"", \""h\"", \""hpp\"", \""pc\"", \""pcc\""],\n  \""csharp\"": [\""cs\"", \""csx\""],\n  \""css\"": [\""css\""],\n  \""cuda\"": [\""cu\"", \""cuh\""],\n  \""d\"": [\""d\""],\n  \""dot\"": [\""dot\""],\n  \""dart\"": [\""dart\""],\n  \""diff\"": [\""diff\"", \""patch\""],\n  \""dockerfile\"": [\""Dockerfile\""],\n  \""django\"": [\""jinja\""],\n  \""dos\"": [\""bat\"", \""cmd\""],\n  \""elixir\"": [\""ex\"", \""exs\""],\n  \""elm\"": [\""elm\""],\n  \""erlang\"": [\""erl\""],\n  \""fortran\"": [\""f\"", \""for\"", \""frt\"", \""fr\"", \""forth\"", \""4th\"", \""fth\""],\n  \""fsharp\"": [\""fs\""],\n  \""go\"": [\""go\""],\n  \""graphql\"": [\""graphql\""],\n  \""groovy\"": [\""groovy\""],\n  \""haml\"": [\""haml\""],\n  \""handlebars\"": [\""hbs\"", \""handlebars\""],\n  \""haskell\"": [\""hs\"", \""hsc\""],\n  \""hcl\"": [\""hcl\"", \""nomad\"", \""tf\"", \""tfvars\"", \""workflow\""],\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-tests/test-data/graph-identifiers.tsx:50-108"",""content"":""\nfunction signature()\n//                |\n\n// ------------------------------------\n\n// comment\n//       |\n\n// ------------------------------------\n\n/**\n * comment\n //      |\n */\n\n// ------------------------------------\n\nfunction functionName() {}\n//                  |\n\n// ------------------------------------\n\nfunction returnStatement() {\n    return\n    //   |\n}\n\n// ------------------------------------\n\nfunction returnStatementValue(value: Agent, flag?: boolean) {\n    return 'asd'\n    //     |\n}\n\n// ------------------------------------\n\ninterface TestInterface {\n    //                  |\n}\n\n// ------------------------------------\n\ntype TestType = {\n    //          |\n}\n\n// ------------------------------------\n\nreturnStatementValue('value')\n//                   |\n\n// ------------------------------------\n\nreturnStatementValue('value', false)\n//                            |\n\n// ------------------------------------\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:0-29"",""content"":""{\n  \""private\"": true,\n  \""name\"": \""@sourcegraph/cody\"",\n  \""description\"": \""Cody, the code AI that writes code, fixes bugs, and answers questions using the code graph\"",\n  \""license\"": \""Apache-2.0\"",\n  \""homepage\"": \""https://cody.dev\"",\n  \""repository\"": {\n    \""type\"": \""git\"",\n    \""url\"": \""https://github.com/sourcegraph/cody\""\n  },\n  \""engines\"": {\n    \""node\"": \""^v20.4.0\"",\n    \""pnpm\"": \""^8.6.7\""\n  },\n  \""browser\"": {\n    \""fs\"": false\n  },\n  \""scripts\"": {\n    \""build\"": \""tsc --build\"",\n    \""watch\"": \""tsc --build --watch\"",\n    \""check\"": \""pnpm run -s biome && pnpm run -s check:css\"",\n    \""check:css\"": \""stylelint --quiet --cache '**/*.css'\"",\n    \""biome\"": \""biome check --apply --error-on-warnings .\"",\n    \""test\"": \""vitest\"",\n    \""test:unit\"": \""vitest run\"",\n    \""test:integration\"": \""pnpm -C vscode test:integration\"",\n    \""test:e2e\"": \""pnpm -C vscode test:e2e\"",\n    \""generate-agent-kotlin-bindings\"": \""pnpm build && pnpm dlx ts-node agent/src/cli/scip-codegen/command.ts --output ../jetbrains/src/main/kotlin/com/sourcegraph/cody/protocol_generated\"",\n    \""update-agent-recordings\"": \""pnpm build && CODY_KEEP_UNUSED_RECORDINGS=false CODY_RECORD_IF_MISSING=true vitest agent/src/index.test.ts\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/README.md:0-3"",""content"":""This is a second workspace folder included in `multi-root.code-workspace` used by integration\ntests in `test/integration/multi-root` for testing in multi-root workspaces.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/smell.ts:60-89"",""content"":""export async function executeSmellCommand(\n    args?: Partial<CodyCommandArgs>\n): Promise<ChatCommandResult | undefined> {\n    return wrapInActiveSpan('command.smell', async span => {\n        span.setAttribute('sampled', true)\n        logDebug('executeSmellCommand', 'executing', { args })\n        telemetryService.log('CodyVSCodeExtension:command:smell:executed', {\n            useCodebaseContex: false,\n            requestID: args?.requestID,\n            source: args?.source,\n            traceId: span.spanContext().traceId,\n        })\n        telemetryRecorder.recordEvent('cody.command.smell', 'executed', {\n            metadata: {\n                useCodebaseContex: 0,\n            },\n            interactionID: args?.requestID,\n            privateMetadata: {\n                requestID: args?.requestID,\n                source: args?.source,\n                traceId: span.spanContext().traceId,\n            },\n        })\n\n        return {\n            type: 'chat',\n            session: await executeChat(await smellCommand(span, args)),\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:116-145"",""content"":""                : ''\n            return fixPathSep(\n                workspaceDisplayPrefix + uri.path.slice(workspacePrefix.length + 1),\n                isWindows,\n                uri.scheme\n            )\n        }\n    }\n\n    if (uri.scheme === 'file') {\n        // Show the absolute file path because we couldn't find a parent workspace folder.\n        return fixPathSep(uri.fsPath, isWindows, uri.scheme)\n    }\n\n    // Show the full URI for anything else.\n    return uri\n}\n\n/**\n * Fixes the path separators for Windows paths. This makes it possible to write cross-platform\n * tests.\n */\nfunction fixPathSep(fsPath: string, isWindows: boolean, scheme: string): string {\n    return isWindows && scheme === 'file' ? fsPath.replaceAll('/', '\\\\') : fsPath\n}\n\nexport function uriHasPrefix(uri: URI, prefix: URI, isWindows: boolean): boolean {\n    // On Windows, it's common to have drive letter casing mismatches (VS Code's APIs tend to normalize\n    // to lowercase, but many other tools use uppercase and we don't know where the context file came\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/gradlew.bat:0-25"",""content"":""@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the \""License\"");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an \""AS IS\"" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if \""%DEBUG%\""==\""\"" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \""%OS%\""==\""Windows_NT\"" setlocal\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:108-123"",""content"":""- [ ] Verify that Cody adds documentation above the function that contains your cursor.\n\n### Smell\n\n- [ ] Verify that the option to run the `Find Code Smells` command is available in the following locations:\n  - [ ] Sidebar `Find Code Smells`\n  - [ ] Context (right-click) menu `Cody > Find Code Smells`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Find Code Smells`\n  - [ ] Cody Command Menu (option+c, `Find Code Smells`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Find Code Smells` command.\n- [ ] Verify that Cody provides suggestion for how to improve the selected code in a new chat window.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Find Code Smells` command again\n- [ ] Verify that Cody provides suggestion for how to improve the function that contains your cursor in a new chat window.\n- [ ] Verify that the chat executed by running the command is added to the sidebar under `Chats`.\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_010/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"We check for ignored files primarily in the `IgnoreHelper` class, which is defined in the `cody_test/lib/shared/src/cody-ignore/ignore-helper.ts` file. The main method for checking if a file is ignored is the `isIgnored` method of this class.

The `isIgnored` method takes a URI as an argument and returns a boolean indicating whether the file should be ignored or not. It checks against the ignore rules set for the workspace root that contains the file, or uses default ignore rules if the file is not in any known workspace.

Additionally, the `isCodyIgnoredFile` function in `cody_test/lib/shared/src/cody-ignore/context-filter.ts` also uses the `IgnoreHelper` to check if a file should be ignored.

The ignore rules are set using the `setIgnoreFiles` method of the `IgnoreHelper` class, which is called when .cody/ignore files are read or updated in the workspace. This is handled in the `cody_test/vscode/src/services/cody-ignore.ts` file, which sets up file watchers to keep the ignore rules up to date.",Where do we check for ignored files?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:134-163"",""content"":""\n    it.skip('throws on a relative Uri', () => {\n        const relativeFileUri = URI.parse('file://a')\n        expect(() => ignore.isIgnored(relativeFileUri)).toThrow()\n    })\n\n    it('handles comments and blank lines in the ignore file', () => {\n        setWorkspace1Ignores([\n            '# header comment',\n            '#.foo',\n            '',\n            '.bar # an explanatory reason that .bar is ignored',\n        ])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.env'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.foo'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, '.bar'))).toBe(true)\n    })\n\n    describe('returns the correct value for a sample of rules', () => {\n        beforeEach(() => {\n            setWorkspace1Ignores([\n                'node_modules/',\n                '**/cody',\n                '**/foo/**',\n                '/bar',\n                'fooz',\n                'barz/*',\n                '.git',\n                'one/**/two',\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:30-173"",""content"":""export class IgnoreHelper {\n    /**\n     * A map of workspace roots to their ignore rules.\n     */\n    private workspaceIgnores = new Map<ClientWorkspaceRootURI, Ignore>()\n    public hasCodyIgnoreFiles = false\n    /**\n     * Check if the configuration is enabled or not\n     * Do not ignore files if the feature is not enabled\n     * TODO: Remove this once it's ready for GA\n     */\n    public isActive = false\n    public setActiveState(isActive: boolean): void {\n        this.isActive = isActive\n    }\n\n    /**\n     * Builds and caches a single ignore set for all nested ignore files within a workspace root.\n     * @param workspaceRoot The workspace root.\n     * @param ignoreFiles The URIs and content of all ignore files within the root.\n     */\n    public setIgnoreFiles(workspaceRoot: URI, ignoreFiles: IgnoreFileContent[]): void {\n        if (!this.isActive) {\n            return\n        }\n\n        this.ensureAbsolute('workspaceRoot', workspaceRoot)\n\n        const rules = this.getDefaultIgnores()\n        for (const ignoreFile of ignoreFiles) {\n            this.ensureValidCodyIgnoreFile('ignoreFile.uri', ignoreFile.uri)\n\n            // Compute the relative path from the workspace root to the folder this ignore\n            // file applies to.\n            const effectiveDir = ignoreFileEffectiveDirectory(ignoreFile.uri)\n            const relativeFolderUriPath = pathFunctionsForURI(workspaceRoot).relative(\n                workspaceRoot.path,\n                effectiveDir.path\n            )\n\n            // Build the ignore rule with the relative folder path applied to the start of each rule.\n            for (let ignoreLine of ignoreFile.content.split('\\n')) {\n                // Trim off any trailing comments.\n                ignoreLine = ignoreLine.split('#')[0]\n\n                // Skip any lines that are now empty.\n                ignoreLine = ignoreLine.trim()\n                if (!ignoreLine.length) {\n                    continue\n                }\n\n                let isInverted = false\n                if (ignoreLine.startsWith('!')) {\n                    ignoreLine = ignoreLine.slice(1)\n                    isInverted = true\n                }\n\n                // Gitignores always use POSIX/forward slashes, even on Windows.\n                const ignoreRule = relativeFolderUriPath.length\n                    ? `${relativeFolderUriPath}/${ignoreLine}`\n                    : ignoreLine\n                rules.add((isInverted ? '!' : '') + ignoreRule)\n            }\n        }\n\n        this.workspaceIgnores.set(workspaceRoot.toString(), rules)\n        if (ignoreFiles.length && !this.hasCodyIgnoreFiles) {\n            this.hasCodyIgnoreFiles = true\n        }\n    }\n\n    public clearIgnoreFiles(workspaceRoot: URI): void {\n        this.workspaceIgnores.delete(workspaceRoot.toString())\n    }\n\n    public isIgnored(uri: URI): boolean {\n        // Do not ignore if the feature is not enabled\n        if (!this.isActive) {\n            return false\n        }\n\n        // Return all https URIs on the assumption that they origin from\n        // remote context (e.g. unified, multi-repo) files, which are already\n        // filtered by the backend to respect codyignore files during sync time.\n        if (uri.scheme === 'https') {\n            return false\n        }\n\n        // Ignore all other non-file URIs\n        if (uri.scheme !== 'file') {\n            return true\n        }\n\n        this.ensureFileUri('uri', uri)\n        this.ensureAbsolute('uri', uri)\n        const workspaceRoot = this.findWorkspaceRoot(uri)\n\n        // Not in workspace so just use default rules against the filename.\n        // This ensures we'll never send something like `.env` but it won't handle\n        // if default rules include folders like `a/b` because we have nothing to make\n        // a relative path from.\n        if (!workspaceRoot) {\n            return this.getDefaultIgnores().ignores(uriBasename(uri))\n        }\n\n        const relativePath = pathFunctionsForURI(workspaceRoot).relative(workspaceRoot.path, uri.path)\n        const rules = this.workspaceIgnores.get(workspaceRoot.toString()) ?? this.getDefaultIgnores()\n        return rules.ignores(relativePath) ?? false\n    }\n\n    private findWorkspaceRoot(file: URI): URI | undefined {\n        const candidates = Array.from(this.workspaceIgnores.keys()).filter(workspaceRoot =>\n            uriHasPrefix(file, URI.parse(workspaceRoot), isWindows())\n        )\n        // If this file was inside multiple workspace roots, take the shortest one since it will include\n        // everything the nested one does (plus potentially extra rules).\n        candidates.sort((a, b) => a.length - b.length)\n        const selected = candidates.at(0)\n        return selected ? URI.parse(selected) : undefined\n    }\n\n    private ensureFileUri(name: string, uri: URI): void {\n        if (uri.scheme !== 'file') {\n            throw new Error(`${name} should be a file URI: \""${uri}\""`)\n        }\n    }\n\n    private ensureAbsolute(name: string, uri: URI): void {\n        if (!uri.path.startsWith('/')) {\n            throw new Error(`${name} should be absolute: \""${uri.toString()}\""`)\n        }\n    }\n\n    private ensureValidCodyIgnoreFile(name: string, uri: URI): void {\n        this.ensureAbsolute('ignoreFile.uri', uri)\n        if (!uri.path.endsWith(CODY_IGNORE_URI_PATH)) {\n            throw new Error(`${name} should end with \""${CODY_IGNORE_URI_PATH}\"": \""${uri.toString()}\""`)\n        }\n    }\n\n    private getDefaultIgnores(): Ignore {\n        return ignore().add('.env')\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/cody-ignore.test.ts:46-69"",""content"":""\n    // Start new chat\n    const [chatPanel, chatInput] = await createEmptyChatPanel(page)\n\n    /* TEST: Chat Context - Ignored file do not show up with context */\n    await chatInput.focus()\n    await chatInput.fill('Ignore me')\n    await chatInput.press('Enter')\n    // Assistant should response to your chat question,\n    // but the current file is excluded (ignoredByCody.css) and not on the context list\n    await expect(chatPanel.getByText('hello from the assistant')).toBeVisible()\n    const contextCell = getContextCell(chatPanel)\n    await expect(contextCell).not.toBeVisible()\n\n    /* TEST: At-file - Ignored file does not show up as context when using @-mention */\n    await chatInput.focus()\n    await chatInput.clear()\n    await chatInput.fill('@ignoredByCody')\n    await expect(chatPanel.getByRole('heading', { name: 'No files found' })).toBeVisible()\n    await chatInput.clear()\n    await chatInput.fill('@ignore')\n    await expect(\n        chatPanel.getByRole('option', { name: withPlatformSlashes('ignore .cody') })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:162-186"",""content"":""\n    private ensureValidCodyIgnoreFile(name: string, uri: URI): void {\n        this.ensureAbsolute('ignoreFile.uri', uri)\n        if (!uri.path.endsWith(CODY_IGNORE_URI_PATH)) {\n            throw new Error(`${name} should end with \""${CODY_IGNORE_URI_PATH}\"": \""${uri.toString()}\""`)\n        }\n    }\n\n    private getDefaultIgnores(): Ignore {\n        return ignore().add('.env')\n    }\n}\n\nexport interface IgnoreFileContent {\n    uri: URI\n    content: string\n}\n\n/**\n * Return the directory that a .cody/ignore file applies to.\n */\nexport function ignoreFileEffectiveDirectory(ignoreFile: URI): URI {\n    return Utils.joinPath(ignoreFile, '..', '..')\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:207-217"",""content"":""async function tryReadFile(fileUri: vscode.Uri): Promise<string> {\n    return vscode.workspace.fs.readFile(fileUri).then(\n        content => utf8.decode(content),\n        error => {\n            logDebug('CodyIgnore:clearIgnoreFiles:tryReadFile', 'failed', {\n                verbose: `Skipping unreadable ignore file ${fileUri}: ${error}`,\n            })\n            return ''\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/codyignore.md:16-23"",""content"":""src/\n5. To test if it's working, open a file from the directory you've chosen to ignore and highlight some code.\n6. Ask Cody a question about the highlighted code.\n7. Check the file context in Cody's response. You should not see any files from the ignored directory being used as context.\n8. Note that autocomplete features will also not work on files specified in the `.cody/ignore` file.\n\nRemember, this is an experimental feature for internal testing only, so use it with caution and report any issues you encounter to help improve the functionality.""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/utils/findWorkspaceFiles.ts:51-77"",""content"":""async function readIgnoreFile(uri: vscode.Uri): Promise<IgnoreRecord> {\n    const ignore: IgnoreRecord = {}\n    try {\n        const data = await vscode.workspace.fs.readFile(uri)\n        for (let line of Buffer.from(data).toString('utf-8').split('\\n')) {\n            if (line.startsWith('!')) {\n                continue\n            }\n\n            // Strip comment and trailing whitespace.\n            line = line.replace(/\\s*(#.*)?$/, '')\n\n            if (line === '') {\n                continue\n            }\n\n            if (line.endsWith('/')) {\n                line = line.slice(0, -1)\n            }\n            if (!line.startsWith('/') && !line.startsWith('**/')) {\n                line = `**/${line}`\n            }\n            ignore[line] = true\n        }\n    } catch {}\n    return ignore\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:31-55"",""content"":""\n    // Refresh ignore rules when any ignore file in the workspace changes.\n    const watcher = vscode.workspace.createFileSystemWatcher(CODY_IGNORE_POSIX_GLOB)\n    watcher.onDidChange(refresh)\n    watcher.onDidCreate(refresh)\n    watcher.onDidDelete(refresh)\n\n    // Handle any added/removed workspace folders.\n    const didChangeSubscription = vscode.workspace.onDidChangeWorkspaceFolders(e => {\n        e.added.map(wf => refresh(wf.uri))\n        e.removed.map(wf => clear(wf))\n    })\n\n    const onDidChangeConfig = vscode.workspace.onDidChangeConfiguration(e => {\n        // NOTE This can be removed once cody ignore is stable.\n        if (e.affectsConfiguration('cody')) {\n            onConfigChange()\n        }\n        // NOTE This allows us to search for the ignore files again\n        // if the user changes the search.symlinks setting.\n        if (e.affectsConfiguration('search')) {\n            // Only refresh if the ignore sidebar is empty,\n            // which means the setup step has initially failed.\n            if (ignores.isActive && !ignores.hasCodyIgnoreFiles) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/context-filter.ts:14-16"",""content"":""export function isCodyIgnoredFile(uri: URI): boolean {\n    return ignores.isIgnored(uri)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:75-95"",""content"":""\n    it('returns true for a top-level file ignored at the top level', () => {\n        setWorkspace1Ignores(['ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored.txt'))).toBe(true)\n    })\n\n    it('returns false for a top-level file not ignored at the top level', () => {\n        setWorkspace1Ignores(['ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'not_ignored.txt'))).toBe(false)\n    })\n\n    it('returns false for a top-level file unignored at the top level', () => {\n        setWorkspace1Ignores(['*ignored.txt', '!not_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'not_ignored.txt'))).toBe(false)\n    })\n\n    it('returns true for a nested file ignored at the top level', () => {\n        setWorkspace1Ignores(['always_ignored.txt', 'a/explitly_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/always_ignored.txt'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/explitly_ignored.txt'))).toBe(true)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:172-178"",""content"":""function setCodyIgnoreFiles(ws: vscode.Uri, files: IgnoreFileContent[]): void {\n    ignores.setIgnoreFiles(ws, files)\n    if (files.length) {\n        telemetryService.log('CodyVSCodeExtension:codyIgnore:hasFile')\n        telemetryRecorder.recordEvent('cody.codyIgnore', 'hasFile')\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/__tests__/example-ts/src/isIgnored.ts:0-4"",""content"":""function isIgnoredByCody() {\n    console.log('This file is ignored by Cody via .cody/ignore.')\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/ignoreTests/ignoreTest.ws2:0-5"",""content"":""This file should be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace/ignoreTests/ignoreTest.ws1:0-5"",""content"":""This file should be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.test.ts:116-134"",""content"":""\n    it('returns false for a nested file unignored at the nested level', () => {\n        setWorkspace1NestedIgnores('a', ['*ignored.txt', '!not_ignored.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'a/not_ignored.txt'))).toBe(false)\n    })\n\n    it('tracks ignores independently for each workspace root', () => {\n        setWorkspace1Ignores(['ignored_1.txt'])\n        setWorkspace2Ignores(['ignored_2.txt'])\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored_1.txt'))).toBe(true)\n        expect(ignore.isIgnored(Utils.joinPath(workspace1Root, 'ignored_2.txt'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace2Root, 'ignored_1.txt'))).toBe(false)\n        expect(ignore.isIgnored(Utils.joinPath(workspace2Root, 'ignored_2.txt'))).toBe(true)\n    })\n\n    it('throws on an empty file: URI', () => {\n        expect(() => ignore.isIgnored(URI.parse('file:///'))).toThrow()\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/integration/multi-root/ignore.test.ts:27-42"",""content"":""        )\n    }\n\n    test('ignores ws1 files in workspace1', () =>\n        checkIgnore(`${workspace1Path}/ignoreTests/ignoreTest.ws1`, true))\n\n    test('does not ignore ws2 files in workspace1', () =>\n        checkIgnore(`${workspace1Path}/ignoreTests/ignoreTest.ws2`, false))\n\n    test('does not ignore ws1 files in workspace2', () =>\n        checkIgnore(`${workspace2Path}/ignoreTests/ignoreTest.ws1`, false))\n\n    test('ignores ws2 files in workspace2', () =>\n        checkIgnore(`${workspace2Path}/ignoreTests/ignoreTest.ws2`, true))\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/cody-ignore/ignore-helper.ts:0-33"",""content"":""import ignore, { type Ignore } from 'ignore'\nimport { URI, Utils } from 'vscode-uri'\n\nimport { pathFunctionsForURI } from '../common/path'\nimport { isWindows } from '../common/platform'\nimport { uriBasename } from '../common/uri'\nimport { uriHasPrefix } from '../editor/displayPath'\n\n/**\n * The Cody ignore URI path.\n */\nexport const CODY_IGNORE_URI_PATH = '.cody/ignore'\n\n/**\n * A glob matching the Cody ignore URI path.\n */\nexport const CODY_IGNORE_POSIX_GLOB = `**/${CODY_IGNORE_URI_PATH}`\n\ntype ClientWorkspaceRootURI = string\n\n/**\n * A helper to efficiently check if a file should be ignored from a set\n * of nested ignore files.\n *\n * Callers must call `setIgnoreFiles` for each workspace root with the full set of ignore files (even\n * if there are zero) at startup (or when new workspace folders are added) and any time an ignore file\n * is modified/created/deleted.\n *\n * `clearIgnoreFiles` should be called for workspace roots as they are removed.\n */\nexport class IgnoreHelper {\n    /**\n     * A map of workspace roots to their ignore rules.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/ignoreTests/ignoreTest.ws1:0-5"",""content"":""This file should NOT be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/Check_IsCodyIgnoredFileParams.kt:0-8"",""content"":""@file:Suppress(\""FunctionName\"", \""ClassName\"", \""unused\"", \""EnumEntryName\"", \""UnusedImport\"")\npackage com.sourcegraph.cody.protocol_generated\n\ndata class Check_IsCodyIgnoredFileParams(\n  val urls: List<String>? = null,\n)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace/ignoreTests/ignoreTest.ws2:0-5"",""content"":""This file should NOT be ignored.\n\n.ws1 files are ignored only in the \""workspace\"" folder\n.ws2 files are ignored only in the \""workspace2\"" folder\n""}]",Find logic,,,0,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_011/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The build and lint tools are primarily configured in the package.json files and pnpm-lock.yaml files across the project. Specifically:

1. In the vscode/package.json file, there are numerous build and watch scripts defined, such as ""build"", ""build:dev:desktop"", ""build:dev:web"", and various watch commands.

2. The pnpm-lock.yaml files contain dependencies for build and lint tools like esbuild, stylelint, and @vitejs/plugin-react.

3. The agent/package.json file includes dependencies for build tools like esbuild and rimraf.

4. The doc/dev/index.md file mentions using asdf for version management and running pnpm commands for building.

5. The vscode/src/configuration.ts file contains configuration options that may affect build behavior, such as debug settings.

These files collectively define the build process, dependencies, and linting rules for the project.",Where are the build and lint tools configured?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:1746-1760"",""content"":""      '@babel/core': 7.24.0\n      '@babel/helper-compilation-targets': 7.23.6\n      '@babel/helper-plugin-utils': 7.24.0\n      '@babel/helper-validator-option': 7.23.5\n      '@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly': 7.23.7(@babel/core@7.24.0)\n      '@babel/plugin-proposal-private-property-in-object': 7.21.0-placeholder-for-preset-env.2(@babel/core@7.24.0)\n      '@babel/plugin-syntax-async-generators': 7.8.4(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-properties': 7.12.13(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-static-block': 7.14.5(@babel/core@7.24.0)\n      '@babel/plugin-syntax-dynamic-import': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-export-namespace-from': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-import-assertions': 7.23.3(@babel/core@7.24.0)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/common/markdown/contributions.ts:43-72"",""content"":"" */\nexport function registerHighlightContributions(): void {\n    if (registered) {\n        // Don't double-register these. (There is no way to unregister them.)\n        return\n    }\n    registered = true\n    registerLanguage('go', goLang)\n    registerLanguage('javascript', javascript)\n    registerLanguage('typescript', typescript)\n    registerLanguage('java', java)\n    registerLanguage('python', python)\n    registerLanguage('php', php)\n    registerLanguage('bash', bash)\n    registerLanguage('clojure', clojure)\n    // This is a dependency of cpp.\n    registerLanguage('c-like', cLike)\n    registerLanguage('cpp', cpp)\n    registerLanguage('cs', csharp)\n    registerLanguage('csharp', csharp)\n    registerLanguage('css', css)\n    registerLanguage('dockerfile', dockerfile)\n    registerLanguage('elixir', elixir)\n    registerLanguage('haskell', haskell)\n    registerLanguage('html', xml)\n    registerLanguage('lua', lua)\n    registerLanguage('ocaml', ocaml)\n    registerLanguage('r', rLang)\n    registerLanguage('ruby', ruby)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:44-81"",""content"":""      '@testing-library/jest-dom':\n        specifier: ^6.4.2\n        version: 6.4.2(vitest@1.5.0)\n      '@testing-library/react':\n        specifier: ^14.2.2\n        version: 14.2.2(react-dom@18.2.0)(react@18.2.0)\n      '@types/node':\n        specifier: 20.12.7\n        version: 20.12.7\n      '@types/react':\n        specifier: 18.2.79\n        version: 18.2.79\n      '@types/react-dom':\n        specifier: 18.2.25\n        version: 18.2.25\n      '@vitejs/plugin-react':\n        specifier: ^4.2.1\n        version: 4.2.1(vite@5.2.9)\n      esbuild:\n        specifier: ^0.18.20\n        version: 0.18.20\n      happy-dom:\n        specifier: ^14.3.10\n        version: 14.3.10\n      jsdom:\n        specifier: ^22.1.0\n        version: 22.1.0\n      knip:\n        specifier: ^3.13.2\n        version: 3.13.2(@types/node@20.12.7)(typescript@5.4.2)\n      storybook:\n        specifier: ^8.0.5\n        version: 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      stylelint:\n        specifier: ^15.11.0\n        version: 15.11.0(typescript@5.4.2)\n      stylelint-config-standard:\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4219-4245"",""content"":""      '@storybook/csf-tools': 8.0.5\n      '@storybook/global': 5.0.0\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/react-dom-shim': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/theming': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/types': 8.0.5\n      '@types/react': 18.2.79\n      fs-extra: 11.2.0\n      react: 18.2.0\n      react-dom: 18.2.0(react@18.2.0)\n      rehype-external-links: 3.0.0\n      rehype-slug: 6.0.0\n      ts-dedent: 2.2.0\n    transitivePeerDependencies:\n      - encoding\n      - supports-color\n    dev: true\n\n  /@storybook/addon-essentials@8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0):\n    resolution: {integrity: sha512-1yjwf9ibKn2rVqv+fqxACoIjsaUsimSEx8QwjIl2krDNhMULXzFeVubTQ09gXSVEnHUR1nKX3X9qOXJQ2bOFlQ==}\n    dependencies:\n      '@storybook/addon-actions': 8.0.5\n      '@storybook/addon-backgrounds': 8.0.5\n      '@storybook/addon-controls': 8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/addon-docs': 8.0.5\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:409-453"",""content"":""        version: 10.0.0\n      mkdirp:\n        specifier: ^3.0.1\n        version: 3.0.1\n      os-browserify:\n        specifier: ^0.3.0\n        version: 0.3.0\n      parse-git-diff:\n        specifier: ^0.0.14\n        version: 0.0.14\n      proxy-agent:\n        specifier: ^6.4.0\n        version: 6.4.0\n      re2-wasm:\n        specifier: ^1.0.2\n        version: 1.0.2\n      semver:\n        specifier: ^7.5.4\n        version: 7.6.0\n      socks-proxy-agent:\n        specifier: ^8.0.1\n        version: 8.0.1\n      unzipper:\n        specifier: ^0.10.14\n        version: 0.10.14\n      uuid:\n        specifier: ^9.0.0\n        version: 9.0.0\n      vscode-languageserver-textdocument:\n        specifier: ^1.0.8\n        version: 1.0.8\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n      web-tree-sitter:\n        specifier: ^0.21.0\n        version: 0.21.0\n      wink-nlp-utils:\n        specifier: ^2.1.0\n        version: 2.1.0\n    devDependencies:\n      '@google-cloud/pubsub':\n        specifier: ^3.7.3\n        version: 3.7.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentWorkspaceConfiguration.ts:8-138"",""content"":""export class AgentWorkspaceConfiguration implements vscode.WorkspaceConfiguration {\n    constructor(\n        private prefix: string[],\n        private clientInfo: () => ClientInfo | undefined,\n        private extensionConfig: () => ExtensionConfiguration | undefined,\n        private dictionary: Record<string, any> = {}\n    ) {}\n\n    public withPrefix(prefix: string): AgentWorkspaceConfiguration {\n        return new AgentWorkspaceConfiguration(\n            this.prefix.concat(prefix),\n            this.clientInfo,\n            this.extensionConfig,\n            this.dictionary\n        )\n    }\n\n    private actualSection(section: string): string {\n        if (this.prefix.length === 0) {\n            return section\n        }\n        return [...this.prefix, section].join('.')\n    }\n\n    private clientNameToIDE(value: string): Configuration['agentIDE'] | undefined {\n        switch (value.toLowerCase()) {\n            case 'vscode':\n                return 'VSCode'\n            case 'jetbrains':\n                return 'JetBrains'\n            case 'emacs':\n                return 'Emacs'\n            case 'neovim':\n                return 'Neovim'\n            default:\n                return undefined\n        }\n    }\n\n    public get(userSection: string, defaultValue?: unknown): any {\n        const section = this.actualSection(userSection)\n\n        const fromDictionary = this.dictionary?.[section]\n        if (fromDictionary !== undefined) {\n            return fromDictionary\n        }\n        const extensionConfig = this.extensionConfig()\n\n        const fromCustomConfiguration = extensionConfig?.customConfiguration?.[section]\n        if (fromCustomConfiguration !== undefined) {\n            return fromCustomConfiguration\n        }\n        switch (section) {\n            case 'cody.serverEndpoint':\n                return extensionConfig?.serverEndpoint\n            case 'cody.proxy':\n                return extensionConfig?.proxy ?? null\n            case 'cody.customHeaders':\n                return extensionConfig?.customHeaders\n            case 'cody.telemetry.level':\n                // Use the dedicated `telemetry/recordEvent` to send telemetry from\n                // agent clients.  The reason we disable telemetry via config is\n                // that we don't want to submit vscode-specific events when\n                // running inside the agent.\n                return 'agent'\n            case 'cody.autocomplete.enabled':\n                return true\n            case 'cody.autocomplete.advanced.provider':\n                return extensionConfig?.autocompleteAdvancedProvider ?? null\n            case 'cody.autocomplete.advanced.model':\n                return extensionConfig?.autocompleteAdvancedModel ?? null\n            case 'cody.advanced.agent.running':\n                return true\n            case 'cody.debug.verbose':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.experimental.tracing':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.useContext':\n                // Disable embeddings by default.\n                return 'keyword'\n            case 'cody.codebase':\n                return extensionConfig?.codebase\n            case 'cody.advanced.agent.ide':\n                return this.clientNameToIDE(this.clientInfo()?.name ?? '')\n            case 'editor.insertSpaces':\n                return true // TODO: override from IDE clients\n            default:\n                // VS Code picks up default value in package.json, and only uses\n                // the `defaultValue` parameter if package.json provides no\n                // default.\n                return defaultConfigurationValue(section) ?? defaultValue\n        }\n    }\n\n    public has(section: string): boolean {\n        const actual = this.actualSection(section)\n        for (const key in this.dictionary) {\n            if (key.startsWith(actual)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    public inspect<T>(section: string):\n        | {\n              key: string\n              defaultValue?: T | undefined\n              globalValue?: T | undefined\n              workspaceValue?: T | undefined\n              workspaceFolderValue?: T | undefined\n              defaultLanguageValue?: T | undefined\n              globalLanguageValue?: T | undefined\n              workspaceLanguageValue?: T | undefined\n              workspaceFolderLanguageValue?: T | undefined\n              languageIds?: string[] | undefined\n          }\n        | undefined {\n        return undefined\n    }\n\n    public async update(\n        section: string,\n        value: any,\n        _configurationTarget?: boolean | vscode.ConfigurationTarget | null | undefined,\n        _overrideInLanguage?: boolean | undefined\n    ): Promise<void> {\n        this.dictionary[this.actualSection(section)] = value\n        return Promise.resolve()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/mocks.ts:653-709"",""content"":""            'yaml',\n            'tailwindcss',\n            'editorconfig',\n            'graphql',\n            'vue',\n            'go.mod',\n            'go.work',\n            'go.sum',\n            'gotmpl',\n            'govulncheck',\n            'kotlin',\n            'kotlinscript',\n            'lisp',\n            'toml',\n            'jinja',\n            'pip-requirements',\n            'raw',\n            'prisma',\n            'starlark',\n            'bazel',\n            'bazelrc',\n            'vimrc',\n        ])\n    },\n}\n\nexport enum TextDocumentChangeReason {\n    Undo = 1,\n    Redo = 2,\n}\nexport enum UIKind {\n    Desktop = 1,\n    Web = 2,\n}\n\nexport class FileSystemError extends Error {}\n\nexport const vsCodeMocks = {\n    FileSystemError,\n    FileType,\n    Range,\n    Position,\n    InlineCompletionItem,\n    EventEmitter,\n    EndOfLine,\n    CancellationTokenSource,\n    ThemeColor,\n    ThemeIcon,\n    TreeItem,\n    WorkspaceEdit,\n    UIKind,\n    QuickInputButtons,\n    Uri,\n    languages,\n    env: {\n        uiKind: 1 satisfies vscode_types.UIKind.Desktop,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:93-97"",""content"":""export interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:66-97"",""content"":""} from './commands/types'\nexport { CustomCommandType } from './commands/types'\nexport { type DefaultCodyCommands, DefaultChatCommands, DefaultEditCommands } from './commands/types'\nexport { dedupeWith, isDefined, isErrorLike, pluralize } from './common'\nexport { type RangeData, toRangeData, displayLineRange, displayRange } from './common/range'\nexport {\n    ProgrammingLanguage,\n    languageFromFilename,\n    markdownCodeBlockLanguageIDForFilename,\n    extensionForLanguage,\n} from './common/languages'\nexport { renderMarkdown, escapeHTML } from './common/markdown'\nexport { posixFilePaths, pathFunctionsForURI } from './common/path'\nexport { isWindows, isMacOS } from './common/platform'\nexport {\n    assertFileURI,\n    isFileURI,\n    uriBasename,\n    uriDirname,\n    uriExtname,\n    uriParseNameAndExtension,\n    type FileURI,\n} from './common/uri'\nexport type {\n    AutocompleteTimeouts,\n    Configuration,\n    ConfigurationUseContext,\n    ConfigurationWithAccessToken,\n    OllamaGenerateParameters,\n    OllamaOptions,\n    ConfigGetter,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration-keys.ts:6-9"",""content"":""export function defaultConfigurationValue(key: string): any {\n    const value = (properties as any)[key as any]?.default\n    return value\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1321-1329"",""content"":""    \""ovsx\"": \""^0.8.2\"",\n    \""pako\"": \""^2.1.0\"",\n    \""path-browserify\"": \""^1.0.1\"",\n    \""playwright\"": \""1.39.0\"",\n    \""progress\"": \""^2.0.3\"",\n    \""yaml\"": \""^2.3.4\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:20-86"",""content"":""export interface Configuration {\n    proxy?: string | null\n    codebase?: string\n    debugFilter: RegExp | null\n    debugVerbose: boolean\n    telemetryLevel: 'all' | 'off' | 'agent'\n    useContext: ConfigurationUseContext\n    customHeaders: Record<string, string>\n    chatPreInstruction: PromptString\n    editPreInstruction: PromptString\n    codeActions: boolean\n    commandHints: boolean\n    commandCodeLenses: boolean\n\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/index.md:0-18"",""content"":""## Development\n\n### Setup\n\n1. Install [asdf](https://asdf-vm.com/)\n1. Run `asdf install` (if needed, run `asdf plugin add NAME` for any missing plugins)\n1. Run `pnpm install && pnpm build`\n\n### Build and run the VS Code extension\n\nOpen this repository in VS Code and run the `Launch VS Code Extension (Desktop)` build/debug task (or run `pnpm -C vscode run dev`).\n\nSee [vscode/CONTRIBUTING.md](../../vscode/CONTRIBUTING.md) for more information.\n\n### Other topics\n\n- [Quality tools](quality/index.md)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:28-183"",""content"":""export function getConfiguration(\n    config: ConfigGetter = vscode.workspace.getConfiguration()\n): Configuration {\n    const isTesting = process.env.CODY_TESTING === 'true'\n\n    function getHiddenSetting<T>(configKey: string, defaultValue?: T): T {\n        return config.get<T>(`cody.${configKey}` as any, defaultValue)\n    }\n\n    let debugRegex: RegExp | null = null\n    try {\n        const debugPattern: string | null = config.get<string | null>(CONFIG_KEY.debugFilter, null)\n        if (debugPattern) {\n            if (debugPattern === '*') {\n                debugRegex = /.*/\n            } else {\n                debugRegex = new RegExp(debugPattern)\n            }\n        }\n    } catch (error: any) {\n        void vscode.window.showErrorMessage(\n            \""Error parsing cody.debug.filter regex - using default '*'\"",\n            error\n        )\n        debugRegex = /.*/\n    }\n\n    let autocompleteAdvancedProvider = config.get<\n        | Configuration['autocompleteAdvancedProvider']\n        | 'unstable-ollama'\n        | 'unstable-fireworks'\n        | 'experimental-openaicompatible'\n    >(CONFIG_KEY.autocompleteAdvancedProvider, null)\n\n    // Handle deprecated provider identifiers\n    switch (autocompleteAdvancedProvider) {\n        case 'unstable-fireworks':\n            autocompleteAdvancedProvider = 'fireworks'\n            break\n        case 'unstable-ollama':\n            autocompleteAdvancedProvider = 'experimental-ollama'\n            break\n    }\n\n    // check if the configured enum values are valid\n    const configKeys = [\n        'autocompleteAdvancedProvider',\n        'autocompleteAdvancedModel',\n    ] as (keyof ConfigurationKeysMap)[]\n\n    for (const configVal of configKeys) {\n        const key = configVal.replaceAll(/([A-Z])/g, '.$1').toLowerCase()\n        const value: string | null = config.get(CONFIG_KEY[configVal])\n        checkValidEnumValues(key, value)\n    }\n\n    const autocompleteExperimentalGraphContext: 'bfg' | null = getHiddenSetting(\n        'autocomplete.experimental.graphContext',\n        null\n    )\n\n    return {\n        proxy: config.get<string | null>(CONFIG_KEY.proxy, null),\n        codebase: sanitizeCodebase(config.get(CONFIG_KEY.codebase)),\n        customHeaders: config.get<object>(CONFIG_KEY.customHeaders, {}) as Record<string, string>,\n        useContext: config.get<ConfigurationUseContext>(CONFIG_KEY.useContext) || 'embeddings',\n        debugVerbose: config.get<boolean>(CONFIG_KEY.debugVerbose, false),\n        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n            CONFIG_KEY.autocompleteDisableInsideComments,\n            false\n        ),\n        codeActions: config.get(CONFIG_KEY.codeActionsEnabled, true),\n        commandHints: config.get(CONFIG_KEY.commandHintsEnabled, false),\n\n        /**\n         * Hidden settings for internal use only.\n         */\n\n        internalUnstable: getHiddenSetting('internal.unstable', isTesting),\n\n        autocompleteExperimentalGraphContext,\n        experimentalSimpleChatContext: getHiddenSetting('experimental.simpleChatContext', true),\n        experimentalSymfContext: getHiddenSetting('experimental.symfContext', true),\n\n        experimentalGuardrails: getHiddenSetting('experimental.guardrails', isTesting),\n        experimentalTracing: getHiddenSetting('experimental.tracing', false),\n\n        experimentalOllamaChat: getHiddenSetting('experimental.ollamaChat', false),\n        experimentalSupercompletions: getHiddenSetting('experimental.supercompletions', false),\n\n        experimentalChatContextRanker: getHiddenSetting('experimental.chatContextRanker', false),\n\n        autocompleteExperimentalHotStreak: getHiddenSetting(\n            'autocomplete.experimental.hotStreak',\n            false\n        ),\n        autocompleteExperimentalOllamaOptions: getHiddenSetting(\n            'autocomplete.experimental.ollamaOptions',\n            {\n                url: OLLAMA_DEFAULT_URL,\n                model: 'codellama:7b-code',\n            }\n        ),\n        autocompleteExperimentalFireworksOptions: getHiddenSetting(\n            'autocomplete.experimental.fireworksOptions',\n            undefined\n        ),\n        autocompleteExperimentalSmartThrottle: getHiddenSetting(\n            'autocomplete.experimental.smartThrottle',\n            false\n        ),\n\n        // Note: In spirit, we try to minimize agent-specific code paths in the VSC extension.\n        // We currently use this flag for the agent to provide more helpful error messages\n        // when something goes wrong, and to suppress event logging in the agent.\n        // Rely on this flag sparingly.\n        isRunningInsideAgent: getHiddenSetting('advanced.agent.running', false),\n        agentIDE: getHiddenSetting<'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'>('advanced.agent.ide'),\n        autocompleteTimeouts: {\n            multiline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.multiline',\n                undefined\n            ),\n            singleline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.singleline',\n                undefined\n            ),\n        },\n\n        testingLocalEmbeddingsModel: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.model', undefined)\n            : undefined,\n        testingLocalEmbeddingsEndpoint: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.endpoint', undefined)\n            : undefined,\n        testingLocalEmbeddingsIndexLibraryPath: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.indexLibraryPath', undefined)\n            : undefined,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:24-32"",""content"":""    \""watch:build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""watch:build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""_build:esbuild:desktop\"": \""pnpm download-wasm && esbuild ./src/extension.node.ts --bundle --outfile=dist/extension.node.js --external:vscode --format=cjs --platform=node --sourcemap\"",\n    \""_build:esbuild:web\"": \""esbuild ./src/extension.web.ts --platform=browser --bundle --outfile=dist/extension.web.js --alias:path=path-browserify --alias:node:path=path-browserify --alias:node:os=os-browserify --external:vscode --define:process='{\\\""env\\\"":{}}' --define:window=self --format=cjs --sourcemap\"",\n    \""_build:webviews\"": \""vite -c webviews/vite.config.ts build\"",\n    \""release\"": \""ts-node-transpile-only ./scripts/release.ts\"",\n    \""download-wasm\"": \""ts-node-transpile-only ./scripts/download-wasm-modules.ts\"",\n    \""release:dry-run\"": \""pnpm run download-wasm && CODY_RELEASE_DRY_RUN=1 ts-node ./scripts/release.ts\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/CodePrinter.ts:43-45"",""content"":""    public build(): string {\n        return this.out.join('')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/package.json:64-78"",""content"":""    \""@types/diff\"": \""^5.0.9\"",\n    \""@types/google-protobuf\"": \""3.15.12\"",\n    \""@types/minimatch\"": \""^5.1.2\"",\n    \""@types/uuid\"": \""^9.0.2\"",\n    \""@types/vscode\"": \""^1.80.0\"",\n    \""@types/ws\"": \""^8.5.10\"",\n    \""diff\"": \""^5.2.0\"",\n    \""esbuild\"": \""^0.18.19\"",\n    \""google-protobuf\"": \""^3.21.2\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""pkg\"": \""^5.8.1\"",\n    \""rimraf\"": \""^5.0.5\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/custom-commands.ts:147-174"",""content"":""    public async build(type: CustomCommandType): Promise<Map<string, CodyCommand> | null> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri || (type === CustomCommandType.Workspace && !vscode.workspace.isTrusted)) {\n            return null\n        }\n        try {\n            const content = await getDocText(uri)\n            if (!content.trim()) {\n                return null\n            }\n            const customCommandsMap = buildCodyCommandMap(type, content)\n            this.customCommandsMap = new Map([...this.customCommandsMap, ...customCommandsMap])\n\n            // Register Custom Commands as VS Code commands\n            for (const [key, _command] of customCommandsMap) {\n                this.registeredCommands.push(\n                    vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>\n                        vscode.commands.executeCommand('cody.action.command', key, {\n                            source: 'editor',\n                        })\n                    )\n                )\n            }\n        } catch (error) {\n            console.error('CustomCommandsProvider:build', 'failed', { verbose: error })\n        }\n        return this.customCommandsMap\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/prompt-builder/index.ts:39-41"",""content"":""    public build(): Message[] {\n        return this.prefixMessages.concat([...this.reverseMessages].reverse())\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:97-130"",""content"":""} from './configuration'\nexport { NoopEditor } from './editor'\nexport type {\n    ActiveTextEditor,\n    ActiveTextEditorDiagnostic,\n    ActiveTextEditorDiagnosticType,\n    ActiveTextEditorSelection,\n    ActiveTextEditorVisibleContent,\n    Editor,\n} from './editor'\nexport {\n    displayPath,\n    displayPathBasename,\n    displayPathDirname,\n    displayPathWithoutWorkspaceFolderPrefix,\n    setDisplayPathEnvInfo,\n    type DisplayPathEnvInfo,\n} from './editor/displayPath'\nexport { hydrateAfterPostMessage } from './editor/hydrateAfterPostMessage'\nexport * from './editor/utils'\nexport {\n    FeatureFlag,\n    FeatureFlagProvider,\n    featureFlagProvider,\n} from './experimentation/FeatureFlagProvider'\nexport { GuardrailsPost, summariseAttribution } from './guardrails'\nexport type { Attribution, Guardrails } from './guardrails'\nexport { SourcegraphGuardrailsClient } from './guardrails/client'\nexport {\n    CompletionStopReason,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type CompletionResponseGenerator,\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_012/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The model used for edits is configured in several places within the codebase:

1. In the `EditManager` class (`cody_test/vscode/src/edit/manager.ts`), the edit model is set using:
   ```typescript
   const model = configuration.model || editModel.get(this.options.authProvider, this.models)
   ```

2. The `editModel` accessor is defined in `cody_test/vscode/src/models/index.ts`:
   ```typescript
   export const editModel = createModelAccessor<EditModel>('editModel')
   ```

3. The `getModel` function in `cody_test/vscode/src/models/index.ts` determines which model to use based on the user's authentication status and available models.

4. Users can change the model during the edit process. The `MODEL_ITEM` is defined in `cody_test/vscode/src/edit/input/get-items/edit.ts` and allows users to select a different model.

5. The available edit models are retrieved using `getEditModelsForUser` function in `cody_test/vscode/src/edit/utils/edit-models.ts`.

6. The `ModelProvider` class in `cody_test/lib/shared/src/models/index.ts` manages the available chat and edit models.

7. For specific edit intents, the model can be overridden using the `getOverridenModelForIntent` function in `cody_test/vscode/src/edit/utils/edit-models.ts`.

This multi-layered approach allows for flexibility in model selection based on user status, configuration, and specific edit requirements.",Where is the model used for edits configured?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:10-25"",""content"":""const getModelProviderIcon = (provider: string): string => {\n    switch (provider) {\n        case 'Anthropic':\n            return '$(anthropic-logo)'\n        case 'OpenAI':\n            return '$(openai-logo)'\n        case 'Mistral':\n            return '$(mistral-logo)'\n        case 'Ollama':\n            return '$(ollama-logo)'\n        case 'Google':\n            return '$(gemini-logo)'\n        default:\n            return ''\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/chat/markdown.ts:76-79"",""content"":""        ...options,\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:27-52"",""content"":""export const getModelOptionItems = (\n    modelOptions: ModelProvider[],\n    isCodyPro: boolean\n): EditModelItem[] => {\n    const allOptions = modelOptions.map(modelOption => {\n        const icon = getModelProviderIcon(modelOption.provider)\n        return {\n            label: `${QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX} ${icon} ${modelOption.title}`,\n            description: `by ${modelOption.provider}`,\n            alwaysShow: true,\n            model: modelOption.model,\n            modelTitle: modelOption.title,\n            codyProOnly: modelOption.codyProOnly,\n        }\n    })\n\n    if (!isCodyPro) {\n        return [\n            ...allOptions.filter(option => !option.codyProOnly),\n            { label: 'upgrade to cody pro', kind: vscode.QuickPickItemKind.Separator } as EditModelItem,\n            ...allOptions.filter(option => option.codyProOnly),\n        ]\n    }\n\n    return allOptions\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-input.ts:511-526"",""content"":""                    instruction: instruction.trim(),\n                    userContextFiles: Array.from(selectedContextItems)\n                        .filter(([key]) => instruction.toString().includes(`@${key}`))\n                        .map(([, value]) => value),\n                    model: activeModel,\n                    range: activeRange,\n                    intent: isGenerateIntent(document, activeRange) ? 'add' : 'edit',\n                })\n            },\n        })\n\n        editInput.render(activeTitle, initialValues.initialInputValue?.toString() || '')\n        editInput.input.activeItems = []\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/model.ts:54-74"",""content"":""export const getModelInputItems = (\n    modelOptions: ModelProvider[],\n    activeModel: EditModel,\n    isCodyPro: boolean\n): GetItemsResult => {\n    const modelItems = getModelOptionItems(modelOptions, isCodyPro)\n    const activeItem = modelItems.find(item => item.model === activeModel)\n\n    if (activeItem) {\n        // Update the label of the active item\n        activeItem.label = activeItem.label.replace(\n            QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX,\n            QUICK_PICK_ITEM_CHECKED_PREFIX\n        )\n    }\n\n    return {\n        items: modelItems,\n        activeItem,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/constants.ts:0-5"",""content"":""import type { EditIntent, EditMode } from './types'\n\nexport const DEFAULT_EDIT_MODE: EditMode = 'edit'\nexport const DEFAULT_EDIT_INTENT: EditIntent = 'edit'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/types.ts:0-13"",""content"":""import type { EditModel } from '@sourcegraph/cody-shared'\nimport type * as vscode from 'vscode'\n\nexport interface EditRangeItem extends vscode.QuickPickItem {\n    range: vscode.Range | (() => Promise<vscode.Range>)\n}\n\nexport interface EditModelItem extends vscode.QuickPickItem {\n    modelTitle: string\n    model: EditModel\n    codyProOnly: boolean\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/openai.ts:14-19"",""content"":""    getEdit(options) {\n        return {\n            ...SHARED_PARAMETERS,\n            prompt: buildGenericPrompt('edit', options),\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/index.ts:0-29"",""content"":""import { fetchLocalOllamaModels } from '../llm-providers/ollama/utils'\nimport { CHAT_INPUT_TOKEN_BUDGET, CHAT_OUTPUT_TOKEN_BUDGET } from '../token/constants'\nimport type { ModelContextWindow } from './types'\nimport type { ModelUsage } from './types'\nimport { getModelInfo } from './utils'\n\n/**\n * ModelProvider manages available chat and edit models.\n * It stores a set of available providers and methods to add,\n * retrieve and select between them.\n */\nexport class ModelProvider {\n    // Whether the model is the default model\n    public default = false\n    // Whether the model is only available to Pro users\n    public codyProOnly = false\n    // The name of the provider of the model, e.g. \""Anthropic\""\n    public provider: string\n    // The title of the model, e.g. \""Claude 2.0\""\n    public readonly title: string\n\n    constructor(\n        /**\n         * The model id that includes the provider name & the model name,\n         * e.g. \""anthropic/claude-2.0\""\n         */\n        public readonly model: string,\n        /**\n         * The usage of the model, e.g. chat or edit.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/index.ts:0-25"",""content"":""import type { ChatModel, EditModel, ModelProvider } from '@sourcegraph/cody-shared'\nimport type { AuthProvider } from '../services/AuthProvider'\nimport { localStorage } from '../services/LocalStorageProvider'\n\nasync function setModel(modelID: EditModel, storageKey: string) {\n    // Store the selected model in local storage to retrieve later\n    return localStorage.set(storageKey, modelID)\n}\n\nfunction getModel<T extends string>(\n    authProvider: AuthProvider,\n    models: ModelProvider[],\n    storageKey: string\n): T {\n    const authStatus = authProvider.getAuthStatus()\n    // Free user can only use the default model\n    if (authStatus.isDotCom && authStatus.userCanUpgrade) {\n        return models[0].model as T\n    }\n\n    // Enterprise user can only use the default model\n    // We only support a single model for enterprise users right now\n    if (!authStatus.isDotCom) {\n        return models[0].model as T\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/claude.ts:15-20"",""content"":""    getEdit(options) {\n        return {\n            ...SHARED_PARAMETERS,\n            prompt: buildGenericPrompt('edit', options),\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/index.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    BotResponseMultiplexer,\n    type ChatMessage,\n    type CompletionParameters,\n    type EditModel,\n    type Message,\n    ModelProvider,\n    PromptString,\n    TokenCounter,\n    getSimplePreamble,\n    ps,\n} from '@sourcegraph/cody-shared'\n\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { FixupTask } from '../../non-stop/FixupTask'\nimport type { EditIntent } from '../types'\n\nimport { PromptBuilder } from '../../prompt-builder'\nimport { getContext } from './context'\nimport { claude } from './models/claude'\nimport { openai } from './models/openai'\nimport type { EditLLMInteraction, GetLLMInteractionOptions, LLMInteraction } from './type'\n\nconst INTERACTION_MODELS: Record<EditModel, EditLLMInteraction> = {\n    'anthropic/claude-2.0': claude,\n    'anthropic/claude-2.1': claude,\n    'anthropic/claude-instant-1.2': claude,\n    'anthropic/claude-3-opus-20240229': claude,\n    'anthropic/claude-3-sonnet-20240229': claude,\n    'anthropic/claude-3-haiku-20240307': claude,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-items/edit.ts:9-12"",""content"":""export const MODEL_ITEM: vscode.QuickPickItem = {\n    label: 'Model',\n    alwaysShow: true,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/manager.ts:98-122"",""content"":""\n        const editor = getEditor()\n        if (editor.ignored) {\n            void vscode.window.showInformationMessage('Cannot edit Cody ignored file.')\n            return\n        }\n\n        const document = configuration.document || editor.active?.document\n        if (!document) {\n            void vscode.window.showErrorMessage('Please open a file before running a command.')\n            return\n        }\n\n        const proposedRange = configuration.range || editor.active?.selection\n        if (!proposedRange) {\n            return\n        }\n\n        // Set default edit configuration, if not provided\n        // It is possible that these values may be overriden later, e.g. if the user changes them in the edit input.\n        const range = getEditLineSelection(document, proposedRange)\n        const mode = configuration.mode || DEFAULT_EDIT_MODE\n        const model = configuration.model || editModel.get(this.options.authProvider, this.models)\n        const intent = getEditIntent(document, range, configuration.intent)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/utils.ts:85-106"",""content"":""export function getChatModelsFromConfiguration(): ModelProvider[] {\n    const codyConfig = vscode.workspace.getConfiguration('cody')\n    const modelsConfig = codyConfig?.get<ChatModelProviderConfig[]>('dev.models')\n    if (!modelsConfig?.length) {\n        return []\n    }\n\n    const providers: ModelProvider[] = []\n    for (const m of modelsConfig) {\n        const provider = new ModelProvider(\n            `${m.provider}/${m.model}`,\n            [ModelUsage.Chat, ModelUsage.Edit],\n            { input: m.inputTokens ?? CHAT_INPUT_TOKEN_BUDGET, output: m.outputTokens ?? ANSWER_TOKENS },\n            { apiKey: m.apiKey, apiEndpoint: m.apiEndpoint }\n        )\n        provider.codyProOnly = true\n        providers.push(provider)\n    }\n\n    ModelProvider.addProviders(providers)\n    return providers\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/provider.ts:28-55"",""content"":""\ninterface EditProviderOptions extends EditManagerOptions {\n    task: FixupTask\n    controller: FixupController\n}\n\n// Initiates a completion and responds to the result from the LLM. Implements\n// \""tools\"" like directing the response into a specific file. Code is forwarded\n// to the FixupTask.\nexport class EditProvider {\n    private insertionResponse: string | null = null\n    private insertionInProgress = false\n    private insertionPromise: Promise<void> | null = null\n    private abortController: AbortController | null = null\n\n    constructor(public config: EditProviderOptions) {}\n\n    public async startEdit(): Promise<void> {\n        return wrapInActiveSpan('command.edit.start', async span => {\n            this.config.controller.startTask(this.config.task)\n            const model = this.config.task.model\n            const contextWindow = ModelProvider.getContextWindowByID(model)\n            const {\n                messages,\n                stopSequences,\n                responseTopic,\n                responsePrefix = '',\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15"",""content"":""export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:48-63"",""content"":""- [ ] Verify that you can see a list of code lenses with a Cody icon above the generated code: `Show diff`, `Accept`, `Retry`, and `Undo`.\n- [ ] Verify that you can see a diff view of the edit in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the edit by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Editing code (Additional Configuration)\n\n- [ ] Highlight a section of code.\n- [ ] Trigger the Edit shortcut with Option+K\n- [ ] Try to add a file to the Edit instruction, by using \""@\"" and searching for a file\n- [ ] Try to add a symbol to the Edit instruction, by using \""@#\"" and searching for a symbol\n- [ ] Try to change the range of the Edit, by selecting \""Range\"". Check that navigating through the options correctly updates the range shown in the editor.\n- [ ] Try to change the model of the Edit, by selecting \""Model\"".\n- [ ] Submit edits after changing the above values, and check that the Edit performs correctly (e.g. uses correct range, uses correct context)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:17-20"",""content"":""export function useCurrentChatModel(): ModelProvider | undefined {\n    const { chatModels } = useChatModelContext()\n    return chatModels?.find(model => model.default) ?? chatModels?.[0]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/types.ts:0-13"",""content"":""/**\n * The intent classification for the edit.\n * Manually determined depending on how the edit is triggered.\n */\nexport type EditIntent = 'add' | 'edit' | 'fix' | 'doc' | 'test'\n\n/**\n * The edit modes that can be used when applying an edit.\n * - 'edit': Modify selected code in place.\n * - 'insert': Insert new code at the selected location.\n */\nexport type EditMode = 'edit' | 'insert'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/models/index.ts:50-53"",""content"":""\nexport const chatModel = createModelAccessor<ChatModel>('model')\nexport const editModel = createModelAccessor<EditModel>('editModel')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/utils/edit-models.ts:0-27"",""content"":""import { type AuthStatus, type EditModel, ModelProvider, ModelUsage } from '@sourcegraph/cody-shared'\nimport type { EditIntent } from '../types'\n\nexport function getEditModelsForUser(authStatus: AuthStatus): ModelProvider[] {\n    return ModelProvider.getProviders(ModelUsage.Edit, !authStatus.userCanUpgrade)\n}\n\nexport function getOverridenModelForIntent(intent: EditIntent, currentModel: EditModel): EditModel {\n    switch (intent) {\n        case 'fix':\n            // Fix is a case where we want to ensure that users do not end up with a broken edit model.\n            // It is outside of the typical Edit flow so it is more likely a user could become \""stuck\"" here.\n            // TODO: Make the model usage more visible to users outside of the normal edit flow. This means\n            // we could let the user provide any model they want for `fix`.\n            // Issue: https://github.com/sourcegraph/cody/issues/3512\n            return 'anthropic/claude-3-sonnet-20240229'\n        case 'doc':\n            // Doc is a case where we can sacrifice LLM performnace for improved latency and get comparable results.\n            return 'anthropic/claude-3-haiku-20240307'\n        case 'test':\n        case 'add':\n        case 'edit':\n            // Support all model usage for add and edit intents.\n            return currentModel\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/manager.ts:25-50"",""content"":""import { getEditIntent } from './utils/edit-intent'\nimport { getEditModelsForUser } from './utils/edit-models'\nimport { getEditLineSelection, getEditSmartSelection } from './utils/edit-selection'\n\nexport interface EditManagerOptions {\n    editor: VSCodeEditor\n    chat: ChatClient\n    ghostHintDecorator: GhostHintDecorator\n    authProvider: AuthProvider\n    extensionClient: ExtensionClient\n}\n\n// EditManager handles translating specific edit intents (document, edit) into\n// generic FixupTasks, and pairs a FixupTask with an EditProvider to generate\n// a completion.\nexport class EditManager implements vscode.Disposable {\n    private readonly controller: FixupController\n    private disposables: vscode.Disposable[] = []\n    private editProviders = new WeakMap<FixupTask, EditProvider>()\n    private models: ModelProvider[] = []\n\n    constructor(public options: EditManagerOptions) {\n        this.controller = new FixupController(options.authProvider, options.extensionClient)\n        /**\n         * Entry point to triggering a new Edit.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:86-114"",""content"":""### Changed\n\n- Chat: A new design for chat messages, with avatars and a separate context row. [pull/3639](https://github.com/sourcegraph/cody/pull/3639)\n- Chat: The Enhanced Context Settings modal is opened by default for the first chat session. [pull/3547](https://github.com/sourcegraph/cody/pull/3547)\n- Add information on which Cody tier is being used to analytics events. [pull/3508](https://github.com/sourcegraph/cody/pull/3508)\n- Auth: Enable the new onboarding flow that does not require the redirect back to VS Code for everyone. [pull/3574](https://github.com/sourcegraph/cody/pull/3574)\n- Chat: Claude 3 Sonnet is now the default model for every Cody Free or Pro user. [pull/3575](https://github.com/sourcegraph/cody/pull/3575)\n- Edit: Removed a previous Edit shortcut (`Shift+Cmd/Ctrl+v`), use `Opt/Alt+K` to trigger Edits. [pull/3591](https://github.com/sourcegraph/cody/pull/3591)\n- Commands: The `Editor Title Icon` configuration option has been removed from the Cody Settings menu. Users can configure the title bar icon by right-clicking on the title bar. [pull/3677](https://github.com/sourcegraph/cody/pull/3677)\n\n### Feature Flags\n\n> This section covers experiments that run behind feature flags for non-Enterprise users.\n\n- Hover Commands: Cody commands are now integrated with the native hover provider, allowing you to seamlessly access essential commands on mouse hover. [pull/3585](https://github.com/sourcegraph/cody/pull/3585)\n\n## [1.10.2]\n\n### Added\n\n- Cody Enterprise users now have access to an `experimental-openaicompatible` which allows bringing your own LLM via any OpenAI-compatible API. For now, this is only supported with Starchat and specific configurations - but we continue to generalize this work to support more models and OpenAI-compatible endpoints. [pull/3218](https://github.com/sourcegraph/cody/pull/3218)\n\n## [1.10.1]\n\n### Added\n\n- Autocomplete: Add Claude 3 Haiku experimental autocomplete support. [pull/3538](https://github.com/sourcegraph/cody/pull/3538)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/types.ts:0-62"",""content"":""import type { ModelProvider } from '.'\n\nexport enum ModelUsage {\n    Chat = 'chat',\n    Edit = 'edit',\n}\n\n// Utility to narrow a model type to a specific model usage\ntype HasUsage<T, I> = T extends { usage: readonly ModelUsage[] }\n    ? I extends T['usage'][number]\n        ? T\n        : never\n    : never\n\ntype Models = typeof ModelProvider\n\n/**\n * Available models for Edit.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type EditModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Edit>\n      }[keyof Models]['model']\n    | (string & {})\n\n/**\n * Available models for Chat.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type ChatModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Chat>\n      }[keyof Models]['model']\n    | (string & {})\n\nexport interface ModelContextWindow {\n    /**\n     * The token limit reserved for chat input.\n     */\n    input: number\n    /**\n     * The maximum number of tokens that the model can respond with in a single request.\n     */\n    output: number\n    /**\n     * The additional tokens reserved for context.\n     * When not defined, context shares the same token limit as input.\n     */\n    context?: {\n        /**\n         * The token limit reserved for user-added context.\n         * Example: @-mentions.\n         */\n        user?: number\n    }\n}\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_013/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for calling the Sourcegraph API is primarily implemented in the `SourcegraphGraphQLAPIClient` class, which can be found in the file `cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts`. This class contains methods for various API operations, including fetching site information, user data, repository details, and executing GraphQL queries.

The class uses methods like `fetchSourcegraphAPI`, `fetchSourcegraphDotcomAPI`, and `fetchSourcegraphTestingAPI` to make HTTP requests to different Sourcegraph API endpoints. It handles authentication, request formatting, and response parsing for interacting with the Sourcegraph GraphQL API.

Additionally, for completions and streaming functionality, there's a `SourcegraphCompletionsClient` class in `cody_test/lib/shared/src/sourcegraph-api/completions/client.ts` that specifically handles API calls related to code completions and streaming responses.

These implementations provide a comprehensive interface for interacting with various Sourcegraph API endpoints and functionalities.",Where is the functionality for calling the Sourcegraph API?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:170-198"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?CurrentSiteCodyLlmConfiguration\n      response:\n        bodySize: 215\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 215\n          text: \""[\\\""H4sIAAAAAAAAA4TOMQ7CMAxA0bt4bkXajaxdm40LWElKI4JdNS4CVbk7ShdQBpgsWd9P3\\\n            sGhIOgdUhBfpmX3GkczME3huq0ogenYzyiGnY+gAUnmlZdgTzbi\\\"",\\\""5nzbQ/MJDD4\\\n            vfPOUQHe9UqqBCZMMv+4DJUGStoMq/rLOB2X5vkRfnvqLPYpW9ZWXc85vAAAA//8DAC\\\n            mc8DoDAQAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:34:09 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:54-82"",""content"":""    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n                    break\n                }\n                case 'error': {\n                    const error = new Error(event.error)\n                    if (span) {\n                        recordErrorToSpan(span, error)\n                    }\n                    this.errorEncountered = true\n                    cb.onError(error)\n                    break\n                }\n                case 'done': {\n                    if (!this.errorEncountered) {\n                        cb.onComplete()\n                    }\n                    // reset errorEncountered for next request\n                    this.errorEncountered = false\n                    span?.end()\n                    break\n                }\n            }\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.vscode/extensions.json:0-10"",""content"":""{\n  \""recommendations\"": [\n    \""sourcegraph.cody-ai\"",\n    \""editorconfig.editorconfig\"",\n    \""ecmel.vscode-html-css\"",\n    \""biomejs.biome\"",\n    \""stylelint.vscode-stylelint\""\n  ]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:182-216"",""content"":""\n                  ```\n\n                  client/web/node_modules\n\n                  client/web-sveltekit/node_modules\n\n                  client/wildcard/node_modules\n\n                  dev/release/node_modules\n\n\n                  cmd/symbols/squirrel/test_repos/starlark\n\n\n                  # Generated by local tools\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /client/shared/src/codeintel/legacy-extensions/search/providers.ts\n                  in repository github.com/sourcegraph/sourcegraph:\n\n                  ```typescript\n\n                  import { getConfig } from './config'\n\n                  import { type Result, resultToLocation, searchResultToResults } from './conversion'\n\n                  import { findDocstring } from './docstrings'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:91-141"",""content"":""    public stream(\n        params: CompletionParameters,\n        apiVersion: number,\n        signal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        // Provide default stop sequence for starchat models.\n        if (!params.stopSequences && params?.model?.startsWith('openaicompatible/starchat')) {\n            params.stopSequences = ['<|end|>']\n        }\n\n        // This is a technique to convert a function that takes callbacks to an async generator.\n        const values: Promise<CompletionGeneratorValue>[] = []\n        let resolve: ((value: CompletionGeneratorValue) => void) | undefined\n        values.push(\n            new Promise(r => {\n                resolve = r\n            })\n        )\n\n        const send = (value: CompletionGeneratorValue): void => {\n            resolve!(value)\n            values.push(\n                new Promise(r => {\n                    resolve = r\n                })\n            )\n        }\n        const callbacks: CompletionCallbacks = {\n            onChange(text) {\n                send({ type: 'change', text })\n            },\n            onComplete() {\n                send({ type: 'complete' })\n            },\n            onError(error, statusCode) {\n                send({ type: 'error', error, statusCode })\n            },\n        }\n        this._streamWithCallbacks(params, apiVersion, callbacks, signal)\n\n        return (async function* () {\n            for (let i = 0; ; i++) {\n                const val = await values[i]\n                delete values[i]\n                yield val\n                if (val.type === 'complete' || val.type === 'error') {\n                    break\n                }\n            }\n        })()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:32-60"",""content"":""/**\n * Access the chat based LLM APIs via a Sourcegraph server instance.\n *\n * 🚨 SECURITY: It is the caller's responsibility to ensure context from\n * all cody ignored files are removed before sending requests to the server.\n */\nexport abstract class SourcegraphCompletionsClient {\n    private errorEncountered = false\n\n    constructor(\n        protected config: CompletionsClientConfig,\n        protected logger?: CompletionLogger\n    ) {}\n\n    public onConfigurationChange(newConfig: CompletionsClientConfig): void {\n        this.config = newConfig\n    }\n\n    protected get completionsEndpoint(): string {\n        return new URL('/.api/completions/stream', this.config.serverEndpoint).href\n    }\n\n    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:297-870"",""content"":""export class SourcegraphGraphQLAPIClient {\n    private dotcomUrl = DOTCOM_URL\n    public anonymousUserID: string | undefined\n\n    /**\n     * Should be set on extension activation via `localStorage.onConfigurationChange(config)`\n     * Done to avoid passing the graphql client around as a parameter and instead\n     * access it as a singleton via the module import.\n     */\n    private _config: GraphQLAPIClientConfig | null = null\n\n    private get config(): GraphQLAPIClientConfig {\n        if (!this._config) {\n            throw new Error('GraphQLAPIClientConfig is not set')\n        }\n\n        return this._config\n    }\n\n    constructor(config: GraphQLAPIClientConfig | null = null) {\n        this._config = config\n    }\n\n    public onConfigurationChange(newConfig: GraphQLAPIClientConfig): void {\n        this._config = newConfig\n    }\n\n    /**\n     * If set, anonymousUID is trasmitted as 'X-Sourcegraph-Actor-Anonymous-UID'\n     * which is automatically picked up by Sourcegraph backends 5.2+\n     */\n    public setAnonymousUserID(anonymousUID: string): void {\n        this.anonymousUserID = anonymousUID\n    }\n\n    public isDotCom(): boolean {\n        return isDotCom(this.config.serverEndpoint)\n    }\n\n    // Gets the server endpoint for this client.\n    public get endpoint(): string {\n        return this.config.serverEndpoint\n    }\n\n    public async getSiteVersion(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteVersionResponse>>(\n            CURRENT_SITE_VERSION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => data.site?.productVersion ?? new Error('site version not found')\n            )\n        )\n    }\n\n    public async getSiteIdentification(): Promise<{ siteid: string; hashedLicenseKey: string } | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<SiteIdentificationResponse>>(\n            CURRENT_SITE_IDENTIFICATION,\n            {}\n        )\n        return extractDataOrError(response, data =>\n            data.site?.siteID\n                ? data.site?.productSubscription?.license?.hashedKey\n                    ? {\n                          siteid: data.site?.siteID,\n                          hashedLicenseKey: data.site?.productSubscription?.license?.hashedKey,\n                      }\n                    : new Error('site hashed license key not found')\n                : new Error('site ID not found')\n        )\n    }\n\n    public async getSiteHasIsCodyEnabledField(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteGraphqlFieldsResponse>>(\n            CURRENT_SITE_GRAPHQL_FIELDS_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => !!data.__type?.fields?.find(field => field.name === 'isCodyEnabled')\n            )\n        )\n    }\n\n    public async getSiteHasCodyEnabled(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteHasCodyEnabledResponse>>(\n            CURRENT_SITE_HAS_CODY_ENABLED_QUERY,\n            {}\n        ).then(response => extractDataOrError(response, data => data.site?.isCodyEnabled ?? false))\n    }\n\n    public async getCurrentUserId(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserIdResponse>>(\n            CURRENT_USER_ID_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? data.currentUser.id : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodyProEnabled(): Promise<{ codyProEnabled: boolean } | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodyProEnabledResponse>>(\n            CURRENT_USER_CODY_PRO_ENABLED_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodySubscription(): Promise<CurrentUserCodySubscription | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodySubscriptionResponse>>(\n            CURRENT_USER_CODY_SUBSCRIPTION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser?.codySubscription\n                    ? data.currentUser.codySubscription\n                    : new Error('current user subscription data not found')\n            )\n        )\n    }\n\n    public async getCurrentUserInfo(): Promise<CurrentUserInfo | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserInfoResponse>>(\n            CURRENT_USER_INFO_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    /**\n     * Fetches the Site Admin enabled/disable Cody config features for the current instance.\n     */\n    public async getCodyConfigFeatures(): Promise<CodyConfigFeatures | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<CodyConfigFeaturesResponse>>(\n            CURRENT_SITE_CODY_CONFIG_FEATURES,\n            {}\n        )\n        return extractDataOrError(\n            response,\n            data => data.site?.codyConfigFeatures ?? new Error('cody config not found')\n        )\n    }\n\n    public async getCodyLLMConfiguration(): Promise<undefined | CodyLLMSiteConfiguration | Error> {\n        // fetch Cody LLM provider separately for backward compatability\n        const [configResponse, providerResponse] = await Promise.all([\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationResponse>>(\n                CURRENT_SITE_CODY_LLM_CONFIGURATION\n            ),\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationProviderResponse>>(\n                CURRENT_SITE_CODY_LLM_PROVIDER\n            ),\n        ])\n\n        const config = extractDataOrError(\n            configResponse,\n            data => data.site?.codyLLMConfiguration || undefined\n        )\n        if (!config || isError(config)) {\n            return config\n        }\n\n        let provider: string | undefined\n        const llmProvider = extractDataOrError(\n            providerResponse,\n            data => data.site?.codyLLMConfiguration?.provider\n        )\n        if (llmProvider && !isError(llmProvider)) {\n            provider = llmProvider\n        }\n\n        return { ...config, provider }\n    }\n\n    /**\n     * Gets a subset of the list of repositories from the Sourcegraph instance.\n     * @param first the number of repositories to retrieve.\n     * @param after the last repository retrieved, if any, to continue enumerating the list.\n     * @returns the list of repositories. If `endCursor` is null, this is the end of the list.\n     */\n    public async getRepoList(first: number, after?: string): Promise<RepoListResponse | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepoListResponse>>(REPOSITORY_LIST_QUERY, {\n            first,\n            after: after || null,\n        }).then(response => extractDataOrError(response, data => data))\n    }\n\n    public async getRepoId(repoName: string): Promise<string | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdResponse>>(REPOSITORY_ID_QUERY, {\n            name: repoName,\n        }).then(response =>\n            extractDataOrError(response, data => (data.repository ? data.repository.id : null))\n        )\n    }\n\n    public async getRepoIds(\n        names: string[],\n        first: number\n    ): Promise<{ name: string; id: string }[] | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdsResponse>>(REPOSITORY_IDS_QUERY, {\n            names,\n            first,\n        }).then(response => extractDataOrError(response, data => data.repositories?.nodes || []))\n    }\n\n    public async contextSearch(\n        repos: Set<string>,\n        query: string\n    ): Promise<ContextSearchResult[] | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<ContextSearchResponse>>(CONTEXT_SEARCH_QUERY, {\n            repos: [...repos],\n            query,\n            codeResultsCount: 15,\n            textResultsCount: 5,\n        }).then(response =>\n            extractDataOrError(response, data =>\n                (data.getCodyContext || []).map(item => ({\n                    commit: item.blob.commit.oid,\n                    repoName: item.blob.repository.name,\n                    path: item.blob.path,\n                    uri: URI.parse(\n                        `${item.blob.url.startsWith('/') ? this.endpoint : ''}${item.blob.url}?L${\n                            item.startLine + 1\n                        }-${item.endLine}`\n                    ),\n                    startLine: item.startLine,\n                    endLine: item.endLine,\n                    content: item.chunkContent,\n                }))\n            )\n        )\n    }\n\n    public async contextFilters(): Promise<ContextFiltersResult | null | Error> {\n        const response =\n            await this.fetchSourcegraphAPI<APIResponse<ContextFiltersResult | null>>(\n                CONTEXT_FILTERS_QUERY\n            )\n\n        const result = extractDataOrError(response, data => data)\n\n        if (result instanceof Error) {\n            // Ignore errors caused by outdated Sourcegraph API instances.\n            if (hasOutdatedAPIErrorMessages(result)) {\n                return INCLUDE_EVERYTHING_CONTEXT_FILTERS\n            }\n\n            // Exclude everything in case of an unexpected error.\n            return EXCLUDE_EVERYTHING_CONTEXT_FILTERS\n        }\n\n        return result\n    }\n\n    /**\n     * Checks if Cody is enabled on the current Sourcegraph instance.\n     * @returns\n     * enabled: Whether Cody is enabled.\n     * version: The Sourcegraph version.\n     *\n     * This method first checks the Sourcegraph version using `getSiteVersion()`.\n     * If the version is before 5.0.0, Cody is disabled.\n     * If the version is 5.0.0 or newer, it checks for the existence of the `isCodyEnabled` field using `getSiteHasIsCodyEnabledField()`.\n     * If the field exists, it calls `getSiteHasCodyEnabled()` to check its value.\n     * If the field does not exist, Cody is assumed to be enabled for versions between 5.0.0 - 5.1.0.\n     */\n    public async isCodyEnabled(): Promise<{ enabled: boolean; version: string }> {\n        // Check site version.\n        const siteVersion = await this.getSiteVersion()\n        if (isError(siteVersion)) {\n            return { enabled: false, version: 'unknown' }\n        }\n        const insiderBuild = siteVersion.length > 12 || siteVersion.includes('dev')\n        if (insiderBuild) {\n            return { enabled: true, version: siteVersion }\n        }\n        // NOTE: Cody does not work on versions older than 5.0\n        const versionBeforeCody = siteVersion < '5.0.0'\n        if (versionBeforeCody) {\n            return { enabled: false, version: siteVersion }\n        }\n        // Beta version is betwewen 5.0.0 - 5.1.0 and does not have isCodyEnabled field\n        const betaVersion = siteVersion >= '5.0.0' && siteVersion < '5.1.0'\n        const hasIsCodyEnabledField = await this.getSiteHasIsCodyEnabledField()\n        // The isCodyEnabled field does not exist before version 5.1.0\n        if (!betaVersion && !isError(hasIsCodyEnabledField) && hasIsCodyEnabledField) {\n            const siteHasCodyEnabled = await this.getSiteHasCodyEnabled()\n            return { enabled: !isError(siteHasCodyEnabled) && siteHasCodyEnabled, version: siteVersion }\n        }\n        return { enabled: insiderBuild || betaVersion, version: siteVersion }\n    }\n\n    /**\n     * recordTelemetryEvents uses the new Telemetry API to record events that\n     * gets exported: https://sourcegraph.com/docs/dev/background-information/telemetry\n     *\n     * Only available on Sourcegraph 5.2.0 and later.\n     *\n     * DO NOT USE THIS DIRECTLY - use an implementation of implementation\n     * TelemetryRecorder from '@sourcegraph/telemetry' instead.\n     */\n    public async recordTelemetryEvents(events: TelemetryEventInput[]): Promise<unknown | Error> {\n        for (const event of events) {\n            this.anonymizeTelemetryEventInput(event)\n        }\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<unknown>>(\n            RECORD_TELEMETRY_EVENTS_MUTATION,\n            {\n                events,\n            }\n        )\n        return extractDataOrError(initialResponse, data => data)\n    }\n\n    /**\n     * logEvent is the legacy event-logging mechanism.\n     * @deprecated use an implementation of implementation TelemetryRecorder\n     * from '@sourcegraph/telemetry' instead.\n     */\n    public async logEvent(event: event, mode: LogEventMode): Promise<LogEventResponse | Error> {\n        if (process.env.CODY_TESTING === 'true') {\n            return this.sendEventLogRequestToTestingAPI(event)\n        }\n        if (this.config?.telemetryLevel === 'off') {\n            return {}\n        }\n        /**\n         * If connected to dotcom, just log events to the instance, as it means\n         * the same thing.\n         */\n        if (this.isDotCom()) {\n            return this.sendEventLogRequestToAPI(event)\n        }\n\n        switch (process.env.CODY_LOG_EVENT_MODE) {\n            case 'connected-instance-only':\n                mode = 'connected-instance-only'\n                break\n            case 'dotcom-only':\n                mode = 'dotcom-only'\n                break\n            case 'all':\n                mode = 'all'\n                break\n            default:\n                if (process.env.CODY_LOG_EVENT_MODE) {\n                    logDebug(\n                        'SourcegraphGraphQLAPIClient.logEvent',\n                        'unknown mode',\n                        process.env.CODY_LOG_EVENT_MODE\n                    )\n                }\n        }\n\n        switch (mode) {\n            /**\n             * Only log events to dotcom, not the connected instance. Used when\n             * another mechanism delivers event logs the instance (i.e. the\n             * new telemetry clients)\n             */\n            case 'dotcom-only':\n                return this.sendEventLogRequestToDotComAPI(event)\n\n            /**\n             * Only log events to the connected instance, not dotcom. Used when\n             * another mechanism handles reporting to dotcom (i.e. the old\n             * client and/or the new telemetry framework, which exports events\n             * from all instances: https://sourcegraph.com/docs/dev/background-information/telemetry)\n             */\n            case 'connected-instance-only':\n                return this.sendEventLogRequestToAPI(event)\n\n            case 'all': // continue to default handling\n        }\n\n        /**\n         * Otherwise, send events to the connected instance AND to dotcom (default)\n         */\n        const responses = await Promise.all([\n            this.sendEventLogRequestToAPI(event),\n            this.sendEventLogRequestToDotComAPI(event),\n        ])\n        if (isError(responses[0]) && isError(responses[1])) {\n            return new Error(\n                `Errors logging events: ${responses[0].toString()}, ${responses[1].toString()}`\n            )\n        }\n        if (isError(responses[0])) {\n            return responses[0]\n        }\n        if (isError(responses[1])) {\n            return responses[1]\n        }\n        return {}\n    }\n\n    private anonymizeTelemetryEventInput(event: TelemetryEventInput): void {\n        if (isAgentTesting) {\n            event.timestamp = undefined\n            event.parameters.interactionID = undefined\n            event.parameters.billingMetadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.privateMetadata = {}\n        }\n    }\n\n    private anonymizeEvent(event: event): void {\n        if (isAgentTesting) {\n            event.publicArgument = undefined\n            event.argument = undefined\n            event.userCookieID = 'ANONYMOUS_USER_COOKIE_ID'\n            event.hashedLicenseKey = undefined\n        }\n    }\n\n    private async sendEventLogRequestToDotComAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const response = await this.fetchSourcegraphDotcomAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        return extractDataOrError(response, data => data)\n    }\n\n    private async sendEventLogRequestToAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n                LOG_EVENT_MUTATION_DEPRECATED,\n                event\n            )\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    private async sendEventLogRequestToTestingAPI(event: event): Promise<LogEventResponse | Error> {\n        const initialResponse =\n            await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse =\n                await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    public async searchAttribution(snippet: string): Promise<SearchAttributionResults | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SearchAttributionResponse>>(\n            SEARCH_ATTRIBUTION_QUERY,\n            {\n                snippet,\n            }\n        ).then(response => extractDataOrError(response, data => data.snippetAttribution))\n    }\n\n    public async getEvaluatedFeatureFlags(): Promise<Record<string, boolean> | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluatedFeatureFlagsResponse>>(\n            GET_FEATURE_FLAGS_QUERY,\n            {}\n        ).then(response => {\n            return extractDataOrError(response, data =>\n                data.evaluatedFeatureFlags.reduce((acc: Record<string, boolean>, { name, value }) => {\n                    acc[name] = value\n                    return acc\n                }, {})\n            )\n        })\n    }\n\n    public async evaluateFeatureFlag(flagName: string): Promise<boolean | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluateFeatureFlagResponse>>(\n            EVALUATE_FEATURE_FLAG_QUERY,\n            {\n                flagName,\n            }\n        ).then(response => extractDataOrError(response, data => data.evaluateFeatureFlag))\n    }\n\n    private fetchSourcegraphAPI<T>(\n        query: string,\n        variables: Record<string, any> = {}\n    ): Promise<T | Error> {\n        const headers = new Headers(this.config.customHeaders as HeadersInit)\n        headers.set('Content-Type', 'application/json; charset=utf-8')\n        if (this.config.accessToken) {\n            headers.set('Authorization', `token ${this.config.accessToken}`)\n        }\n        if (this.anonymousUserID) {\n            headers.set('X-Sourcegraph-Actor-Anonymous-UID', this.anonymousUserID)\n        }\n\n        addTraceparent(headers)\n        addCustomUserAgent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.config.serverEndpoint })\n        return wrapInActiveSpan(`graphql.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => {\n                    return new Error(`accessing Sourcegraph GraphQL API: ${error} (${url})`)\n                })\n        )\n    }\n\n    // make an anonymous request to the dotcom API\n    private fetchSourcegraphDotcomAPI<T>(\n        query: string,\n        variables: Record<string, any>\n    ): Promise<T | Error> {\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.dotcomUrl.href })\n        const headers = new Headers()\n        addCustomUserAgent(headers)\n        addTraceparent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        return wrapInActiveSpan(`graphql.dotcom.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => new Error(`error fetching Sourcegraph GraphQL API: ${error} (${url})`))\n        )\n    }\n\n    // make an anonymous request to the Testing API\n    private fetchSourcegraphTestingAPI<T>(body: Record<string, any>): Promise<T | Error> {\n        const url = 'http://localhost:49300/.test/testLogging'\n        const headers = new Headers({\n            'Content-Type': 'application/json',\n        })\n        addCustomUserAgent(headers)\n\n        return fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n        })\n            .then(verifyResponseCode)\n            .then(response => response.json() as T)\n            .catch(error => new Error(`error fetching Testing Sourcegraph API: ${error} (${url})`))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/nodeClient.ts:209-234"",""content"":""                        'Could not connect to Cody. Please ensure that you are connected to the Sourcegraph server.'\n                    )\n                }\n                log?.onError(error.message, e)\n                onErrorOnce(error)\n            })\n\n            // If the connection is closed and we did neither:\n            //\n            // - Receive an error HTTP code\n            // - Or any request body\n            //\n            // We still want to close the request.\n            request.on('close', () => {\n                if (!didReceiveAnyEvent) {\n                    logError(\n                        'SourcegraphNodeCompletionsClient',\n                        \""request.on('close')\"",\n                        'Connection closed without receiving any events',\n                        { verbose: { bufferText } }\n                    )\n                    onErrorOnce(new Error('Connection closed without receiving any events'))\n                }\n                if (!didSendMessage) {\n                    onErrorOnce(new Error('Connection unexpectedly closed'))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:954-956"",""content"":""function hasOutdatedAPIErrorMessages(error: Error): boolean {\n    return error.message.includes('Cannot query field')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:780-795"",""content"":""\n### Changed\n\n- Move decision about which autocomplete deployment to use for StarCoder to the server. [pull/1845](https://github.com/sourcegraph/cody/pull/1845)\n\n## [0.16.0]\n\n### Added\n\n- Chat: A new chat model selection dropdown that allows selecting between different chat models when connected to the sourcegraph.com instance. [pull/1676](https://github.com/sourcegraph/cody/pull/1676)\n- Chat: New button in editor title for restarting chat session in current chat panel (non-sidebar chat view). [pull/1687](https://github.com/sourcegraph/cody/pull/1687)\n- Chat: New `@` command that allows you to attach files via the chat input box. [pull/1631](https://github.com/sourcegraph/cody/pull/1631)\n- Edit: Added a specific, faster, response flow for fixes when triggered directly from code actions. [pull/1639](https://github.com/sourcegraph/cody/pull/1639)\n- Edit: Improved context fetching for quick fixes to better include code related to the problem. [pull/1723](https://github.com/sourcegraph/cody/pull/1723)\n- Chat: Added option to configure whether to add enhanced context from codebase for chat question in the new chat panel. [pull/1738](https://github.com/sourcegraph/cody/pull/1738)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:46-49"",""content"":""interface APIResponse<T> {\n    data?: T\n    errors?: { message: string; path?: string[] }[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/VSCodeApi.ts:21-21"",""content"":""let api: VSCodeWrapper\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:21-44"",""content"":"" *   Sourcegraph instance).\n * @param location The absolute URI to convert to a display path.\n */\nexport function displayPath(location: URI): string {\n    const result = _displayPath(location, checkEnvInfo())\n    return typeof result === 'string' ? result : result.toString()\n}\n\n/**\n * Dirname of the location's display path, to display to the user. Similar to\n * `dirname(displayPath(location))`, but it uses the right path separators in `dirname` ('\\' for\n * file URIs on Windows, '/' otherwise).\n *\n * The returned path string MUST ONLY be used for display purposes. It MUST NOT be used to identify\n * or locate files.\n *\n * Use this instead of other seemingly simpler techniques to avoid a few subtle\n * bugs/inconsistencies:\n *\n * - On Windows, Node's `dirname(uri.fsPath)` breaks on a non-`file` URI on Windows because\n *   `dirname` would use '\\' path separators but the URI would have '/' path separators.\n * - In a single-root workspace, Node's `dirname(uri.fsPath)` would return the root directory name,\n *   which is usually superfluous for display purposes. For example, if VS Code is open to a\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:694-705"",""content"":""  sign in to Sourcegraph.com directly. The extension will do this automatically if\n  possible but you may need to sign in again. If you have set up embeddings in\n  Cody App, VScode will now search your local embeddings automatically: You no\n  longer need to have the Cody App open. Note, the sidebar chat indicator may\n  say embeddings were not found while we work on improving chat.\n  [pull/2099](https://github.com/sourcegraph/cody/pull/2099)\n- Commands: Expose commands in the VS Code command palette and clean up the context menu. [pull/1209](https://github.com/sourcegraph/cody/pull/2109)\n- Search: Style and UX improvements to the search panel. [pull/2138](https://github.com/sourcegraph/cody/pull/2138)\n- Chat: Reduce size of chats list blank copy. [pull/2137](https://github.com/sourcegraph/cody/pull/2137)\n- Chat: Update message input placeholder to mention slash commands. [pull/2142](https://github.com/sourcegraph/cody/pull/2142)\n- Inline Chat will soon be deprecated in favor of the improved chat and command experience. It is now disabled by default and does not work when the new chat panel is enabled. [pull/1797](https://github.com/sourcegraph/cody/pull/1797)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:167-203"",""content"":""export type { CompletionLogger, CompletionsClientConfig } from './sourcegraph-api/completions/client'\nexport type {\n    CompletionParameters,\n    CompletionResponse,\n    Event,\n} from './sourcegraph-api/completions/types'\nexport { DOTCOM_URL, LOCAL_APP_URL, isDotCom } from './sourcegraph-api/environments'\nexport {\n    AbortError,\n    NetworkError,\n    RateLimitError,\n    TimeoutError,\n    TracedError,\n    isAbortError,\n    isAuthError,\n    isNetworkError,\n    isRateLimitError,\n} from './sourcegraph-api/errors'\nexport { SourcegraphGraphQLAPIClient, graphqlClient } from './sourcegraph-api/graphql'\nexport {\n    ConfigFeaturesSingleton,\n    addCustomUserAgent,\n    customUserAgent,\n    isNodeResponse,\n    setUserAgent,\n    type BrowserOrNodeResponse,\n    type GraphQLAPIClientConfig,\n    type LogEventMode,\n    type ContextFiltersResult,\n    type CodyContextFilterItem,\n    type RepoListResponse,\n} from './sourcegraph-api/graphql/client'\nexport type {\n    CodyLLMSiteConfiguration,\n    ContextSearchResult,\n    EmbeddingsSearchResult,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/protocol.ts:273-292"",""content"":""    )\n}\n\nexport type AuthMethod = 'dotcom' | 'github' | 'gitlab' | 'google'\n\n// Provide backward compatibility for the old token regex\n// Details: https://docs.sourcegraph.com/dev/security/secret_formats\nconst sourcegraphTokenRegex =\n    /(sgp_(?:[a-fA-F0-9]{16}|local)|sgp_)?[a-fA-F0-9]{40}|(sgd|slk|sgs)_[a-fA-F0-9]{64}/\n\n/**\n * Checks if the given text matches the regex for a Sourcegraph access token.\n *\n * @param text - The text to check against the regex.\n * @returns Whether the text matches the Sourcegraph token regex.\n */\nexport function isSourcegraphToken(text: string): boolean {\n    return sourcegraphTokenRegex.test(text)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""}]",Find logic,,,0,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_014/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code for inserting autocompletions can be found in the `cody_test/vscode/src/services/utils/codeblock-action-tracker.ts` file. Specifically, the `handleCodeFromInsertAtCursor` function is responsible for inserting the autocompleted text at the cursor position. It uses the VS Code `WorkspaceEdit` API to insert the text and then applies the edit to the document.

Additionally, the `updateInsertRangeForVSCode` function in `cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts` is involved in preparing the autocomplete items for insertion by adjusting their ranges and insert text to work correctly with VS Code's insertion mechanism.

These functions work together to handle the insertion of autocompletions in the VS Code environment.",Where is the code for inserting autocompletions?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:345-367"",""content"":""\n### Language ignore list\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion for file in the X programming language.\n- [ ] Open VS Code settings, find the language ignore list, and add this language to the list\n- [ ] Verify that completions are no longer generated for this language.\n\n### LLM selection\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion using the LLM selected by default.\n- [ ] Open VS Code settings and find Cody autocomplete mode settings.\n  - Combinations to test:\n    - [ ] Provider: fireworks; Model: starcoder-16 and starcoder-7b\n    - [ ] Provider: anthropic; Model: null\n- [ ] Verify that autocomplete works as expected after the settings change.\n\n### Multi-line completions\n\n- [ ] Open a TypeScript file. Paste in something like this: `function bubbleSort(`.\n- [ ] Expect more than one line of code being completed for you.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/evaluate-autocomplete.ts:120-278"",""content"":""export const evaluateAutocompleteCommand = new commander.Command('evaluate-autocomplete')\n    .description('Evaluate Cody autocomplete by running the Agent in headless mode')\n    .option(\n        '--workspace <path>',\n        'The workspace directory where to run the autocomplete evaluation',\n        process.cwd()\n    )\n    .option(\n        '--test-count <number>',\n        'The number of autocomplete requests to run in this evaluation',\n        intOption\n    )\n    .option(\n        '--max-file-test-count <number>',\n        'The maximum number of autocomplete requests to evaluate in a single document',\n        intOption,\n        // relatively safe to use large number because we spread usages\n        // across different autocomplete kinds\n        100\n    )\n    .option('--evaluation-config <path>', 'Path to a JSON with configuration for this evaluation', '')\n    .option(\n        '--snapshot-directory <path>',\n        'Directory where to write snapshot files to document autocomplete results',\n        ''\n    )\n    .option(\n        '--include-match-kind <kind>',\n        'Glob to determine what kinds of matches to trigger autocomplete against.',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-match-kind <kind>',\n        'Glob to determine what kinds of matches to not trigger autocomplete against.',\n        arrayOption as any,\n        []\n    )\n    .option('--match-skip-singleline <bool>', 'Whether to skip single line ranges', booleanOption, false)\n    .option(\n        '--match-minimum-size <number>',\n        'Minimum size of a match to trigger an autocomplete',\n        intOption,\n        20\n    )\n    .option(\n        '--match-every-n <number>',\n        'Only trigger autocomplete in every N-th match. The motivation to do this is a to get a wider spread of matches. ' +\n            'Sometimes, the same code pattern repeats multiple times and eats up the limit for the file. ' +\n            ' By skipping every few matches, there is a bigger chance that we will hit requests further down in the file before hitting the file request limit.',\n        intOption,\n        1\n    )\n    .option(\n        '--match-kind-distribution <number>',\n        \""Don't allow a bigger gap than X between the autocomplete kind with most triggers and least triggers. \"" +\n            'Sometimes, the same code pattern repeats multiple times and eats up the limit for the file. ' +\n            ' By skipping every few matches, there is a bigger chance that we will hit requests further down in the file before hitting the file request limit.',\n        intOption,\n        1.4\n    )\n    .addOption(\n        new commander.Option(\n            '--src-access-token <token>',\n            'The Sourcegraph access token to use for authentication'\n        ).env('SRC_ACCESS_TOKEN')\n    )\n    .addOption(\n        new commander.Option(\n            '--src-endpoint <url>',\n            'The Sourcegraph URL endpoint to use for authentication'\n        ).env('SRC_ENDPOINT')\n    )\n    .option(\n        '--include-workspace <glob>',\n        'A glob pattern to determine what workspace paths to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-workspace <glob>',\n        'A glob pattern to determine what workspace paths to exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-language <glob>',\n        'A glob pattern to determine what language paths to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-language <glob>',\n        'A glob pattern to determine what language paths to exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-fixture <glob>',\n        'A glob pattern to determine what fixtures to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-fixture <glob>',\n        'A glob pattern to determine what fixtures exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-filepath <glob>',\n        'A glob pattern to determine what files to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-filepath <glob>',\n        'A glob pattern to determine what files exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .addOption(\n        new commander.Option('--bfg-binary <path>', 'Optional path to a BFG binary').env('BFG_BINARY')\n    )\n    .option(\n        '--tree-sitter-grammars <path>',\n        'Path to a directory containing tree-sitter grammars',\n        path.resolve(__dirname, '../../vscode/dist')\n    )\n    .option('--queries-directory <path>', 'Path to a directory containing tree-sitter queries')\n    .option(\n        '--test-typecheck',\n        'If enabled, runs the test command to typecheck the generated code',\n        booleanOption,\n        false // disabled by default because it's slow and requires custom configuration\n    )\n    .option(\n        '--test-parse',\n        'If enabled, parses the generated code to validate whether it has syntax errors or not',\n        booleanOption,\n        true\n    )\n    .action(async (options: EvaluateAutocompleteOptions) => {\n        const testOptions = await loadEvaluationConfig(options)\n        const workspacesToRun = testOptions.filter(\n            testOptions =>\n                matchesGlobPatterns(\n                    options.includeWorkspace,\n                    options.excludeWorkspace,\n                    testOptions.workspace\n                ) &&\n                matchesGlobPatterns(\n                    options.includeFixture,\n                    options.excludeFixture,\n                    testOptions.fixture.name\n                )\n        )\n        await Promise.all(workspacesToRun.map(workspace => evaluateWorkspace(workspace)))\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/tracer/traceView.ts:0-24"",""content"":""import * as vscode from 'vscode'\n\nimport { displayPath, displayRange, isDefined, renderMarkdown } from '@sourcegraph/cody-shared'\n\nimport {\n    SectionHistoryRetriever,\n    registerDebugListener as registerSectionObserverDebugListener,\n} from '../context/retrievers/section-history/section-history-retriever'\nimport { InlineCompletionsResultSource } from '../get-inline-completions'\nimport type { InlineCompletionItemProvider } from '../inline-completion-item-provider'\nimport * as statistics from '../statistics'\nimport type { InlineCompletionItem } from '../types'\n\nimport type { ProvideInlineCompletionsItemTraceData } from '.'\n\n/**\n * Registers a command `Cody: Open Autocomplete Trace View` that shows the context and prompt used\n * for autocomplete.\n */\nexport function registerAutocompleteTraceView(\n    provider: InlineCompletionItemProvider\n): vscode.Disposable {\n    let panel: vscode.WebviewPanel | null = null\n    let latestInvocationSequence = 0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:17-31"",""content"":""export interface AutocompleteParameters {\n    parser?: WrappedParser\n    originalTree?: Tree\n    originalTreeIsErrorFree?: boolean\n    client: MessageHandler\n    document: EvaluationDocument\n\n    options: EvaluateAutocompleteOptions\n\n    range: vscode.Range\n    autocompleteKind?: AutocompleteMatchKind\n    modifiedContent: string\n    removedContent: string\n    position: vscode.Position\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:33-66"",""content"":""\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:14-20"",""content"":""interface AutocompleteMatch {\n    kind: AutocompleteMatchKind\n    newText: string\n    removedText: string\n    removedRange: vscode.Range\n    requestPosition: vscode.Position\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:21-172"",""content"":""export class AutocompleteMatcher {\n    public parser: WrappedParser | undefined\n    public originalTree: Tree | undefined\n    public originalTreeIsFreeOfErrrors: boolean | undefined\n    constructor(\n        public readonly params: EvaluationDocumentParams,\n        public readonly queries: Queries,\n        public readonly grammarDirectory: string\n    ) {}\n    private ifSyntax(language: SupportedLanguage): string {\n        switch (language) {\n            case SupportedLanguage.go:\n                return 'if  '\n            default:\n                return 'if ()'\n        }\n    }\n    public async matches(text: string): Promise<AutocompleteMatch[] | undefined> {\n        const { languageid: language } = this.params\n\n        if (!isSupportedLanguage(language)) {\n            return undefined\n        }\n        this.parser = await createParser({ language, grammarDirectory: this.grammarDirectory })\n        if (!this.parser) {\n            return undefined\n        }\n        const query = await this.queries.loadQuery(this.parser, language, 'context')\n        if (!query) {\n            return\n        }\n        this.originalTree = this.parser.parse(text)\n        this.originalTreeIsFreeOfErrrors = !this.originalTree.rootNode.hasError()\n        const result: AutocompleteMatch[] = []\n        const document = new EvaluationDocument(this.params, text, vscode.Uri.file(this.params.filepath))\n        for (const queryMatch of query.matches(this.originalTree.rootNode)) {\n            for (const capture of queryMatch.captures) {\n                if (capture.name === 'if_statement') {\n                    const ifSyntax = this.ifSyntax(language)\n\n                    const newText = [\n                        text.slice(0, capture.node.startIndex),\n                        ifSyntax,\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'if_statement',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            capture.node.startIndex + ifSyntax.length - 1\n                        ),\n                    })\n                } else if (capture.name === 'function_declaration') {\n                    const openParen = queryMatch.captures.find(c => c.name === 'opening_paren')?.node\n                    if (!openParen) {\n                        throw new Error('Missing capture group @opening_paren for @function_declaration')\n                    }\n                    const newText = [\n                        text.slice(0, openParen.startIndex),\n                        '()',\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'function_declaration',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            openParen.startIndex + '('.length\n                        ),\n                    })\n                } else if (capture.name === 'call_expression') {\n                    const openParenPosition = queryMatch.captures.find(c => c.name === 'opening_paren')\n                        ?.node.startIndex\n                    const closeParenPosition = queryMatch.captures.find(c => c.name === 'closing_paren')\n                        ?.node.endIndex\n                    if (openParenPosition && closeParenPosition) {\n                        const openParenSyntax = text.charAt(openParenPosition) ?? '('\n                        const closeParenSyntax = text.charAt(closeParenPosition - 1) ?? ')'\n                        if (\n                            closeParenSyntax !== ')' &&\n                            closeParenSyntax !== '}' &&\n                            closeParenSyntax !== ']' &&\n                            closeParenSyntax !== '>'\n                        ) {\n                            throw new Error(\n                                `Invalid close paren syntax. ${JSON.stringify({\n                                    params: this.params,\n                                    closeParenSyntax,\n                                })}`\n                            )\n                        }\n                        const newText = [\n                            text.slice(0, openParenPosition),\n                            openParenSyntax,\n                            closeParenSyntax,\n                            text.slice(closeParenPosition),\n                        ]\n                        result.push({\n                            kind: 'call_expression',\n                            newText: newText.join(''),\n                            removedText: text.slice(openParenPosition, closeParenPosition),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(openParenPosition),\n                                document.textDocument.positionAt(closeParenPosition)\n                            ),\n                            requestPosition: document.textDocument.positionAt(\n                                openParenPosition + openParenSyntax.length\n                            ),\n                        })\n                    } else {\n                        throw new Error(\n                            `Missing @opening_paren and/or @closing_parent captures for node: ${capture.node.text}`\n                        )\n                    }\n                } else if (capture.name === 'assignment_statement') {\n                    const equalSign = queryMatch.captures.find(c => c.name === 'equal_sign')?.node\n                    if (equalSign) {\n                        const startIndex = equalSign.startIndex\n                        const endIndex =\n                            text.at(capture.node.endIndex) === ';'\n                                ? capture.node.endIndex + 1\n                                : capture.node.endIndex\n                        const newText = [text.slice(0, startIndex), text.slice(endIndex)]\n                        result.push({\n                            kind: 'assignment_statement',\n                            newText: newText.join(''),\n                            removedText: text.slice(startIndex, endIndex),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(startIndex),\n                                document.textDocument.positionAt(endIndex)\n                            ),\n                            requestPosition: document.textDocument.positionAt(startIndex - 1),\n                        })\n                    } else {\n                        throw new Error(`Missing @equal_sign capture for node: ${capture.node.text}`)\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:342-378"",""content"":""\ninterface CompletionItemParams {\n    completionID: string\n}\n\ninterface AutocompleteParams {\n    uri: string\n    filePath?: string\n    position: Position\n    // Defaults to 'Automatic' for autocompletions which were not explicitly\n    // triggered.\n    triggerKind?: 'Automatic' | 'Invoke'\n    selectedCompletionInfo?: SelectedCompletionInfo\n}\n\ninterface SelectedCompletionInfo {\n    readonly range: Range\n    readonly text: string\n}\n\nexport interface ChatExportResult {\n    chatID: string\n    transcript: SerializedChatTranscript\n}\nexport interface AutocompleteResult {\n    items: AutocompleteItem[]\n\n    /** completionEvent is not deprecated because it's used by non-editor clients like evaluate-autocomplete that need access to book-keeping data to evaluate results. */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\nexport interface AutocompleteItem {\n    id: string\n    insertText: string\n    range: Range\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:33-162"",""content"":""export async function triggerAutocomplete(parameters: AutocompleteParameters): Promise<void> {\n    const { range, client, document, modifiedContent, autocompleteKind, removedContent, position } =\n        parameters\n    client.notify('textDocument/didChange', {\n        uri: document.uri.toString(),\n        filePath: document.uri.fsPath,\n        content: modifiedContent,\n    })\n    let result: AutocompleteResult\n    try {\n        result = await client.request('autocomplete/execute', {\n            uri: document.uri.toString(),\n            filePath: document.uri.fsPath,\n            position,\n            // We don't use the \""automatic\"" trigger to avoid certain code paths like\n            // synthetic latency when acceptance rate is low.\n            triggerKind: 'Invoke',\n        })\n    } catch (error) {\n        const resultError = error instanceof Error ? error.message : String(error)\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultError,\n        })\n        return\n    }\n\n    const didNotSendNetworkRequest =\n        result.items.length === 0 && result.completionEvent?.networkRequestStartedAt === null\n    if (didNotSendNetworkRequest) {\n        return\n    }\n\n    const textDocument = new AgentTextDocument(\n        ProtocolTextDocumentWithUri.from(document.uri, { content: modifiedContent })\n    )\n    for (const [index, item] of result.items.entries()) {\n        const info = result.completionEvent?.items?.[index]\n        const original = textDocument.getText(\n            new vscode.Range(\n                item.range.start.line,\n                item.range.start.character,\n                item.range.end.line,\n                item.range.end.character\n            )\n        )\n        const start = new vscode.Position(item.range.start.line, item.range.start.character)\n        const end = new vscode.Position(item.range.end.line, item.range.end.character)\n        const modifiedDocument = new AgentTextDocument(\n            ProtocolTextDocumentWithUri.from(document.uri, { content: parameters.modifiedContent })\n        )\n        const newText = [\n            modifiedDocument.getText(new vscode.Range(new vscode.Position(0, 0), start)),\n            item.insertText,\n            modifiedDocument.getText(\n                new vscode.Range(end, new vscode.Position(modifiedDocument.lineCount, 0))\n            ),\n        ].join('')\n        const testParameters: TestParameters = { ...parameters, item, newText }\n        let resultParses: boolean | undefined\n        if (parameters.originalTreeIsErrorFree && parameters.parser && parameters.options.testParse) {\n            resultParses = testParses(newText, parameters.parser)\n        }\n\n        const resultTypechecks = await testTypecheck(testParameters)\n        const patches: string[] = []\n        let hasNonInsertPatch = false\n        for (const [sx, ex, text] of calcPatch(original, item.insertText)) {\n            if (sx !== ex) {\n                hasNonInsertPatch = true\n                continue\n            }\n            patches.push(text)\n        }\n        if (hasNonInsertPatch) {\n            document.pushItem({\n                resultText: item.insertText,\n                autocompleteKind,\n                range,\n                resultTypechecks,\n                resultParses,\n                resultNonInsertPatch: true,\n                event: result.completionEvent,\n                info,\n            })\n        } else if (patches.length > 0) {\n            const text = patches.join('')\n            if (text === removedContent) {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultExact: true,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            } else {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultText: text,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            }\n        } else {\n            document.pushItem({\n                autocompleteKind,\n                info,\n                range,\n                resultEmpty: true,\n                event: result.completionEvent,\n                resultParses,\n            })\n        }\n    }\n    if (result.items.length === 0) {\n        const expectedEmptyMatch = removedContent === ''\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultExact: expectedEmptyMatch,\n            resultEmpty: !expectedEmptyMatch,\n        })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/logger.ts:62-92"",""content"":""\n    /** Wether the completion is a singleline or multiline one. */\n    multiline: boolean\n\n    /**\n     * `null` means singleline, `block` means multiline.\n     * @deprecated Use `multiline` instead.\n     */\n    multilineMode: null | 'block'\n\n    /** Describes how the autocomplete request was triggered by the user. */\n    triggerKind: TriggerKind\n\n    /** Information about what provider is used. e.g. `anthropic` or `fireworks`. */\n    providerIdentifier: string\n\n    /** Information about which model was used. e.g. `starcoder-7b` or `claude-instant`. */\n    providerModel: string\n\n    /** Language of the document being completed. */\n    languageId: string\n\n    /** If we're inside a test file */\n    testFile: boolean\n\n    /**\n     * Information about the context retrieval process that lead to this autocomplete request. Refer\n     * to the documentation of {@link ContextSummary}\n     */\n    contextSummary?: ContextSummary\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:25-38"",""content"":""    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/unstable-openai.ts:0-36"",""content"":""import {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport { forkSignal, generatorWithTimeout, zipGenerators } from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n} from './provider'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:0-45"",""content"":""import * as anthropic from '@anthropic-ai/sdk'\n\nimport {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type Message,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    type PrefixComponents,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport {\n    forkSignal,\n    generatorWithErrorObserver,\n    generatorWithTimeout,\n    messagesToText,\n    zipGenerators,\n} from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:47-82"",""content"":""} from './suggested-autocomplete-items-cache'\nimport type { ProvideInlineCompletionItemsTracer, ProvideInlineCompletionsItemTraceData } from './tracer'\n\ninterface AutocompleteResult extends vscode.InlineCompletionList {\n    logId: CompletionLogID\n    items: AutocompleteItem[]\n    /** @deprecated */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\ninterface CodyCompletionItemProviderConfig {\n    providerConfig: ProviderConfig\n    statusBar: CodyStatusBar\n    tracer?: ProvideInlineCompletionItemsTracer | null\n    triggerNotice: ((notice: { key: string }) => void) | null\n    isRunningInsideAgent?: boolean\n\n    authStatus: AuthStatus\n    isDotComUser?: boolean\n\n    createBfgRetriever?: () => BfgRetriever\n\n    // Settings\n    formatOnAccept?: boolean\n    disableInsideComments?: boolean\n\n    // Feature flags\n    completeSuggestWidgetSelection?: boolean\n}\n\ninterface CompletionRequest {\n    document: vscode.TextDocument\n    position: vscode.Position\n    context: vscode.InlineCompletionContext\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:95-112"",""content"":""        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/request-manager.ts:0-28"",""content"":""import { partition } from 'lodash'\nimport { LRUCache } from 'lru-cache'\nimport type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    FeatureFlag,\n    isDefined,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport { addAutocompleteDebugEvent } from '../services/open-telemetry/debug-utils'\n\nimport { logDebug } from '../log'\nimport { completionProviderConfig } from './completion-provider-config'\nimport {\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n} from './get-inline-completions'\nimport { type CompletionLogID, logCompletionBookkeepingEvent } from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport { STOP_REASON_HOT_STREAK } from './providers/hot-streak'\nimport type { CompletionProviderTracer, Provider } from './providers/provider'\nimport { reuseLastCandidate } from './reuse-last-candidate'\nimport { lines, removeIndentation } from './text-processing'\nimport {\n    type InlineCompletionItemWithAnalytics,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/codeblock-action-tracker.ts:77-94"",""content"":""export async function handleCodeFromInsertAtCursor(text: string): Promise<void> {\n    const editor = getEditor()\n    const activeEditor = editor.active\n    const selectionRange = activeEditor?.selection\n    if (!activeEditor || !selectionRange) {\n        throw new Error('No editor or selection found to insert text')\n    }\n\n    const edit = new vscode.WorkspaceEdit()\n    // trimEnd() to remove new line added by Cody\n    edit.insert(activeEditor.document.uri, selectionRange.start, `${text}\\n`)\n    await vscode.workspace.applyEdit(edit)\n\n    // Log insert event\n    const op = 'insert'\n    const eventName = `${op}Button`\n    setLastStoredCode(text, eventName)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1033-1050"",""content"":""          \""default\"": null,\n          \""enum\"": [null, \""starcoder-16b\"", \""starcoder-7b\"", \""llama-code-13b\""],\n          \""markdownDescription\"": \""Overwrite the  model used for code autocompletion inference. This is only supported with the `fireworks` provider\""\n        },\n        \""cody.autocomplete.completeSuggestWidgetSelection\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Autocomplete based on the currently selection in the suggest widget. Requires the VS Code user setting `editor.inlineSuggest.suppressSuggestions` set to true and will change it to true in user settings if it is not true.\""\n        },\n        \""cody.autocomplete.formatOnAccept\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Format completions on accept using [the default document formatter](https://code.visualstudio.com/docs/editor/codebasics#_formatting).\""\n        },\n        \""cody.autocomplete.disableInsideComments\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/autocomplete.md:0-11"",""content"":""## Code Autocomplete\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-cody-autocomplete-tsx.gif\"">\n\nStart writing code and Cody will complete the line (or the entire function) for you. Hit tab to accept the suggestion.\n\n**✨ Pro-tips for using Cody autocomplete**\n<br>• Autocomplete uses the surrounding code and context to inform the suggestions, so if you need to guide it you can add a comment above the line you're editing.\n<br>• You can hover over the grey suggestion to see a toolbar of alternative suggestions, as well as other options such as accepting a single word at a time.\n<br>• You can use the \""Trigger Autocomplete at Cursor\"" command to trigger a code suggestion at any time, using the default keyboard shortcut of `Option` `\\` on macOS and `Alt` `\\` on Windows & Linux.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts:171-194"",""content"":""export function updateInsertRangeForVSCode(items: AutocompleteItem[]): AutocompleteItem[] {\n    return items.map(item => {\n        const {\n            insertText,\n            range,\n            requestParams: { position, document },\n        } = item\n\n        const currentLine = document.lineAt(position)\n        const currentLinePrefix = document.getText(currentLine.range.with({ end: position }))\n\n        const start = currentLine.range.start\n        // If the completion does not have a range set it will always exclude the same line suffix,\n        // so it has to overwrite the current same line suffix and reach to the end of the line.\n        const end = range?.end || currentLine.range.end\n\n        const vscodeInsertRange = new vscode.Range(start, end)\n\n        item.range = vscodeInsertRange\n        item.insertText = currentLinePrefix + (insertText as string)\n\n        return item\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:24-47"",""content"":""import { formatCompletion } from './format-completion'\nimport { getCurrentDocContext } from './get-current-doc-context'\nimport {\n    type InlineCompletionsParams,\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n    TriggerKind,\n    getInlineCompletions,\n} from './get-inline-completions'\nimport { isCompletionVisible } from './is-completion-visible'\nimport type { CompletionBookkeepingEvent, CompletionItemID, CompletionLogID } from './logger'\nimport * as CompletionLogger from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport type { ProviderConfig } from './providers/provider'\nimport { RequestManager, type RequestParams } from './request-manager'\nimport { getRequestParamsFromLastCandidate } from './reuse-last-candidate'\nimport { SmartThrottleService } from './smart-throttle'\nimport {\n    type AutocompleteInlineAcceptedCommandArgs,\n    type AutocompleteItem,\n    analyticsItemToAutocompleteItem,\n    suggestedAutocompleteItemsCache,\n    updateInsertRangeForVSCode,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:998-1015"",""content"":""### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n- Now removes completions from cache when the initial suggestion prefix is deleted by users after a suggestion was displayed. This avoids unhelpful/stale suggestions from persisting. [pull/1105](https://github.com/sourcegraph/cody/pull/1105)\n- VScode can now share a dotcom access token with future versions of Cody App. [pull/1090](https://github.com/sourcegraph/cody/pull/1090)\n\n### Fixed\n\n- Fix a potential race condition for autocomplete requests that happen when a completion is stored as the last shown candidate when it will not be shown. [pull/1059](https://github.com/sourcegraph/cody/pull/1059)\n- Use `insert` instead of `replace` for `Insert at Cursor` button for inserting code to current cursor position. [pull/1118](https://github.com/sourcegraph/cody/pull/1118)\n- Autocomplete: Fix support for working with CRLF line endings. [pull/1124](https://github.com/sourcegraph/cody/pull/1124)\n- Fix issue that caused the custom commands menu to unable to execute commands. [pull/1123](https://github.com/sourcegraph/cody/pull/1123)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:66-98"",""content"":""\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nexport interface AutocompleteTimeouts {\n    multiline?: number\n    singleline?: number\n}\n\nexport interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_015/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The context items from different sources are chosen in the context mixer, specifically in the file 'cody_test/vscode/src/completions/context/context-mixer.ts'. This file contains the logic for combining multiple context retrieval strategies into a single proposed context list.

The context mixer uses a method called reciprocal rank fusion to rank the order of documents, and then combines snippets from each retriever into a single list using a top-k approach. This process allows for the selection and prioritization of context items from various sources such as embeddings, user mentions, keyword searches, editor state, and more.

The `GetContextResult` interface in this file defines the structure for the combined context, including an array of `AutocompleteContextSnippet` and a `ContextSummary` for logging purposes.",Where do we choose the context items from different sources?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:168-197"",""content"":""    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:26-66"",""content"":""export type {\n    ChatError,\n    EventSource,\n    ChatHistory,\n    ChatMessage,\n    UserLocalHistory,\n    SerializedChatMessage,\n} from './chat/transcript/messages'\nexport {\n    CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID,\n    webviewOpenURIForContextItem,\n} from './chat/transcript/display-text'\nexport { Typewriter } from './chat/typewriter'\nexport { reformatBotMessageForChat } from './chat/viewHelpers'\nexport type {\n    ContextGroup,\n    ContextProvider,\n    ContextStatusProvider,\n    Disposable,\n    EnhancedContextContextT,\n    LocalEmbeddingsProvider,\n    LocalSearchProvider,\n    RemoteSearchProvider,\n    SearchProvider,\n} from './codebase-context/context-status'\nexport {\n    type ContextItem,\n    type ContextItemFile,\n    ContextItemSource,\n    type ContextItemWithContent,\n    type ContextItemSymbol,\n    type ContextFileType,\n    type ContextMessage,\n    type SymbolKind,\n} from './codebase-context/messages'\nexport type {\n    CodyCommand,\n    CodyCommandContext,\n    CodyCommandType,\n    TerminalOutputArguments,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/cells/contextCell/ContextCell.tsx:0-27"",""content"":""import type { ContextItem } from '@sourcegraph/cody-shared'\nimport classNames from 'classnames'\nimport type React from 'react'\nimport { FileLink } from '../../../Components/FileLink'\nimport { SourcegraphLogo } from '../../../icons/SourcegraphLogo'\nimport { MENTION_CLASS_NAME } from '../../../promptEditor/nodes/ContextItemMentionNode'\nimport { getVSCodeAPI } from '../../../utils/VSCodeApi'\nimport { LoadingDots } from '../../components/LoadingDots'\nimport { Cell } from '../Cell'\nimport styles from './ContextCell.module.css'\n\n/**\n * A component displaying the context for a human message.\n */\nexport const ContextCell: React.FunctionComponent<{\n    contextFiles: ContextItem[] | undefined\n    disabled?: boolean\n    className?: string\n\n    /** For use in storybooks only. */\n    __storybook__initialOpen?: boolean\n}> = ({ contextFiles, disabled, className, __storybook__initialOpen }) => {\n    const usedContext = []\n    const excludedAtContext = []\n    if (contextFiles) {\n        for (const f of contextFiles) {\n            if (f.isTooLarge) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:59-73"",""content"":""function convertContextItemMentionElement(domNode: HTMLElement): DOMConversionOutput | null {\n    const data = domNode.getAttribute(DOM_DATA_ATTR)\n    if (data !== null) {\n        try {\n            const contextItem: SerializedContextItem = JSON.parse(data)\n            const node = $createContextItemMentionNode(contextItem)\n            return { node }\n        } catch (error) {\n            console.error(error)\n            return null\n        }\n    }\n\n    return null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/cody.json:16-24"",""content"":""      \""context\"": {\n        \""currentFile\"": true\n      },\n      \""type\"": \""default\""\n    },\n    \""test\"": {\n      \""description\"": \""Generate unit tests\"",\n      \""prompt\"": \""Review the shared context to identify the testing framework and libraries in use. Then, generate a suite of multiple unit tests for the selected function using the detected test framework and libraries. Be sure to import the function being tested. Use the same patterns, testing framework, conventions, and libraries as shown in the shared context. Only import modules, functions, dependencies, and mocks based on shared code. If a test suite for the selected code is in the shared context, focus on generating new tests for uncovered cases. If none are detected, import common unit test libraries for {languageName}. Focus on validating key functionality with simple and complete assertions. Before writing the tests, identify which testing libraries and frameworks to use and import. At the end, enclose the fully completed code for the new unit tests without any comments, fragments, or TODOs. The new tests should validate the expected functionality and cover edge cases for with all required imports, including the function being tested. Do not repeat tests from the shared context. Enclose only the complete runnable tests.\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:130-167"",""content"":""} from './inferenceClient/misc'\nexport type {\n    ContextResult,\n    FilenameContextFetcher,\n    IndexedKeywordContextFetcher,\n    LocalEmbeddingsFetcher,\n    IRemoteSearch,\n    Result,\n    SearchPanelFile,\n    SearchPanelSnippet,\n} from './local-context'\nexport { logDebug, logError, setLogger } from './logger'\nexport {\n    createOllamaClient,\n    ollamaChatClient,\n    type OllamaGenerateParams,\n    OLLAMA_DEFAULT_URL,\n} from './llm-providers/ollama'\nexport {\n    MAX_BYTES_PER_FILE,\n    MAX_CURRENT_FILE_TOKENS,\n    ANSWER_TOKENS,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    SURROUNDING_LINES,\n} from './prompt/constants'\nexport { PromptMixin, newPromptMixin } from './prompt/prompt-mixin'\nexport * from './prompt/templates'\nexport {\n    truncateText,\n    truncateTextNearestLine,\n    truncatePromptStringStart,\n    truncatePromptString,\n} from './prompt/truncation'\nexport type { Message } from './sourcegraph-api'\nexport { SourcegraphBrowserCompletionsClient } from './sourcegraph-api/completions/browserClient'\nexport { SourcegraphCompletionsClient } from './sourcegraph-api/completions/client'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:213-217"",""content"":""export function $createContextItemTextNode(contextItem: ContextItem | SerializedContextItem): TextNode {\n    const atNode = new ContextItemMentionNode(contextItem)\n    const textNode = new TextNode(atNode.__text)\n    return $applyNodeReplacement(textNode)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:418-421"",""content"":""\n    return context.concat(currentFileNameComment, prompt.prefix)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:190-199"",""content"":""export function $createContextItemMentionNode(\n    contextItem: ContextItem | SerializedContextItem\n): ContextItemMentionNode {\n    const node = new ContextItemMentionNode(contextItem)\n    node.setMode('token').toggleDirectionless()\n    contextItem.type === 'file' &&\n        contextItem.isTooLarge &&\n        node.setStyle('color: var(--vscode-list-errorForeground)')\n    return $applyNodeReplacement(node)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItem.kt:22-53"",""content"":""\ndata class ContextItemFile(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: file\n) : ContextItem() {\n\n  enum class TypeEnum {\n    @SerializedName(\""file\"") File,\n  }\n}\n\ndata class ContextItemSymbol(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: symbol\n  val symbolName: String? = null,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:77-173"",""content"":""export class ContextItemMentionNode extends TextNode {\n    static getType(): string {\n        return 'contextItemMention'\n    }\n\n    static clone(node: ContextItemMentionNode): ContextItemMentionNode {\n        return new ContextItemMentionNode(node.contextItem, node.__text, node.__key)\n    }\n    static importJSON(serializedNode: SerializedContextItemMentionNode): ContextItemMentionNode {\n        const node = $createContextItemMentionNode(serializedNode.contextItem)\n        node.setTextContent(serializedNode.text)\n        node.setFormat(serializedNode.format)\n        node.setDetail(serializedNode.detail)\n        node.setMode(serializedNode.mode)\n        node.setStyle(serializedNode.style)\n        return node\n    }\n\n    private contextItem: SerializedContextItem\n\n    constructor(\n        contextItemWithAllFields: ContextItem | SerializedContextItem,\n        text?: string,\n        key?: NodeKey\n    ) {\n        // Make sure we only bring over the fields on the context item that we need, or else we\n        // could accidentally include tons of data (including the entire contents of files).\n        const contextItem = serializeContextItem(contextItemWithAllFields)\n\n        super(text ?? contextItemMentionNodeDisplayText(contextItem), key)\n\n        this.contextItem = contextItem\n    }\n\n    exportJSON(): SerializedContextItemMentionNode {\n        return {\n            ...super.exportJSON(),\n            contextItem: this.contextItem,\n            type: ContextItemMentionNode.getType(),\n            version: 1,\n        }\n    }\n\n    private static CLASS_NAMES = `context-item-mention-node ${styles.contextItemMentionNode}`\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config)\n        element.className = ContextItemMentionNode.CLASS_NAMES\n        return element\n    }\n\n    exportDOM(): DOMExportOutput {\n        const element = document.createElement('span')\n        element.setAttribute(DOM_DATA_ATTR, JSON.stringify(this.contextItem))\n        element.className = ContextItemMentionNode.CLASS_NAMES\n\n        const link = document.createElement('a')\n        const { href, target } = webviewOpenURIForContextItem({\n            uri: URI.parse(this.contextItem.uri),\n            range: this.contextItem.range,\n        })\n        link.href = href\n        if (target) {\n            link.target = target\n        }\n        link.textContent = this.__text\n        element.appendChild(link)\n\n        return { element }\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            span: (domNode: HTMLElement) => {\n                if (!domNode.hasAttribute(DOM_DATA_ATTR)) {\n                    return null\n                }\n                return {\n                    conversion: convertContextItemMentionElement,\n                    priority: 1,\n                }\n            },\n        }\n    }\n\n    isTextEntity(): true {\n        return true\n    }\n\n    canInsertTextBefore(): boolean {\n        return false\n    }\n\n    canInsertTextAfter(): boolean {\n        return false\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-input.ts:396-419"",""content"":""\n                const matchingContext = await getMatchingContext(mentionQuery)\n                if (matchingContext.length === 0) {\n                    // Attempted to match but found nothing\n                    input.items = [\n                        {\n                            alwaysShow: true,\n                            label:\n                                mentionQuery.type === 'symbol'\n                                    ? mentionQuery.text.length === 0\n                                        ? SYMBOL_HELP_LABEL\n                                        : NO_SYMBOL_MATCHES_LABEL\n                                    : mentionQuery.text.length === 0\n                                      ? FILE_HELP_LABEL\n                                      : NO_FILE_MATCHES_LABEL,\n                        },\n                    ]\n                    return\n                }\n\n                // Update stored context items so we can retrieve them later\n                for (const { key, item } of matchingContext) {\n                    contextItems.set(key, item)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:35-48"",""content"":""export function serializeContextItem(\n    contextItem: ContextItem | SerializedContextItem\n): SerializedContextItem {\n    // Make sure we only bring over the fields on the context item that we need, or else we\n    // could accidentally include tons of data (including the entire contents of files).\n    return {\n        ...contextItem,\n        uri: contextItem.uri.toString(),\n\n        // Don't include the `content` (if it's present) because it's quite large, and we don't need\n        // to serialize it here. It can be hydrated on demand.\n        content: undefined,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320"",""content"":""\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:50-52"",""content"":""export function deserializeContextItem(contextItem: SerializedContextItem): ContextItem {\n    return { ...contextItem, uri: URI.parse(contextItem.uri) }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:40-68"",""content"":""export async function fetchContentForURLContextItem(\n    url: string,\n    signal?: AbortSignal\n): Promise<string | null> {\n    const resp = await fetch(url.toString(), { signal })\n    if (!resp.ok) {\n        return null\n    }\n    const body = await resp.text()\n\n    // HACK(sqs): Rudimentarily strip HTML tags, script, and other unneeded elements from body using\n    // regexp. This is NOT intending to be a general-purpose HTML parser and is NOT sanitizing the\n    // value for security.\n    const bodyWithoutTags = body\n        .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n        .replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '')\n        .replace(/<svg\\b[^<]*(?:(?!<\\/svg>)<[^<]*)*<\\/svg>/gi, '')\n        .replace(/<!--.*?-->/gs, '')\n        .replace(/\\s(?:class|style)=[\""'][^\""']*[\""']/gi, '')\n        .replace(/\\sdata-[\\w-]+(=[\""'][^\""']*[\""'])?/gi, '')\n\n    // TODO(sqs): Arbitrarily trim the response text to avoid overflowing the context window for the\n    // LLM. Ideally we would make the prompt builder prioritize this context item over other context\n    // because it is explicitly from the user.\n    const MAX_LENGTH = 14000\n    return bodyWithoutTags.length > MAX_LENGTH\n        ? `${bodyWithoutTags.slice(0, MAX_LENGTH)}... (web page content was truncated)`\n        : bodyWithoutTags\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-matching-context.ts:0-31"",""content"":""import type { ContextItem, MentionQuery } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\n\nimport { getChatContextItemsForMention } from '../../chat/context/chatContext'\nimport { getLabelForContextItem } from './utils'\n\ninterface FixupMatchingContext {\n    /* Unique identifier for the context, shown in the input value but not necessarily in the quick pick selector */\n    key: string\n    /* If present, will override the key shown in the quick pick selector */\n    shortLabel?: string\n    item: ContextItem\n}\n\nexport async function getMatchingContext(mentionQuery: MentionQuery): Promise<FixupMatchingContext[]> {\n    const token = new vscode.CancellationTokenSource()?.token\n    const results = await getChatContextItemsForMention(mentionQuery, token)\n    return results.map(result => {\n        return {\n            key: getLabelForContextItem(result),\n            item: result,\n            shortLabel:\n                result.type === 'symbol'\n                    ? `${result.kind === 'class' ? '$(symbol-structure)' : '$(symbol-method)'} ${\n                          result.symbolName\n                      }`\n                    : undefined,\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:7-34"",""content"":""export async function getURLContextItems(\n    urlInput: string,\n    signal?: AbortSignal\n): Promise<ContextItem[]> {\n    const url = tryParsePossiblyIncompleteURL(urlInput)\n    if (url === null) {\n        return []\n    }\n\n    try {\n        const content = await fetchContentForURLContextItem(url.toString(), signal)\n        if (content === null) {\n            return []\n        }\n        return [\n            {\n                type: 'file',\n                uri: url,\n                content,\n                title: tryGetHTMLDocumentTitle(content),\n                source: ContextItemSource.Uri,\n            },\n        ]\n    } catch (error) {\n        // Suppress errors because the user might be typing a URL that is not yet valid.\n        return []\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport type { ContextRetriever } from '../types'\n\nimport type { BfgRetriever } from './retrievers/bfg/bfg-retriever'\nimport { JaccardSimilarityRetriever } from './retrievers/jaccard-similarity/jaccard-similarity-retriever'\nimport { SectionHistoryRetriever } from './retrievers/section-history/section-history-retriever'\n\nexport type ContextStrategy =\n    | 'bfg'\n    | 'jaccard-similarity'\n    | 'new-jaccard-similarity'\n    | 'bfg-mixed'\n    | 'local-mixed'\n    | 'none'\n\nexport interface ContextStrategyFactory extends vscode.Disposable {\n    getStrategy(document: vscode.TextDocument): { name: ContextStrategy; retrievers: ContextRetriever[] }\n}\n\nexport class DefaultContextStrategyFactory implements ContextStrategyFactory {\n    private disposables: vscode.Disposable[] = []\n\n    private localRetriever: ContextRetriever | undefined\n    private graphRetriever: ContextRetriever | undefined\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:36-38"",""content"":""export function isURLContextItem(item: Pick<ContextItem, 'uri'>): boolean {\n    return item.uri.scheme === 'http' || item.uri.scheme === 'https'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:33-61"",""content"":""            suggestedItems: number\n            /** Number of total snippets */\n            retrievedItems: number\n            /** Duration of the individual retriever */\n            duration: number\n            /**\n             * A bitmap that indicates at which position in the result set an entry from the given\n             * retriever is included. It only includes information about the first 32 entries.\n             *\n             * The lowest bit indicates if the first entry is included, the second lowest bit\n             * indicates if the second entry is included, and so on.\n             */\n            positionBitmap: number\n        }\n    }\n}\n\nexport interface GetContextResult {\n    context: AutocompleteContextSnippet[]\n    logSummary: ContextSummary\n}\n\n/**\n * The context mixer is responsible for combining multiple context retrieval strategies into a\n * single proposed context list.\n *\n * This is done by ranking the order of documents using reciprocal rank fusion and then combining\n * the snippets from each retriever into a single list using top-k (so we will pick all returned\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:199-210"",""content"":""    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:212-226"",""content"":""    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77"",""content"":""        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItemSource.kt:0-6"",""content"":""@file:Suppress(\""FunctionName\"", \""ClassName\"", \""unused\"", \""EnumEntryName\"", \""UnusedImport\"")\npackage com.sourcegraph.cody.protocol_generated\n\ntypealias ContextItemSource = String // One of: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_016/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"We check for content attribution in the ChatMessageContent component, specifically in the useEffect hook. The code snippet from the file cody_test/vscode/webviews/chat/ChatMessageContent.tsx shows that when guardrails are enabled, it calls the searchAttribution method for each code block in the chat message. 

The attribution check is triggered after the buttons for copying and inserting code are created. If attribution is found, it updates the UI to display the attribution status using the GuardrailsStatusController.

The attribution search is performed asynchronously, and the UI is updated based on the result:
- If no attribution is found, it sets a success status.
- If attribution is found, it displays the repository names where the code was attributed.
- If there's an error or the attribution is unavailable, it shows an appropriate status.

This implementation ensures that users are informed about the source of code snippets provided in chat responses, which is an important feature for maintaining code integrity and compliance.",Where do we check for content attribution?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:203-214"",""content"":""function checkValidEnumValues(configName: string, value: string | null): void {\n    const validEnumValues = getConfigEnumValues(`cody.${configName}`)\n    if (value) {\n        if (!validEnumValues.includes(value)) {\n            void vscode.window.showErrorMessage(\n                `Invalid value for ${configName}: ${value}. Valid values are: ${validEnumValues.join(\n                    ', '\n                )}`\n            )\n        }\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:4054-4078"",""content"":""            2n1Tofe+i1bW2ZHXhNA1apTk30hqndqL17plySGZAuO/ijE6yxkED6hm8fHpRnN1d85\\\n            U0Fl9xzhFnlzIk0U01WnbfsaZ+ggLtCTg1vgaeba2Ftnty9VlgYeyasRZaHWuzPYroh\\\n            NXPcXi8sDBeqyj0c78bJM/rORz+8//94VUrS/3Bbt2rP/37lbbFnzsfnL9W/NdPr5X9\\\n            tFdP7f/+sPu03/xf/4gb8+F/fWjeVZt//mr++ue//PO3fz6//tfP/b8VbfFj9fo38+5\\\n            p8/jtXv74f17kj/XT5s1fDn99fFcXPz63/7K7WPz4Xdw0/3hb/Ni+/PX/+Uv9rx/r47\\\n            /++enbv/7zH2/Vj388Fj/+4/j5/Q/vfvrlw9sP5mD+Pv1e/vOP3YcnZz7Yb//n1X/+8\\\n            5///P8BAAD//0QFQV3tCQIA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:32:13 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: retry-after\n            value: \""282\""\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/attribution.test.ts:12-33"",""content"":""const test = baseTest\n    .extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n    .extend<ExpectedEvents>({\n        // list of events we expect this test to log, add to this list as needed\n        expectedEvents: [\n            'CodyInstalled',\n            'CodyVSCodeExtension:auth:clickOtherSignInOptions',\n            'CodyVSCodeExtension:login:clicked',\n            'CodyVSCodeExtension:auth:selectSigninMenu',\n            'CodyVSCodeExtension:auth:fromToken',\n            'CodyVSCodeExtension:Auth:connected',\n            'CodyVSCodeExtension:chat-question:submitted',\n            'CodyVSCodeExtension:chat-question:executed',\n            'CodyVSCodeExtension:chatResponse:hasCode',\n        ],\n    })\n    .extend<ExtraWorkspaceSettings>({\n        extraWorkspaceSettings: {\n            // TODO(#59720): Remove experimental setting.\n            'cody.experimental.guardrails': true,\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:105-138"",""content"":""      _order: 0\n      cache: {}\n      request:\n        bodySize: 10486\n        cookies: []\n        headers:\n          - name: content-type\n            value: application/json\n          - name: accept-encoding\n            value: gzip;q=0\n          - name: authorization\n            value: token\n              REDACTED_b20717265e7ab1d132874d8ff0be053ab9c1dacccec8dce0bbba76888b6a0a69\n          - name: user-agent\n            value: enterpriseClient / v1\n          - name: host\n            value: demo.sourcegraph.com\n        headersSize: 265\n        httpVersion: HTTP/1.1\n        method: POST\n        postData:\n          mimeType: application/json\n          params: []\n          textJSON:\n            maxTokensToSample: 1000\n            messages:\n              - speaker: human\n                text: You are Cody, an AI coding assistant from Sourcegraph.\n              - speaker: assistant\n                text: I am Cody, an AI coding assistant from Sourcegraph.\n              - speaker: human\n                text: >-\n                  Codebase context from file /agent/README.md in repository\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:7357-7384"",""content"":""            TV68pkB+nxayTnfUxFI4Sug+6FETlcN5vseCqWw5dIsYKxBKg01OJm6s+D7T1NbQBqQ\\\n            BtYz94lGT6PUejuxbG/2wJv7Mk6JUl+MJxEct3461Pyk7GO6O4yONy+fXDayr6VVyAL\\\n            CfoVP1ChiONKzIspRcrOLM251/n8/kPAAAA//8DANaF7gAtBAAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:31 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:21-30"",""content"":""interface ChatMessageContentProps {\n    displayMarkdown: string\n    wrapLinksWithCodyCommand: boolean\n\n    copyButtonOnSubmit?: CodeBlockActionsProps['copyButtonOnSubmit']\n    insertButtonOnSubmit?: CodeBlockActionsProps['insertButtonOnSubmit']\n\n    guardrails?: Guardrails\n    className?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:5321-5347"",""content"":""            z//9zYtWVuqDWdsXf/j3C2XKP3bOW3ct3o+fXhfm0654aP/rw/bTbvXnn8JKf/jth+a\\\n            7zeofP+q//vEv//j5H0+v//VD/1vZln/avP5Zf/ewevNqV7z9/3bln+pG/fD79l//+K\\\n            n+6z8/Pa5+eP1m9ebTZvXnj6H880+vVm//0v78j6fvPz5Xrz69+9jzey//+Zf657d/b\\\n            1dvvtWf9Qe97pfMf/7zn//8vwAAAP//7inTaSEHAgA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:38:54 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: content-encoding\n            value: gzip\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:138-147"",""content"":""                  github.com/sourcegraph/cody:\n\n                  ```markdown\n\n                  | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n\n                  | `pnpm test agent/src/index.test.ts`                                                                                  | Run agent tests in replay mode                                                                                                                                |\n\n                  | `source agent/scripts/export-cody-http-recording-tokens.sh`                                                          | Export access tokens to enable recording mode                                                                                                                 |\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/rateLimitedClient_2043004676/recording.har.yaml:1047-1076"",""content"":""                siteID: SourcegraphWeb\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 17 Apr 2024 09:12:26 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Cookie,Accept-Encoding,Authorization,Cookie, Authorization,\n              X-Requested-With,Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n            value: 1; mode=block\n          - name: strict-transport-security\n            value: max-age=31536000; includeSubDomains; preload\n          - name: content-encoding\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupContentStore.ts:9-75"",""content"":""export class ContentProvider implements vscode.TextDocumentContentProvider, vscode.Disposable {\n    // This stores the content of the document for each task ID\n    // The content is initialized by the fixup task with the original content\n    // and then updated by the fixup task with the replacement content\n    private contentStore = new Map<FixupTaskID, fileContent>()\n    // This tracks the task IDs belong toe each file path\n    private tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    private _onDidChange = new vscode.EventEmitter<vscode.Uri>()\n    private _disposables: vscode.Disposable\n\n    constructor() {\n        // TODO: Handle applying fixups to files which are opened and closed.\n        // This is tricky because we need to re-sync the range we are tracking\n        // when the file is opened.\n        this._disposables = vscode.workspace.onDidCloseTextDocument(doc =>\n            this.deleteByFilePath(doc.uri.fsPath)\n        )\n    }\n    // Get content from the content store\n    public provideTextDocumentContent(uri: vscode.Uri): string | null {\n        const id = uri.fragment\n        return this.contentStore.get(id) || null\n    }\n    // Add to store - store origin content by fixup task id\n    public async set(id: string, docUri: vscode.Uri): Promise<void> {\n        const doc = await vscode.workspace.openTextDocument(docUri)\n        this.contentStore.set(id, doc.getText())\n        this.tasksByFilePath.set(docUri.fsPath, [...(this.tasksByFilePath.get(docUri.fsPath) || []), id])\n    }\n\n    // Remove by ID\n    public delete(id: string): void {\n        this.contentStore.delete(id)\n        // remove task from tasksByFilePath\n        for (const [filePath, tasks] of this.tasksByFilePath) {\n            const index = tasks.indexOf(id)\n            if (index > -1) {\n                tasks.splice(index, 1)\n            }\n            if (tasks.length === 0) {\n                this.deleteByFilePath(filePath)\n            }\n        }\n    }\n\n    // Remove by file path\n    private deleteByFilePath(fileName: string): void {\n        const files = this.tasksByFilePath.get(fileName)\n        if (!files) {\n            return\n        }\n        for (const id of files) {\n            this.contentStore.delete(id)\n        }\n    }\n\n    public get onDidChange(): vscode.Event<vscode.Uri> {\n        return this._onDidChange.event\n    }\n\n    public dispose(): void {\n        this._disposables.dispose()\n        this._onDidChange.dispose()\n        this.contentStore = new Map<FixupTaskID, fileContent>()\n        this.tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:156-175"",""content"":""\n    // Updates the extension configuration and returns the new\n    // authentication status, which indicates whether the provided credentials are\n    // valid or not. The agent can't support autocomplete or chat if the credentials\n    // are invalid.\n    'extensionConfiguration/change': [ExtensionConfiguration, AuthStatus | null]\n\n    // Returns the current authentication status without making changes to it.\n    'extensionConfiguration/status': [null, AuthStatus | null]\n\n    // Run attribution search for a code snippet displayed in chat.\n    // Attribution is an enterprise feature which allows to look for code generated\n    // by Cody in an open source code corpus. User is notified if any such attribution\n    // is found.\n    // For more details, please see:\n    // *   PRD: https://docs.google.com/document/d/1c3CLC7ICDaG63NOWjO6zWm-UElwuXkFrKbCKTw-7H6Q/edit\n    // *   RFC: https://docs.google.com/document/d/1zSxFDQPxZcn5b6yKx40etpJayoibVzj_Gnugzln1weI/edit\n    'attribution/search': [\n        { id: string; snippet: string },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:235-309"",""content"":""export const ChatMessageContent: React.FunctionComponent<ChatMessageContentProps> = ({\n    displayMarkdown,\n    wrapLinksWithCodyCommand,\n    copyButtonOnSubmit,\n    insertButtonOnSubmit,\n    guardrails,\n    className,\n}) => {\n    const rootRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        const preElements = rootRef.current?.querySelectorAll('pre')\n        if (!preElements?.length || !copyButtonOnSubmit) {\n            return\n        }\n\n        for (const preElement of preElements) {\n            const preText = preElement.textContent\n            if (preText?.trim() && preElement.parentNode) {\n                const buttons = createButtons(preText, copyButtonOnSubmit, insertButtonOnSubmit)\n                if (guardrails) {\n                    const container = document.createElement('div')\n                    container.classList.add(styles.attributionContainer)\n                    buttons.append(container)\n\n                    const g = new GuardrailsStatusController(container)\n                    g.setPending()\n\n                    guardrails\n                        .searchAttribution(preText)\n                        .then(attribution => {\n                            if (isError(attribution)) {\n                                g.setUnavailable(attribution)\n                            } else if (attribution.repositories.length === 0) {\n                                g.setSuccess()\n                            } else {\n                                g.setFailure(\n                                    attribution.repositories.map(r => r.name),\n                                    attribution.limitHit\n                                )\n                            }\n                        })\n                        .catch(error => {\n                            g.setUnavailable(error)\n                            return\n                        })\n                }\n\n                // Insert the buttons after the pre using insertBefore() because there is no insertAfter()\n                preElement.parentNode.insertBefore(buttons, preElement.nextSibling)\n\n                // capture copy events (right click or keydown) on code block\n                preElement.addEventListener('copy', () => {\n                    if (copyButtonOnSubmit) {\n                        copyButtonOnSubmit(preText, 'Keydown')\n                    }\n                })\n            }\n        }\n    }, [copyButtonOnSubmit, insertButtonOnSubmit, guardrails])\n\n    return (\n        <div\n            ref={rootRef}\n            className={classNames(styles.content, className)}\n            // biome-ignore lint/security/noDangerouslySetInnerHtml: the result is run through dompurify\n            dangerouslySetInnerHTML={{\n                // wrapLinksWithCodyCommand opens all links in assistant responses using the\n                // _cody.vscode.open command (but not human messages because those already\n                // have the right URIs and are trusted).\n                __html: renderCodyMarkdown(displayMarkdown, { wrapLinksWithCodyCommand }),\n            }}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/index.md:0-8"",""content"":""# Cody documentation\n\n> **Note**\n> We're in the process of moving Cody documentation from the [`sourcegraph/sourcegraph` repository `doc/cody` directory](https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/tree/doc/cody) to this repository.\n\n- [Development](development/index.md)\n- [All other Cody documentation](https://sourcegraph.com/docs/cody)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/TextDocumentWithUri.ts:45-47"",""content"":""    public get content(): string | undefined {\n        return this.underlying.content\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:23-25"",""content"":""    public get content(): string {\n        return this.protocolDocument.underlying.content ?? ''\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320"",""content"":""\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // 🚨 Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // 🚨 We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/guardrails/index.ts:3-6"",""content"":""export interface Attribution {\n    limitHit: boolean\n    repositories: RepositoryAttribution[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.module.css:44-100"",""content"":""\n.attribution-container {\n    all: unset;\n    display: flex;\n    margin-left: auto;\n}\n\n\n.attribution-icon-unavailable {\n    color: var(--hl-orange);\n}\n\n.attribution-icon-found {\n    color: var(--hl-dark-red);\n}\n\n.status {\n    display: flex;\n    align-items: center;\n}\n\n.codicon-loading {\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    from { transform: rotate(0deg); }\n    to { transform: rotate(360deg); }\n}\n\n/*\n * Content\n */\n:root {\n    --spacing: 1rem;\n}\n\n.content {\n    word-break: break-word;\n    line-height: 150%;\n    text-wrap: wrap;\n}\n\n/* Style @-file tokens to match TranscriptAction context files */\n.content a[href^=\""vscode://file\""] em,\n.content a[href^=\""vscode-insiders://file\""] em,\n.content a[href^=\""vscodium://file\""] em,\n.content a[href^=\""cursor://file\""] em\n{\n    padding: 1px 2px;\n    box-sizing: border-box;\n    background-color: color-mix(in srgb, var(--vscode-textLink-foreground) 15%, transparent);\n    border-radius: 2px;\n    font-style: normal;\n    word-break: break-all;\n}\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_017/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Custom actions are triggered in multiple places within the codebase:

1. In the sidebar, as indicated by the `cody.menu.custom-commands` command in the package.json file.

2. Through the `cody.action.command` command, which can be executed from various sources, including the sidebar and editor context menu.

3. Via custom keybindings that users can set up for their custom commands, as described in the keyboard.md documentation.

4. The CustomCommandsManager class handles loading, building, and maintaining custom commands retrieved from cody.json files.

5. Custom commands are also registered as VS Code commands, allowing them to be triggered through the command palette or other VS Code interfaces.

6. The SidebarCommands.ts file shows that custom commands can be triggered from the sidebar with a specific logging action.

These implementations provide multiple entry points for users to access and execute their custom Cody commands.",Where do we trigger custom actions?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:7-21"",""content"":""    public provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): vscode.CodeAction[] {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n        return [this.createCommandCodeAction(document.uri, diagnostics)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:0-18"",""content"":""# Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can easily update these bindings in the `Keyboard Shortcuts editor`, which you can access by clicking on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**`.\n\nThis feature can be particularly useful if the default key bindings conflict with your current or preferred key bindings.\n\n## Keyboard Shortcuts Editor\n\nThe Keyboard Shortcuts editor allows you to easily update the key bindings for any of the Cody commands. To open the `Keyboard Shortcuts Editor`:\n1. Open the Cody sidebar and expand the `**SETTINGS AND SUPPORT**` section.\n2. Click on the `**Keyboard Shortcuts**` icon.\n\n## Custom Commands\n\n![editor](images/keyboard_editor.png)\n\nYou have the option to assign key bindings (keyboard shortcuts) to individual custom commands:\n1. In the Cody sidebar under `**SETTINGS AND SUPPORT**`, click on the `**Keyboard Shortcuts**` icon to open the Keyboard Shortcuts editor.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/BaseEditor.tsx:77-101"",""content"":""                                    />\n                                </div>\n                            </div>\n                        }\n                        placeholder={<div className={styles.placeholder}>{placeholder}</div>}\n                        ErrorBoundary={LexicalErrorBoundary}\n                    />\n                    <HistoryPlugin />\n                    <OnChangePlugin onChange={onChange} ignoreSelectionChange={true} />\n                    <MentionsPlugin />\n                    <CodeHighlightPlugin />\n                    <AutoFocusPlugin />\n                    {onFocusChange && <OnFocusChangePlugin onFocusChange={onFocusChange} />}\n                    {editorRef && <EditorRefPlugin editorRef={editorRef} />}\n                    <KeyboardEventPlugin\n                        onKeyDown={onKeyDown}\n                        onEnterKey={onEnterKey}\n                        onEscapeKey={onEscapeKey}\n                    />\n                </LexicalComposer>\n            </div>\n        </div>\n    )\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:851-862"",""content"":""- Assign requestID to each Code Block actions. [pull/1586](https://github.com/sourcegraph/cody/pull/1586)\n- [Internal Experimental] Chat: New Experimental Chat View that appears in the editor panel instead of the sidebar when `cody.experimental.chatPanel` is enabled. [pull/1509](https://github.com/sourcegraph/cody/pull/1509)\n\n### Fixed\n\n- Commands: Smart selection not working on the first line of code. [pull/1508](https://github.com/sourcegraph/cody/pull/1508)\n- Chat: Aborted messages are now saved to local chat history properly. [pull/1550](https://github.com/sourcegraph/cody/pull/1550)\n- Adjust a completion range if it does not match the current line suffix. [pull/1507](https://github.com/sourcegraph/cody/pull/1507)\n- Chat: Fix heading styles and inline code colors. [pull/1528](https://github.com/sourcegraph/cody/pull/1528)\n- Custom Commands: Fix custom command menu not showing for a single custom command. [pull/1532](https://github.com/sourcegraph/cody/pull/1532)\n- Chat: Focus chat input on mount even when notification for version update is shown. [pull/1556](https://github.com/sourcegraph/cody/pull/1556)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:10-12"",""content"":""interface CodeActionProviderOptions {\n    contextProvider: ContextProvider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:27-48"",""content"":""import {\n    executeDocCommand,\n    executeExplainCommand,\n    executeExplainOutput,\n    executeSmellCommand,\n    executeTestCaseEditCommand,\n    executeTestChatCommand,\n    executeTestEditCommand,\n} from './commands/execute'\nimport type { CodyCommandArgs } from './commands/types'\nimport { newCodyCommandArgs } from './commands/utils/get-commands'\nimport { createInlineCompletionItemProvider } from './completions/create-inline-completion-item-provider'\nimport { getConfiguration, getFullConfig } from './configuration'\nimport { EnterpriseContextFactory } from './context/enterprise-context-factory'\nimport { EditManager } from './edit/manager'\nimport { manageDisplayPathEnvInfoForExtension } from './editor/displayPathEnvInfo'\nimport { VSCodeEditor } from './editor/vscode-editor'\nimport type { PlatformContext } from './extension.common'\nimport { configureExternalServices } from './external-services'\nimport { logDebug, logError } from './log'\nimport { getChatModelsFromConfiguration, syncModelProviders } from './models/utils'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/document.ts:8-37"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [documentableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getDocumentableNode',\n        })\n        if (!documentableNode) {\n            return []\n        }\n\n        const { range: documentableRange, symbol: documentableSymbol } = documentableNode\n        if (!documentableSymbol || !documentableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            documentableRange.node.startPosition.row,\n            documentableRange.node.startPosition.column,\n            documentableRange.node.endPosition.row,\n            documentableRange.node.endPosition.column\n        )\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Documentation for ${documentableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/HoverCommandsProvider.ts:0-28"",""content"":""import {\n    type AuthStatus,\n    FeatureFlag,\n    PromptString,\n    featureFlagProvider,\n    isCodyIgnoredFile,\n    logDebug,\n    ps,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { executeEdit } from '../edit/execute'\nimport { fetchDocumentSymbols } from '../edit/input/utils'\nimport { telemetryService } from '../services/telemetry'\nimport { telemetryRecorder } from '../services/telemetry-v2'\nimport { logFirstEnrollmentEvent } from '../services/utils/enrollment-event'\nimport { execQueryWrapper as execQuery } from '../tree-sitter/query-sdk'\nimport { executeDocCommand } from './execute'\nimport { executeHoverChatCommand } from './execute/hover'\nimport type { CodyCommandArgs } from './types'\n\n/**\n * NOTE: Behind the feature flag `cody-hover-commands`.\n *\n * Provides clickable commands on hover and handles clicking on commands.\n */\nclass HoverCommandsProvider implements vscode.Disposable {\n    private readonly id = FeatureFlag.CodyHoverCommands\n    private disposables: vscode.Disposable[] = []\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:14-45"",""content"":""    public async provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): Promise<vscode.CodeAction[]> {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n\n        // Expand range to include the full line for better fixup quality\n        const expandedRange = new vscode.Range(\n            document.lineAt(range.start.line).range.start,\n            document.lineAt(range.end.line).range.end\n        )\n\n        // TODO bee check if the diagnostics are related to imports and include import ranges instead of error lines\n        // const importDiagnostics = diagnostics.filter(diagnostic => diagnostic.message.includes('import'))\n\n        // Expand range by getting the folding range contains the target (error) area\n        const targetAreaRange = await getSmartSelection(document.uri, range.start)\n\n        const newRange = targetAreaRange\n            ? new vscode.Range(targetAreaRange.start, targetAreaRange.end)\n            : expandedRange\n        const codeAction = await this.createCommandCodeAction(document, diagnostics, newRange)\n        return [codeAction]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:792-822"",""content"":""          \""group\"": \""navigation@1\""\n        },\n        {\n          \""command\"": \""cody.search.index-update-all\"",\n          \""when\"": \""view == cody.search && cody.activated\"",\n          \""group\"": \""navigation@2\""\n        }\n      ],\n      \""editor/title\"": [\n        {\n          \""command\"": \""cody.menu.commands\"",\n          \""when\"": \""cody.activated && !editorReadonly && (resourceScheme == file || activeWebviewPanelId == cody.chatPanel)\"",\n          \""group\"": \""navigation\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""cody.chat.panel.new\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated\"",\n          \""group\"": \""navigation@1\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""cody.chat.history.panel\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated\"",\n          \""group\"": \""navigation@2\"",\n          \""visibility\"": \""visible\""\n        },\n        {\n          \""command\"": \""workbench.action.moveEditorToNewWindow\"",\n          \""when\"": \""activeWebviewPanelId == cody.chatPanel && cody.activated && !isAuxiliaryEditorPart\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/test.ts:8-38"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [testableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getTestableNode',\n        })\n        if (!testableNode) {\n            return []\n        }\n\n        const { range: testableRange, symbol: testableSymbol } = testableNode\n        if (!testableSymbol || !testableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            testableRange.node.startPosition.row,\n            testableRange.node.startPosition.column,\n            testableRange.node.endPosition.row,\n            testableRange.node.endPosition.column\n        )\n\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Tests for ${testableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:32-58"",""content"":""\n    // \""⌘\"" on Mac or \""Ctrl\"" on other systems\n    const isMac = isMacOS()\n    const osIcon = isMac ? '⌘' : 'Ctrl+'\n\n    // The Chat Actions are conditionally rendered based on the 'when' property.\n    // The \""Cancel Edit\"" action is only available when isEditing is true, meaning\n    // the user is in the process of editing a message.\n    // The \""Edit Last Message\"" and \""New Chat\"" actions are available when isEditing is false,\n    // indicating that the user is not editing a message and can either edit their last message\n    // or start a new chat session via these buttons that also have keyboard shortcuts associated with them.\n    const actions: {\n        name: string\n        keyLabel: string\n        keyRequiresFocus?: boolean\n        onClick?: () => void\n        focus: boolean\n        when: boolean\n    }[] = [\n        {\n            name: 'Cancel Edit',\n            keyLabel: 'ESC',\n            keyRequiresFocus: true,\n            onClick: onCancelEditClick,\n            focus: false,\n            when: isEditing && !isEmptyChat,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:14-54"",""content"":""export class CodeActionProvider implements vscode.Disposable {\n    private configurationChangeListener: vscode.Disposable\n    private actionProviders: vscode.Disposable[] = []\n\n    constructor(options: CodeActionProviderOptions) {\n        this.registerCodeActions(options.contextProvider.config)\n        this.configurationChangeListener = options.contextProvider.configurationChangeEvent.event(() => {\n            this.registerCodeActions(options.contextProvider.config)\n        })\n    }\n\n    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n    }\n\n    private addActionProvider(ActionType: {\n        new (): vscode.CodeActionProvider\n        providedCodeActionKinds: vscode.CodeActionKind[]\n    }): void {\n        const provider = vscode.languages.registerCodeActionsProvider('*', new ActionType(), {\n            providedCodeActionKinds: ActionType.providedCodeActionKinds,\n        })\n        this.actionProviders.push(provider)\n    }\n\n    public dispose(): void {\n        this.configurationChangeListener.dispose()\n        vscode.Disposable.from(...this.actionProviders).dispose()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/actions/TranscriptAction.tsx:6-15"",""content"":""interface TranscriptActionStep {\n    verb: string\n    object: string | JSX.Element\n\n    /**\n     * The SVG path of an icon.\n     * @example mdiSearchWeb\n     */\n    icon?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:0-32"",""content"":""import type React from 'react'\nimport { useEffect, useRef } from 'react'\n\nimport { isMacOS } from '@sourcegraph/cody-shared'\nimport styles from './ChatActions.module.css'\n\nexport const ChatActions: React.FunctionComponent<{\n    isWebviewActive: boolean\n    isEditing: boolean\n    isMessageInProgress: boolean\n    isEmptyChat: boolean\n    isEmptyEditorValue: boolean\n    isEditorFocused: boolean\n    onChatResetClick: () => void\n    onCancelEditClick: () => void\n    onEditLastMessageClick: () => void\n    setInputFocus: (focus: boolean) => void\n    onRestoreLastChatClick?: () => void\n}> = ({\n    isEditing,\n    isEmptyChat,\n    isEmptyEditorValue,\n    isEditorFocused,\n    isMessageInProgress,\n    onChatResetClick,\n    onCancelEditClick,\n    onEditLastMessageClick,\n    setInputFocus,\n    onRestoreLastChatClick,\n    isWebviewActive,\n}) => {\n    const buttonRef = useRef<HTMLButtonElement>(null)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/actions/TranscriptAction.tsx:17-44"",""content"":""export const TranscriptAction: React.FunctionComponent<{\n    title: string | { verb: string; object: string; tooltip?: string }\n    steps: TranscriptActionStep[]\n    className?: string\n    onClick?: () => void\n}> = ({ title, steps, className, onClick }) => {\n    return (\n        <details className={classNames(className, styles.container)}>\n            <summary onClick={onClick} onKeyDown={onClick}>\n                {typeof title === 'string' ? (\n                    title\n                ) : (\n                    <span title={title.tooltip}>\n                        {title.verb} <strong>{title.object}</strong>\n                    </span>\n                )}\n            </summary>\n            <div className={styles.steps}>\n                {steps.map((step, index) => (\n                    // biome-ignore lint/suspicious/noArrayIndexKey: no other natural key, and this is stable/immutable\n                    <span key={index} className={styles.step}>\n                        {step.object}\n                    </span>\n                ))}\n            </div>\n        </details>\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:18-24"",""content"":""2. Search for `cody.command.custom.{CUSTOM_COMMAND_NAME}`. \n3. Replace `{CUSTOM_COMMAND_NAME}` with the name or key of your custom command, for example, `cody.command.custom.commit`.\n4. Click on the `+` icon next to the command to assign a custom keybinding for your custom command.\n\nFor more information on keyboard settings in VS Code, please refer to the official documentation on [Key Bindings for Visual Studio Code](https://code.visualstudio.com/docs/getstarted/keybindings#_keyboard-shortcuts-editor).\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:727-760"",""content"":""          \""when\"": \""cody.activated\"",\n          \""group\"": \""command\""\n        },\n        {\n          \""command\"": \""cody.menu.custom-commands\"",\n          \""when\"": \""cody.activated\"",\n          \""group\"": \""custom-commands\""\n        },\n        {\n          \""command\"": \""cody.focus\"",\n          \""when\"": \""!cody.activated\"",\n          \""group\"": \""other\""\n        },\n        {\n          \""command\"": \""cody.guardrails.debug\"",\n          \""when\"": \""cody.activated && config.cody.experimental.guardrails && editorHasSelection\"",\n          \""group\"": \""other\""\n        }\n      ],\n      \""view/title\"": [\n        {\n          \""command\"": \""cody.chat.panel.new\"",\n          \""when\"": \""view == cody.chat.tree.view && cody.activated\"",\n          \""group\"": \""navigation@1\""\n        },\n        {\n          \""command\"": \""cody.chat.history.clear\"",\n          \""when\"": \""view == cody.chat.tree.view && cody.activated && cody.hasChatHistory\"",\n          \""enablement\"": \""cody.hasChatHistory\"",\n          \""group\"": \""navigation@2\""\n        },\n        {\n          \""command\"": \""cody.chat.history.export\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:402-435"",""content"":""      },\n      {\n        \""command\"": \""cody.autocomplete.manual-trigger\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Trigger Autocomplete at Cursor\"",\n        \""when\"": \""cody.activated && config.cody.autocomplete && editorHasFocus && !editorReadonly && !editorHasSelection && !inlineSuggestionsVisible\""\n      },\n      {\n        \""command\"": \""cody.chat.panel.new\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""New Chat Panel\"",\n        \""when\"": \""cody.activated\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(new-comment-icon)\""\n      },\n      {\n        \""command\"": \""workbench.action.moveEditorToNewWindow\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Pop out\"",\n        \""when\"": \""cody.activated\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(link-external)\""\n      },\n      {\n        \""command\"": \""cody.chat.tree.view.focus\"",\n        \""category\"": \""Cody\"",\n        \""title\"": \""Open Cody Sidebar\"",\n        \""group\"": \""Cody\"",\n        \""icon\"": \""$(layout-sidebar-left)\""\n      },\n      {\n        \""command\"": \""cody.chat.history.edit\"",\n        \""category\"": \""Cody\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/custom-commands.ts:0-319"",""content"":""import os from 'node:os'\nimport { omit } from 'lodash'\nimport * as vscode from 'vscode'\n\nimport type { CodyCommand } from '@sourcegraph/cody-shared'\n\nimport { logDebug, logError } from '../../log'\n\nimport { isMacOS } from '@sourcegraph/cody-shared'\nimport { CustomCommandType } from '@sourcegraph/cody-shared'\nimport { URI, Utils } from 'vscode-uri'\nimport { getConfiguration } from '../../configuration'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getCommandTreeItems } from '../../services/tree-views/commands'\nimport { showNewCustomCommandMenu } from '../menus'\nimport { type CodyCommandsFile, ConfigFiles } from '../types'\nimport { createFileWatchers, createJSONFile, saveJSONFile } from '../utils/config-file'\nimport { buildCodyCommandMap } from '../utils/get-commands'\nimport { getDocText } from '../utils/workspace-files'\n\nconst isTesting = process.env.CODY_TESTING === 'true'\nconst userHomePath = os.homedir() || process.env.HOME || process.env.USERPROFILE || ''\n\n/**\n * Handles loading, building, and maintaining Custom Commands retrieved from cody.json files\n */\nexport class CustomCommandsManager implements vscode.Disposable {\n    // Watchers for the cody.json files\n    private fileWatcherDisposables: vscode.Disposable[] = []\n    private registeredCommands: vscode.Disposable[] = []\n    private disposables: vscode.Disposable[] = []\n\n    public customCommandsMap = new Map<string, CodyCommand>()\n\n    // Configuration files\n    protected configFileName\n    private userConfigFile\n    private get workspaceConfigFile(): vscode.Uri | undefined {\n        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri\n        if (!workspaceRoot) {\n            return undefined\n        }\n        return Utils.joinPath(workspaceRoot, this.configFileName)\n    }\n\n    constructor(private sidebar: TreeViewProvider) {\n        // TODO (bee) Migrate to use .cody/commands.json for VS Code\n        // Right now agent is using .cody/commands.json for Custom Commands,\n        // .vscode/cody.json in VS Code.\n        const workspaceConfig = vscode.workspace.getConfiguration()\n        const config = getConfiguration(workspaceConfig)\n        this.configFileName = config.isRunningInsideAgent ? ConfigFiles.COMMAND : ConfigFiles.VSCODE\n        this.userConfigFile = Utils.joinPath(URI.file(userHomePath), this.configFileName)\n\n        this.disposables.push(\n            vscode.commands.registerCommand('cody.menu.custom.build', () =>\n                this.newCustomCommandQuickPick()\n            ),\n            vscode.commands.registerCommand('cody.commands.open.json', type =>\n                this.configFileActions(type, 'open')\n            ),\n            vscode.commands.registerCommand('cody.commands.delete.json', type =>\n                this.configFileActions(type, 'delete')\n            )\n        )\n    }\n\n    /**\n     // TODO (bee) Migrate to use .cody/commands.json\n     * Create file watchers for cody.json files.\n     * Automatically update the command map when the cody.json files are changed\n     */\n    public init(): void {\n        const userConfigWatcher = createFileWatchers(this.userConfigFile)\n        if (userConfigWatcher) {\n            this.fileWatcherDisposables.push(\n                userConfigWatcher,\n                userConfigWatcher.onDidChange(() => this.refresh?.()),\n                userConfigWatcher.onDidDelete(() => this.refresh?.())\n            )\n        }\n\n        // Create file watchers in trusted workspaces only\n        if (vscode.workspace.isTrusted) {\n            const wsConfigWatcher = createFileWatchers(this.workspaceConfigFile)\n            if (wsConfigWatcher) {\n                this.fileWatcherDisposables.push(\n                    wsConfigWatcher,\n                    wsConfigWatcher.onDidChange(() => this.refresh?.()),\n                    wsConfigWatcher.onDidDelete(() => this.refresh?.())\n                )\n            }\n        }\n\n        if (this.fileWatcherDisposables.length) {\n            logDebug('CommandsController:init', 'watchers created')\n        }\n    }\n\n    /**\n     * Gets the map of custom commands.\n     *\n     * The custom commands map is a collection of CodyCommand objects, where the key\n     * is the command name and the value is the command object.\n     */\n    public get commands(): Map<string, CodyCommand> {\n        return this.customCommandsMap\n    }\n\n    /**\n     * Get the uri of the cody.json file for the given type\n     */\n    private getConfigFileByType(type: CustomCommandType): vscode.Uri | undefined {\n        const configFileUri =\n            type === CustomCommandType.User ? this.userConfigFile : this.workspaceConfigFile\n        return configFileUri\n    }\n\n    /**\n     * Rebuild the Custom Commands Map from the cody.json files\n     */\n    public async refresh(): Promise<CodyCommandsFile> {\n        try {\n            // Deregister all commands before rebuilding them to avoid duplicates\n            this.disposeRegisteredCommands()\n            // Reset the map before rebuilding\n            this.customCommandsMap = new Map<string, CodyCommand>()\n            // user commands\n            if (this.userConfigFile?.path) {\n                await this.build(CustomCommandType.User)\n            }\n            // 🚨 SECURITY: Only build workspace command in trusted workspace\n            if (vscode.workspace.isTrusted) {\n                await this.build(CustomCommandType.Workspace)\n            }\n        } catch (error) {\n            logError('CustomCommandsProvider:refresh', 'failed', { verbose: error })\n        }\n        this.sidebar.setTreeNodes(getCommandTreeItems([...this.customCommandsMap.values()]))\n        return { commands: this.customCommandsMap }\n    }\n\n    /**\n     * Handles building the Custom Commands Map from the cody.json files\n     *\n     * 🚨 SECURITY: Only build workspace command in trusted workspace\n     */\n    public async build(type: CustomCommandType): Promise<Map<string, CodyCommand> | null> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri || (type === CustomCommandType.Workspace && !vscode.workspace.isTrusted)) {\n            return null\n        }\n        try {\n            const content = await getDocText(uri)\n            if (!content.trim()) {\n                return null\n            }\n            const customCommandsMap = buildCodyCommandMap(type, content)\n            this.customCommandsMap = new Map([...this.customCommandsMap, ...customCommandsMap])\n\n            // Register Custom Commands as VS Code commands\n            for (const [key, _command] of customCommandsMap) {\n                this.registeredCommands.push(\n                    vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>\n                        vscode.commands.executeCommand('cody.action.command', key, {\n                            source: 'editor',\n                        })\n                    )\n                )\n            }\n        } catch (error) {\n            console.error('CustomCommandsProvider:build', 'failed', { verbose: error })\n        }\n        return this.customCommandsMap\n    }\n\n    /**\n     * Quick pick for creating a new custom command\n     */\n    private async newCustomCommandQuickPick(): Promise<void> {\n        const commands = [...this.customCommandsMap.values()].map(c => c.key)\n        const newCommand = await showNewCustomCommandMenu(commands)\n        if (!newCommand) {\n            return\n        }\n\n        // Save the prompt to the current Map and Extension storage\n        await this.save(newCommand.key, newCommand.prompt, newCommand.type)\n        await this.refresh()\n\n        // Notify user\n        const isUserCommand = newCommand.type === CustomCommandType.User\n        const buttonTitle = `Open ${isUserCommand ? 'User' : 'Workspace'} Settings (JSON)`\n        void vscode.window\n            .showInformationMessage(\n                `New ${newCommand.key} command saved to ${newCommand.type} settings`,\n                buttonTitle\n            )\n            .then(async choice => {\n                if (choice === buttonTitle) {\n                    await this.configFileActions(newCommand.type, 'open')\n                }\n            })\n\n        logDebug('CustomCommandsProvider:newCustomCommandQuickPick:', 'saved', {\n            verbose: newCommand,\n        })\n    }\n\n    /**\n     * Add the newly create command via quick pick to the cody.json file on disk\n     */\n    private async save(\n        id: string,\n        command: CodyCommand,\n        type: CustomCommandType = CustomCommandType.User\n    ): Promise<void> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri) {\n            return\n        }\n        const fileContent = await getDocText(uri)\n        const parsed = JSON.parse(fileContent) as Record<string, any>\n        const commands = parsed.commands ?? parsed\n        commands[id] = omit(command, 'key')\n        await saveJSONFile(parsed, uri)\n    }\n\n    private async configFileActions(\n        type: CustomCommandType,\n        action: 'open' | 'delete' | 'create'\n    ): Promise<void> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri) {\n            return\n        }\n        switch (action) {\n            case 'open':\n                void vscode.commands.executeCommand('vscode.open', uri)\n                break\n            case 'delete': {\n                let fileType = 'user settings file (~/.vscode/cody.json)'\n                if (type === CustomCommandType.Workspace) {\n                    fileType = 'workspace settings file (.vscode/cody.json)'\n                }\n                const bin = isMacOS() ? 'Trash' : 'Recycle Bin'\n                const confirmationKey = `Move to ${bin}`\n                // Playwright cannot capture and interact with pop-up modal in VS Code,\n                // so we need to turn off modal mode for the display message during tests.\n                const modal = !isTesting\n                vscode.window\n                    .showInformationMessage(\n                        `Are you sure you want to delete your Cody ${fileType}?`,\n                        { detail: `You can restore this file from the ${bin}.`, modal },\n                        confirmationKey\n                    )\n                    .then(async choice => {\n                        if (choice === confirmationKey) {\n                            void vscode.workspace.fs.delete(uri)\n                        }\n                    })\n                break\n            }\n            case 'create':\n                await createJSONFile(uri)\n                    .then(() => {\n                        vscode.window\n                            .showInformationMessage(\n                                `Cody ${type} settings file created`,\n                                'View Documentation'\n                            )\n                            .then(async choice => {\n                                if (choice === 'View Documentation') {\n                                    await openCustomCommandDocsLink()\n                                }\n                            })\n                    })\n                    .catch(error => {\n                        const errorMessage = 'Failed to create cody.json file: '\n                        void vscode.window.showErrorMessage(`${errorMessage} ${error}`)\n                        logDebug('CustomCommandsProvider:configActions:create', 'failed', {\n                            verbose: error,\n                        })\n                    })\n                break\n        }\n    }\n\n    /**\n     * Reset\n     */\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.disposeRegisteredCommands()\n        this.disposeWatchers()\n        this.customCommandsMap = new Map<string, CodyCommand>()\n    }\n\n    private disposeWatchers(): void {\n        for (const disposable of this.fileWatcherDisposables) {\n            disposable.dispose()\n        }\n        this.fileWatcherDisposables = []\n    }\n\n    private disposeRegisteredCommands(): void {\n        for (const rc of this.registeredCommands) {\n            rc.dispose()\n        }\n        this.registeredCommands = []\n    }\n}\n\nexport async function openCustomCommandDocsLink(): Promise<void> {\n    const uri = 'https://sourcegraph.com/docs/cody/custom-commands'\n    await vscode.env.openExternal(vscode.Uri.parse(uri))\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:70-91"",""content"":""\n    // Trigger chat-based commands (explain, test, smell), which are effectively\n    // shortcuts to start a new chat with a templated question. The return value\n    // of these commands is the same as `chat/new`, an ID to reference to the\n    // webview panel where the reply from this command appears.\n    'commands/explain': [null, string] // TODO: rename to chatCommands/{explain,test,smell}\n    'commands/test': [null, string]\n    'commands/smell': [null, string]\n\n    // Trigger custom commands that could be a chat-based command or an edit command.\n    'commands/custom': [{ key: string }, CustomCommandResult]\n\n    // Trigger commands that edit the code.\n    'editCommands/code': [{ instruction: string; model: string }, EditTask]\n    'editCommands/test': [null, EditTask]\n    'editCommands/document': [null, EditTask]\n\n    // If the task is \""applied\"", discards the task.\n    'editTask/accept': [{ id: FixupTaskID }, null]\n    // If the task is \""applied\"", attempts to revert the task's edit, then\n    // discards the task.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/SidebarCommands.ts:0-30"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    ACCOUNT_LIMITS_INFO_URL,\n    ACCOUNT_UPGRADE_URL,\n    ACCOUNT_USAGE_URL,\n    CODY_DOC_URL,\n    CODY_FEEDBACK_URL,\n    CODY_SUPPORT_URL,\n    DISCORD_URL,\n} from '../chat/protocol'\nimport { releaseNotesURL } from '../release'\nimport { telemetryService } from '../services/telemetry'\nimport { telemetryRecorder } from '../services/telemetry-v2'\nimport { version } from '../version'\n\nexport function registerSidebarCommands(): vscode.Disposable[] {\n    function logSidebarClick(feature: string) {\n        telemetryService.log(`CodyVSCodeExtension:sidebar:${feature}:clicked`, undefined, {\n            hasV2Event: true,\n        })\n        telemetryRecorder.recordEvent(`cody.sidebar.${feature}`, 'clicked')\n    }\n\n    return [\n        vscode.commands.registerCommand('cody.sidebar.commands', (feature: string, command: string) => {\n            // For Custom Commands\n            if (command === 'cody.action.command') {\n                logSidebarClick('custom')\n                void vscode.commands.executeCommand(command, feature, { source: 'sidebar' })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1015-1050"",""content"":""### Changed\n\n- Remove `starter` and `premade` fields from the configuration files for custom commands (cody.json). [pull/939](https://github.com/sourcegraph/cody/pull/939)\n- Enabled streaming responses for all autocomplete requests. [pull/995](https://github.com/sourcegraph/cody/pull/995)\n- Sign out immediately instead of showing the quick-pick menu. [pull/1032](https://github.com/sourcegraph/cody/pull/1032)\n- UX improvements to the custom command workflow (and new [custom command docs](https://sourcegraph.com/docs/cody/custom-commands)). [pull/992](https://github.com/sourcegraph/cody/pull/992)\n- You can now use `alt` + `\\` to trigger autocomplete requests manually. [pull/1060](https://github.com/sourcegraph/cody/pull/1060)\n- Slightly reduce latency when manually triggering autocomplete requests. [pull/1060](https://github.com/sourcegraph/cody/pull/1060)\n- Configure autocomplete provider based on cody LLM settings in site config. [pull/1035](https://github.com/sourcegraph/cody/pull/1035)\n- Filters out single character autocomplete results. [pull/1109](https://github.com/sourcegraph/cody/pull/1109)\n- Register inline completion provider for text files and notebooks only to ensure autocomplete works in environments that are fully supported. [pull/1114](https://github.com/sourcegraph/cody/pull/1114)\n- The `Generate Unit Tests` command has been improved with an enhanced context fetching process that produces test results with better quality. [pull/907](https://github.com/sourcegraph/cody/pull/907)\n\n## [0.10.2]\n\n### Added\n\n### Fixed\n\n### Changed\n\n- Use the same token limits for StarCoder as we do for Anthropic for the current experiments. [pull/1058](https://github.com/sourcegraph/cody/pull/1058)\n\n## [0.10.1]\n\n### Added\n\n### Fixed\n\n- Fix feature flag initialization for autocomplete providers. [pull/965](https://github.com/sourcegraph/cody/pull/965)\n\n### Changed\n\n## [0.10.0]\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_018/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The decision to use enhanced context for chat is determined in the `getEnhancedContext` function in the file `cody_test/vscode/src/chat/chat-view/context.ts`. This function checks the `strategy` parameter, which is of type `ConfigurationUseContext`. If the strategy is not set to 'none', it will proceed to retrieve enhanced context from various sources such as embeddings, remote search, and local search (symf).

Additionally, the `useEnhancedContextEnabled` hook in `cody_test/vscode/webviews/chat/EnhancedContext.tsx` is used to determine if enhanced context is enabled in the chat UI.

The `EnhancedContextSettings` component in `cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx` also plays a role in managing the enhanced context settings, allowing users to toggle this feature.",Where do we determine whether to use enhanced context for chat?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/can-use-partial-completion.ts:0-41"",""content"":""import type { TextDocument } from 'vscode'\n\nimport type { DocumentContext } from '@sourcegraph/cody-shared'\nimport { hasCompleteFirstLine } from './text-processing'\nimport { parseAndTruncateCompletion } from './text-processing/parse-and-truncate-completion'\nimport type { InlineCompletionItemWithAnalytics } from './text-processing/process-inline-completions'\n\ninterface CanUsePartialCompletionParams {\n    document: TextDocument\n    docContext: DocumentContext\n}\n\n/**\n * Evaluates a partial completion response and returns it when we can already use it. This is used\n * to terminate any streaming responses where we can get a token-by-token access to the result and\n * want to terminate as soon as stop conditions are triggered.\n *\n * Right now this handles two cases:\n *  1. When a single line completion is requested, it terminates after the first full line was\n *     received.\n *  2. For a multi-line completion, it terminates when the completion will be truncated based on the\n *     multi-line indentation logic.\n */\nexport function canUsePartialCompletion(\n    partialResponse: string,\n    params: CanUsePartialCompletionParams\n): InlineCompletionItemWithAnalytics | null {\n    const { docContext } = params\n\n    if (!hasCompleteFirstLine(partialResponse)) {\n        return null\n    }\n\n    const item = parseAndTruncateCompletion(partialResponse, params)\n\n    if (docContext.multilineTrigger) {\n        return (item.lineTruncatedCount || 0) > 0 ? item : null\n    }\n\n    return item.insertText.trim() === '' ? null : item\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/counter.ts:26-43"",""content"":""     * Indicates whether the Chat and User-Context share the same token budget.\n     * - If true, all types of messages share the same token budget with Chat.\n     * - If false (Feature Flag required), the User-Context will has a separated budget.\n     * NOTE: Used in remainingTokens for calculating the remaining token budget for each budget type.\n     */\n    private shareChatAndUserBudget = true\n\n    constructor(contextWindow: ModelContextWindow) {\n        // If there is no context window reserved for context.user,\n        // context will share the same token budget with chat.\n        this.shareChatAndUserBudget = !contextWindow.context?.user\n        this.maxChatTokens = contextWindow.input\n        this.maxContextTokens = {\n            user: contextWindow.context?.user ?? contextWindow.input,\n            enhanced: Math.floor(contextWindow.input * ENHANCED_CONTEXT_ALLOCATION),\n        }\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:51-53"",""content"":""function useChatContextClient(): ChatContextClient {\n    return useContext(ChatContextClientContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/active-editor.ts:0-26"",""content"":""import * as vscode from 'vscode'\n\nimport { isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\n/**\n * Interface for tracking the last active text editor that is not a webview panel for\n * the new Chat Panel UI.\n *\n * active: The current valid active/supported text editor instance.\n * ignored: Whether the active editor is ignored by Cody or not.\n */\ninterface LastActiveTextEditor {\n    active?: vscode.TextEditor\n    ignored?: boolean\n}\n\n/**\n * This returns the current active text editor instance if available,\n * along with a boolean indicating if the text editor is on the Cody ignored list.\n * Returns undefined if no editor is active.\n *\n * NOTE: ALL USERS of chat interface in VS Code should use this to get the correct Active Editor instead of using\n * 'vscode.window.activeTextEditor' as this handles cases where the activeTextEditor API will always return\n * 'undefined' when user is focused on the webview chat panel.\n *\n * NOTE: Users that operate within an actual text editor (non-webview panels) do not need to use this API as calling\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:56-108"",""content"":""export function useChatContextItems(query: string | null): ContextItem[] | undefined {\n    const chatContextClient = useChatContextClient()\n    const [results, setResults] = useState<ContextItem[]>()\n    // biome-ignore lint/correctness/useExhaustiveDependencies: we only want to run this when query changes.\n    useEffect(() => {\n        // An empty query is a valid query that we use to get open tabs context,\n        // while a null query means this is not an at-mention query.\n        if (query === null) {\n            setResults(undefined)\n            return\n        }\n\n        // If the query ends with a colon, we will reuse current results but remove the range.\n        if (query.endsWith(':')) {\n            const selected = results?.find(r => displayPath(r.uri) === query.slice(0, -1))\n            setResults(\n                selected\n                    ? [{ ...selected, range: undefined }]\n                    : results?.map(r => ({ ...r, range: undefined }))\n            )\n            return\n        }\n\n        // If user is typing a line range, fetch new chat context items only if there are no results\n        if (results?.length && RANGE_MATCHES_REGEXP.test(query) && !LINE_RANGE_REGEXP.test(query)) {\n            return\n        }\n\n        // Track if the query changed since this request was sent (which would make our results\n        // no longer valid).\n        let invalidated = false\n\n        if (chatContextClient) {\n            chatContextClient\n                .getChatContextItems(query)\n                .then(mentions => {\n                    if (invalidated) {\n                        return\n                    }\n                    setResults(mentions)\n                })\n                .catch(error => {\n                    setResults(undefined)\n                    console.error(error)\n                })\n        }\n\n        return () => {\n            invalidated = true\n        }\n    }, [query])\n    return results\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:98-116"",""content"":""            }\n            const enhancedContext = prevContext.filter(c => c.source !== 'user')\n            if (promptBuilder.tryAddContext('enhanced', enhancedContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior enhanced context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n            }\n\n            // Add additional context from current editor or broader search when enhanced context is enabled\n            if (this.getEnhancedContext) {\n                const lastMessage = reverseTranscript[0]\n                if (!lastMessage?.text) {\n                    throw new Error('No last message or last message text was empty')\n                }\n                if (lastMessage.speaker === 'assistant') {\n                    throw new Error('Last message in prompt needs speaker \""human\"", but was \""assistant\""')\n                }\n                const newEnhancedContext = await this.getEnhancedContext(lastMessage.text)\n                sortContextItems(newEnhancedContext)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/animal.ts:0-5"",""content"":""interface Animal {\n    name: string;\n    age: number;\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/local-embeddings.test.ts:140-164"",""content"":""    await openFile(page, 'main.c')\n    await sidebarSignin(page, sidebar)\n    const chatFrame = await newChat(page)\n\n    const enableEmbeddingsButton = chatFrame.getByText('Enable Embeddings')\n    // This may take a while, we download and start cody-engine\n    await expect(enableEmbeddingsButton).toBeVisible({ timeout: 60000 })\n    await enableEmbeddingsButton.click()\n\n    await expect(chatFrame.getByText('Embeddings — Indexed')).toBeVisible({\n        timeout: 30000,\n    })\n\n    // Search the embeddings. This test uses the \""stub\"" embedding model, which\n    // is deterministic, but the searches are not semantic.\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    await chatInput.fill('hello world')\n    await chatInput.press('Enter')\n    const contextCell = getContextCell(chatFrame)\n    await expectContextCellCounts(contextCell, {\n        files: 2,\n        timeout: 10000,\n    })\n})\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/squirrel.ts:0-11"",""content"":""interface CodeIntelligence {\n    symbols: string[]\n}\n\n/**\n * Squirrel is a code intelligence API.\n */\ninterface Squirrel {\n    symbolInformation(file: string): CodeIntelligence\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:32-64"",""content"":""    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n}\nexport async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/README.md:0-5"",""content"":""# Cody Agent\n\nThe `@sourcegraph/cody-agent` package implements a JSON-RPC server to interact\nwith Cody via stdout/stdin. This package is intended to be used by\nnon-ECMAScript clients such as the JetBrains and NeoVim plugins.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:682-694"",""content"":""\n### Changed\n\n- Chat: Uses the new Chat UI by default. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Inline Chat is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Fixup Tree View is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Enhanced Context used to turn off automatically after the first chat. Now it stays enabled until you disable it. [pull/2069](https://github.com/sourcegraph/cody/pull/2069)\n- Chat: Reuse existing New Chat panel to prevent having multiple new chats open at once. [pull/2087](https://github.com/sourcegraph/cody/pull/2087)\n- Chat: Close the Enhanced Context popover on chat input focus. [pull/2091](https://github.com/sourcegraph/cody/pull/2091)\n- Chat: Show onboarding glowy dot guide until first time opening Enhanced Context. [pull/2097](https://github.com/sourcegraph/cody/pull/2097)\n- In 0.12, we simplified the sign-in process and removed the option to sign into\n  Cody App from VScode. If you were still signed in to Cody App, we invite you to\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:67-69"",""content"":""function useEnhancedContextEventHandlers(): EnhancedContextEventHandlersT {\n    return React.useContext(EnhancedContextEventHandlers)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:94-157"",""content"":""async function getEnhancedContextFromRanker({\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    return wrapInActiveSpan('chat.enhancedContextRanker', async span => {\n        // Get all possible context items to rank\n        let searchContext = getVisibleEditorContext(editor)\n\n        const numResults = 50\n        const embeddingsContextItemsPromise = retrieveContextGracefully(\n            searchEmbeddingsLocal(providers.localEmbeddings, text, numResults),\n            'local-embeddings'\n        )\n\n        const modelSpecificEmbeddingsContextItemsPromise = contextRanking\n            ? retrieveContextGracefully(\n                  contextRanking.searchModelSpecificEmbeddings(text, numResults),\n                  'model-specific-embeddings'\n              )\n            : []\n\n        const precomputeQueryEmbeddingPromise = contextRanking?.precomputeContextRankingFeatures(text)\n\n        const localSearchContextItemsPromise = providers.symf\n            ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n            : []\n\n        const remoteSearchContextItemsPromise = providers.remoteSearch\n            ? await retrieveContextGracefully(\n                  searchRemote(providers.remoteSearch, text),\n                  'remote-search'\n              )\n            : []\n\n        const keywordContextItemsPromise = (async () => [\n            ...(await localSearchContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n        ])()\n\n        const [embeddingsContextItems, keywordContextItems, modelEmbeddingContextItems] =\n            await Promise.all([\n                embeddingsContextItemsPromise,\n                keywordContextItemsPromise,\n                modelSpecificEmbeddingsContextItemsPromise,\n                precomputeQueryEmbeddingPromise,\n            ])\n\n        searchContext = searchContext\n            .concat(keywordContextItems)\n            .concat(embeddingsContextItems)\n            .concat(modelEmbeddingContextItems)\n        const editorContext = await getPriorityContext(text, editor, searchContext)\n        const allContext = editorContext.concat(searchContext)\n        if (!contextRanking) {\n            return allContext\n        }\n        const rankedContext = wrapInActiveSpan('chat.enhancedContextRanker.reranking', () =>\n            contextRanking.rankContextItems(text, allContext)\n        )\n        return rankedContext\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:24-35"",""content"":""interface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/context-settings.test.ts:24-43"",""content"":""\n    // Opening the enhanced context settings should focus the checkbox for toggling it.\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n\n    // Enhanced context should be enabled by default.\n    await expect(enhancedContextCheckbox).toBeChecked()\n    await page.keyboard.press('Space') // Disable enhanced context\n    // The keyboard should toggle the checkbox, but not dismiss the popup.\n    await expect(enhancedContextCheckbox).not.toBeChecked()\n    await expect(enhancedContextCheckbox).toBeVisible()\n\n    // The popup should be dismiss-able with the keyboard.\n    await page.keyboard.press('Escape')\n    // Closing the enhanced context settings should close the dialog...\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    // ... and the focus is moved to the chat input on close.\n    const contextSettingsButton = chatFrame.getByTitle('Configure Enhanced Context')\n    await expect(contextSettingsButton.and(page.locator(':focus'))).not.toBeVisible()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:36-92"",""content"":""export async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n                      searchEmbeddingsLocal(providers.localEmbeddings, text),\n                      'local-embeddings'\n                  )\n                : []\n\n        //  Get search (symf or remote search) context if config is not set to 'embeddings' only\n        const remoteSearchContextItemsPromise =\n            providers.remoteSearch && strategy !== 'embeddings'\n                ? await retrieveContextGracefully(\n                      searchRemote(providers.remoteSearch, text),\n                      'remote-search'\n                  )\n                : []\n        const localSearchContextItemsPromise =\n            providers.symf && strategy !== 'embeddings'\n                ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n                : []\n\n        // Combine all context sources\n        const searchContext = [\n            ...(await embeddingsContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n            ...(await localSearchContextItemsPromise),\n        ]\n\n        const priorityContext = await getPriorityContext(text, editor, searchContext)\n        return priorityContext.concat(searchContext)\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15"",""content"":""export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287"",""content"":""\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the “Chats” panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the “Chats” panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the “Chats” panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \""Enhanced Context\"" icon next to the chat input.\n- [ ] Verify that \""Enhanced Context\"" is enabled by default.\n\n### Consumer\n\nSet up steps:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:377-385"",""content"":""- We now allocate no more than 60% of the overall LLM context window for enhanced context. This preserves more room for follow-up questions and context. [pull/2768](https://github.com/sourcegraph/cody/pull/2768)\n- Chat: Renamed the \""Restart Chat Session\"" button to \""New Chat Session\"". [pull/2786](https://github.com/sourcegraph/cody/pull/2786)\n- Removed the `cody.experimental.chatPredictions` setting. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Removed support for the `context.codebase` custom command property. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Autocomplete: Better cancellation of requests that are no longer relevant. [pull/2855](https://github.com/sourcegraph/cody/pull/2855)\n- Updated Enhanced Context popover copy and added a link to the docs. [pull/2864](https://github.com/sourcegraph/cody/pull/2864)\n- Include meta information about unit test files in Autocomplete analytics. [pull/2868](https://github.com/sourcegraph/cody/pull/2868)\n- Moved the Context Limit errors in chat into the deboug log output. [pull/2891](https://github.com/sourcegraph/cody/pull/2891)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.test.ts:0-150"",""content"":""import { describe, expect, it } from 'vitest'\nimport * as vscode from 'vscode'\n\nimport type * as status from '@sourcegraph/cody-shared'\n\nimport { ContextStatusAggregator } from './enhanced-context-status'\n\nclass TestProvider implements status.ContextStatusProvider {\n    public emitter: vscode.EventEmitter<status.ContextStatusProvider> = new vscode.EventEmitter()\n\n    constructor(private status_: status.ContextGroup[] | undefined = undefined) {}\n\n    public onDidChangeStatus(\n        callback: (provider: status.ContextStatusProvider) => void\n    ): vscode.Disposable {\n        return this.emitter.event(callback)\n    }\n\n    public get status(): status.ContextGroup[] {\n        return (\n            this.status_ || [\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'embeddings',\n                            state: 'unconsented',\n                        },\n                    ],\n                },\n            ]\n        )\n    }\n    public set status(status: status.ContextGroup[]) {\n        this.status_ = status\n    }\n}\n\ndescribe('ContextStatusAggregator', () => {\n    it('should fire status changed when providers are added and pass through simple status', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => resolve(provider.status))\n        })\n        aggregator.addProvider(new TestProvider())\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                ],\n            },\n        ])\n        aggregator.dispose()\n    })\n    it('should fire aggregate status from multiple providers', async () => {\n        const aggregator = new ContextStatusAggregator()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        aggregator.addProvider(new TestProvider())\n        aggregator.addProvider(\n            new TestProvider([\n                {\n                    displayName: 'host.example/foo',\n                    providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n                },\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'search',\n                            type: 'remote',\n                            state: 'ready',\n                            id: 'quux',\n                            inclusion: 'manual',\n                        },\n                    ],\n                },\n            ])\n        )\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id: 'quux',\n                        inclusion: 'manual',\n                    },\n                ],\n            },\n            {\n                displayName: 'host.example/foo',\n                providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n            },\n        ])\n        // Not only does it aggregate status, it coalesces update events\n        expect(callbackCount).toBe(1)\n        aggregator.dispose()\n    })\n    it('should respond to child events by firing an event of its own', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const provider = new TestProvider()\n        aggregator.addProvider(provider)\n        // Skip the first update event.\n        await Promise.resolve()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        provider.status = [\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [{ kind: 'search', type: 'local', state: 'indexing' }],\n            },\n        ]\n        provider.emitter.fire(provider)\n\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'local',\n                        state: 'indexing',\n                    },\n                ],\n            },\n        ])\n        expect(callbackCount).toBe(1)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:64-89"",""content"":""\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.ts:0-158"",""content"":""import * as vscode from 'vscode'\n\nimport type { ContextGroup, ContextStatusProvider } from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\n// Collects context status from a set of ContextStatusProviders and produces\n// a merged status view.\nexport class ContextStatusAggregator implements vscode.Disposable, ContextStatusProvider {\n    private static TAG = 'ContextStatusAggregator'\n    private disposables: Set<vscode.Disposable> = new Set()\n    private statusEmitter: vscode.EventEmitter<ContextStatusProvider> =\n        new vscode.EventEmitter<ContextStatusProvider>()\n    private providerStatusMap: Map<ContextStatusProvider, ContextGroup[] | 'needs-status'> | undefined =\n        new Map()\n\n    // Whether we have been notified of status changes, but are yet to pass that\n    // notification on. We do this to de-bounce updates from multiple status\n    // providers in one turn of the event loop.\n    private pendingPublish = false\n\n    // Disposes this ContextStatusAggregator.\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.providerStatusMap = undefined\n    }\n\n    // Adds a provider to this ContextStatusAggregator. The aggregator will\n    // subscribe to the provider and aggregate its updates into a merged status.\n    // To remove this provider, dispose of the returned disposable.\n    //\n    // If the provider is disposable, it should dispose of the registration in\n    // its dispose method. Otherwise this ContextStatusAggregator may continue\n    // to poll its status property, and show its status in the aggregate status.\n    public addProvider(provider: ContextStatusProvider): vscode.Disposable {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const disposable = provider.onDidChangeStatus(putativeProvider => {\n            if (provider !== putativeProvider) {\n                logDebug(\n                    ContextStatusAggregator.TAG,\n                    'got onDidChangeStatus event but passed mismatched provider'\n                )\n            }\n            this.providerDidChangeStatus(provider)\n        })\n        this.disposables.add(disposable)\n        this.providerStatusMap.set(provider, 'needs-status')\n        this.providerDidChangeStatus(provider)\n        return {\n            dispose: (): void => {\n                if (this.providerStatusMap) {\n                    this.providerStatusMap.delete(provider)\n                    this.disposables.delete(disposable)\n                    disposable.dispose()\n                    this.publishStatus()\n                }\n            },\n        }\n    }\n\n    // Records that the provider's state is dirty, and schedules an update.\n    private providerDidChangeStatus(provider: ContextStatusProvider): void {\n        if (this.providerStatusMap === undefined) {\n            // We have been disposed\n            return\n        }\n        if (!this.providerStatusMap.has(provider)) {\n            // The provider has been removed. This should not happen if the\n            // providers are following the dispose protocol.\n            return\n        }\n        // Record that we need to get provider status next update.\n        this.providerStatusMap.set(provider, 'needs-status')\n        // Schedule an update.\n        this.publishStatus()\n    }\n\n    // Aggregates and publishes status asynchronously. Multiple context status\n    // providers updating \""at once\"" will be coalesced into one update.\n    private publishStatus(): void {\n        if (this.pendingPublish) {\n            // Coalesce multiple updates.\n            return\n        }\n        this.pendingPublish = true\n        void Promise.resolve().then(() => {\n            this.pendingPublish = false\n            this.statusEmitter.fire(this)\n        })\n    }\n\n    // ContextStatusProvider implementation of onDidChangeStatus. The\n    // ContextStatusAggregator can be stacked to combine per-workspace and\n    // per-chat context status.\n    public onDidChangeStatus(callback: (sender: ContextStatusProvider) => void): vscode.Disposable {\n        return this.statusEmitter.event(callback)\n    }\n\n    // Computes the merged context status. This may throw if any of the\n    // aggregated providers' status throw.\n    public get status(): ContextGroup[] {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const groupBy: { [name: string]: ContextGroup } = {}\n        // Iterate through provider status map entries\n        for (let [provider, status] of this.providerStatusMap.entries()) {\n            if (status === 'needs-status') {\n                // The provider's status is stale; poll it.\n                status = provider.status\n                if (this.providerStatusMap.get(provider) !== 'needs-status') {\n                    logDebug(\n                        ContextStatusAggregator.TAG,\n                        'ContextStatusProvider.status should only report status, not change state',\n                        provider\n                    )\n                }\n                // Deep clone the status object so providers can't continue to change it without notifying.\n                status = JSON.parse(JSON.stringify(status)) as ContextGroup[]\n                // Cache the status so we don't re-poll this provider unless it changes.\n                this.providerStatusMap.set(provider, status)\n            }\n\n            // Collect context groups by name\n            for (const group of status) {\n                if (group.displayName in groupBy) {\n                    // Merge the items in the group.\n                    groupBy[group.displayName].providers.push(...group.providers)\n                } else {\n                    // Create a new group for the merged result.\n                    groupBy[group.displayName] = {\n                        displayName: group.displayName,\n                        providers: [...group.providers],\n                    }\n                }\n            }\n        }\n        // Order sources within the groups by a canonical order\n        for (const groups of Object.values(groupBy)) {\n            // Sort by a fixed locale for consistency. The 'kind' key is not a\n            // localized UI label.\n            groups.providers.sort((a, b) => a.kind.localeCompare(b.kind, 'en-US'))\n        }\n        return [...Object.values(groupBy)]\n    }\n\n    // TODO: Create a publisher to push into the webview\n    // TODO: Hook in local embeddings\n    // TODO: Hook in cloud embeddings\n    // TODO: Hook in symf\n    // TODO: Hook in graph\n    // TODO: Hook in the Cody: building code index ... notification pusher's\n    // state\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/common.ts:50-74"",""content"":""\n/**\n * Create and open a new chat panel, and close the enhanced context settings window.\n * Returns the chat panel frame locator.\n */\nexport async function createEmptyChatPanel(page: Page): Promise<[FrameLocator, Locator]> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    const chatFrame = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n    await page.keyboard.press('Escape')\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    return [chatFrame, chatInput]\n}\n\n/**\n * Gets the chat context cell. If {@link counts} is specified, then validates that the context\n * exactly matches the specified file and line counts.\n */\nexport function getContextCell(\n    chatPanel: FrameLocator,\n    counts?: { files: number; lines: number }\n): Locator {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/EnhancedContext.tsx:4-6"",""content"":""export function useEnhancedContextEnabled(): boolean {\n    return React.useContext(EnhancedContextEnabled)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_019/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, we query the embeddings model in the `retrieveEmbeddingBasedContext` method of the `ContextRankingController` class. This can be seen in the file `cody_test/vscode/src/local-context/context-ranking.ts`.

The relevant code snippet is:

```typescript
const resp = await service.request('context-ranking/context-retriever-embedding', {
    repoPath: repoUri.path,
    query: query.toString(),
    modelName: modelName,
    numResults: numResults,
})
```

This method sends a request to the 'context-ranking/context-retriever-embedding' endpoint with the repository path, query, model name, and the number of results to retrieve. The model name used for embeddings is 'sentence-transformers/multi-qa-mpnet-base-dot-v1', as specified in the `searchModelSpecificEmbeddings` method of the same file.",Where do we query the embeddings model?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/index.ts:132-134"",""content"":""    public static getProviderByModel(modelID: string): ModelProvider | undefined {\n        return ModelProvider.providers.find(m => m.model === modelID)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:502-541"",""content"":""      },\n      {\n        \""command\"": \""cody.embeddings.resolveIssue\"",\n        \""title\"": \""Cody Embeddings\"",\n        \""when\"": \""cody.embeddings.hasIssue\""\n      },\n      {\n        \""command\"": \""cody.debug.export.logs\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Export Logs…\""\n      },\n      {\n        \""command\"": \""cody.debug.outputChannel\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Open Output Channel\""\n      },\n      {\n        \""command\"": \""cody.debug.enable.all\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Enable Debug Mode\"",\n        \""when\"": \""!config.cody.debug.verbose\""\n      },\n      {\n        \""command\"": \""cody.debug.reportIssue\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Report Issue\""\n      },\n      {\n        \""command\"": \""cody.copy.version\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""icon\"": \""$(copy)\"",\n        \""title\"": \""Copy Cody Extension Version\""\n      }\n    ],\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:4-7"",""content"":""export interface ChatModelContext {\n    chatModels?: ModelProvider[]\n    onCurrentChatModelChange?: (model: ModelProvider) => void\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:103-127"",""content"":""        this.disposables.push(\n            vscode.commands.registerCommand('cody.embeddings.resolveIssue', () =>\n                this.resolveIssueCommand()\n            )\n        )\n\n        // Pick up the initial access token, and whether the account is dotcom.\n        this.accessToken = config.accessToken || undefined\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n\n        this.model = config.testingLocalEmbeddingsModel || 'openai/text-embedding-ada-002'\n        this.endpoint =\n            config.testingLocalEmbeddingsEndpoint || 'https://cody-gateway.sourcegraph.com/v1/embeddings'\n        this.indexLibraryPath = config.testingLocalEmbeddingsIndexLibraryPath\n            ? URI.file(config.testingLocalEmbeddingsIndexLibraryPath)\n            : undefined\n    }\n\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.statusBar?.dispose()\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:21-38"",""content"":""    public async loadQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const fromCache = this.cache.find(\n            compiled => compiled.language === language && compiled.queryName === name\n        )\n        if (fromCache) {\n            return fromCache.compiledQuery\n        }\n        try {\n            return await this.compileQuery(parser, language, name)\n        } catch (error) {\n            console.error(`Queries.loadQuery(): ${language}/${name}`, error)\n            process.exit(1)\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3000-3017"",""content"":""                writer.writeMessage(22, this.super_type, () => this.super_type.serialize(writer))\n            if (this.has_constant_type)\n                writer.writeMessage(23, this.constant_type, () => this.constant_type.serialize(writer))\n            if (this.has_intersection_type)\n                writer.writeMessage(17, this.intersection_type, () =>\n                    this.intersection_type.serialize(writer)\n                )\n            if (this.has_union_type)\n                writer.writeMessage(18, this.union_type, () => this.union_type.serialize(writer))\n            if (this.has_with_type)\n                writer.writeMessage(19, this.with_type, () => this.with_type.serialize(writer))\n            if (this.has_structural_type)\n                writer.writeMessage(7, this.structural_type, () =>\n                    this.structural_type.serialize(writer)\n                )\n            if (this.has_annotated_type)\n                writer.writeMessage(8, this.annotated_type, () => this.annotated_type.serialize(writer))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:40-84"",""content"":""    private async compileQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const languages = [language, ...(grammarInheritance[language] ?? [])]\n        const queryStrings: string[] = []\n        for (const queryLanguage of languages) {\n            const queryPath = path.join(this.queriesDirectory, queryLanguage, `${name}.scm`)\n            try {\n                const stat = await fspromises.stat(queryPath)\n                if (!stat.isFile()) {\n                    continue\n                }\n            } catch {\n                if (this.queryDirectoryExists === undefined) {\n                    try {\n                        this.queryDirectoryExists = (\n                            await fspromises.stat(this.queriesDirectory)\n                        ).isDirectory()\n                        if (!this.queryDirectoryExists) {\n                            throw new Error(\n                                `Query directory ${this.queriesDirectory} is not a directory. To fix this problem, update the value of the flag --queries-directory <path>`\n                            )\n                        }\n                    } catch {\n                        throw new Error(\n                            `Query directory ${this.queriesDirectory} does not exist. To fix this problem, update the value of the flag --queries-directory <path>`\n                        )\n                    }\n                }\n                continue\n            }\n            const queryString = await fspromises.readFile(queryPath)\n            queryStrings.push(queryString.toString())\n        }\n        const uncompiled: UncompiledQuery = {\n            language,\n            queryName: name,\n            queryString: queryStrings.join('\\n\\n'),\n        }\n        const compiled = compileQuery(uncompiled, parser)\n        this.cache.push(compiled)\n        return compiled.compiledQuery\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:68-95"",""content"":""\n// Model identifiers can be found in https://docs.fireworks.ai/explore/ and in our internal\n// conversations\nconst MODEL_MAP = {\n    // Virtual model strings. Cody Gateway will map to an actual model\n    starcoder: 'fireworks/starcoder',\n    'starcoder-16b': 'fireworks/starcoder-16b',\n    'starcoder-7b': 'fireworks/starcoder-7b',\n    'starcoder2-15b': 'fireworks/starcoder2-15b',\n    'starcoder2-7b': 'fireworks/starcoder2-7b',\n\n    // Fireworks model identifiers\n    'llama-code-13b': 'fireworks/accounts/fireworks/models/llama-v2-13b-code',\n}\n\ntype FireworksModel =\n    | keyof typeof MODEL_MAP\n    // `starcoder-hybrid` uses the 16b model for multiline requests and the 7b model for single line\n    | 'starcoder-hybrid'\n    // `starcoder2-hybrid` uses the 15b model for multiline requests and the 7b model for single line\n    | 'starcoder2-hybrid'\n\nfunction getMaxContextTokens(model: FireworksModel): number {\n    switch (model) {\n        case 'starcoder':\n        case 'starcoder2-hybrid':\n        case 'starcoder2-15b':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.test.ts:0-46"",""content"":""import { afterEach, describe, expect, it } from 'vitest'\n\nimport { SupportedLanguage } from './grammars'\nimport { resetParsersCache } from './parser'\nimport { getDocumentQuerySDK } from './query-sdk'\nimport { initTreeSitterParser } from './test-helpers'\n\ndescribe('getDocumentQuerySDK', () => {\n    afterEach(() => {\n        resetParsersCache()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.javascript },\n        { languageId: SupportedLanguage.typescript },\n        { languageId: SupportedLanguage.javascriptreact },\n        { languageId: SupportedLanguage.typescriptreact },\n        { languageId: SupportedLanguage.go },\n        { languageId: SupportedLanguage.python },\n    ])('returns valid SDK for $languageId', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk?.queries.intents).toBeTruthy()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.cpp },\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.php },\n    ])('returns null for $languageId because queries are not defined', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk).toBeNull()\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:0-26"",""content"":""// Add anything else here that needs to be used outside of this library.\n\nexport { ModelProvider } from './models'\nexport { type ChatModel, type EditModel, ModelUsage, type ModelContextWindow } from './models/types'\nexport { getDotComDefaultModels } from './models/dotcom'\nexport {\n    getProviderName,\n    getModelInfo,\n} from './models/utils'\nexport { BotResponseMultiplexer } from './chat/bot-response-multiplexer'\nexport { ChatClient } from './chat/chat'\nexport { ignores, isCodyIgnoredFile } from './cody-ignore/context-filter'\nexport {\n    IgnoreHelper,\n    CODY_IGNORE_POSIX_GLOB,\n    type IgnoreFileContent,\n    CODY_IGNORE_URI_PATH,\n} from './cody-ignore/ignore-helper'\nexport { renderCodyMarkdown } from './chat/markdown'\nexport { getSimplePreamble } from './chat/preamble'\nexport type {\n    SerializedChatInteraction,\n    SerializedChatTranscript,\n} from './chat/transcript'\nexport { serializeChatMessage } from './chat/transcript'\nexport { errorToChatError, DEFAULT_EVENT_SOURCE } from './chat/transcript/messages'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.ts:0-550"",""content"":""import { findLast } from 'lodash'\nimport type { Position, TextDocument } from 'vscode'\nimport type {\n    Language,\n    Point,\n    Query,\n    QueryCapture,\n    SyntaxNode,\n    Tree,\n    default as Parser,\n} from 'web-tree-sitter'\n\nimport { type SupportedLanguage, isSupportedLanguage } from './grammars'\nimport { getCachedParseTreeForDocument } from './parse-tree-cache'\nimport { type WrappedParser, getParser } from './parser'\nimport { type CompletionIntent, type QueryName, intentPriority, languages } from './queries'\n\ninterface ParsedQuery {\n    compiled: Query\n    raw: string\n}\ntype ResolvedQueries = {\n    [name in QueryName]: ParsedQuery\n}\n\nconst QUERIES_LOCAL_CACHE: Partial<Record<SupportedLanguage, ResolvedQueries & QueryWrappers>> = {}\n\n/**\n * Reads all language queries from disk and parses them.\n * Saves queries the local cache for further use.\n */\nexport function initQueries(language: Language, languageId: SupportedLanguage, parser: Parser): void {\n    const cachedQueries = QUERIES_LOCAL_CACHE[languageId]\n    if (cachedQueries) {\n        return\n    }\n\n    const languageQueries = languages[languageId]\n    if (languageQueries === undefined) {\n        return\n    }\n\n    const queryEntries = Object.entries(languageQueries).map(([name, raw]) => {\n        return [\n            name,\n            {\n                raw,\n                compiled: language.query(raw),\n            },\n        ] as const\n    })\n\n    const queries = Object.fromEntries<ParsedQuery>(queryEntries) as ResolvedQueries\n\n    QUERIES_LOCAL_CACHE[languageId] = {\n        ...queries,\n        ...getLanguageSpecificQueryWrappers(queries, parser, languageId),\n    }\n}\n\nexport interface DocumentQuerySDK {\n    parser: WrappedParser\n    queries: ResolvedQueries & QueryWrappers\n    language: SupportedLanguage\n}\n\n/**\n * Returns the query SDK only if the language has queries defined and\n * the relevant language parser is initialized.\n */\nexport function getDocumentQuerySDK(language: string): DocumentQuerySDK | null {\n    if (!isSupportedLanguage(language)) {\n        return null\n    }\n\n    const parser = getParser(language)\n    const queries = QUERIES_LOCAL_CACHE[language]\n\n    if (!parser || !queries) {\n        return null\n    }\n\n    return {\n        parser,\n        queries,\n        language,\n    }\n}\n\nexport interface QueryWrappers {\n    getSinglelineTrigger: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: 'trigger' }]\n    getCompletionIntent: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: CompletionIntent }]\n    getDocumentableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  insertionPoint?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n    getGraphContextIdentifiers: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getEnclosingFunction: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getTestableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n}\n\n/**\n * Query wrappers with custom post-processing logic.\n */\nfunction getLanguageSpecificQueryWrappers(\n    queries: ResolvedQueries,\n    _parser: Parser,\n    languageId: SupportedLanguage\n): QueryWrappers {\n    return {\n        getSinglelineTrigger: (root, start, end) => {\n            const captures = queries.singlelineTriggers.compiled.captures(root, start, end)\n            const { trigger, block } = getTriggerNodeWithBlockStaringAtPoint(captures, start)\n\n            if (!trigger || !block || !isBlockNodeEmpty(block)) {\n                return []\n            }\n\n            return [{ node: trigger, name: 'trigger' }] as const\n        },\n        getCompletionIntent: (root, start, end) => {\n            const captures = queries.intents.compiled.captures(root, start, end)\n\n            const { intentCapture } = getIntentFromCaptures(captures, start)\n\n            if (!intentCapture) {\n                return []\n            }\n\n            return [{ node: intentCapture.node, name: intentCapture.name as CompletionIntent }] as const\n        },\n        getDocumentableNode: (root, start, end) => {\n            const captures = queries.documentableNodes.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const documentableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = documentableRanges.at(-1)\n\n            let insertionPoint: QueryCapture | undefined\n            if (languageId === 'python' && range) {\n                /**\n                 * Python is a special case for generating documentation.\n                 * The insertion point of the documentation should differ if the symbol is a function or class.\n                 * We need to query again for an insertion point, this time using the correct determined range.\n                 *\n                 * See https://peps.python.org/pep-0257/ for the documentation conventions for Python.\n                 */\n                const insertionCaptures = queries.documentableNodes.compiled\n                    .captures(root, range.node.startPosition, range.node.endPosition)\n                    .filter(({ name }) => name.startsWith('insertion'))\n\n                insertionPoint = insertionCaptures.find(\n                    ({ node }) =>\n                        node.startIndex >= range.node.startIndex && node.endIndex <= range.node.endIndex\n                )\n            }\n\n            /**\n             * Modify where we look for a docstring depending on the language and syntax.\n             * For Python functions and classes, we will have a provided `insertionPoint`, use the line below this.\n             * For all other cases, docstrings should be attached above the symbol range, use this.\n             */\n            const docStringLine =\n                languageId === 'python' && insertionPoint\n                    ? insertionPoint.node.startPosition.row + 1\n                    : start.row - 1\n            const docstringCaptures = queries.documentableNodes.compiled\n                .captures(\n                    root,\n                    { row: docStringLine, column: 0 },\n                    { row: docStringLine, column: Number.MAX_SAFE_INTEGER }\n                )\n                .filter(node => node.name.startsWith('comment'))\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one documentable range for this position, we can be confident it makes sense to document. Show the hint.\n             * 2. Otherwise, only show the hint if the symbol is a function\n             * 3. Don't show hint if there is no docstring already present.\n             */\n            const showHint = Boolean(\n                (documentableRanges.length === 1 || symbol?.name.includes('function')) &&\n                    docstringCaptures.length === 0\n            )\n\n            return [\n                {\n                    symbol,\n                    range,\n                    insertionPoint,\n                    meta: { showHint },\n                },\n            ]\n        },\n        getGraphContextIdentifiers: (root, start, end) => {\n            return queries.graphContextIdentifiers.compiled.captures(root, start, end)\n        },\n        getEnclosingFunction: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled\n                .captures(root, start, end)\n                .filter(capture => capture.name.startsWith('range'))\n\n            const firstEnclosingFunction = findLast(captures, ({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            if (!firstEnclosingFunction) {\n                return []\n            }\n\n            return [firstEnclosingFunction]\n        },\n        getTestableNode: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const testableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = testableRanges.at(-1)\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one testable range for this position, we can be confident it makes sense to test. Show the hint.\n             * 2. TODO: Look for usages of this function in test files, if it's already used then don't show the hint.\n             */\n            const showHint = Boolean(testableRanges.length === 1)\n\n            return [\n                {\n                    symbol,\n                    range,\n                    meta: { showHint },\n                },\n            ]\n        },\n    }\n}\n\n// TODO: check if the block parent is empty in the consumer.\n// Tracking: https://github.com/sourcegraph/cody/issues/1452\nfunction getIntentFromCaptures(\n    captures: QueryCapture[],\n    cursor: Point\n): { cursorCapture?: Parser.QueryCapture; intentCapture?: Parser.QueryCapture } {\n    const emptyResult = {\n        cursorCapture: undefined,\n        intentCapture: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    // Find the cursor capture group if exists.\n    const [cursorCapture] = sortByIntentPriority(\n        captures.filter(capture => {\n            const { name, node } = capture\n\n            const matchesCursorPosition =\n                node.startPosition.column === cursor.column && node.startPosition.row === cursor.row\n\n            return name.endsWith('.cursor') && matchesCursorPosition\n        })\n    )\n\n    // Find the corresponding preceding intent capture that matches the cursor capture name.\n    const intentCapture = findLast(captures, capture => {\n        return capture.name === withoutCursorSuffix(cursorCapture?.name)\n    })\n\n    if (cursorCapture && intentCapture) {\n        return { cursorCapture, intentCapture }\n    }\n\n    // If we didn't find a multinode intent, use the most nested atomic capture group.\n    // Atomic capture groups are matches with one node and `!` at the end the capture group name.\n    const atomicCapture = findLast(captures, capture => {\n        const enclosesCursor =\n            (capture.node.startPosition.column <= cursor.column ||\n                capture.node.startPosition.row < cursor.row) &&\n            (cursor.column <= capture.node.endPosition.column ||\n                cursor.row < capture.node.endPosition.row)\n\n        return capture.name.endsWith('!') && enclosesCursor\n    })\n\n    if (atomicCapture) {\n        return {\n            intentCapture: {\n                ...atomicCapture,\n                // Remove `!` from the end of the capture name.\n                name: atomicCapture.name.slice(0, -1),\n            },\n        }\n    }\n\n    return emptyResult\n}\n\nfunction sortByIntentPriority(captures: QueryCapture[]): QueryCapture[] {\n    return captures.sort((a, b) => {\n        return (\n            intentPriority.indexOf(withoutCursorSuffix(a.name) as CompletionIntent) -\n            intentPriority.indexOf(withoutCursorSuffix(b.name) as CompletionIntent)\n        )\n    })\n}\n\nfunction withoutCursorSuffix(name?: string): string | undefined {\n    return name?.split('.').slice(0, -1).join('.')\n}\n\nfunction getTriggerNodeWithBlockStaringAtPoint(\n    captures: QueryCapture[],\n    point: Point\n): { trigger?: SyntaxNode; block?: SyntaxNode } {\n    const emptyResult = {\n        trigger: undefined,\n        block: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    const blockStart = getNodeIfMatchesPoint({\n        captures,\n        name: 'block_start',\n        // Taking the last result to get the most nested node.\n        // See https://github.com/tree-sitter/tree-sitter/discussions/2067\n        index: -1,\n        point,\n    })\n\n    const trigger = getCapturedNodeAt({\n        captures,\n        name: 'trigger',\n        index: -1,\n    })\n\n    const block = blockStart?.parent\n\n    if (!blockStart || !block || !trigger) {\n        return emptyResult\n    }\n\n    // Verify that the block node ends at the same position as the trigger node.\n    if (trigger.endIndex !== block?.endIndex) {\n        return emptyResult\n    }\n\n    return { trigger, block }\n}\n\ninterface GetNodeIfMatchesPointParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n    point: Point\n}\n\nfunction getNodeIfMatchesPoint(params: GetNodeIfMatchesPointParams): SyntaxNode | null {\n    const { captures, name, index, point } = params\n\n    const node = getCapturedNodeAt({ captures, name, index })\n\n    if (node && node.startPosition.column === point.column && node.startPosition.row === point.row) {\n        return node\n    }\n\n    return null\n}\n\ninterface GetCapturedNodeAtParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n}\n\nfunction getCapturedNodeAt(params: GetCapturedNodeAtParams): SyntaxNode | null {\n    const { captures, name, index } = params\n\n    return captures.filter(capture => capture.name === name).at(index)?.node || null\n}\n\n/**\n * Consider a block empty if it does not have any named children or is missing its closing tag.\n */\nfunction isBlockNodeEmpty(node: SyntaxNode | null): boolean {\n    // Consider a node empty if it does not have any named children.\n    const isBlockEmpty = node?.children.filter(c => c.isNamed()).length === 0\n    const isMissingBlockEnd = Boolean(node?.lastChild?.isMissing())\n\n    return isBlockEmpty || isMissingBlockEnd\n}\n\ninterface QueryPoints {\n    startPoint: Point\n    endPoint: Point\n}\n\nexport function positionToQueryPoints(position: Pick<Position, 'line' | 'character'>): QueryPoints {\n    const startPoint = {\n        row: position.line,\n        column: position.character,\n    }\n\n    const endPoint = {\n        row: position.line,\n        // Querying around one character after trigger position.\n        column: position.character + 1,\n    }\n\n    return { startPoint, endPoint }\n}\n\ntype ExecQueryWrapperParams<T> = {\n    queryWrapper: T\n} & (\n    | {\n          document: TextDocument\n          queryPoints: QueryPoints\n      }\n    | {\n          document: TextDocument\n          position: Pick<Position, 'line' | 'character'>\n      }\n    | {\n          tree: Tree\n          languageId: string\n          queryPoints: QueryPoints\n      }\n    | {\n          tree: Tree\n          languageId: string\n          position: Pick<Position, 'line' | 'character'>\n      }\n)\n\nexport function execQueryWrapper<T extends keyof QueryWrappers>(\n    params: ExecQueryWrapperParams<T>\n): ReturnType<QueryWrappers[T]> | never[] {\n    const { queryWrapper } = params\n\n    const treeToQuery =\n        'document' in params ? getCachedParseTreeForDocument(params.document)?.tree : params.tree\n    const languageId = 'document' in params ? params.document.languageId : params.languageId\n    const documentQuerySDK = getDocumentQuerySDK(languageId as SupportedLanguage)\n\n    const queryPoints =\n        'position' in params ? positionToQueryPoints(params.position) : params.queryPoints\n    const { startPoint, endPoint } = queryPoints\n\n    if (documentQuerySDK && treeToQuery) {\n        return documentQuerySDK.queries[queryWrapper](\n            treeToQuery.rootNode,\n            startPoint,\n            endPoint\n        ) as ReturnType<QueryWrappers[T]>\n    }\n\n    return []\n}\n\nexport type { CompletionIntent }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:7525-7552"",""content"":""      '@esbuild/linux-arm64': 0.20.2\n      '@esbuild/linux-ia32': 0.20.2\n      '@esbuild/linux-loong64': 0.20.2\n      '@esbuild/linux-mips64el': 0.20.2\n      '@esbuild/linux-ppc64': 0.20.2\n      '@esbuild/linux-riscv64': 0.20.2\n      '@esbuild/linux-s390x': 0.20.2\n      '@esbuild/linux-x64': 0.20.2\n      '@esbuild/netbsd-x64': 0.20.2\n      '@esbuild/openbsd-x64': 0.20.2\n      '@esbuild/sunos-x64': 0.20.2\n      '@esbuild/win32-arm64': 0.20.2\n      '@esbuild/win32-ia32': 0.20.2\n      '@esbuild/win32-x64': 0.20.2\n    dev: true\n\n  /escalade@3.1.1:\n    resolution: {integrity: sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==}\n    engines: {node: '>=6'}\n\n  /escalade@3.1.2:\n    resolution: {integrity: sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA==}\n    engines: {node: '>=6'}\n    dev: true\n\n  /escape-html@1.0.3:\n    resolution: {integrity: sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/embeddings-protocol.ts:0-125"",""content"":""/**\n * The protocol for communicating between Cody and local embeddings.\n */\n\ninterface InitializeParams {\n    codyGatewayEndpoint: string\n    indexPath: string\n    chunkingPolicy?: ChunkingPolicy\n}\n\ninterface ChunkingPolicy {\n    maxFileSizeBytes: number\n    pathsToExcludeRegexp: string\n}\n\ninterface QueryParams {\n    repoName: string\n    query: string\n    numResults: number\n}\n\nexport interface QueryResultSet {\n    results: QueryResult[]\n}\n\ninterface QueryResult {\n    fileName: string\n    startLine: number\n    endLine: number\n    content: string\n}\n\ninterface IndexHealthRequest {\n    // The name of the repository to scrutinize the index for. Note, this\n    // is a repo name, like github.com/sourcegraph/cody, not a file path.\n    repoName: string\n}\n\ntype IndexHealthResult = IndexHealthResultFound | IndexHealthResultNotFound\n\nexport interface IndexHealthResultFound {\n    type: 'found'\n    repoName: string\n    format: 'App' | 'LocalEmbeddings'\n    commit: string\n    model: string\n    dimension: number\n    numItems: number\n    numItemsDeleted: number\n    numItemsNeedEmbedding: number\n    numItemsFailed: number\n    numFiles: number\n}\n\ninterface IndexHealthResultNotFound {\n    type: 'notFound'\n    repoName: string\n}\n\nexport interface IndexRequest {\n    repoPath: string\n    mode: IndexRequestMode\n}\n\ntype IndexRequestMode = IndexRequestModeNew | IndexRequestModeContinue\n\ninterface IndexRequestModeNew {\n    type: 'new'\n    model: string\n    dimension: number\n}\n\ninterface IndexRequestModeContinue {\n    type: 'continue'\n}\n\ninterface IndexResult {\n    repoName: string\n}\n\ninterface LoadResult {\n    repoName: string\n}\nexport type Requests = {\n    'embeddings/echo': [string, string]\n    // Instruct local embeddings to index the specified repository path.\n    'embeddings/index': [IndexRequest, IndexResult]\n    // Get statistics for the index for a given repository name.\n    'embeddings/index-health': [IndexHealthRequest, IndexHealthResult]\n    // Initializes the local embeddings service. You must call this first.\n    'embeddings/initialize': [InitializeParams, Record<string, never>]\n    // Searches for and loads an index for the specified repository name.\n    'embeddings/load': [string, LoadResult]\n    // Queries loaded index.\n    'embeddings/query': [QueryParams, QueryResultSet]\n    // Sets the Sourcegraph access token.\n    'embeddings/set-token': [string, Record<string, never>]\n    // Shuts down the local embeddings service.\n    'embeddings/shutdown': [Record<string, never>, Record<string, never>]\n}\n\ntype ProgressValue = Progress | ProgressError | ProgressDone\n\ninterface Progress {\n    type: 'progress'\n    currentPath: string\n    repoName: string\n    repoPath: string\n    numItems: number\n    totalItems: number\n}\n\ninterface ProgressDone {\n    type: 'done'\n    repoName: string\n}\n\ninterface ProgressError {\n    type: 'error'\n    repoName: string\n    message: string\n}\nexport type Notifications = {\n    'embeddings/progress': [ProgressValue]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:279-311"",""content"":""    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:111-118"",""content"":""    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:30-58"",""content"":""\nexport type LocalEmbeddingsConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & {\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/embeddings`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/embeddings`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\embeddings`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\ninterface RepoState {\n    repoName: string | false\n    indexable: boolean\n    errorReason: GetFieldType<LocalEmbeddingsProvider, 'errorReason'>\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/uri.ts:72-74"",""content"":""    public get query(): string {\n        return this.uri.query\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/types.ts:0-62"",""content"":""import type { ModelProvider } from '.'\n\nexport enum ModelUsage {\n    Chat = 'chat',\n    Edit = 'edit',\n}\n\n// Utility to narrow a model type to a specific model usage\ntype HasUsage<T, I> = T extends { usage: readonly ModelUsage[] }\n    ? I extends T['usage'][number]\n        ? T\n        : never\n    : never\n\ntype Models = typeof ModelProvider\n\n/**\n * Available models for Edit.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type EditModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Edit>\n      }[keyof Models]['model']\n    | (string & {})\n\n/**\n * Available models for Chat.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type ChatModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Chat>\n      }[keyof Models]['model']\n    | (string & {})\n\nexport interface ModelContextWindow {\n    /**\n     * The token limit reserved for chat input.\n     */\n    input: number\n    /**\n     * The maximum number of tokens that the model can respond with in a single request.\n     */\n    output: number\n    /**\n     * The additional tokens reserved for context.\n     * When not defined, context shares the same token limit as input.\n     */\n    context?: {\n        /**\n         * The token limit reserved for user-added context.\n         * Example: @-mentions.\n         */\n        user?: number\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:2-2"",""content"":""export const MODEL = 'anthropic/claude-3-haiku-20240307'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:226-254"",""content"":""    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:286-313"",""content"":""                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-57"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_020/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for running symf is primarily implemented in the `SymfRunner` class, which is located in the file `cody_test/vscode/src/local-context/symf.ts`. This class handles various operations related to symf, including indexing, querying, and managing the symf index.

Some key functions in the `SymfRunner` class include:
- `getResults`: For querying symf
- `ensureIndex`: For creating or updating the symf index
- `reindexIfStale`: For checking and updating the index if needed
- `unsafeRunQuery`: For executing symf queries

The `SymfRunner` is instantiated in the `extension.node.ts` file, where it's passed as an argument to the `createSymfRunner` function.

Additionally, the `download-symf.ts` file in the same directory handles the downloading and installation of the symf binary if it's not already present on the system.",Where is the functionality for running symf?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:565-582"",""content"":""\n### Changed\n\n- Settings: Relabel \""symf Context\"" as \""Search Context\"". [pull/2285](https://github.com/sourcegraph/cody/pull/2285)\n- Chat: Removed 'Chat Suggestions' setting. [pull/2284](https://github.com/sourcegraph/cody/pull/2284)\n- Edit: Completed edits are no longer scrolled back into view in the active file. [pull/2297](https://github.com/sourcegraph/cody/pull/2297)\n- Chat: Update welcome message. [pull/2298](https://github.com/sourcegraph/cody/pull/2298)\n- Edit: Decorations are no longer shown once an edit has been applied. [pull/2304](https://github.com/sourcegraph/cody/pull/2304)\n\n## [0.18.4]\n\n### Added\n\n### Fixed\n\n- Fixes an issue where the sidebar would not properly load when not signed in. [pull/2267](https://github.com/sourcegraph/cody/pull/2267)\n- Fixes an issue where telemetry events were not properly logged with the new chat experience. [pull/2291](https://github.com/sourcegraph/cody/pull/2291)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:62-67"",""content"":""\n        onConfigurationChange: setCustomAgent,\n        extensionClient,\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/isRunningInsideAgent.ts:2-4"",""content"":""export function isRunningInsideAgent(): boolean {\n    return vscode.workspace.getConfiguration().get<boolean>('cody.advanced.agent.running', false)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80"",""content"":""\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:46-62"",""content"":""\n    return activateCommon(context, {\n        createLocalEmbeddingsController: isLocalEmbeddingsDisabled\n            ? undefined\n            : (config: LocalEmbeddingsConfig): LocalEmbeddingsController =>\n                  createLocalEmbeddingsController(context, config),\n        createContextRankingController: (config: ContextRankerConfig) =>\n            createContextRankingController(context, config),\n        createCompletionsClient: (...args) => new SourcegraphNodeCompletionsClient(...args),\n        createCommandsProvider: () => new CommandsProvider(),\n        createSymfRunner: (...args) => new SymfRunner(...args),\n        createBfgRetriever: () => new BfgRetriever(context),\n        createSentryService: (...args) => new NodeSentryService(...args),\n        createOpenTelemetryService: (...args) => new OpenTelemetryService(...args),\n        getRemoteUrlGetters: () => [gitRemoteUrlFromGitCli],\n        startTokenReceiver: (...args) => startTokenReceiver(...args),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:543-580"",""content"":""function parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:630-642"",""content"":""function toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:49-486"",""content"":""export class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_021/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that interacts with the symf binary is primarily located in the `vscode/src/local-context/symf.ts` and `vscode/src/local-context/download-symf.ts` files.

In `symf.ts`, there's a `SymfRunner` class that handles the execution of the symf binary. It includes methods to get symf information and run symf commands.

The `download-symf.ts` file contains functions for downloading and managing the symf binary. It includes the `getSymfPath` function, which either returns the path to an existing symf binary or downloads it if not found.

Additionally, the `vscode/src/main.ts` file shows integration of the symf runner into the extension, and `vscode/src/external-services.ts` includes symf-related configuration options.

These files collectively handle the downloading, setup, and execution of the symf binary within the Cody VS Code extension.",Where is the code that interacts with symf  binary ?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:10-12"",""content"":""interface CodeActionProviderOptions {\n    contextProvider: ContextProvider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupTask.ts:59-79"",""content"":""\n    constructor(\n        /**\n         * The file that will be updated by Cody with the replacement text at the end of stream\n         * This is set by the FixupController when creating the task,\n         * and will be updated by the FixupController for tasks using the 'new' mode\n         */\n        public fixupFile: FixupFile,\n        public readonly instruction: PromptString,\n        public readonly userContextItems: ContextItem[],\n        /* The intent of the edit, derived from the source of the command. */\n        public readonly intent: EditIntent,\n        /* The range being edited. This range is tracked and updates as the user (or Cody) edits code. */\n        public selectionRange: vscode.Range,\n        /* The mode indicates how code should be inserted */\n        public readonly mode: EditMode,\n        public readonly model: EditModel,\n        /* the source of the instruction, e.g. 'code-action', 'doc', etc */\n        public source?: EventSource,\n        /* The file to write the edit to. If not provided, the edit will be applied to the fixupFile. */\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:14-45"",""content"":""    public async provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): Promise<vscode.CodeAction[]> {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n\n        // Expand range to include the full line for better fixup quality\n        const expandedRange = new vscode.Range(\n            document.lineAt(range.start.line).range.start,\n            document.lineAt(range.end.line).range.end\n        )\n\n        // TODO bee check if the diagnostics are related to imports and include import ranges instead of error lines\n        // const importDiagnostics = diagnostics.filter(diagnostic => diagnostic.message.includes('import'))\n\n        // Expand range by getting the folding range contains the target (error) area\n        const targetAreaRange = await getSmartSelection(document.uri, range.start)\n\n        const newRange = targetAreaRange\n            ? new vscode.Range(targetAreaRange.start, targetAreaRange.end)\n            : expandedRange\n        const codeAction = await this.createCommandCodeAction(document, diagnostics, newRange)\n        return [codeAction]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-workspace.yaml:0-6"",""content"":""packages:\n  - agent\n  - cli\n  - lib/*\n  - vscode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/edit.ts:7-29"",""content"":""    public provideCodeActions(document: vscode.TextDocument): vscode.CodeAction[] {\n        const editor = vscode.window.activeTextEditor\n\n        if (!editor) {\n            return []\n        }\n\n        if (\n            editor.selection.isEmpty &&\n            !document.lineAt(editor.selection.start.line).isEmptyOrWhitespace\n        ) {\n            // Empty selection but a non-empty line, show nothing as the user likely won't want to generate here.\n            return []\n        }\n\n        if (editor.selection.isEmpty) {\n            // Empty selection and empty line, show generate action\n            return [this.createGenerateCodeAction(document, editor.selection)]\n        }\n\n        // Non-empty selection, show edit action\n        return [this.createEditCommandCodeAction(document, editor.selection)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/queries/typescript/context.scm:0-12"",""content"":"";; Inherits from javascript/context.scm\n\n((function_declaration\n   name: (_) @name\n   (formal_parameters (_ (type_annotation) @search)))\n (#search! \""type_identifier\""))\n\n((variable_declarator\n  name: (_) @name\n  type: (type_annotation) @search)\n (#search! \""type_identifier\""))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:7-21"",""content"":""    public provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): vscode.CodeAction[] {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n        return [this.createCommandCodeAction(document.uri, diagnostics)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:433-461"",""content"":""\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/document.ts:8-37"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [documentableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getDocumentableNode',\n        })\n        if (!documentableNode) {\n            return []\n        }\n\n        const { range: documentableRange, symbol: documentableSymbol } = documentableNode\n        if (!documentableSymbol || !documentableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            documentableRange.node.startPosition.row,\n            documentableRange.node.startPosition.column,\n            documentableRange.node.endPosition.row,\n            documentableRange.node.endPosition.column\n        )\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Documentation for ${documentableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:14-54"",""content"":""export class CodeActionProvider implements vscode.Disposable {\n    private configurationChangeListener: vscode.Disposable\n    private actionProviders: vscode.Disposable[] = []\n\n    constructor(options: CodeActionProviderOptions) {\n        this.registerCodeActions(options.contextProvider.config)\n        this.configurationChangeListener = options.contextProvider.configurationChangeEvent.event(() => {\n            this.registerCodeActions(options.contextProvider.config)\n        })\n    }\n\n    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n    }\n\n    private addActionProvider(ActionType: {\n        new (): vscode.CodeActionProvider\n        providedCodeActionKinds: vscode.CodeActionKind[]\n    }): void {\n        const provider = vscode.languages.registerCodeActionsProvider('*', new ActionType(), {\n            providedCodeActionKinds: ActionType.providedCodeActionKinds,\n        })\n        this.actionProviders.push(provider)\n    }\n\n    public dispose(): void {\n        this.configurationChangeListener.dispose()\n        vscode.Disposable.from(...this.actionProviders).dispose()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:91-109"",""content"":""    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:0-27"",""content"":""import * as fs from 'node:fs'\nimport fspromises from 'node:fs/promises'\nimport * as os from 'node:os'\nimport * as path from 'node:path'\n\nimport axios from 'axios'\nimport * as unzipper from 'unzipper'\nimport * as vscode from 'vscode'\n\nimport { Mutex } from 'async-mutex'\nimport { logDebug } from '../log'\nimport { getOSArch } from '../os'\nimport { captureException } from '../services/sentry/sentry'\n\nconst symfVersion = 'v0.0.9'\n\n/**\n * Get the path to `symf`. If the symf binary is not found, download it.\n */\nexport async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:153-182"",""content"":""\n\n                  ## Debugging the agent\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /agent/src/__tests__/example-ts/src/squirrel.ts in repository\n                  github.com/sourcegraph/cody:\n\n                  ```typescript\n\n                  /**\n                   * Squirrel is an interface that mocks something completely unrelated to squirrels.\n                   * It is related to the implementation of precise code navigation in Sourcegraph.\n                   */\n                  export interface Squirrel {}\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file /.bazelignore in repository\n                  github.com/sourcegraph/sourcegraph:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:67-102"",""content"":""\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80"",""content"":""\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:164-170"",""content"":""async function removeOldSymfBinaries(containingDir: string, currentSymfPath: string): Promise<void> {\n    const symfDirContents = await fspromises.readdir(containingDir)\n    const oldSymfBinaries = symfDirContents.filter(f => f.startsWith('symf-') && f !== currentSymfPath)\n    for (const oldSymfBinary of oldSymfBinaries) {\n        await fspromises.rm(path.join(containingDir, oldSymfBinary))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_022/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that interacts with the bfg binary is primarily located in the `spawn-bfg.ts` file. This file contains the `spawnBfg` function, which is responsible for:

1. Downloading the BFG binary using the `downloadBfg` function.
2. Spawning the BFG process using `child_process.spawn`.
3. Setting up event listeners for the child process.
4. Handling input/output streams between the BFG binary and the application.

Additionally, the `download-bfg.ts` file contains functions for downloading, unzipping, and managing the BFG binary, including:

- `downloadBfg`: Handles the download process of the BFG binary.
- `downloadBfgBinary`: Performs the actual download of the binary.
- `unzipBfg`: Extracts the downloaded zip file.
- `removeOldBfgBinaries`: Cleans up old versions of the BFG binary.

These files work together to manage the lifecycle of the BFG binary, from acquisition to execution within the Cody extension.",Where is the code that interacts with bfg binary?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/spawn-bfg.ts:9-44"",""content"":""export async function spawnBfg(\n    context: vscode.ExtensionContext,\n    reject: (reason?: any) => void\n): Promise<MessageHandler> {\n    const bfg = new MessageHandler()\n    const codyrpc = await downloadBfg(context)\n    if (!codyrpc) {\n        throw new Error(\n            'Failed to download BFG binary. To fix this problem, set the \""cody.experimental.cody-engine.path\"" configuration to the path of your BFG binary'\n        )\n    }\n    const isVerboseDebug = vscode.workspace.getConfiguration().get<boolean>('cody.debug.verbose', false)\n    const child = child_process.spawn(codyrpc, {\n        stdio: 'pipe',\n        env: {\n            VERBOSE_DEBUG: `${isVerboseDebug}`,\n            RUST_BACKTRACE: isVerboseDebug ? '1' : '0',\n            // See bfg issue 138\n            RUST_LIB_BACKTRACE: '0',\n        },\n    })\n    child.stderr.on('data', chunk => {\n        logDebug('CodyEngine', 'spawnBfg:stderr', { verbose: chunk.toString() })\n    })\n    child.on('disconnect', () => reject())\n    child.on('close', () => reject())\n    child.on('error', error => reject(error))\n    child.on('exit', code => {\n        bfg.exit()\n        reject(code)\n    })\n    child.stderr.pipe(process.stderr)\n    child.stdout.pipe(bfg.messageDecoder)\n    bfg.messageEncoder.pipe(child.stdin)\n    return bfg\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5905-5936"",""content"":""        }\n        set value(value: number) {\n            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): DoubleConstant {\n            const message = new DoubleConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeDouble(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DoubleConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:111-119"",""content"":""async function unzipBfg(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:933-953"",""content"":""        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.scheme.length) writer.writeString(1, this.scheme)\n            if (this.has_package)\n                writer.writeMessage(2, this.package, () => this.package.serialize(writer))\n            if (this.descriptors.length)\n                writer.writeRepeatedMessage(3, this.descriptors, (item: Descriptor) =>\n                    item.serialize(writer)\n                )\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Symbol {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Symbol()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.scheme = reader.readString()\n                        break\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:20-109"",""content"":""export async function downloadBfg(context: vscode.ExtensionContext): Promise<string | null> {\n    // First, wait for any in-progress downloads.\n    await serializeBfgDownload\n\n    // Now we are the in-progress download.\n    serializeBfgDownload = (async () => {\n        const config = vscode.workspace.getConfiguration()\n        const userBfgPath = config.get<string>('cody.experimental.cody-engine.path')\n        if (userBfgPath) {\n            const bfgStat = await fspromises.stat(userBfgPath)\n            if (!bfgStat.isFile()) {\n                throw new Error(`not a file: ${userBfgPath}`)\n            }\n            logDebug('CodyEngine', `using user-provided path: ${userBfgPath} ${bfgStat.isFile()}`)\n            return userBfgPath\n        }\n\n        const osArch = getOSArch()\n        if (!osArch) {\n            logDebug('CodyEngine', 'getOSArch returned nothing')\n            return null\n        }\n        const { platform, arch } = osArch\n\n        if (!arch) {\n            logDebug('CodyEngine', 'getOSArch returned undefined arch')\n            return null\n        }\n\n        if (!platform) {\n            logDebug('CodyEngine', 'getOSArch returned undefined platform')\n            return null\n        }\n        // Rename returned architecture to match RFC 795 conventions\n        // https://docs.google.com/document/d/11cw-7dAp93JmasITNSNCtx31xrQsNB1L2OoxVE6zrTc/edit\n        const archRenames = new Map([\n            ['aarch64', 'arm64'],\n            ['x86_64', 'x64'],\n        ])\n        let rfc795Arch = archRenames.get(arch ?? '') ?? arch\n        if (rfc795Arch === 'arm64' && platform === 'win') {\n            // On Windows Arm PCs, we rely on emulation and use the x64 binary.\n            // See https://learn.microsoft.com/en-us/windows/arm/apps-on-arm-x86-emulation\n            rfc795Arch = 'x64'\n        }\n\n        const bfgContainingDir = path.join(context.globalStorageUri.fsPath, 'cody-engine')\n        const bfgVersion = config.get<string>('cody.experimental.cody-engine.version', defaultBfgVersion)\n        await fspromises.mkdir(bfgContainingDir, { recursive: true })\n        const bfgFilename = `cody-engine-${bfgVersion}-${platform}-${rfc795Arch}`\n        const bfgPath = path.join(bfgContainingDir, bfgFilename)\n        const isAlreadyDownloaded = await fileExists(bfgPath)\n        if (isAlreadyDownloaded) {\n            logDebug('CodyEngine', `using downloaded path \""${bfgPath}\""`)\n            return bfgPath\n        }\n\n        const bfgURL = `https://github.com/sourcegraph/bfg/releases/download/v${bfgVersion}/bfg-${platform}-${rfc795Arch}.zip`\n        try {\n            await vscode.window.withProgress(\n                {\n                    location: vscode.ProgressLocation.Window,\n                    title: 'Downloading cody-engine',\n                    cancellable: false,\n                },\n                async progress => {\n                    progress.report({ message: 'Downloading cody-engine' })\n                    const bfgZip = path.join(bfgContainingDir, 'bfg.zip')\n                    await downloadBfgBinary(bfgURL, bfgZip)\n                    await unzipBfg(bfgZip, bfgContainingDir)\n                    logDebug('CodyEngine', bfgPath)\n                    // The zip file contains a binary named `bfg` or `bfg.exe`. We unzip it with that name first and then rename into\n                    // a version-specific binary so that we can delete old versions of bfg.\n                    const unzipPath = platform === 'windows' ? 'bfg.exe' : 'bfg'\n                    await fspromises.rename(path.join(bfgContainingDir, unzipPath), bfgPath)\n                    await fspromises.chmod(bfgPath, 0o755)\n                    await fspromises.rm(bfgZip)\n                    logDebug('CodyEngine', `downloaded cody-engine to ${bfgPath}`)\n                }\n            )\n            void removeOldBfgBinaries(bfgContainingDir, bfgFilename)\n        } catch (error) {\n            captureException(error)\n            void vscode.window.showErrorMessage(`Failed to download bfg from URL ${bfgURL}: ${error}`)\n            return null\n        }\n        return bfgPath\n    })()\n    return serializeBfgDownload\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5636-5662"",""content"":""            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CharConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new CharConstant()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.value = reader.readInt32()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:25-38"",""content"":""    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3411-3438"",""content"":""                message.symbol = data.symbol\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                symbol?: string\n            } = {}\n            if (this.symbol != null) {\n                data.symbol = this.symbol\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.symbol.length) writer.writeString(1, this.symbol)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ThisType {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new ThisType()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/SidebarCommands.ts:57-78"",""content"":""        }),\n        vscode.commands.registerCommand('cody.sidebar.keyboardShortcuts', () => {\n            logSidebarClick('keyboardShortcuts')\n            void vscode.commands.executeCommand(\n                'workbench.action.openGlobalKeybindings',\n                '@ext:sourcegraph.cody-ai'\n            )\n        }),\n        vscode.commands.registerCommand('cody.sidebar.releaseNotes', () => {\n            logSidebarClick('releaseNotes')\n            void vscode.commands.executeCommand('vscode.open', releaseNotesURL(version))\n        }),\n        vscode.commands.registerCommand('cody.sidebar.documentation', () => {\n            logSidebarClick('documentation')\n            void vscode.commands.executeCommand('vscode.open', CODY_DOC_URL.href)\n        }),\n        vscode.commands.registerCommand('cody.sidebar.support', () => {\n            logSidebarClick('support')\n            void vscode.commands.executeCommand('vscode.open', CODY_SUPPORT_URL.href)\n        }),\n        vscode.commands.registerCommand('cody.sidebar.feedback', () => {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5695-5726"",""content"":""        }\n        set value(value: number) {\n            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): IntConstant {\n            const message = new IntConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5487-5516"",""content"":""            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): ByteConstant {\n            const message = new ByteConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ByteConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/commands.md:0-13"",""content"":""## Cody Commands\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-explain.gif\"">\n\nCody has a range of commands for explaining code, generating unit tests, adding documentation, and more.\n\nTo get started: select code in your editor, right click, and choose a command from the \""Cody\"" menu.\n\nYou can also use the [Cody: Commands Menu](command:cody.menu.commands) which has the default keyboard shortcut of `Option` `C` on macOS and `Alt` `C` on Windows & Linux.\n\n**✨ Pro-tips for using Cody commands**\n<br>• You can build your own [Custom Commands (Beta)](https://sourcegraph.com/docs/cody/custom-commands) with custom prompts, output into chat or perform code edits, and more.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1700-1723"",""content"":""            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Relationship {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Relationship()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.symbol = reader.readString()\n                        break\n                    case 2:\n                        message.is_reference = reader.readBool()\n                        break\n                    case 3:\n                        message.is_implementation = reader.readBool()\n                        break\n                    case 4:\n                        message.is_type_definition = reader.readBool()\n                        break\n                    case 5:\n                        message.is_definition = reader.readBool()\n                        break\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/bfg-protocol.ts:0-39"",""content"":""/**\n * This file declares the protocol for communicating between Cody and BFG (Blazingly Fast Graph), a Rust implementation\n * of the \""Graph Context\"" feature flag.\n */\nimport type { Position } from './agent-protocol'\n\ninterface BFGFileContextSnippet {\n    fileName: string\n    content: string\n}\n\ninterface BFGSymbolContextSnippet extends BFGFileContextSnippet {\n    symbol: string\n}\n\nexport type Requests = {\n    'bfg/initialize': [{ clientName: string }, { serverVersion: string }]\n    'bfg/contextAtPosition': [\n        { uri: string; content: string; position: Position; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[]; files?: BFGFileContextSnippet[] },\n    ]\n    'bfg/contextForIdentifiers': [\n        { uri: string; identifiers: string[]; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[] },\n    ]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/gitRevision/didChange': [{ gitDirectoryUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/workspace/didChange': [{ workspaceUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/shutdown': [null, void]\n\n    'embeddings/hello': [null, string]\n}\n\nexport type Notifications = {\n    'bfg/placeholderNotification': [null]\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:25-50"",""content"":""\n    constructor(\n        private contextStrategy: ContextStrategy,\n        createBfgRetriever?: () => BfgRetriever\n    ) {\n        switch (contextStrategy) {\n            case 'none':\n                break\n            case 'bfg-mixed':\n            case 'bfg':\n                // The bfg strategy uses jaccard similarity as a fallback if no results are found or\n                // the language is not supported by BFG\n                this.localRetriever = new JaccardSimilarityRetriever()\n                this.disposables.push(this.localRetriever)\n                if (createBfgRetriever) {\n                    this.graphRetriever = createBfgRetriever()\n                    this.disposables.push(this.graphRetriever)\n                }\n                break\n            case 'jaccard-similarity':\n                this.localRetriever = new JaccardSimilarityRetriever()\n                this.disposables.push(this.localRetriever)\n                break\n            case 'local-mixed':\n                this.localRetriever = new JaccardSimilarityRetriever()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts:0-303"",""content"":""import * as vscode from 'vscode'\n\nimport { spawnBfg } from '../../../../graph/bfg/spawn-bfg'\nimport type { MessageHandler } from '../../../../jsonrpc/jsonrpc'\nimport { logDebug } from '../../../../log'\nimport type { Repository } from '../../../../repository/builtinGitExtension'\nimport { gitAPI } from '../../../../repository/git-extension-api'\nimport { captureException } from '../../../../services/sentry/sentry'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\n\nimport type { AutocompleteContextSnippet } from '@sourcegraph/cody-shared'\nimport {\n    getLastNGraphContextIdentifiersFromDocument,\n    getLastNGraphContextIdentifiersFromString,\n} from '../graph/identifiers'\nimport { type SimpleRepository, inferGitRepository } from './simple-git'\n\nexport class BfgRetriever implements ContextRetriever {\n    public identifier = 'bfg'\n    private loadedBFG: Promise<MessageHandler>\n    private bfgIndexingPromise = Promise.resolve<void>(undefined)\n    private awaitIndexing: boolean\n    private didFailLoading = false\n    // Keys are repository URIs, values are revisions (commit hashes).\n    private indexedRepositoryRevisions = new Map<string, string>()\n    constructor(private context: vscode.ExtensionContext) {\n        this.awaitIndexing = vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.await-indexing', false)\n        this.loadedBFG = this.loadBFG()\n\n        this.loadedBFG.then(\n            () => {},\n            error => {\n                captureException(error)\n                this.didFailLoading = true\n                logDebug('CodyEngine', 'failed to initialize', error)\n            }\n        )\n\n        this.bfgIndexingPromise = this.indexWorkspace()\n    }\n\n    private async indexWorkspace(): Promise<void> {\n        await this.indexGitRepositories()\n        await this.indexRemainingWorkspaceFolders()\n    }\n    private isWorkspaceIndexed(folder: vscode.Uri): boolean {\n        const uri = folder.toString()\n        logDebug('CodyEngine', 'Checking if folder is indexed', uri)\n        for (const key of this.indexedRepositoryRevisions.keys()) {\n            if (uri.startsWith(key)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private async indexRemainingWorkspaceFolders(): Promise<void> {\n        logDebug(\n            'CodyEngine',\n            'workspaceFolders',\n            vscode.workspace.workspaceFolders?.map(folder => folder.uri.toString()) ?? []\n        )\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.isWorkspaceIndexed(folder.uri)) {\n                continue\n            }\n            await this.indexEntry({ workspace: folder.uri })\n        }\n    }\n    private async indexGitRepositories(): Promise<void> {\n        const git = gitAPI()\n        if (!git) {\n            return\n        }\n        for (const repository of git.repositories) {\n            await this.didChangeGitExtensionRepository(repository)\n        }\n        this.context.subscriptions.push(\n            git.onDidOpenRepository(repository => this.didChangeGitExtensionRepository(repository))\n        )\n        this.context.subscriptions.push(\n            vscode.workspace.onDidChangeWorkspaceFolders(() => this.indexInferredGitRepositories())\n        )\n        // TODO: handle closed repositories\n\n        await this.indexInferredGitRepositories()\n    }\n\n    private shouldInferGitRepositories(): boolean {\n        // Some users may not want to allow Cody to index code outside the VS\n        // Code workspace folder so we support an escape hatch to disable this\n        // functionality. This setting is hidden because all the other\n        // BFG-related settings are hidden.\n        return vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.index-parent-git-folder', false)\n    }\n\n    // Infers what git repositories that are relevant but may not be \""open\"" by\n    // the git extension.  For example, by default, the git extension doesn't\n    // open git repositories when the workspace root is a subfolder. There's a\n    // setting to automatically open parent git repositories but the setting is\n    // disabled by default.\n    private async indexInferredGitRepositories(): Promise<void> {\n        if (!this.shouldInferGitRepositories()) {\n            return\n        }\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.indexedRepositoryRevisions.has(folder.uri.toString())) {\n                continue\n            }\n            const repo = await inferGitRepository(folder.uri)\n            if (repo) {\n                await this.didChangeSimpleRepository(repo)\n            }\n        }\n    }\n\n    private async didChangeGitExtensionRepository(repository: Repository): Promise<void> {\n        const commit = repository?.state?.HEAD?.commit\n        if (!commit) {\n            return\n        }\n        await this.didChangeSimpleRepository({ uri: repository.rootUri, commit })\n    }\n\n    private async didChangeSimpleRepository(repository: SimpleRepository): Promise<void> {\n        const uri = repository.uri.toString()\n        if (repository.commit !== this.indexedRepositoryRevisions.get(uri)) {\n            this.indexedRepositoryRevisions.set(uri, repository.commit ?? '')\n            await this.indexEntry({ repository })\n        }\n    }\n\n    private async indexEntry(params: {\n        repository?: SimpleRepository\n        workspace?: vscode.Uri\n    }): Promise<void> {\n        const { repository, workspace } = params\n        if (!repository && !workspace) {\n            return\n        }\n        const bfg = await this.loadedBFG\n        const indexingStartTime = Date.now()\n        // TODO: include commit?\n        try {\n            if (repository) {\n                await bfg.request('bfg/gitRevision/didChange', {\n                    gitDirectoryUri: repository.uri.toString(),\n                })\n            }\n            if (workspace) {\n                await bfg.request('bfg/workspace/didChange', { workspaceUri: workspace.toString() })\n            }\n            const elapsed = Date.now() - indexingStartTime\n            const label = repository\n                ? `${repository.uri.fsPath}:${repository.commit}`\n                : workspace\n                  ? workspace.fsPath\n                  : ''\n            if (label) {\n                logDebug('CodyEngine', `gitRevision/didChange ${label} indexing time ${elapsed}ms`)\n            }\n        } catch (error) {\n            logDebug('CodyEngine', `indexing error ${error}`)\n        }\n    }\n\n    public async retrieve({\n        document,\n        position,\n        docContext,\n        hints,\n        lastCandidate,\n    }: ContextRetrieverOptions): Promise<AutocompleteContextSnippet[]> {\n        try {\n            if (this.didFailLoading) {\n                return []\n            }\n            const bfg = await this.loadedBFG\n            if (!bfg.isAlive()) {\n                logDebug('CodyEngine', 'not alive')\n                return []\n            }\n\n            if (this.awaitIndexing) {\n                await this.bfgIndexingPromise\n            }\n\n            const lastCandidateCurrentLine =\n                (lastCandidate?.lastTriggerDocContext.currentLinePrefix || '') +\n                lastCandidate?.result.items[0].insertText\n\n            const bfgRequestStart = performance.now()\n            const inputIdentifiers = Array.from(\n                new Set([\n                    // Get last 10 identifiers from the last candidate insert text\n                    // in hopes that LLM partially guessed the right completion.\n                    ...getLastNGraphContextIdentifiersFromString({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                        source: lastCandidateCurrentLine,\n                    }),\n                    // Get last 10 identifiers from the current document prefix.\n                    ...getLastNGraphContextIdentifiersFromDocument({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                    }),\n                ])\n            )\n\n            const response = await bfg.request('bfg/contextForIdentifiers', {\n                uri: document.uri.toString(),\n                identifiers: inputIdentifiers,\n                maxSnippets: 20,\n                maxDepth: 4,\n            })\n\n            // Just in case, handle non-object results\n            if (typeof response !== 'object') {\n                return []\n            }\n\n            // Convert BFG snippets to match the format expected on the client.\n            const symbols = (response.symbols || []).map(contextSnippet => ({\n                ...contextSnippet,\n                uri: vscode.Uri.from({ scheme: 'file', path: contextSnippet.fileName }),\n            })) satisfies Omit<AutocompleteContextSnippet, 'startLine' | 'endLine'>[]\n\n            logDebug('CodyEngine', 'bfg/contextForIdentifiers', {\n                verbose: {\n                    inputIdentifiers,\n                    duration: `${performance.now() - bfgRequestStart}ms`,\n                    symbols: symbols.map(s => `${s.symbol} ${s.content}`),\n                },\n            })\n\n            // TODO: add `startLine` and `endLine` to `responses` or explicitly add\n            // another context snippet type to the client.\n            // @ts-ignore\n            return symbols\n        } catch (error) {\n            logDebug('CodyEngine:error', `${error}`)\n            return []\n        }\n    }\n\n    public isSupportedForLanguageId(languageId: string): boolean {\n        switch (languageId) {\n            case 'typescript':\n            case 'typescriptreact':\n            case 'javascript':\n            case 'javascriptreact':\n            case 'java':\n            case 'go':\n            case 'dart':\n            case 'python':\n            case 'zig':\n                return true\n            default:\n                return false\n        }\n    }\n\n    public dispose(): void {\n        if (this.didFailLoading) {\n            return\n        }\n        this.loadedBFG.then(\n            bfg => bfg.request('bfg/shutdown', null),\n            () => {}\n        )\n    }\n\n    // We lazily load BFG to allow the Cody extension to finish activation as\n    // quickly as possible.\n    private loadBFG(): Promise<MessageHandler> {\n        // This is implemented as a custom promise instead of async/await so that we can reject\n        // the promise in the 'exit' handler if we fail to start the bfg process for some reason.\n        return new Promise<MessageHandler>((resolve, reject) => {\n            logDebug('CodyEngine', 'loading bfg')\n            this.doLoadBFG(reject).then(\n                bfg => resolve(bfg),\n                error => {\n                    captureException(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    private async doLoadBFG(reject: (reason?: any) => void): Promise<MessageHandler> {\n        const bfg = await spawnBfg(this.context, reject)\n        await bfg.request('bfg/initialize', { clientName: 'vscode' })\n        return bfg\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5271-5292"",""content"":""            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Constant()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        reader.readMessage(\n                            message.unit_constant,\n                            () => (message.unit_constant = UnitConstant.deserialize(reader))\n                        )\n                        break\n                    case 2:\n                        reader.readMessage(\n                            message.boolean_constant,\n                            () => (message.boolean_constant = BooleanConstant.deserialize(reader))\n                        )\n                        break\n                    case 3:\n                        reader.readMessage(\n                            message.byte_constant,\n                            () => (message.byte_constant = ByteConstant.deserialize(reader))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:139-145"",""content"":""async function removeOldBfgBinaries(containingDir: string, currentBfgPath: string): Promise<void> {\n    const bfgDirContents = await fspromises.readdir(containingDir)\n    const oldBfgBinaries = bfgDirContents.filter(f => f.startsWith('bfg') && f !== currentBfgPath)\n    for (const oldBfgBinary of oldBfgBinaries) {\n        await fspromises.rm(path.join(containingDir, oldBfgBinary))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/evaluate-autocomplete.ts:208-243"",""content"":""        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-language <glob>',\n        'A glob pattern to determine what language paths to exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-fixture <glob>',\n        'A glob pattern to determine what fixtures to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-fixture <glob>',\n        'A glob pattern to determine what fixtures exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-filepath <glob>',\n        'A glob pattern to determine what files to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-filepath <glob>',\n        'A glob pattern to determine what files exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .addOption(\n        new commander.Option('--bfg-binary <path>', 'Optional path to a BFG binary').env('BFG_BINARY')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:121-137"",""content"":""async function downloadBfgBinary(url: string, destination: string): Promise<void> {\n    logDebug('CodyEngine', `downloading from URL ${url}`)\n    const response = await axios({\n        url,\n        method: 'GET',\n        responseType: 'stream',\n        maxRedirects: 10,\n    })\n\n    const stream = fs.createWriteStream(destination)\n    response.data.pipe(stream)\n\n    await new Promise((resolve, reject) => {\n        stream.on('finish', resolve)\n        stream.on('error', reject)\n    })\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_023/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that enforces the context length limit appears in several places throughout the codebase. Here are some key locations:

1. In the `truncateTextNearestLine` function in `cody_test/lib/shared/src/prompt/truncation.ts`, which truncates text to a specified maximum number of bytes.

2. In the `standardContextSizeHints` function in `cody_test/vscode/src/completions/providers/provider.ts`, which calculates character limits for different parts of the context based on a maximum token count.

3. In the `limitMatches` function in `mocked/codebase_context/limit.go`, which limits the number of matches in file search results.

4. In the `limitLineMatches` and `limitChunkMatches` functions in `mocked/codebase_context/limit.go`, which enforce limits on line matches and chunk matches respectively.

5. In the `getWorkspaceFilesContext` function in `cody_test/vscode/src/commands/context/workspace.ts`, which limits the number of files retrieved from the workspace.

6. In the `getContextFileFromUri` function in `cody_test/vscode/src/commands/context/file-path.ts`, which counts tokens in file content.

7. In various constants defined in `cody_test/lib/shared/src/token/constants.ts`, which set token budgets for different parts of the context.

These implementations work together to ensure that the context provided to the AI model stays within the specified limits.",Where is the code that enforces the context length limit?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:61-63"",""content"":""func (r *RateLimit) IsValid() bool {\n\treturn r != nil && r.Interval > 0 && r.Limit > 0 && len(r.AllowedModels) > 0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/directory.ts:49-74"",""content"":""\n                // check file size before opening the file. skip file if it's larger than 1MB\n                const fileSize = await vscode.workspace.fs.stat(fileUri)\n                if (fileSize.size > 1000000 || !fileSize.size) {\n                    continue\n                }\n\n                const bytes = await vscode.workspace.fs.readFile(fileUri)\n                const content = new TextDecoder('utf-8').decode(bytes)\n                const range = new vscode.Range(0, 0, content.split('\\n').length - 1 || 0, 0)\n                const size = TokenCounter.countTokens(content)\n\n                contextFiles.push({\n                    type: 'file',\n                    uri: fileUri,\n                    content,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                })\n\n                // Limit the number of files to 10\n                const maxResults = 10\n                if (contextFiles.length >= maxResults) {\n                    return contextFiles\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:164-169"",""content"":""type updateOnErrorLimiter struct {\n\tlogger log.Logger\n\tactor  *Actor\n\n\tnextLimiter limiter.Limiter\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:91-122"",""content"":""            ),\n            rangeIncludingLineBreak: new vscode_shim.Range(\n                new vscode_shim.Position(line, 0),\n                new vscode_shim.Position(line, text.length + this.offsets.newlineLength(line))\n            ),\n            text,\n        }\n    }\n\n    public offsetAt(position: vscode.Position | protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public protocolOffsetAt(position: protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public positionAt(offset: number): vscode.Position {\n        const { line, character } = this.offsets.position(offset)\n        return new vscode_shim.Position(line, character)\n    }\n\n    public getText(range?: vscode.Range | undefined): string {\n        if (range === undefined) {\n            return this.content\n        }\n        const start = this.offsets.offset(range.start)\n        const end = this.offsets.offset(range.end)\n        const text = this.content.slice(start, end)\n        return text\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:132-134"",""content"":""func (l *concurrencyLimiter) Usage(ctx context.Context) (int, time.Time, error) {\n\treturn l.nextLimiter.Usage(ctx)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:80-125"",""content"":""func limitChunkMatches(file *FileMatch, limit int) int {\n\tfor i := range file.ChunkMatches {\n\t\tcm := &file.ChunkMatches[i]\n\t\tif len(cm.Ranges) > limit {\n\t\t\t// We potentially need to effect the limit upon 3 different fields:\n\t\t\t// Ranges, SymbolInfo, and Content.\n\n\t\t\t// Content is the most complicated: we need to remove the last N\n\t\t\t// lines from it, where N is the difference between the line number\n\t\t\t// of the end of the old last Range and that of the new last Range.\n\t\t\t// This calculation is correct in the presence of both context lines\n\t\t\t// and multiline Ranges, taking into account that Content never has\n\t\t\t// a trailing newline.\n\t\t\tn := cm.Ranges[len(cm.Ranges)-1].End.LineNumber - cm.Ranges[limit-1].End.LineNumber\n\t\t\tif n > 0 {\n\t\t\t\tfor b := len(cm.Content) - 1; b >= 0; b-- {\n\t\t\t\t\tif cm.Content[b] == '\\n' {\n\t\t\t\t\t\tn -= 1\n\t\t\t\t\t}\n\t\t\t\t\tif n == 0 {\n\t\t\t\t\t\tcm.Content = cm.Content[:b]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\t// Should be impossible.\n\t\t\t\t\tlog.Panicf(\""Failed to find enough newlines when truncating Content, %d left over, %d ranges\"", n, len(cm.Ranges))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcm.Ranges = cm.Ranges[:limit]\n\t\t\tif cm.SymbolInfo != nil {\n\t\t\t\t// When non-nil, SymbolInfo is specified to have the same length\n\t\t\t\t// as Ranges.\n\t\t\t\tcm.SymbolInfo = cm.SymbolInfo[:limit]\n\t\t\t}\n\t\t}\n\t\tif len(cm.Ranges) == limit {\n\t\t\tfile.ChunkMatches = file.ChunkMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(cm.Ranges)\n\t}\n\treturn limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:129-143"",""content"":""func limitLineMatches(file *FileMatch, limit int) int {\n\tfor i := range file.LineMatches {\n\t\tlm := &file.LineMatches[i]\n\t\tif len(lm.LineFragments) > limit {\n\t\t\tlm.LineFragments = lm.LineFragments[:limit]\n\t\t}\n\t\tif len(lm.LineFragments) == limit {\n\t\t\tfile.LineMatches = file.LineMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(lm.LineFragments)\n\t}\n\treturn limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/file-path.ts:0-43"",""content"":""import {\n    type ContextItem,\n    ContextItemSource,\n    TokenCounter,\n    logError,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\n/**\n * Generate ContextFile for a file URI.\n */\nexport async function getContextFileFromUri(file: URI, range?: vscode.Range): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.filePath', async span => {\n        try {\n            const doc = await vscode.workspace.openTextDocument(file)\n            const content = doc?.getText(range).trim()\n            if (!content) {\n                throw new Error('No file content')\n            }\n\n            const startLine = range?.start?.line ?? 0\n            range = new vscode.Range(startLine, 0, startLine + content.split('\\n').length, 0)\n            const size = TokenCounter.countTokens(content)\n\n            return [\n                {\n                    type: 'file',\n                    content,\n                    uri: file,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                },\n            ] satisfies ContextItem[]\n        } catch (error) {\n            logError('getContextFileFromUri', 'failed', { verbose: error })\n            return []\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:20-36"",""content"":""type RateLimit struct {\n\t// AllowedModels is a set of models in Cody Gateway's model configuration\n\t// format, \""$PROVIDER/$MODEL_NAME\"". A single-item slice with value '*' means\n\t// that all models in the 'master allowlist' are allowed.\n\t//\n\t// DO NOT USE DIRECTLY when enforcing permissions: use EvaluateAllowedModels(...)\n\t// instead.\n\tAllowedModels []string `json:\""allowedModels\""`\n\n\tLimit    int64         `json:\""limit\""`\n\tInterval time.Duration `json:\""interval\""`\n\n\t// ConcurrentRequests, ConcurrentRequestsInterval are generally applied\n\t// with NewRateLimitWithPercentageConcurrency.\n\tConcurrentRequests         int           `json:\""concurrentRequests\""`\n\tConcurrentRequestsInterval time.Duration `json:\""concurrentRequestsInterval\""`\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/workspace.ts:22-51"",""content"":""\n        const contextFiles: ContextItem[] = []\n\n        // set cancellation token to time out after 20s\n        const token = new CancellationTokenSource()\n        setTimeout(() => {\n            token.cancel()\n        }, 20000)\n\n        try {\n            const results = await workspace.findFiles(globalPattern, excluded, maxResults, token.token)\n\n            for (const result of results) {\n                const decoded = await getDocText(result)\n                const contextFile = await createContextFile(result, decoded)\n\n                if (contextFile) {\n                    contextFiles.push(contextFile)\n                }\n            }\n\n            return contextFiles\n        } catch (error) {\n            logError('getWorkspaceFilesContext failed', `${error}`)\n\n            return contextFiles\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:62-76"",""content"":""func limitMatches(files []FileMatch, limit int, chunkMatches bool) ([]FileMatch, int) {\n\tvar limiter func(file *FileMatch, limit int) int\n\tif chunkMatches {\n\t\tlimiter = limitChunkMatches\n\t} else {\n\t\tlimiter = limitLineMatches\n\t}\n\tfor i := range files {\n\t\tlimit = limiter(&files[i], limit)\n\t\tif limit <= 0 {\n\t\t\treturn files[:i+1], 0\n\t\t}\n\t}\n\treturn files, limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:175-199"",""content"":""        }\n\n        for (let snippetsToInclude = 0; snippetsToInclude < snippets.length + 1; snippetsToInclude++) {\n            if (snippetsToInclude > 0) {\n                const snippet = snippets[snippetsToInclude - 1]\n                const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n                if (contextPrompts.symbol) {\n                    intro.push(\n                        ps`Additional documentation for \\`${contextPrompts.symbol}\\`:\\n\\n${contextPrompts.content}`\n                    )\n                } else {\n                    intro.push(\n                        ps`Here is a reference snippet of code from ${PromptString.fromDisplayPath(\n                            snippet.uri\n                        )}:\\n\\n${contextPrompts.content}`\n                    )\n                }\n            }\n\n            const introString = ps`${PromptString.join(\n                PromptString.join(intro, ps`\\n\\n`)\n                    .split('\\n')\n                    .map(line => ps`${languageConfig ? languageConfig.commentStart : ps`// `}${line}`),\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/context.ts:39-61"",""content"":""    const truncatedPrecedingText = truncatePromptStringStart(precedingText, MAX_CURRENT_FILE_TOKENS)\n    const truncatedFollowingText = truncatePromptString(followingText, MAX_CURRENT_FILE_TOKENS)\n\n    // Disable no case declarations because we get better type checking with a switch case\n    switch (intent) {\n        /**\n         * The context for the test intent is handled by the executeTestEditCommand function,\n         * we don't need to add additional context here to avoid duplication.\n         */\n        case 'test':\n            return []\n        /**\n         * Very broad set of possible instructions.\n         * Fetch context from the users' instructions and use context from current file.\n         * Include the following code from the current file.\n         * The preceding code is already included as part of the response to better guide the output.\n         */\n        case 'add': {\n            return [\n                {\n                    speaker: 'human',\n                    text: populateCodeGenerationContextTemplate(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:85-99"",""content"":""type concurrencyLimiter struct {\n\tlogger  log.Logger\n\tactor   *Actor\n\tfeature codygateway.Feature\n\n\t// redis must be a prefixed store\n\tredis limiter.RedisStore\n\n\tconcurrentRequests int\n\tconcurrentInterval time.Duration\n\n\tnextLimiter limiter.Limiter\n\n\tnowFunc func() time.Time\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/provider.ts:27-57"",""content"":""\n    /**\n     * A string identifier for the provider config used in event logs.\n     */\n    identifier: string\n\n    /**\n     * Defines which model is used with the respective provider.\n     */\n    model: string\n}\n\ninterface ProviderContextSizeHints {\n    /** Total max length of all context (prefix + suffix + snippets). */\n    totalChars: number\n\n    /** Max length of the document prefix (text before the cursor). */\n    prefixChars: number\n\n    /** Max length of the document suffix (text after the cursor). */\n    suffixChars: number\n}\n\nexport function standardContextSizeHints(maxContextTokens: number): ProviderContextSizeHints {\n    return {\n        totalChars: Math.floor(tokensToChars(0.9 * maxContextTokens)), // keep 10% margin for preamble, etc.\n        prefixChars: Math.floor(tokensToChars(0.6 * maxContextTokens)),\n        suffixChars: Math.floor(tokensToChars(0.1 * maxContextTokens)),\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/truncation.ts:25-60"",""content"":"" * which should be ignored anyway).\n */\nexport function truncateTextNearestLine(\n    text: string,\n    maxBytes: number\n): { truncated: string; range?: RangeData } {\n    if (text.length <= maxBytes) {\n        return { truncated: text }\n    }\n    const textMaxBytes = text.slice(0, maxBytes)\n    const textMaxBytesLines = textMaxBytes.split('\\n')\n    if (text.at(maxBytes) === '\\n' || text.at(maxBytes - 1) === '\\n') {\n        return {\n            truncated: textMaxBytes,\n            range: {\n                start: { line: 0, character: 0 },\n                end: { line: textMaxBytesLines.length, character: 0 },\n            },\n        }\n    }\n\n    const truncated = textMaxBytesLines.slice(0, -1).join('\\n')\n    return {\n        truncated,\n        range: {\n            start: { line: 0, character: 0 },\n            end: { line: textMaxBytesLines.length - 1, character: 0 },\n        },\n    }\n}\n\n/**\n * Truncates text to the given number of tokens, keeping the end of the text.\n */\nexport function truncateTextStart(text: string, maxTokens: number): string {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:152-163"",""content"":""                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:57-80"",""content"":""                throw new Error(\n                    `Preamble length exceeded context window size ${chat.contextWindow.input}`\n                )\n            }\n\n            // Add existing chat transcript messages\n            const reverseTranscript: ChatMessage[] = [...chat.getMessages()].reverse()\n            const transcriptLimitReached = promptBuilder.tryAddMessages(reverseTranscript)\n            if (transcriptLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    `Ignored ${transcriptLimitReached} transcript messages due to context limit`\n                )\n            }\n\n            // NOTE: Only display excluded context from user-specifed context items\n            const newContextIgnored: ContextItem[] = []\n            const newContextUsed: ContextItem[] = []\n\n            // Add context from new user-specified context items, e.g. @-mentions, @-uri\n            sortContextItems(this.explicitContext)\n            const {\n                limitReached: userLimitReached,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/utils.ts:104-135"",""content"":""        return 1\n    }\n\n    return 0 // zero refers to the legacy, unversioned, Cody API\n}\n\n/**\n * Counts the total number of bytes used in a list of chat messages.\n *\n * This function is exported and can be used to calculate the byte usage\n * of chat messages for storage/bandwidth purposes.\n *\n * @param messages - The list of chat messages to count bytes for\n * @returns The total number of bytes used in the messages\n */\nexport function countBytesInChatMessages(messages: ChatMessage[]): number {\n    if (messages.length === 0) {\n        return 0\n    }\n    return messages.reduce((acc, msg) => acc + msg.speaker.length + (msg.text?.length || 0) + 3, 0)\n}\n\n/**\n * Gets the context window limit in bytes for chat messages, taking into\n * account the maximum allowed character count. Returns 0 if the used bytes\n * exceeds the limit.\n * @param messages - The chat messages\n * @param maxChars - The maximum allowed character count\n * @returns The context window limit in bytes\n */\nexport function getContextWindowLimitInBytes(messages: ChatMessage[], maxChars: number): number {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/jaccard-similarity/jaccard-similarity-retriever.ts:0-22"",""content"":""import * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\nimport { getContextRange } from '../../../doc-context-getters'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\nimport { baseLanguageId } from '../../utils'\nimport { type DocumentHistory, VSCodeDocumentHistory } from './history'\n\nimport { lastNLines } from '../../../text-processing'\nimport { type JaccardMatch, bestJaccardMatches } from './bestJaccardMatch'\n\n/**\n * The size of the Jaccard distance match window in number of lines. It determines how many\n * lines of the 'matchText' are considered at once when searching for a segment\n * that is most similar to the 'targetText'. In essence, it sets the maximum number\n * of lines that the best match can be. A larger 'windowSize' means larger potential matches\n */\nconst SNIPPET_WINDOW_SIZE = 50\n\n/**\n * Limits the number of jaccard windows that are fetched for a single file. This is mostly added to\n * avoid large files taking up too much compute time and to avoid a single file to take up too much\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:138-138"",""content"":""\tlimit      int\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""}]",Find logic,,,0,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_024/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The logic for opening a new chat window is primarily handled in the `ChatPanelsManager` class, specifically in the `createWebviewPanel` method. This can be found in the file `cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts`.

Additionally, the `ChatManager` class in `cody_test/vscode/src/chat/chat-view/ChatManager.ts` registers a command `cody.chat.panel.new` that calls the `createNewWebviewPanel` method.

For testing purposes, there's a helper function `newChat` in `cody_test/vscode/test/e2e/helpers.ts` that simulates clicking the ""New Chat"" button to open a new chat window.

The actual UI interaction for creating a new chat is handled in the React component `Chat` in `cody_test/vscode/webviews/Chat.tsx`, which includes the logic for the chat input and submission.",Where is the logic for opening a new chat window?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/helpers.ts:391-394"",""content"":""export async function newChat(page: Page): Promise<FrameLocator> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    return page.frameLocator('iframe.webview').last().frameLocator('iframe')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:77-95"",""content"":""            vscode.commands.registerCommand('cody.chat.history.clear', () => this.clearHistory()),\n            vscode.commands.registerCommand('cody.chat.history.delete', item => this.clearHistory(item)),\n            vscode.commands.registerCommand('cody.chat.history.edit', item =>\n                this.editChatHistory(item)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.new', () => this.createNewWebviewPanel()),\n            vscode.commands.registerCommand('cody.chat.panel.restore', (id, chat) =>\n                this.restorePanel(id, chat)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.reset', () =>\n                this.chatPanelsManager.resetPanel()\n            ),\n            vscode.commands.registerCommand(CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID, (...args) =>\n                this.passthroughVsCodeOpen(...args)\n            ),\n            vscode.commands.registerCommand('cody.chat.context.add', () => this.sendSelectionToChat())\n        )\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/open-telemetry/OpenTelemetryService.node.ts:0-95"",""content"":""import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\nimport { registerInstrumentations } from '@opentelemetry/instrumentation'\nimport { HttpInstrumentation } from '@opentelemetry/instrumentation-http'\nimport { Resource } from '@opentelemetry/resources'\nimport { NodeTracerProvider } from '@opentelemetry/sdk-trace-node'\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\n\nimport {\n    type ConfigurationWithAccessToken,\n    FeatureFlag,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport { DiagConsoleLogger, DiagLogLevel, diag } from '@opentelemetry/api'\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { version } from '../../version'\nimport { ConsoleBatchSpanExporter } from './console-batch-span-exporter'\n\nexport type OpenTelemetryServiceConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'experimentalTracing' | 'debugVerbose'\n>\n\nexport class OpenTelemetryService {\n    private tracerProvider?: NodeTracerProvider\n    private unloadInstrumentations?: () => void\n\n    private lastTraceUrl: string | undefined\n    // We use a single promise object that we chain on to, to avoid multiple reconfigure calls to\n    // be run in parallel\n    private reconfigurePromiseMutex: Promise<void> = Promise.resolve()\n\n    constructor(protected config: OpenTelemetryServiceConfig) {\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    public onConfigurationChange(newConfig: OpenTelemetryServiceConfig): void {\n        this.config = newConfig\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    private async reconfigure(): Promise<void> {\n        const isEnabled =\n            this.config.experimentalTracing ||\n            (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.CodyAutocompleteTracing))\n\n        if (!isEnabled) {\n            return\n        }\n\n        const traceUrl = new URL('/-/debug/otlp/v1/traces', this.config.serverEndpoint).toString()\n        if (this.lastTraceUrl === traceUrl) {\n            return\n        }\n        this.lastTraceUrl = traceUrl\n\n        const logLevel = this.config.debugVerbose ? DiagLogLevel.INFO : DiagLogLevel.ERROR\n        diag.setLogger(new DiagConsoleLogger(), logLevel)\n\n        await this.reset()\n\n        this.unloadInstrumentations = registerInstrumentations({\n            instrumentations: [new HttpInstrumentation()],\n        })\n        this.configureTracerProvider(traceUrl)\n    }\n\n    public configureTracerProvider(traceUrl: string): void {\n        this.tracerProvider = new NodeTracerProvider({\n            resource: new Resource({\n                [SemanticResourceAttributes.SERVICE_NAME]: 'cody-client',\n                [SemanticResourceAttributes.SERVICE_VERSION]: version,\n            }),\n        })\n\n        // Add the default tracer exporter used in production.\n        this.tracerProvider.addSpanProcessor(\n            new BatchSpanProcessor(\n                new OTLPTraceExporter({ url: traceUrl, httpAgentOptions: { rejectUnauthorized: false } })\n            )\n        )\n\n        // Add the console exporter used in development for verbose logging and debugging.\n        if (process.env.NODE_ENV === 'development' || this.config.debugVerbose) {\n            this.tracerProvider.addSpanProcessor(new BatchSpanProcessor(new ConsoleBatchSpanExporter()))\n        }\n\n        this.tracerProvider.register()\n    }\n\n    public async reset(): Promise<void> {\n        await this.tracerProvider?.shutdown()\n        this.unloadInstrumentations?.()\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:776-807"",""content"":""            },\n        })\n    }\n\n    /**\n     * Low-level utility to post a message to the webview, pending initialization.\n     *\n     * cody-invariant: this.webview?.postMessage should never be invoked directly\n     * except within this method.\n     */\n    private postMessage(message: ExtensionMessage): Thenable<boolean | undefined> {\n        return this.initDoer.do(() => this.webview?.postMessage(message))\n    }\n\n    private postChatTitle(): void {\n        if (this.webviewPanel) {\n            this.webviewPanel.title = this.chatModel.getChatTitle()\n        }\n    }\n\n    // #endregion\n    // =======================================================================\n    // #region chat request lifecycle methods\n    // =======================================================================\n\n    /**\n     * Constructs the prompt and updates the UI with the context used in the prompt.\n     */\n    private async buildPrompt(\n        prompter: IPrompter,\n        sendTelemetry?: (contextSummary: any, privateContextStats?: any) => void\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.test.ts:0-46"",""content"":""import { describe, expect, test } from 'vitest'\n\nimport { getChatPanelTitle } from './chat-helpers'\n\ndescribe('getChatPanelTitle', () => {\n    test('returns default title when no lastDisplayText', () => {\n        const result = getChatPanelTitle()\n        expect(result).toEqual('New Chat')\n    })\n\n    test('long titles will be truncated', () => {\n        const longTitle = 'This is a very long title that should get truncated by the function'\n        const result = getChatPanelTitle(longTitle)\n        expect(result).toEqual('This is a very long title...')\n    })\n\n    test('keeps command key', () => {\n        const title = '/explain this symbol'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain this symbol')\n    })\n\n    test('keeps command key with file path', () => {\n        const title = '/explain [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain @a.ts')\n    })\n\n    test('removes markdown links', () => {\n        const title = 'Summarize this file [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Summarize this file @a.ts')\n    })\n\n    test('removes multiple markdown links', () => {\n        const title = '[_@a.py_](a.py) [_@b.py_](b.py) explain'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('@a.py @b.py explain')\n    })\n\n    test('truncates long title with multiple markdown links', () => {\n        const title = 'Explain the relationship...'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Explain the relationship....')\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:23-48"",""content"":""\n    const heyTreeItem = page.getByRole('treeitem', { name: 'Hey' })\n    const holaTreeItem = page.getByRole('treeitem', { name: 'Hola' })\n\n    const [chatPanelFrame, chatInput] = await createEmptyChatPanel(page)\n\n    await chatInput.fill('Hey')\n    await chatInput.press('Enter')\n\n    // Check if chat shows up in sidebar chat history tree view\n    await expect(heyTreeItem).toBeVisible()\n\n    // Wait at least 1 second to ensure that the 2 chats have different IDs (which are currently\n    // created using `new Date(Date.now()).toUTCString()`, so they are the same if they are\n    // generated in the same second).\n    //\n    // TODO(sqs): investigate and fix the underlying bug here\n    await page.waitForTimeout(1000)\n\n    // Clear and restart chat session\n    // All current messages should be removed, and the panel name should be updated to 'New Chat'\n    await chatInput.fill('/reset')\n    await chatInput.press('Enter')\n    await expect(chatPanelFrame.getByText('Hey')).not.toBeVisible()\n    await expect(page.getByRole('tab', { name: 'New Chat' })).toBeVisible()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.ts:0-39"",""content"":""import * as vscode from 'vscode'\n\nimport type { RangeData } from '@sourcegraph/cody-shared'\n\nexport async function openFile(\n    uri: vscode.Uri,\n    range?: RangeData,\n    currentViewColumn?: vscode.ViewColumn\n): Promise<void> {\n    let viewColumn = vscode.ViewColumn.Beside\n    if (currentViewColumn) {\n        viewColumn = currentViewColumn - 1 || currentViewColumn + 1\n    }\n    const doc = await vscode.workspace.openTextDocument(uri)\n    // +1 because selection range starts at 0 while editor line starts at 1\n    const selection = range && new vscode.Range(range.start.line, 0, range.end.line + 1, 0)\n    await vscode.window.showTextDocument(doc, {\n        selection,\n        viewColumn,\n        preserveFocus: true,\n        preview: true,\n    })\n}\n\nexport function getChatPanelTitle(lastHumanText?: string, truncateTitle = true): string {\n    if (!lastHumanText) {\n        return 'New Chat'\n    }\n\n    let text = lastHumanText\n    // Regex to remove the markdown formatted links with this format: '[_@FILENAME_]()'\n    const MARKDOWN_LINK_REGEX = /\\[_(.+?)_]\\((.+?)\\)/g\n    text = text.replaceAll(MARKDOWN_LINK_REGEX, '$1')?.trim()\n    if (!truncateTitle) {\n        return text\n    }\n    // truncate title that is too long\n    return text.length > 25 ? `${text.slice(0, 25).trim()}...` : text\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1017-1043"",""content"":""\n    // #endregion\n    // =======================================================================\n    // #region session management\n    // =======================================================================\n\n    // A unique identifier for this SimpleChatPanelProvider instance used to identify\n    // it when a handle to this specific panel provider is needed.\n    public get sessionID(): string {\n        return this.chatModel.sessionID\n    }\n\n    // Sets the provider up for a new chat that is not being restored from a\n    // saved session.\n    public async newSession(): Promise<void> {\n        // Set the remote search's selected repos to the workspace repo list\n        // by default.\n        this.remoteSearch?.setRepos(\n            (await this.repoPicker?.getDefaultRepos()) || [],\n            RepoInclusion.Manual\n        )\n    }\n\n    // Attempts to restore the chat to the given sessionID, if it exists in\n    // history. If it does, then saves the current session and cancels the\n    // current in-progress completion. If the chat does not exist, then this\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:48-533"",""content"":""export const Chat: React.FunctionComponent<React.PropsWithChildren<ChatboxProps>> = ({\n    welcomeMessage,\n    messageInProgress,\n    transcript,\n    vscodeAPI,\n    telemetryService,\n    isTranscriptError,\n    chatEnabled,\n    userInfo,\n    guardrails,\n    chatIDHistory,\n    isWebviewActive,\n    isNewInstall,\n    userContextFromSelection,\n}) => {\n    const [messageBeingEdited, setMessageBeingEdited] = useState<number | undefined>(undefined)\n\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n            }\n            const editorValue = editorRef.current.getSerializedValue()\n            if (!editorValue.text.trim()) {\n                throw new Error('Chat message cannot be empty')\n            }\n            // Handle edit requests\n            if (submitType === 'edit') {\n                if (messageBeingEdited === undefined) {\n                    throw new Error('unexpected: messageBeingEdited is undefined')\n                }\n                vscodeAPI.postMessage({\n                    command: 'edit',\n                    index: messageBeingEdited!,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            } else {\n                vscodeAPI.postMessage({\n                    command: 'submit',\n                    submitType,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            }\n        },\n        [addEnhancedContext, messageBeingEdited, vscodeAPI]\n    )\n\n    const feedbackButtonsOnSubmit = useCallback(\n        (text: string) => {\n            const eventData = {\n                value: text,\n                lastChatUsedEmbeddings: Boolean(\n                    transcript.at(-1)?.contextFiles?.some(file => file.source === 'embeddings')\n                ),\n                transcript: '',\n            }\n\n            if (userInfo.isDotComUser) {\n                eventData.transcript = JSON.stringify(transcript)\n            }\n\n            telemetryService.log(`CodyVSCodeExtension:codyFeedback:${text}`, eventData)\n        },\n        [telemetryService, transcript, userInfo]\n    )\n\n    const copyButtonOnSubmit = useCallback(\n        (text: string, eventType: 'Button' | 'Keydown' = 'Button') => {\n            const op = 'copy'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const insertButtonOnSubmit = useCallback(\n        (text: string, newFile = false) => {\n            const op = newFile ? 'newFile' : 'insert'\n            const eventType = 'Button'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const postMessage = useCallback<ApiPostMessage>(msg => vscodeAPI.postMessage(msg), [vscodeAPI])\n\n    const setInputFocus = useCallback((focus: boolean): void => {\n        editorRef.current?.setFocus(focus)\n    }, [])\n\n    // When New Chat Mode is enabled, all non-edit questions will be asked in a new chat session\n    // Users can toggle this feature via \""shift\"" + \""Meta(Mac)/Control\"" keys\n    const [enableNewChatMode, setEnableNewChatMode] = useState(false)\n\n    const lastHumanMessageIndex = useMemo<number | undefined>(() => {\n        if (!transcript?.length) {\n            return undefined\n        }\n        const index = transcript.findLastIndex(msg => msg.speaker === 'human')\n\n        return index\n    }, [transcript])\n\n    /**\n     * Sets the state to edit a message at the given index in the transcript.\n     * Checks that the index is valid, then gets the display text  to set as the\n     * form input.\n     *\n     * An undefined index number means there is no message being edited.\n     */\n    const setEditMessageState = useCallback(\n        (index?: number): void => {\n            // When a message is no longer being edited\n            // we will reset the form input fill to empty state\n            if (index === undefined && index !== messageBeingEdited) {\n                setEditorState(null)\n            }\n            setMessageBeingEdited(index)\n            if (index === undefined || index > transcript.length) {\n                return\n            }\n            const messageAtIndex = transcript[index]\n            if (messageAtIndex) {\n                setEditorState(serializedPromptEditorStateFromChatMessage(messageAtIndex))\n            }\n            // move focus back to chatbox\n            setInputFocus(true)\n        },\n        [messageBeingEdited, transcript, setEditorState, setInputFocus]\n    )\n\n    /**\n     * Reset current chat view with a new empty chat session.\n     *\n     * Calls setEditMessageState() to reset any in-progress edit state.\n     * Sends a 'reset' command to postMessage to reset the chat on the server.\n     */\n    const onChatResetClick = useCallback(\n        (eventType: 'keyDown' | 'click' = 'click') => {\n            setEditMessageState()\n            postMessage?.({ command: 'reset' })\n            postMessage?.({\n                command: 'event',\n                eventName: 'CodyVSCodeExtension:chatActions:reset:executed',\n                properties: { source: 'chat', eventType },\n            })\n        },\n        [postMessage, setEditMessageState]\n    )\n\n    const submitInput = useCallback(\n        (submitType: WebviewChatSubmitType): void => {\n            if (messageInProgress && submitType !== 'edit') {\n                return\n            }\n            onSubmit(submitType)\n\n            setEditorState(null)\n            setEditMessageState()\n        },\n        [messageInProgress, onSubmit, setEditMessageState, setEditorState]\n    )\n\n    const onChatSubmit = useCallback((): void => {\n        // Submit edits when there is one being edited\n        if (messageBeingEdited !== undefined) {\n            onAbortMessageInProgress()\n            submitInput('edit')\n            return\n        }\n\n        // Submit chat only when input is not empty and not in progress\n        if (!isEmptyEditorValue && !messageInProgress?.speaker) {\n            const submitType = enableNewChatMode ? 'user-newchat' : 'user'\n            submitInput(submitType)\n        }\n    }, [\n        isEmptyEditorValue,\n        messageBeingEdited,\n        messageInProgress?.speaker,\n        enableNewChatMode,\n        submitInput,\n        onAbortMessageInProgress,\n    ])\n\n    const onEditorEscapeKey = useCallback((): void => {\n        // Close the enhanced context settings modal if it's open\n        setIsEnhancedContextOpen(false)\n\n        // Exits editing mode if a message is being edited\n        if (messageBeingEdited !== undefined) {\n            setEditMessageState()\n            return\n        }\n\n        // Aborts a message in progress if one exists\n        if (messageInProgress?.speaker) {\n            onAbortMessageInProgress()\n            return\n        }\n    }, [messageBeingEdited, setEditMessageState, messageInProgress, onAbortMessageInProgress])\n\n    const onEditorEnterKey = useCallback(\n        (event: KeyboardEvent | null): void => {\n            // Submit input on Enter press (without shift) when input is not empty.\n            if (event && !event.shiftKey && !event.isComposing && !isEmptyEditorValue) {\n                event.preventDefault()\n                onChatSubmit()\n                return\n            }\n        },\n        [onChatSubmit, isEmptyEditorValue]\n    )\n\n    const onEditorKeyDown = useCallback(\n        (event: KeyboardEvent, caretPosition: number): void => {\n            // Check if the Ctrl key is pressed on Windows/Linux or the Cmd key is pressed on macOS\n            const isModifierDown = isMac ? event.metaKey : event.ctrlKey\n            if (isModifierDown) {\n                // Ctrl/Cmd + / - Clears the chat and starts a new session\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick('keyDown')\n                    return\n                }\n                // Ctrl/Cmd + K - When not already editing, edits the last human message\n                if (messageBeingEdited === undefined && event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    setEditMessageState(lastHumanMessageIndex)\n\n                    postMessage?.({\n                        command: 'event',\n                        eventName: 'CodyVSCodeExtension:chatActions:editLast:executed',\n                        properties: { source: 'chat', eventType: 'keyDown' },\n                    })\n                    return\n                }\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            if (event.altKey && event.key === 'c') {\n                event.preventDefault()\n                event.stopPropagation()\n                return\n            }\n\n            // Allow navigation/selection with Ctrl(+Shift?)+Arrows\n            const arrowKeys = new Set(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'])\n            if (event.ctrlKey && arrowKeys.has(event.key)) {\n                return\n            }\n\n            // Handles keyboard shortcuts with Ctrl key.\n            // Checks if the Ctrl key is pressed with a key not in the allow list\n            // to avoid triggering default browser shortcuts and bubbling the event.\n            const ctrlKeysAllowList = new Set([\n                'a',\n                'c',\n                'v',\n                'x',\n                'y',\n                'z',\n                'Enter',\n                'Shift' /* follow-up */,\n            ])\n            if (event.ctrlKey && !ctrlKeysAllowList.has(event.key)) {\n                event.preventDefault()\n                return\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            const vscodeCodyShortcuts = new Set(['Slash', 'KeyC'])\n            if (event.altKey && vscodeCodyShortcuts.has(event.code)) {\n                event.preventDefault()\n                return\n            }\n\n            // TODO (bee) - Update to use Option key instead\n            // TODO (bee) - remove once updated to use Option key\n            // Toggles between new chat mode and regular chat mode\n            if (event.altKey && event.shiftKey && isModifierDown) {\n                // use as a temporary block for this key combination\n                event.preventDefault()\n                setEnableNewChatMode(!enableNewChatMode)\n                return\n            }\n\n            // If there's no input and ArrowUp is pressed, edit the last message.\n            if (event.key === 'ArrowUp' && isEmptyEditorValue) {\n                setEditMessageState(lastHumanMessageIndex)\n            }\n        },\n        [\n            messageBeingEdited,\n            isEmptyEditorValue,\n            onChatResetClick,\n            setEditMessageState,\n            lastHumanMessageIndex,\n            enableNewChatMode,\n            postMessage,\n        ]\n    )\n\n    // Set up the message listener for adding new context from user's editor to chat.\n    // Turns the new context into @-mentions token in chat.\n    useEffect(() => {\n        if (!userContextFromSelection.length) {\n            return\n        }\n        editorRef.current?.addContextItemAsToken(userContextFromSelection)\n    }, [userContextFromSelection])\n\n    // Focus the textarea when the webview (re)gains focus (unless there is text selected or a modal\n    // is open). This makes it so that the user can immediately start typing to Cody after invoking\n    // `Cody: Focus on Chat View` with the keyboard.\n    useEffect(() => {\n        // Focus the input when the enhanced context settings modal is closed\n        setInputFocus(!isEnhancedContextOpen)\n        // Add window focus event listener to focus the input when the window is focused\n        const handleFocus = (): void => {\n            if (document.getSelection()?.isCollapsed && !isEnhancedContextOpen) {\n                setInputFocus(true)\n            }\n        }\n        window.addEventListener('focus', handleFocus)\n        return () => {\n            window.removeEventListener('focus', handleFocus)\n        }\n    }, [setInputFocus, isEnhancedContextOpen])\n\n    const onCancelEditClick = useCallback(() => setEditMessageState(), [setEditMessageState])\n    const onEditLastMessageClick = useCallback(\n        () => setEditMessageState(lastHumanMessageIndex),\n        [setEditMessageState, lastHumanMessageIndex]\n    )\n\n    const onRestoreLastChatClick = useMemo(\n        () =>\n            // Display the restore button if there is a previous chat id in current window\n            // And the current chat window is new\n            chatIDHistory.length > 1\n                ? () =>\n                      postMessage?.({\n                          command: 'restoreHistory',\n                          chatID: chatIDHistory.at(-2),\n                      })\n                : undefined,\n        [chatIDHistory, postMessage]\n    )\n\n    // biome-ignore lint/correctness/useExhaustiveDependencies: We don't want to re-run this effect.\n    const onEnhancedContextTogglerClick = useCallback((open: boolean) => {\n        if (!isEnhancedContextOpen && !open) {\n            setInputFocus(true)\n        }\n        setIsEnhancedContextOpen(open)\n    }, [])\n\n    const [isEditorFocused, setIsEditorFocused] = useState(false)\n\n    const isNewChat = transcript.length === 0\n    const TIPS = '(@ for files, @# for symbols)'\n    const placeholder = chatEnabled\n        ? isNewChat\n            ? `Message ${TIPS}`\n            : `Follow-Up Message ${TIPS}`\n        : 'Chat has been disabled by your Enterprise instance site administrator'\n\n    return (\n        <div className={classNames(styles.innerContainer)}>\n            {\n                <Transcript\n                    transcript={transcript}\n                    welcomeMessage={welcomeMessage}\n                    messageInProgress={messageInProgress}\n                    messageBeingEdited={messageBeingEdited}\n                    setMessageBeingEdited={setEditMessageState}\n                    className={styles.transcriptContainer}\n                    feedbackButtonsOnSubmit={feedbackButtonsOnSubmit}\n                    copyButtonOnSubmit={copyButtonOnSubmit}\n                    insertButtonOnSubmit={insertButtonOnSubmit}\n                    isTranscriptError={isTranscriptError}\n                    userInfo={userInfo}\n                    postMessage={postMessage}\n                    guardrails={guardrails}\n                />\n            }\n            <form className={classNames(styles.inputRow)}>\n                {/* Don't show chat action buttons on empty chat session unless it's a new cha*/}\n\n                <ChatActions\n                    setInputFocus={setInputFocus}\n                    isWebviewActive={isWebviewActive}\n                    isEmptyChat={transcript.length < 1}\n                    isMessageInProgress={!!messageInProgress?.speaker}\n                    isEditing={transcript.length > 1 && messageBeingEdited !== undefined}\n                    isEmptyEditorValue={isEmptyEditorValue}\n                    isEditorFocused={isEditorFocused}\n                    onChatResetClick={onChatResetClick}\n                    onCancelEditClick={onCancelEditClick}\n                    onEditLastMessageClick={onEditLastMessageClick}\n                    onRestoreLastChatClick={onRestoreLastChatClick}\n                />\n\n                <div className={styles.textAreaContainer}>\n                    <div className={styles.editorOuterContainer}>\n                        <PromptEditor\n                            placeholder={placeholder}\n                            onChange={onEditorChange}\n                            onFocusChange={setIsEditorFocused}\n                            disabled={!chatEnabled}\n                            onKeyDown={onEditorKeyDown}\n                            onEnterKey={onEditorEnterKey}\n                            onEscapeKey={onEditorEscapeKey}\n                            editorRef={editorRef}\n                        />\n                        <div className={styles.contextButton}>\n                            <EnhancedContextSettings\n                                isOpen={isEnhancedContextOpen}\n                                setOpen={onEnhancedContextTogglerClick}\n                                presentationMode={userInfo.isDotComUser ? 'consumer' : 'enterprise'}\n                                isNewInstall={isNewInstall}\n                            />\n                        </div>\n                    </div>\n                    <SubmitButton\n                        type={\n                            messageBeingEdited === undefined\n                                ? enableNewChatMode\n                                    ? 'user-newchat'\n                                    : 'user'\n                                : 'edit'\n                        }\n                        className={styles.submitButton}\n                        onClick={onChatSubmit}\n                        disabled={isEmptyEditorValue && !messageInProgress}\n                        onAbortMessageInProgress={\n                            messageInProgress ? onAbortMessageInProgress : undefined\n                        }\n                    />\n                </div>\n            </form>\n        </div>\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/command-menu.test.ts:20-35"",""content"":""\n    // Submit a chat question via command menu using \""New Chat\"" option in Command Menu\n    await page.getByRole('button', { name: /Commands \\(.*/ }).dblclick()\n    const commandInputBox = page.getByPlaceholder(/Search for a command or enter/)\n    await expect(commandInputBox).toBeVisible()\n    await commandInputBox.fill('new chat submitted from command menu')\n    // this will fail if more than 1 New Chat item in the menu is found\n    await page.getByLabel('comment  New Chat, Start a new chat', { exact: true }).hover()\n    await expect(page.getByLabel('comment  New Chat, Start a new chat', { exact: true })).toBeVisible()\n    await page.getByLabel('wand  Edit Code, Start a code edit', { exact: true }).hover()\n    await expect(page.getByLabel('wand  Edit Code, Start a code edit', { exact: true })).toBeVisible()\n    await page.getByLabel('Start a new chat').locator('a').click()\n\n    // the question should show up in the chat panel on submit\n    const chatPanel = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:56-80"",""content"":""\n    private options: ChatPanelProviderOptions\n\n    // Tree view for chat history\n    public treeViewProvider = new TreeViewProvider('chat', featureFlagProvider)\n    public treeView\n\n    public supportTreeViewProvider = new TreeViewProvider('support', featureFlagProvider)\n\n    // We keep track of the currently authenticated account and dispose open chats when it changes\n    private currentAuthAccount: undefined | { endpoint: string; primaryEmail: string; username: string }\n\n    protected disposables: vscode.Disposable[] = []\n\n    constructor(\n        { extensionUri, ...options }: SidebarViewOptions,\n        private chatClient: ChatClient,\n        private readonly localEmbeddings: LocalEmbeddingsController | null,\n        private readonly contextRanking: ContextRankingController | null,\n        private readonly symf: SymfRunner | null,\n        private readonly enterpriseContext: EnterpriseContextFactory | null,\n        private readonly guardrails: Guardrails\n    ) {\n        logDebug('ChatPanelsManager:constructor', 'init')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:238-257"",""content"":""    private async passthroughVsCodeOpen(...args: unknown[]): Promise<void> {\n        if (args[1] && (args[1] as any).viewColumn === vscode.ViewColumn.Beside) {\n            // Make vscode.ViewColumn.Beside work as expected from a webview: open it to the side,\n            // instead of always opening a new editor to the right.\n            //\n            // If the active editor is undefined, that means the chat panel is the active editor, so\n            // we will open the file in the first visible editor instead.\n            const textEditor = vscode.window.activeTextEditor || vscode.window.visibleTextEditors[0]\n            ;(args[1] as any).viewColumn = textEditor ? textEditor.viewColumn : vscode.ViewColumn.Beside\n        }\n        if (args[1] && Array.isArray((args[1] as any).selection)) {\n            // Fix a weird issue where the selection was getting encoded as a JSON array, not an\n            // object.\n            ;(args[1] as any).selection = new vscode.Selection(\n                (args[1] as any).selection[0],\n                (args[1] as any).selection[1]\n            )\n        }\n        await vscode.commands.executeCommand('vscode.open', ...args)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287"",""content"":""\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the “Chats” panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the “Chats” panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the “Chats” panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \""Enhanced Context\"" icon next to the chat input.\n- [ ] Verify that \""Enhanced Context\"" is enabled by default.\n\n### Consumer\n\nSet up steps:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:266-276"",""content"":""    private async createNewWebviewPanel(): Promise<ChatSession | undefined> {\n        const debounceCreatePanel = debounce(() => this.chatPanelsManager.createWebviewPanel(), 250, {\n            leading: true,\n            trailing: true,\n        })\n\n        if (this.chatPanelsManager) {\n            return debounceCreatePanel()\n        }\n        return undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:138-165"",""content"":""        // Check if any existing panel is available\n        // NOTE: Never reuse webviews when running inside the agent.\n        if (this.activePanelProvider && !this.options.config.isRunningInsideAgent) {\n            return this.activePanelProvider\n        }\n\n        const provider = await this.createWebviewPanel()\n        return provider\n    }\n\n    /**\n     * Creates a new webview panel for chat.\n     */\n    public async createWebviewPanel(\n        chatID?: string,\n        chatQuestion?: string,\n        panel?: vscode.WebviewPanel\n    ): Promise<SimpleChatPanelProvider> {\n        if (chatID && this.panelProviders.map(p => p.sessionID).includes(chatID)) {\n            const provider = this.panelProviders.find(p => p.sessionID === chatID)\n            if (provider?.webviewPanel) {\n                provider.webviewPanel?.reveal()\n                this.activePanelProvider = provider\n                void this.selectTreeItem(chatID)\n                return provider\n            }\n        }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1254-1272"",""content"":""function newChatModelFromSerializedChatTranscript(\n    json: SerializedChatTranscript,\n    modelID: string\n): SimpleChatModel {\n    return new SimpleChatModel(\n        json.chatModel || modelID,\n        json.interactions.flatMap((interaction: SerializedChatInteraction): ChatMessage[] =>\n            [\n                PromptString.unsafe_deserializeChatMessage(interaction.humanMessage),\n                interaction.assistantMessage\n                    ? PromptString.unsafe_deserializeChatMessage(interaction.assistantMessage)\n                    : null,\n            ].filter(isDefined)\n        ),\n        json.id,\n        json.chatTitle,\n        json.enhancedContext?.selectedRepos\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:89-117"",""content"":""                // Ctrl/Cmd + K: edits the last human message\n                if (event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onEditLastMessageClick()\n                    return\n                }\n\n                // Ctrl/Cmd + /: starts a new chat\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick()\n                    return\n                }\n            }\n        }\n        document.addEventListener('keydown', onKeyDown)\n    }, [onEditLastMessageClick, onChatResetClick, isMac])\n\n    useEffect(() => {\n        // Focus on the Edit button after a question has been submitted\n        // This allows users to edit the message they just submitted right away\n        if (!isEditing && isMessageInProgress) {\n            setInputFocus(false)\n            buttonRef?.current?.focus()\n        }\n        // Remove focus on the Edit button when stream ends\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:124-127"",""content"":""    public async getNewChatPanel(): Promise<SimpleChatPanelProvider> {\n        const provider = await this.createWebviewPanel()\n        return provider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/llm-providers/groq/index.ts:24-52"",""content"":"" */\ninterface GroqChatMessage extends OpenAIMessage {\n    name?: string\n    seed?: number\n}\n\n/**\n * Default context window sizes for various Groq models.\n *\n * @see https://console.groq.com/docs/models\n */\nexport const GROQ_DEFAULT_CONTEXT_WINDOW = {\n    mixtral: 32768,\n    llama2: 4096,\n    gemma: 8192,\n}\n\n/**\n * Represents the response from the Groq Chat Completion API.\n *\n * @property {string} model - The model used for the completion.\n * @property {GroqCompletionsError} [error] - Any error that occurred during the completion.\n * @property {Object[]} [choices] - The completion choices returned by the API.\n * @property {string} [choices[].finish_reason] - The reason the completion finished.\n * @property {string|null} [choices[].logprobs] - The log probabilities of the tokens in the completion.\n * @property {GroqChatMessage} [choices[].message] - The completion message.\n * @property {boolean} done - Indicates whether the completion is done.\n * @property {GroqCompletionsResponseUsage} [usage] - Usage information for the completion.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.test.ts:0-128"",""content"":""import { describe, expect, it } from 'vitest'\nimport { URI } from 'vscode-uri'\n\nimport { convertFileUriToTestFileUri, createDefaultTestFile } from './new-test-file'\n\ndescribe('createDefaultTestFile', () => {\n    it.each([\n        ['/path/to/file.java', '/path/to/fileTest.java'],\n        ['/path/to/file.js', '/path/to/file.test.js'],\n        ['/path/to/file.go', '/path/to/file_test.go'],\n        ['/path/to/test_file.py', '/path/to/test_file.py'],\n        ['/path/to/test-file.js', '/path/to/test-file.test.js'],\n        ['/path/to/node_modules/file.js', '/path/to/node_modules/file.test.js'],\n        ['/path/to/node_modules/file_test.ts', '/path/to/node_modules/file_test.ts'],\n        ['/path/to/fileTest.js', '/path/to/fileTest.js'],\n        ['test_example.py', 'test_example.py'],\n        ['example.cpp', 'exampleTest.cpp'],\n        ['example.test.js', 'example.test.js'],\n        ['Example.java', 'ExampleTest.java'],\n        ['ExampleTest.java', 'ExampleTest.java'],\n        ['example.rb', 'example_spec.rb'],\n        ['Example.cs', 'ExampleTest.cs'],\n        ['ExampleTest.php', 'ExampleTest.php'],\n        ['ExampleSpec.scala', 'ExampleSpec.scala'],\n        ['file.rb', 'file_spec.rb'],\n        ['contest.ts', 'contest.test.ts'],\n    ])('for file %j it returns %j', (file, test) => {\n        expect(createDefaultTestFile(URI.file(file)).toString()).toBe(URI.file(test).toString())\n    })\n})\n\ndescribe('convertFileUriToTestFileUri', () => {\n    it('should return the current file uri if it is already a test file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.test.ts')).toString()).toBe(\n            URI.file('/path/to/testFile.test.ts').toString()\n        )\n    })\n\n    it('should return the current file uri if it is already a spec file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.spec.rb')).toString()).toBe(\n            URI.file('/path/to/testFile.spec.rb').toString()\n        )\n    })\n\n    it('should generate a test file uri from a non-test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate the default spec file uri from a non-test file uri for ruby', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.rb'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_spec.rb').toString())\n    })\n\n    it('should follow an existing test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/existingTestFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should respect test file with different naming conventions', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should handle a non-alphanumeric character at the test character index', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/test-ExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.py'),\n                URI.file('/path/to/testFile_test.py')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_test.py').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python when no existing test path provided', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/test-file.py')).toString()).toBe(\n            URI.file('/path/to/test-file_test.py').toString()\n        )\n    })\n\n    it('should generate the default spec file uri for ruby when no existing test files is found', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/file.rb'), undefined).toString()).toBe(\n            URI.file('/path/to/file_spec.rb').toString()\n        )\n    })\n\n    it('should generate the corrent test file uri for window files', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\path\\\\to\\\\file.ts'),\n                URI.file('\\\\path\\\\to\\\\testFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('\\\\path\\\\to\\\\file.test.ts').toString())\n    })\n\n    it('should follow an existing test file uri format to generate new test file uri on windows', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\server\\\\c$\\\\folder\\\\current-file.go'),\n                URI.file('\\\\path\\\\to\\\\file_test.go')\n            ).toString()\n        ).toBe(URI.file('\\\\server\\\\c$\\\\folder\\\\current-file_test.go').toString())\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.ts:0-94"",""content"":""import { type URI, Utils } from 'vscode-uri'\n\nimport { uriBasename, uriExtname, uriParseNameAndExtension } from '@sourcegraph/cody-shared'\n\nimport { isValidTestFile } from './test-commands'\n\n// Language extension that uses '.test' suffix for test files\nconst TEST_FILE_DOT_SUFFIX_EXTENSIONS = new Set(['js', 'ts', 'jsx', 'tsx'])\n// language extension that uses '_test' suffix for test files\nconst TEST_FILE_DASH_SUFFIX_EXTENSIONS = new Set(['py', 'go'])\n// language extension that uses '_spec' suffix for most unit test files\nconst TEST_FILE_SPEC_SUFFIX_EXTENSIONS = new Set(['rb'])\n\n/**\n * NOTE: This is only being used as fallback when test files cannot be found in current workspace\n *\n * Generates a generic test file name and path for the given file\n * based on conventions for the file extension.\n * @param file - The original file URI\n * @returns The generated test file URI\n */\nexport function createDefaultTestFile(file: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(file)) {\n        return file\n    }\n\n    const extWithDot = uriExtname(file)\n    const fileName = uriBasename(file, extWithDot)\n    const ext = extWithDot.slice(1)\n\n    let testFileName = `${fileName}Test.${ext}`\n    if (TEST_FILE_DOT_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}.test.${ext}`\n    }\n    if (TEST_FILE_DASH_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_test.${ext}`\n    }\n    if (TEST_FILE_SPEC_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_spec.${ext}`\n    }\n\n    return Utils.joinPath(file, '..', testFileName)\n}\n\n/**\n * Converts a file URI to a corresponding test file URI using conventions based on file extension.\n *\n * If not a test file, generates a default test file name based on file extension conventions.\n *\n * If existing test file URI provided, attempts to match its naming convention.\n * Falls back to default test file name if naming does not follow conventions.\n * @param currentFile - Original file to convert\n * @param testFile - Optional existing test file to match naming with\n * @returns The converted test file\n */\nexport function convertFileUriToTestFileUri(currentFile: URI, testFile?: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(currentFile)) {\n        return currentFile\n    }\n\n    // If there is an existing test file, create the test file following its naming convention\n    if (testFile?.path && isValidTestFile(testFile)) {\n        const parsedCurrentFile = uriParseNameAndExtension(currentFile)\n        const parsedTestFile = uriParseNameAndExtension(testFile)\n        if (parsedCurrentFile.ext === parsedTestFile.ext) {\n            const testFileName = parsedTestFile.name\n            const index = testFileName.lastIndexOf('test') || testFileName.lastIndexOf('spec')\n            const endsWithCapitalTest = testFileName.endsWith('Test') || testFileName.endsWith('Spec')\n            // This checks if the existing test file has a non-alphanumeric character at the test character index\n            // e.g. \""_test\"", \"".test\"", \""test_\""\n            // This is because files with 'test' in the name are not always a test file, while\n            // file with non-alphanumeric character before 'test' are more likely to be test files\n            // e.g. \""testPath\"" or \""test-helper\"" are not likely test files\n            const hasVerifiedTestPath = index > -1 && !/^[\\da-z]$/i.test(testFileName[index - 1])\n            // If yes, generate a test file by replacing existing test file name with current file name\n            if (endsWithCapitalTest || hasVerifiedTestPath) {\n                // Remove everything after the test character index from the existing test file name\n                // then replace it with the current file name\n                // e.g. \""current_file\"" & \""existing_test\"" => \""current_file_test\""\n                const strippedTestFileName = testFileName.slice(0, index - 1)\n                const newTestFileName = testFileName.replace(\n                    strippedTestFileName,\n                    parsedCurrentFile.name\n                )\n                return Utils.joinPath(currentFile, '..', `${newTestFileName}${parsedCurrentFile.ext}`)\n            }\n        }\n    }\n\n    // else, generate a generic test file\n    return createDefaultTestFile(currentFile)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-input.test.ts:76-94"",""content"":""\n    // Submit a new chat question from the command menu.\n    await page.getByLabel(/Commands \\(/).hover()\n    await page.getByLabel(/Commands \\(/).click()\n    await page.waitForTimeout(100)\n    // HACK: The 'delay' command is used to make sure the response is streamed 400ms after\n    // the command is sent. This provides us with a small window to move the cursor\n    // from the new opened chat window back to the editor, before the chat has finished\n    // streaming its response.\n    await chatInput.fill('delay')\n    await chatInput.press('Enter')\n    await expect(chatInput).toBeFocused()\n\n    // Ensure equal-width columns so we can be sure the code we're about to click is in view (and is\n    // not out of the editor's scroll viewport). This became required due to new (undocumented)\n    // behavior in VS Code 1.88.0 where the Cody panel would take up ~80% of the width when it was\n    // focused, meaning that the buzz.ts editor tab would take up ~20% and the text we intend to\n    // click would be only partially visible, making the click() call fail.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/chat/chat.ts:25-59"",""content"":""    public chat(\n        messages: Message[],\n        params: Partial<ChatParameters> & Pick<ChatParameters, 'maxTokensToSample'>,\n        abortSignal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        const authStatus = this.getAuthStatus()\n        const useApiV1 = authStatus.codyApiVersion >= 1 && params.model?.includes('claude-3')\n        const isLastMessageFromHuman = messages.length > 0 && messages.at(-1)!.speaker === 'human'\n\n        const augmentedMessages =\n            params?.model?.startsWith('fireworks/') || useApiV1\n                ? sanitizeMessages(messages)\n                : isLastMessageFromHuman\n                  ? messages.concat([{ speaker: 'assistant' }])\n                  : messages\n\n        // We only want to send up the speaker and prompt text, regardless of whatever other fields\n        // might be on the messages objects (`file`, `displayText`, `contextFiles`, etc.).\n        const messagesToSend = augmentedMessages.map(({ speaker, text }) => ({\n            text,\n            speaker,\n        }))\n\n        const completionParams = {\n            ...DEFAULT_CHAT_COMPLETION_PARAMETERS,\n            ...params,\n            messages: messagesToSend,\n        }\n\n        return this.completions.stream(\n            completionParams,\n            useApiV1 ? authStatus.codyApiVersion : 0,\n            abortSignal\n        )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:165-184"",""content"":""\n        // Reuse existing \""New Chat\"" panel if there is an empty one\n        const emptyNewChatProvider = this.panelProviders.find(p => p.webviewPanel?.title === 'New Chat')\n        if (\n            !this.options.config.isRunningInsideAgent && // Don't reuse panels in the agent\n            !chatID &&\n            !panel &&\n            this.panelProviders.length &&\n            emptyNewChatProvider\n        ) {\n            emptyNewChatProvider.webviewPanel?.reveal()\n            this.activePanelProvider = emptyNewChatProvider\n            this.options.contextProvider.webview = emptyNewChatProvider.webview\n            void this.selectTreeItem(emptyNewChatProvider.sessionID)\n            return emptyNewChatProvider\n        }\n\n        // Get the view column of the current active chat panel so that we can open a new one on top of it\n        const activePanelViewColumn = this.activePanelProvider?.webviewPanel?.viewColumn\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:798-813"",""content"":""### Fixed\n\n- Edit: Updated the fixup create task to just use the previous command text. [pull/1615](https://github.com/sourcegraph/cody/pull/1615)\n- Fixed an issue that would cause an aborted chat message to show an error \""Cody did not respond with any text\"". [pull/1668](https://github.com/sourcegraph/cody/pull/1668)\n- Chat: Opening files from the new chat panel will now show up beside the chat panel instead of on top of the chat panel. [pull/1677](https://github.com/sourcegraph/cody/pull/1677)\n- Chat: Prevented default events on certain key combos when chat box is focused. [pull/1690](https://github.com/sourcegraph/cody/pull/1690)\n- Command: Fixed an issue that opened a new chat window when running `/doc` and `/edit` commands from the command palette. [pull/1678](https://github.com/sourcegraph/cody/pull/1678)\n- Chat: Prevent sidebar from opening when switching editor chat panels. [pull/1691](https://github.com/sourcegraph/cody/pull/1691)\n- Chat: Prevent `\""command 'cody.chat'panel.new' not found\""` error when the new chat panel UI is disabled. [pull/1696](https://github.com/sourcegraph/cody/pull/1696)\n- Autocomplete: Improved the multiline completions truncation logic. [pull/1709](https://github.com/sourcegraph/cody/pull/1709)\n- Autocomplete: Fix an issue where typing as suggested causes the completion to behave unexpectedly. [pull/1701](https://github.com/sourcegraph/cody/pull/1701)\n- Chat: Forbid style tags in DOMPurify config to prevent code block rendering issues. [pull/1747](https://github.com/sourcegraph/cody/pull/1747)\n- Edit: Fix `selectedCode` and `problemCode` sometimes being added to the document after an edit. [pull/1765](https://github.com/sourcegraph/cody/pull/1765)\n- Edit: Fix the code lens containing options to diff, undo and retry being automatically dismissed for users who have `autoSave` enabled. [pull/1767](https://github.com/sourcegraph/cody/pull/1767)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:48-73"",""content"":""\n    // Submit a new message and check if both sessions are showing up in the sidebar\n    await chatInput.fill('Hola')\n    await chatInput.press('Enter')\n    await expect(holaTreeItem).toBeVisible()\n    await expect(heyTreeItem).toBeVisible()\n\n    // The panel name is now updated to the last submitted message\n    await expect(page.getByRole('tab', { name: 'Hola' })).toBeVisible()\n\n    // Click on the previous chat session to open the chat panel in editor\n    // Both chat panels should be visible as tabs in the editor\n    await page\n        .getByRole('treeitem', { name: 'Hey' })\n        .locator('div')\n        .filter({ hasText: 'Hey' })\n        .nth(3)\n        .click()\n    await expect(page.getByRole('tab', { name: 'Hey' })).toBeVisible()\n\n    // NOTE: Action buttons may only appear when we're hovering a chat.\n    // Deleting a chat should also close its associated chat panel\n    await heyTreeItem.hover()\n    await heyTreeItem.getByLabel('Delete Chat').hover()\n    await heyTreeItem.getByLabel('Delete Chat').click()\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,claude-3.5-sonnet,chat,question_025/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The logic for adding context by mentioning files with @ is implemented in several parts of the codebase:

1. In `cody_test/lib/shared/src/mentions/query.ts`, there's a `parseMentionQuery` function that handles parsing @-mention queries.

2. The `getFileContextFiles` function in `cody_test/vscode/src/editor/utils/editor-context.ts` is responsible for finding and returning file context based on user queries.

3. The `ContextItemMentionNode` class in `cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts` handles the creation and rendering of context item mentions in the UI.

4. The `getContextFileFromUri` function in `cody_test/vscode/src/commands/context/file-path.ts` retrieves context for a specific file URI.

5. The e2e tests in `cody_test/vscode/test/e2e/chat-atFile.test.ts` cover various behaviors of the @-mention feature for files.

These components work together to implement the file mentioning functionality, from parsing user input to retrieving and displaying the relevant file context in the chat interface.",Where is the logic for adding context by mentioning files with @?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:108-123"",""content"":""- [ ] Verify that Cody adds documentation above the function that contains your cursor.\n\n### Smell\n\n- [ ] Verify that the option to run the `Find Code Smells` command is available in the following locations:\n  - [ ] Sidebar `Find Code Smells`\n  - [ ] Context (right-click) menu `Cody > Find Code Smells`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Find Code Smells`\n  - [ ] Cody Command Menu (option+c, `Find Code Smells`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Find Code Smells` command.\n- [ ] Verify that Cody provides suggestion for how to improve the selected code in a new chat window.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Find Code Smells` command again\n- [ ] Verify that Cody provides suggestion for how to improve the function that contains your cursor in a new chat window.\n- [ ] Verify that the chat executed by running the command is added to the sidebar under `Chats`.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItem.kt:22-53"",""content"":""\ndata class ContextItemFile(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: file\n) : ContextItem() {\n\n  enum class TypeEnum {\n    @SerializedName(\""file\"") File,\n  }\n}\n\ndata class ContextItemSymbol(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: symbol\n  val symbolName: String? = null,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-atFile.test.ts:352-373"",""content"":""\n    // @-file with the correct line range shows up in the chat view and it opens on click\n    const contextCell = getContextCell(chatPanelFrame)\n    await expectContextCellCounts(contextCell, { files: 1 })\n    await contextCell.hover()\n    await contextCell.click()\n    const chatContext = chatPanelFrame.locator('details').last()\n    await chatContext.getByRole('link', { name: 'buzz.ts:1-15' }).hover()\n    await chatContext.getByRole('link', { name: 'buzz.ts:1-15' }).click()\n    const previewTab = page.getByRole('tab', { name: /buzz.ts, preview, Editor Group/ })\n    await previewTab.hover()\n    await expect(previewTab).toBeVisible()\n})\n\ntest.extend<ExpectedEvents>({\n    expectedEvents: [\n        'CodyVSCodeExtension:addChatContext:clicked',\n        'CodyVSCodeExtension:addChatContext:clicked',\n    ],\n})('add selected code as @-mention with \""Cody Chat: Add context\""', async ({ page, sidebar }) => {\n    await sidebarSignin(page, sidebar)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:59-73"",""content"":""function convertContextItemMentionElement(domNode: HTMLElement): DOMConversionOutput | null {\n    const data = domNode.getAttribute(DOM_DATA_ATTR)\n    if (data !== null) {\n        try {\n            const contextItem: SerializedContextItem = JSON.parse(data)\n            const node = $createContextItemMentionNode(contextItem)\n            return { node }\n        } catch (error) {\n            console.error(error)\n            return null\n        }\n    }\n\n    return null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/open-tabs.ts:0-42"",""content"":""import { type ContextItem, logError, wrapInActiveSpan } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { getContextFileFromUri } from './file-path'\n\n/**\n * Gets context files from the currently open tabs.\n *\n * Iterates through all open tabs, filters to only file tabs in the workspace,\n * and then creates ContextFile objects for each valid tab.\n */\nexport async function getContextFileFromTabs(): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.openTabs', async span => {\n        const contextFiles: ContextItem[] = []\n        try {\n            // Get open tabs from the current editor\n            const tabGroups = vscode.window.tabGroups.all\n            const openTabs = tabGroups.flatMap(group =>\n                group.tabs.map(tab => tab.input)\n            ) as vscode.TabInputText[]\n\n            for (const tab of openTabs) {\n                // Skip non-file items\n                if (tab?.uri?.scheme !== 'file') {\n                    continue\n                }\n\n                // Skip files that are not from the current workspace\n                if (!vscode.workspace.getWorkspaceFolder(tab?.uri)) {\n                    continue\n                }\n\n                // Create context message\n                contextFiles.push(...(await getContextFileFromUri(tab?.uri)))\n            }\n        } catch (error) {\n            logError('getContextFileFromTabs', 'failed', { verbose: error })\n        }\n        // Returns what we have so far\n        return contextFiles\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:190-199"",""content"":""export function $createContextItemMentionNode(\n    contextItem: ContextItem | SerializedContextItem\n): ContextItemMentionNode {\n    const node = new ContextItemMentionNode(contextItem)\n    node.setMode('token').toggleDirectionless()\n    contextItem.type === 'file' &&\n        contextItem.isTooLarge &&\n        node.setStyle('color: var(--vscode-list-errorForeground)')\n    return $applyNodeReplacement(node)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:60-86"",""content"":""    // Shell command to run to get context\n    command?: string\n    // The relative path of a file within your workspace root\n    filePath?: string\n    // The relative path of a directory within your workspace root\n    directoryPath?: string\n\n    // NOTE: Currently not supported\n    // Codebase context from current codebase\n    codebase?: boolean\n}\n\nexport type CodyCommandType = CustomCommandType | DefaultCommandType | 'recently used'\n\nexport enum CustomCommandType {\n    Workspace = 'workspace',\n    User = 'user',\n}\n\ntype DefaultCommandType = 'default' | 'experimental'\n\nexport interface TerminalOutputArguments {\n    name: string\n    selection?: string\n    creationOptions?: { shellPath?: string; shellArgs?: string[] }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:145-170"",""content"":""    // from).\n    const uriPath =\n        isWindows && uri.scheme === 'file'\n            ? uri.path.slice(0, 2).toUpperCase() + uri.path.slice(2)\n            : uri.path\n    const prefixPath =\n        isWindows && prefix.scheme === 'file'\n            ? prefix.path.slice(0, 2).toUpperCase() + prefix.path.slice(2)\n            : prefix.path\n    return (\n        uri.scheme === prefix.scheme &&\n        (uri.authority ?? '') === (prefix.authority ?? '') && // different URI impls treat empty different\n        (uriPath === prefixPath ||\n            uriPath.startsWith(prefixPath.endsWith('/') ? prefixPath : `${prefixPath}/`) ||\n            (prefixPath.endsWith('/') && uriPath === prefixPath.slice(0, -1)))\n    )\n}\n\n/** The information necessary for {@link displayPath} to compute a display path. */\nexport interface DisplayPathEnvInfo {\n    workspaceFolders: URI[]\n    isWindows: boolean\n}\n\nlet envInfo: DisplayPathEnvInfo | null = null\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/unit-test-file.ts:18-51"",""content"":""export async function getContextFilesForUnitTestCommand(file: URI): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.test', async span => {\n        const contextFiles: ContextItem[] = []\n\n        // exclude any files in the path with e2e, integration, node_modules, or dist\n        const excludePattern = '**/*{e2e,integration,node_modules,dist}*/**'\n        // To search for files in the current directory only\n        const searchCurrentDirectoryOnly = true\n        // The max number of files to search for in each workspace search\n        const max = 10\n\n        // Search for a test file that has the same file name first\n        const sameNameTestPattern = getSearchPatternForTestFiles(file, !searchCurrentDirectoryOnly, true)\n        const testWithSameName = await getWorkspaceFilesContext(sameNameTestPattern, excludePattern, 1)\n\n        // Search for test files in the current directory\n        const currentDirPattern = getSearchPatternForTestFiles(file, searchCurrentDirectoryOnly)\n        const currentDirContext = await getWorkspaceFilesContext(currentDirPattern, excludePattern, max)\n\n        contextFiles.push(...testWithSameName, ...currentDirContext)\n\n        // If no test files found in the current directory, search the entire workspace\n        if (!contextFiles.length) {\n            // Will try to look for half the max number of files in the workspace for faster results\n            const wsTestPattern = getSearchPatternForTestFiles(file, !searchCurrentDirectoryOnly)\n            const codebaseFiles = await getWorkspaceFilesContext(wsTestPattern, excludePattern, max / 2)\n\n            contextFiles.push(...codebaseFiles)\n        }\n\n        // Return valid test files only\n        return contextFiles.filter(f => isValidTestFile(f.uri))\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-atFile.test.md:0-20"",""content"":""# Expected behaviors for the @-mention feature\n\nCurrently covered by the e2e tests in `chat-atFile.test.ts`:\n\n- Typing '@' in the chat input shows a search box for files. Typing '@#' shows one for symbols instead.\n- Searching for a non-existent file or symbol shows a \""No files/symbols found\"" message.\n- Search only matches files in the relative visible path, not full absolute paths.\n- Search includes dotfiles after \"".\"".\n- Searches match with either forward or backslashes.\n- Can click a file result fom the box to insert it into the chat input.\n- Inserted file context persists when resending a message from history.\n- Can use the Up and Down arrow keys to navigate through suggested file results.\n- Can use the ESC key to close the file selector without modifying the input text.\n- Pressing tab after a full filename inserts the @-mention with a trailing space.\n- Pressing tab after a partial filename completes to an existing @-mention.\n- Can @-mention files mid-sentence.\n- Don't show the file selector on @-queries that ends with non-alphanumeric char (e.g. @foo/bar?) without results.\n- Input box is cleared on submit, with @-mentions removed and selector closed.\n- Explicitly @-mentioned files show up in the file context list below the message.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:77-173"",""content"":""export class ContextItemMentionNode extends TextNode {\n    static getType(): string {\n        return 'contextItemMention'\n    }\n\n    static clone(node: ContextItemMentionNode): ContextItemMentionNode {\n        return new ContextItemMentionNode(node.contextItem, node.__text, node.__key)\n    }\n    static importJSON(serializedNode: SerializedContextItemMentionNode): ContextItemMentionNode {\n        const node = $createContextItemMentionNode(serializedNode.contextItem)\n        node.setTextContent(serializedNode.text)\n        node.setFormat(serializedNode.format)\n        node.setDetail(serializedNode.detail)\n        node.setMode(serializedNode.mode)\n        node.setStyle(serializedNode.style)\n        return node\n    }\n\n    private contextItem: SerializedContextItem\n\n    constructor(\n        contextItemWithAllFields: ContextItem | SerializedContextItem,\n        text?: string,\n        key?: NodeKey\n    ) {\n        // Make sure we only bring over the fields on the context item that we need, or else we\n        // could accidentally include tons of data (including the entire contents of files).\n        const contextItem = serializeContextItem(contextItemWithAllFields)\n\n        super(text ?? contextItemMentionNodeDisplayText(contextItem), key)\n\n        this.contextItem = contextItem\n    }\n\n    exportJSON(): SerializedContextItemMentionNode {\n        return {\n            ...super.exportJSON(),\n            contextItem: this.contextItem,\n            type: ContextItemMentionNode.getType(),\n            version: 1,\n        }\n    }\n\n    private static CLASS_NAMES = `context-item-mention-node ${styles.contextItemMentionNode}`\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config)\n        element.className = ContextItemMentionNode.CLASS_NAMES\n        return element\n    }\n\n    exportDOM(): DOMExportOutput {\n        const element = document.createElement('span')\n        element.setAttribute(DOM_DATA_ATTR, JSON.stringify(this.contextItem))\n        element.className = ContextItemMentionNode.CLASS_NAMES\n\n        const link = document.createElement('a')\n        const { href, target } = webviewOpenURIForContextItem({\n            uri: URI.parse(this.contextItem.uri),\n            range: this.contextItem.range,\n        })\n        link.href = href\n        if (target) {\n            link.target = target\n        }\n        link.textContent = this.__text\n        element.appendChild(link)\n\n        return { element }\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            span: (domNode: HTMLElement) => {\n                if (!domNode.hasAttribute(DOM_DATA_ATTR)) {\n                    return null\n                }\n                return {\n                    conversion: convertContextItemMentionElement,\n                    priority: 1,\n                }\n            },\n        }\n    }\n\n    isTextEntity(): true {\n        return true\n    }\n\n    canInsertTextBefore(): boolean {\n        return false\n    }\n\n    canInsertTextAfter(): boolean {\n        return false\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/query.ts:64-94"",""content"":""\n/**\n * The location and content of a mention in free-form user text input.\n */\nexport interface MentionTrigger {\n    /** The number of characters from the start of the text to the mention trigger (`@`). */\n    leadOffset: number\n\n    /**\n     * The string that is used to query for the context item to mention (to be passed to\n     * {@link parseMentionQuery}).\n     */\n    matchingString: string\n\n    /**\n     * Equal to `@` + {@link matchingString}. The entire string that should be replaced with the\n     * context item when the at-mention reference is chosen.\n     */\n    replaceableString: string\n}\n\n/**\n * Scans free-form user text input (in a chat message editor, for example) for possible mentions\n * with the `@` trigger character.\n *\n * The {@link textBeforeCursor} is all of the text in the input field before the text insertion\n * point cursor. For example, if the input field looks like `hello\n * @foo█bar`, then {@link textBeforeCursor} should be `hello @foo`.\n */\nexport function scanForMentionTriggerInUserTextInput(textBeforeCursor: string): MentionTrigger | null {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/cody-ignore.test.ts:46-69"",""content"":""\n    // Start new chat\n    const [chatPanel, chatInput] = await createEmptyChatPanel(page)\n\n    /* TEST: Chat Context - Ignored file do not show up with context */\n    await chatInput.focus()\n    await chatInput.fill('Ignore me')\n    await chatInput.press('Enter')\n    // Assistant should response to your chat question,\n    // but the current file is excluded (ignoredByCody.css) and not on the context list\n    await expect(chatPanel.getByText('hello from the assistant')).toBeVisible()\n    const contextCell = getContextCell(chatPanel)\n    await expect(contextCell).not.toBeVisible()\n\n    /* TEST: At-file - Ignored file does not show up as context when using @-mention */\n    await chatInput.focus()\n    await chatInput.clear()\n    await chatInput.fill('@ignoredByCody')\n    await expect(chatPanel.getByRole('heading', { name: 'No files found' })).toBeVisible()\n    await chatInput.clear()\n    await chatInput.fill('@ignore')\n    await expect(\n        chatPanel.getByRole('option', { name: withPlatformSlashes('ignore .cody') })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/utils/editor-context.ts:49-112"",""content"":""export async function getFileContextFiles(\n    query: string,\n    maxResults: number\n): Promise<ContextItemFile[]> {\n    if (!query.trim()) {\n        return []\n    }\n\n    const uris = await throttledFindFiles()\n    if (!uris) {\n        return []\n    }\n\n    if (isWindows()) {\n        // On Windows, if the user has typed forward slashes, map them to backslashes before\n        // running the search so they match the real paths.\n        query = query.replaceAll('/', '\\\\')\n    }\n\n    // Add on the relative URIs for search, so we only search the visible part\n    // of the path and not the full FS path.\n    const urisWithRelative = uris.map(uri => ({ uri, relative: displayPath(uri) }))\n    const results = fuzzysort.go(query, urisWithRelative, {\n        key: 'relative',\n        limit: maxResults,\n        // We add a threshold for performance as per fuzzysort’s\n        // recommendations. Testing with sg/sg path strings, somewhere over 10k\n        // threshold is where it seems to return results that make no sense. VS\n        // Code’s own fuzzy finder seems to cap out much higher. To be safer and\n        // to account for longer paths from even deeper source trees we use\n        // 100k. We may want to revisit this number if we get reports of missing\n        // file results from very large repos.\n        threshold: -100000,\n    })\n\n    // Apply a penalty for segments that are in the low scoring list.\n    const adjustedResults = [...results].map(result => {\n        const segments = result.obj.uri.path.split(/[\\/\\\\]/).filter(segment => segment !== '')\n        for (const lowScoringPathSegment of lowScoringPathSegments) {\n            if (segments.includes(lowScoringPathSegment) && !query.includes(lowScoringPathSegment)) {\n                return {\n                    ...result,\n                    score: result.score - 100000,\n                }\n            }\n        }\n        return result\n    })\n    // fuzzysort can return results in different order for the same query if\n    // they have the same score :( So we do this hacky post-limit sorting (first\n    // by score, then by path) to ensure the order stays the same.\n    const sortedResults = adjustedResults\n        .sort((a, b) => {\n            return (\n                b.score - a.score ||\n                new Intl.Collator(undefined, { numeric: true }).compare(a.obj.uri.path, b.obj.uri.path)\n            )\n        })\n        .flatMap(result => createContextFileFromUri(result.obj.uri, ContextItemSource.User, 'file'))\n\n    // TODO(toolmantim): Add fuzzysort.highlight data to the result so we can show it in the UI\n\n    return await filterContextItemFiles(sortedResults)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/fixtures.ts:52-78"",""content"":""                        },\n                        {\n                            detail: 1,\n                            format: 0,\n                            mode: 'token',\n                            style: '',\n                            text: '@dir/dir/file-a-1.py',\n                            type: 'contextItemMention',\n                            version: 1,\n                            contextItem: {\n                                type: 'file',\n                                uri: 'file:///dir/dir/file-a-1.py',\n                            },\n                        },\n                        {\n                            detail: 0,\n                            format: 0,\n                            mode: 'normal',\n                            style: '',\n                            text: ' do? Also use ',\n                            type: 'text',\n                            version: 1,\n                        },\n                        {\n                            detail: 1,\n                            format: 0,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/file-path.ts:13-41"",""content"":""export async function getContextFileFromUri(file: URI, range?: vscode.Range): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.filePath', async span => {\n        try {\n            const doc = await vscode.workspace.openTextDocument(file)\n            const content = doc?.getText(range).trim()\n            if (!content) {\n                throw new Error('No file content')\n            }\n\n            const startLine = range?.start?.line ?? 0\n            range = new vscode.Range(startLine, 0, startLine + content.split('\\n').length, 0)\n            const size = TokenCounter.countTokens(content)\n\n            return [\n                {\n                    type: 'file',\n                    content,\n                    uri: file,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                },\n            ] satisfies ContextItem[]\n        } catch (error) {\n            logError('getContextFileFromUri', 'failed', { verbose: error })\n            return []\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/utils.ts:0-30"",""content"":""import { type ContextItem, displayLineRange, displayPath } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport {\n    QUICK_PICK_ITEM_CHECKED_PREFIX,\n    QUICK_PICK_ITEM_EMPTY_INDENT_PREFIX,\n} from '../../chat/context/constants'\n\n/**\n * Removes the string after the last '@' character in the given string.\n * Returns the original string if '@' is not found.\n */\nexport function removeAfterLastAt(str: string): string {\n    const lastIndex = str.lastIndexOf('@')\n    if (lastIndex === -1) {\n        // Return the original string if \""@\"" is not found\n        return str\n    }\n    return str.slice(0, lastIndex)\n}\n\n/**\n * Returns a string representation of the given ContextItem for use in UI labels.\n * Includes the file path and an optional range or symbol specifier.\n */\nexport function getLabelForContextItem(item: ContextItem): string {\n    const isFileType = item.type === 'file'\n    if (isFileType && item.title) {\n        return `Add context from: ${item.title}`\n    }\n    const rangeLabel = item.range ? `:${displayLineRange(item.range)}` : ''\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/current-file.ts:10-48"",""content"":""export async function getContextFileFromCurrentFile(): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.file', async span => {\n        try {\n            const editor = getEditor()\n            const document = editor?.active?.document\n            if (!document) {\n                throw new Error('No active editor')\n            }\n\n            const selection = new vscode.Selection(\n                0,\n                0,\n                document.lineCount - 1,\n                document.lineAt(document.lineCount - 1).text.length\n            )\n\n            const content = document.getText(selection)\n            const size = TokenCounter.countTokens(content)\n\n            if (!content.trim()) {\n                throw new Error('No content')\n            }\n\n            return [\n                {\n                    type: 'file',\n                    uri: document.uri,\n                    content,\n                    source: ContextItemSource.Editor,\n                    range: selection,\n                    size,\n                } satisfies ContextItem,\n            ]\n        } catch (error) {\n            logError('getContextFileFromCurrentFile', 'failed', { verbose: error })\n            return []\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/query.ts:0-26"",""content"":""/**\n * The parsed representation of a user's (partial or complete) input of an @-mention query.\n */\nexport interface MentionQuery {\n    /**\n     * The type of context item to search for.\n     */\n    type: 'file' | 'symbol' | 'url' | 'empty'\n\n    /**\n     * The user's text input, to be interpreted as a fuzzy-matched query. It is stripped of any\n     * prefix characters that indicate the {@link MentionQuery.type}, such as `#` for symbols.\n     */\n    text: string\n}\n\n/**\n * Parse an @-mention query. The {@link query} value is whatever the UI determines is the query\n * based on the current text input; it is not the full value of a message that may or may not\n * contain an @-mention.\n *\n * The {@link query} MUST be stripped of the trigger character (usually `@`). The only valid case\n * where {@link query} may begin with `@` is if the user is searching for context items that contain\n * `@`, such as if the user typed `@@foo` to mention a file that is literally named `@foo.js`.\n */\nexport function parseMentionQuery(query: string): MentionQuery {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/create-context-file.ts:0-23"",""content"":""import { type ContextItem, ContextItemSource, TokenCounter } from '@sourcegraph/cody-shared'\n\nimport * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\nexport async function createContextFile(file: URI, content: string): Promise<ContextItem | undefined> {\n    try {\n        const range = new vscode.Range(0, 0, content.split('\\n').length, 0)\n        const size = TokenCounter.countTokens(content)\n\n        return {\n            type: 'file',\n            uri: file,\n            content,\n            source: ContextItemSource.Editor,\n            range,\n            size,\n        } satisfies ContextItem\n    } catch (error) {\n        console.error(error)\n    }\n    return undefined\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/unit-test-case.ts:8-47"",""content"":""export async function getContextFilesForAddingUnitTestCases(testFile: URI): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.testCase', async span => {\n        // Get the context from the current directory\n        // and then find the original file of the test file in the returned context\n        // If the original file is found, return it\n        // e.g. if the test file is src/foo/bar.spec.ts, look for src/foo/bar.ts\n        const directoryContext = await getContextFileFromDirectory()\n        const originalFileContext = directoryContext.find(f => isTestFileForOriginal(f.uri, testFile))\n        if (originalFileContext) {\n            return [originalFileContext]\n        }\n\n        // TODO (bee) improves context search\n        const contextFiles: ContextItem[] = []\n        // exclude any files in the path with e2e, integration, node_modules, or dist\n        const excludePattern = '**/*{e2e,integration,node_modules,dist}*/**'\n        // To search for files in the current directory only\n        const searchInCurrentDirectoryOnly = true\n        // The max number of files to search for in each workspace search\n        const max = 10\n\n        // Search for test files in the current directory first\n        const curerntDirPattern = getSearchPatternForTestFiles(testFile, searchInCurrentDirectoryOnly)\n        const currentDirContext = await getWorkspaceFilesContext(curerntDirPattern, excludePattern, max)\n\n        contextFiles.push(...currentDirContext)\n\n        // If no test files found in the current directory, search the entire workspace\n        if (!contextFiles.length) {\n            const wsTestPattern = getSearchPatternForTestFiles(testFile, !searchInCurrentDirectoryOnly)\n            // Will try to look for half the max number of files in the workspace for faster results\n            const codebaseFiles = await getWorkspaceFilesContext(wsTestPattern, excludePattern, max / 2)\n\n            contextFiles.push(...codebaseFiles)\n        }\n\n        // Return valid test files only\n        return contextFiles.filter(f => isValidTestFile(f.uri))\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/fixtures.ts:74-101"",""content"":""    explainCode2: [\n        {\n            speaker: 'human',\n            text: ps`What does @#Symbol1 in @dir/dir/file-a-1.py do? Also use @README.md:2-8.`,\n            editorState: FILE_MENTION_EDITOR_STATE_FIXTURE,\n            contextFiles: [\n                {\n                    type: 'symbol',\n                    uri: URI.file('dir/dir/file-a-1.py'),\n                    symbolName: 'Symbol1',\n                    kind: 'function',\n                    range: { start: { line: 1, character: 0 }, end: { line: 8, character: 0 } },\n                },\n                { type: 'file', uri: URI.file('dir/dir/file-a-1.py') },\n                {\n                    type: 'file',\n                    uri: URI.file('README.md'),\n                    range: { start: { line: 1, character: 0 }, end: { line: 8, character: 0 } },\n                },\n            ],\n        },\n        {\n            speaker: 'assistant',\n            text: ps`This code is very cool.`,\n        },\n    ],\n}\n""}]",Find logic,,,0,,1,false,,,,,,,,,,,,,,,,
