 question: Where do we determine whether to use enhanced context for chat?
# CHAT
# CHAT_QUESTION Where do we determine whether to use enhanced context for chat?

# CHAT_REPLY The decision to use enhanced context for chat is determined in the `getEnhancedContext` function in the file `cody_test/vscode/src/chat/chat-view/context.ts`. This function checks the `strategy` parameter, which is of type `ConfigurationUseContext`. If the strategy is not set to 'none', it will proceed to retrieve enhanced context from various sources such as embeddings, remote search, and local search (symf).
# CHAT_REPLY 
# CHAT_REPLY Additionally, the `useEnhancedContextEnabled` hook in `cody_test/vscode/webviews/chat/EnhancedContext.tsx` is used to determine if enhanced context is enabled in the chat UI.
# CHAT_REPLY 
# CHAT_REPLY The `EnhancedContextSettings` component in `cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx` also plays a role in managing the enhanced context settings, allowing users to toggle this feature.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/can-use-partial-completion.ts:0-41","content":"import type { TextDocument } from 'vscode'\n\nimport type { DocumentContext } from '@sourcegraph/cody-shared'\nimport { hasCompleteFirstLine } from './text-processing'\nimport { parseAndTruncateCompletion } from './text-processing/parse-and-truncate-completion'\nimport type { InlineCompletionItemWithAnalytics } from './text-processing/process-inline-completions'\n\ninterface CanUsePartialCompletionParams {\n    document: TextDocument\n    docContext: DocumentContext\n}\n\n/**\n * Evaluates a partial completion response and returns it when we can already use it. This is used\n * to terminate any streaming responses where we can get a token-by-token access to the result and\n * want to terminate as soon as stop conditions are triggered.\n *\n * Right now this handles two cases:\n *  1. When a single line completion is requested, it terminates after the first full line was\n *     received.\n *  2. For a multi-line completion, it terminates when the completion will be truncated based on the\n *     multi-line indentation logic.\n */\nexport function canUsePartialCompletion(\n    partialResponse: string,\n    params: CanUsePartialCompletionParams\n): InlineCompletionItemWithAnalytics | null {\n    const { docContext } = params\n\n    if (!hasCompleteFirstLine(partialResponse)) {\n        return null\n    }\n\n    const item = parseAndTruncateCompletion(partialResponse, params)\n\n    if (docContext.multilineTrigger) {\n        return (item.lineTruncatedCount || 0) > 0 ? item : null\n    }\n\n    return item.insertText.trim() === '' ? null : item\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/counter.ts:26-43","content":"     * Indicates whether the Chat and User-Context share the same token budget.\n     * - If true, all types of messages share the same token budget with Chat.\n     * - If false (Feature Flag required), the User-Context will has a separated budget.\n     * NOTE: Used in remainingTokens for calculating the remaining token budget for each budget type.\n     */\n    private shareChatAndUserBudget = true\n\n    constructor(contextWindow: ModelContextWindow) {\n        // If there is no context window reserved for context.user,\n        // context will share the same token budget with chat.\n        this.shareChatAndUserBudget = !contextWindow.context?.user\n        this.maxChatTokens = contextWindow.input\n        this.maxContextTokens = {\n            user: contextWindow.context?.user ?? contextWindow.input,\n            enhanced: Math.floor(contextWindow.input * ENHANCED_CONTEXT_ALLOCATION),\n        }\n    }\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:51-53","content":"function useChatContextClient(): ChatContextClient {\n    return useContext(ChatContextClientContext)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/active-editor.ts:0-26","content":"import * as vscode from 'vscode'\n\nimport { isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\n/**\n * Interface for tracking the last active text editor that is not a webview panel for\n * the new Chat Panel UI.\n *\n * active: The current valid active/supported text editor instance.\n * ignored: Whether the active editor is ignored by Cody or not.\n */\ninterface LastActiveTextEditor {\n    active?: vscode.TextEditor\n    ignored?: boolean\n}\n\n/**\n * This returns the current active text editor instance if available,\n * along with a boolean indicating if the text editor is on the Cody ignored list.\n * Returns undefined if no editor is active.\n *\n * NOTE: ALL USERS of chat interface in VS Code should use this to get the correct Active Editor instead of using\n * 'vscode.window.activeTextEditor' as this handles cases where the activeTextEditor API will always return\n * 'undefined' when user is focused on the webview chat panel.\n *\n * NOTE: Users that operate within an actual text editor (non-webview panels) do not need to use this API as calling\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:56-108","content":"export function useChatContextItems(query: string | null): ContextItem[] | undefined {\n    const chatContextClient = useChatContextClient()\n    const [results, setResults] = useState<ContextItem[]>()\n    // biome-ignore lint/correctness/useExhaustiveDependencies: we only want to run this when query changes.\n    useEffect(() => {\n        // An empty query is a valid query that we use to get open tabs context,\n        // while a null query means this is not an at-mention query.\n        if (query === null) {\n            setResults(undefined)\n            return\n        }\n\n        // If the query ends with a colon, we will reuse current results but remove the range.\n        if (query.endsWith(':')) {\n            const selected = results?.find(r => displayPath(r.uri) === query.slice(0, -1))\n            setResults(\n                selected\n                    ? [{ ...selected, range: undefined }]\n                    : results?.map(r => ({ ...r, range: undefined }))\n            )\n            return\n        }\n\n        // If user is typing a line range, fetch new chat context items only if there are no results\n        if (results?.length && RANGE_MATCHES_REGEXP.test(query) && !LINE_RANGE_REGEXP.test(query)) {\n            return\n        }\n\n        // Track if the query changed since this request was sent (which would make our results\n        // no longer valid).\n        let invalidated = false\n\n        if (chatContextClient) {\n            chatContextClient\n                .getChatContextItems(query)\n                .then(mentions => {\n                    if (invalidated) {\n                        return\n                    }\n                    setResults(mentions)\n                })\n                .catch(error => {\n                    setResults(undefined)\n                    console.error(error)\n                })\n        }\n\n        return () => {\n            invalidated = true\n        }\n    }, [query])\n    return results\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:98-116","content":"            }\n            const enhancedContext = prevContext.filter(c => c.source !== 'user')\n            if (promptBuilder.tryAddContext('enhanced', enhancedContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior enhanced context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n            }\n\n            // Add additional context from current editor or broader search when enhanced context is enabled\n            if (this.getEnhancedContext) {\n                const lastMessage = reverseTranscript[0]\n                if (!lastMessage?.text) {\n                    throw new Error('No last message or last message text was empty')\n                }\n                if (lastMessage.speaker === 'assistant') {\n                    throw new Error('Last message in prompt needs speaker \"human\", but was \"assistant\"')\n                }\n                const newEnhancedContext = await this.getEnhancedContext(lastMessage.text)\n                sortContextItems(newEnhancedContext)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/animal.ts:0-5","content":"interface Animal {\n    name: string;\n    age: number;\n}\n\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/local-embeddings.test.ts:140-164","content":"    await openFile(page, 'main.c')\n    await sidebarSignin(page, sidebar)\n    const chatFrame = await newChat(page)\n\n    const enableEmbeddingsButton = chatFrame.getByText('Enable Embeddings')\n    // This may take a while, we download and start cody-engine\n    await expect(enableEmbeddingsButton).toBeVisible({ timeout: 60000 })\n    await enableEmbeddingsButton.click()\n\n    await expect(chatFrame.getByText('Embeddings — Indexed')).toBeVisible({\n        timeout: 30000,\n    })\n\n    // Search the embeddings. This test uses the \"stub\" embedding model, which\n    // is deterministic, but the searches are not semantic.\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    await chatInput.fill('hello world')\n    await chatInput.press('Enter')\n    const contextCell = getContextCell(chatFrame)\n    await expectContextCellCounts(contextCell, {\n        files: 2,\n        timeout: 10000,\n    })\n})\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/squirrel.ts:0-11","content":"interface CodeIntelligence {\n    symbols: string[]\n}\n\n/**\n * Squirrel is a code intelligence API.\n */\ninterface Squirrel {\n    symbolInformation(file: string): CodeIntelligence\n}\n\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:32-64","content":"    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n}\nexport async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/README.md:0-5","content":"# Cody Agent\n\nThe `@sourcegraph/cody-agent` package implements a JSON-RPC server to interact\nwith Cody via stdout/stdin. This package is intended to be used by\nnon-ECMAScript clients such as the JetBrains and NeoVim plugins.\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:682-694","content":"\n### Changed\n\n- Chat: Uses the new Chat UI by default. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Inline Chat is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Fixup Tree View is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Enhanced Context used to turn off automatically after the first chat. Now it stays enabled until you disable it. [pull/2069](https://github.com/sourcegraph/cody/pull/2069)\n- Chat: Reuse existing New Chat panel to prevent having multiple new chats open at once. [pull/2087](https://github.com/sourcegraph/cody/pull/2087)\n- Chat: Close the Enhanced Context popover on chat input focus. [pull/2091](https://github.com/sourcegraph/cody/pull/2091)\n- Chat: Show onboarding glowy dot guide until first time opening Enhanced Context. [pull/2097](https://github.com/sourcegraph/cody/pull/2097)\n- In 0.12, we simplified the sign-in process and removed the option to sign into\n  Cody App from VScode. If you were still signed in to Cody App, we invite you to\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:67-69","content":"function useEnhancedContextEventHandlers(): EnhancedContextEventHandlersT {\n    return React.useContext(EnhancedContextEventHandlers)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32","content":"\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:94-157","content":"async function getEnhancedContextFromRanker({\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    return wrapInActiveSpan('chat.enhancedContextRanker', async span => {\n        // Get all possible context items to rank\n        let searchContext = getVisibleEditorContext(editor)\n\n        const numResults = 50\n        const embeddingsContextItemsPromise = retrieveContextGracefully(\n            searchEmbeddingsLocal(providers.localEmbeddings, text, numResults),\n            'local-embeddings'\n        )\n\n        const modelSpecificEmbeddingsContextItemsPromise = contextRanking\n            ? retrieveContextGracefully(\n                  contextRanking.searchModelSpecificEmbeddings(text, numResults),\n                  'model-specific-embeddings'\n              )\n            : []\n\n        const precomputeQueryEmbeddingPromise = contextRanking?.precomputeContextRankingFeatures(text)\n\n        const localSearchContextItemsPromise = providers.symf\n            ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n            : []\n\n        const remoteSearchContextItemsPromise = providers.remoteSearch\n            ? await retrieveContextGracefully(\n                  searchRemote(providers.remoteSearch, text),\n                  'remote-search'\n              )\n            : []\n\n        const keywordContextItemsPromise = (async () => [\n            ...(await localSearchContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n        ])()\n\n        const [embeddingsContextItems, keywordContextItems, modelEmbeddingContextItems] =\n            await Promise.all([\n                embeddingsContextItemsPromise,\n                keywordContextItemsPromise,\n                modelSpecificEmbeddingsContextItemsPromise,\n                precomputeQueryEmbeddingPromise,\n            ])\n\n        searchContext = searchContext\n            .concat(keywordContextItems)\n            .concat(embeddingsContextItems)\n            .concat(modelEmbeddingContextItems)\n        const editorContext = await getPriorityContext(text, editor, searchContext)\n        const allContext = editorContext.concat(searchContext)\n        if (!contextRanking) {\n            return allContext\n        }\n        const rankedContext = wrapInActiveSpan('chat.enhancedContextRanker.reranking', () =>\n            contextRanking.rankContextItems(text, allContext)\n        )\n        return rankedContext\n    })\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121","content":"\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \"from\" the human. (In the future, this could be from \"system\" for\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:24-35","content":"interface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/context-settings.test.ts:24-43","content":"\n    // Opening the enhanced context settings should focus the checkbox for toggling it.\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n\n    // Enhanced context should be enabled by default.\n    await expect(enhancedContextCheckbox).toBeChecked()\n    await page.keyboard.press('Space') // Disable enhanced context\n    // The keyboard should toggle the checkbox, but not dismiss the popup.\n    await expect(enhancedContextCheckbox).not.toBeChecked()\n    await expect(enhancedContextCheckbox).toBeVisible()\n\n    // The popup should be dismiss-able with the keyboard.\n    await page.keyboard.press('Escape')\n    // Closing the enhanced context settings should close the dialog...\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    // ... and the focus is moved to the chat input on close.\n    const contextSettingsButton = chatFrame.getByTitle('Configure Enhanced Context')\n    await expect(contextSettingsButton.and(page.locator(':focus'))).not.toBeVisible()\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:36-92","content":"export async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n                      searchEmbeddingsLocal(providers.localEmbeddings, text),\n                      'local-embeddings'\n                  )\n                : []\n\n        //  Get search (symf or remote search) context if config is not set to 'embeddings' only\n        const remoteSearchContextItemsPromise =\n            providers.remoteSearch && strategy !== 'embeddings'\n                ? await retrieveContextGracefully(\n                      searchRemote(providers.remoteSearch, text),\n                      'remote-search'\n                  )\n                : []\n        const localSearchContextItemsPromise =\n            providers.symf && strategy !== 'embeddings'\n                ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n                : []\n\n        // Combine all context sources\n        const searchContext = [\n            ...(await embeddingsContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n            ...(await localSearchContextItemsPromise),\n        ]\n\n        const priorityContext = await getPriorityContext(text, editor, searchContext)\n        return priorityContext.concat(searchContext)\n    })\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88","content":"\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15","content":"export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287","content":"\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the “Chats” panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the “Chats” panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the “Chats” panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \"Enhanced Context\" icon next to the chat input.\n- [ ] Verify that \"Enhanced Context\" is enabled by default.\n\n### Consumer\n\nSet up steps:\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65","content":"function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:377-385","content":"- We now allocate no more than 60% of the overall LLM context window for enhanced context. This preserves more room for follow-up questions and context. [pull/2768](https://github.com/sourcegraph/cody/pull/2768)\n- Chat: Renamed the \"Restart Chat Session\" button to \"New Chat Session\". [pull/2786](https://github.com/sourcegraph/cody/pull/2786)\n- Removed the `cody.experimental.chatPredictions` setting. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Removed support for the `context.codebase` custom command property. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Autocomplete: Better cancellation of requests that are no longer relevant. [pull/2855](https://github.com/sourcegraph/cody/pull/2855)\n- Updated Enhanced Context popover copy and added a link to the docs. [pull/2864](https://github.com/sourcegraph/cody/pull/2864)\n- Include meta information about unit test files in Autocomplete analytics. [pull/2868](https://github.com/sourcegraph/cody/pull/2868)\n- Moved the Context Limit errors in chat into the deboug log output. [pull/2891](https://github.com/sourcegraph/cody/pull/2891)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.test.ts:0-150","content":"import { describe, expect, it } from 'vitest'\nimport * as vscode from 'vscode'\n\nimport type * as status from '@sourcegraph/cody-shared'\n\nimport { ContextStatusAggregator } from './enhanced-context-status'\n\nclass TestProvider implements status.ContextStatusProvider {\n    public emitter: vscode.EventEmitter<status.ContextStatusProvider> = new vscode.EventEmitter()\n\n    constructor(private status_: status.ContextGroup[] | undefined = undefined) {}\n\n    public onDidChangeStatus(\n        callback: (provider: status.ContextStatusProvider) => void\n    ): vscode.Disposable {\n        return this.emitter.event(callback)\n    }\n\n    public get status(): status.ContextGroup[] {\n        return (\n            this.status_ || [\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'embeddings',\n                            state: 'unconsented',\n                        },\n                    ],\n                },\n            ]\n        )\n    }\n    public set status(status: status.ContextGroup[]) {\n        this.status_ = status\n    }\n}\n\ndescribe('ContextStatusAggregator', () => {\n    it('should fire status changed when providers are added and pass through simple status', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => resolve(provider.status))\n        })\n        aggregator.addProvider(new TestProvider())\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                ],\n            },\n        ])\n        aggregator.dispose()\n    })\n    it('should fire aggregate status from multiple providers', async () => {\n        const aggregator = new ContextStatusAggregator()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        aggregator.addProvider(new TestProvider())\n        aggregator.addProvider(\n            new TestProvider([\n                {\n                    displayName: 'host.example/foo',\n                    providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n                },\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'search',\n                            type: 'remote',\n                            state: 'ready',\n                            id: 'quux',\n                            inclusion: 'manual',\n                        },\n                    ],\n                },\n            ])\n        )\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id: 'quux',\n                        inclusion: 'manual',\n                    },\n                ],\n            },\n            {\n                displayName: 'host.example/foo',\n                providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n            },\n        ])\n        // Not only does it aggregate status, it coalesces update events\n        expect(callbackCount).toBe(1)\n        aggregator.dispose()\n    })\n    it('should respond to child events by firing an event of its own', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const provider = new TestProvider()\n        aggregator.addProvider(provider)\n        // Skip the first update event.\n        await Promise.resolve()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        provider.status = [\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [{ kind: 'search', type: 'local', state: 'indexing' }],\n            },\n        ]\n        provider.emitter.fire(provider)\n\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'local',\n                        state: 'indexing',\n                    },\n                ],\n            },\n        ])\n        expect(callbackCount).toBe(1)\n    })\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:64-89","content":"\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.ts:0-158","content":"import * as vscode from 'vscode'\n\nimport type { ContextGroup, ContextStatusProvider } from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\n// Collects context status from a set of ContextStatusProviders and produces\n// a merged status view.\nexport class ContextStatusAggregator implements vscode.Disposable, ContextStatusProvider {\n    private static TAG = 'ContextStatusAggregator'\n    private disposables: Set<vscode.Disposable> = new Set()\n    private statusEmitter: vscode.EventEmitter<ContextStatusProvider> =\n        new vscode.EventEmitter<ContextStatusProvider>()\n    private providerStatusMap: Map<ContextStatusProvider, ContextGroup[] | 'needs-status'> | undefined =\n        new Map()\n\n    // Whether we have been notified of status changes, but are yet to pass that\n    // notification on. We do this to de-bounce updates from multiple status\n    // providers in one turn of the event loop.\n    private pendingPublish = false\n\n    // Disposes this ContextStatusAggregator.\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.providerStatusMap = undefined\n    }\n\n    // Adds a provider to this ContextStatusAggregator. The aggregator will\n    // subscribe to the provider and aggregate its updates into a merged status.\n    // To remove this provider, dispose of the returned disposable.\n    //\n    // If the provider is disposable, it should dispose of the registration in\n    // its dispose method. Otherwise this ContextStatusAggregator may continue\n    // to poll its status property, and show its status in the aggregate status.\n    public addProvider(provider: ContextStatusProvider): vscode.Disposable {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const disposable = provider.onDidChangeStatus(putativeProvider => {\n            if (provider !== putativeProvider) {\n                logDebug(\n                    ContextStatusAggregator.TAG,\n                    'got onDidChangeStatus event but passed mismatched provider'\n                )\n            }\n            this.providerDidChangeStatus(provider)\n        })\n        this.disposables.add(disposable)\n        this.providerStatusMap.set(provider, 'needs-status')\n        this.providerDidChangeStatus(provider)\n        return {\n            dispose: (): void => {\n                if (this.providerStatusMap) {\n                    this.providerStatusMap.delete(provider)\n                    this.disposables.delete(disposable)\n                    disposable.dispose()\n                    this.publishStatus()\n                }\n            },\n        }\n    }\n\n    // Records that the provider's state is dirty, and schedules an update.\n    private providerDidChangeStatus(provider: ContextStatusProvider): void {\n        if (this.providerStatusMap === undefined) {\n            // We have been disposed\n            return\n        }\n        if (!this.providerStatusMap.has(provider)) {\n            // The provider has been removed. This should not happen if the\n            // providers are following the dispose protocol.\n            return\n        }\n        // Record that we need to get provider status next update.\n        this.providerStatusMap.set(provider, 'needs-status')\n        // Schedule an update.\n        this.publishStatus()\n    }\n\n    // Aggregates and publishes status asynchronously. Multiple context status\n    // providers updating \"at once\" will be coalesced into one update.\n    private publishStatus(): void {\n        if (this.pendingPublish) {\n            // Coalesce multiple updates.\n            return\n        }\n        this.pendingPublish = true\n        void Promise.resolve().then(() => {\n            this.pendingPublish = false\n            this.statusEmitter.fire(this)\n        })\n    }\n\n    // ContextStatusProvider implementation of onDidChangeStatus. The\n    // ContextStatusAggregator can be stacked to combine per-workspace and\n    // per-chat context status.\n    public onDidChangeStatus(callback: (sender: ContextStatusProvider) => void): vscode.Disposable {\n        return this.statusEmitter.event(callback)\n    }\n\n    // Computes the merged context status. This may throw if any of the\n    // aggregated providers' status throw.\n    public get status(): ContextGroup[] {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const groupBy: { [name: string]: ContextGroup } = {}\n        // Iterate through provider status map entries\n        for (let [provider, status] of this.providerStatusMap.entries()) {\n            if (status === 'needs-status') {\n                // The provider's status is stale; poll it.\n                status = provider.status\n                if (this.providerStatusMap.get(provider) !== 'needs-status') {\n                    logDebug(\n                        ContextStatusAggregator.TAG,\n                        'ContextStatusProvider.status should only report status, not change state',\n                        provider\n                    )\n                }\n                // Deep clone the status object so providers can't continue to change it without notifying.\n                status = JSON.parse(JSON.stringify(status)) as ContextGroup[]\n                // Cache the status so we don't re-poll this provider unless it changes.\n                this.providerStatusMap.set(provider, status)\n            }\n\n            // Collect context groups by name\n            for (const group of status) {\n                if (group.displayName in groupBy) {\n                    // Merge the items in the group.\n                    groupBy[group.displayName].providers.push(...group.providers)\n                } else {\n                    // Create a new group for the merged result.\n                    groupBy[group.displayName] = {\n                        displayName: group.displayName,\n                        providers: [...group.providers],\n                    }\n                }\n            }\n        }\n        // Order sources within the groups by a canonical order\n        for (const groups of Object.values(groupBy)) {\n            // Sort by a fixed locale for consistency. The 'kind' key is not a\n            // localized UI label.\n            groups.providers.sort((a, b) => a.kind.localeCompare(b.kind, 'en-US'))\n        }\n        return [...Object.values(groupBy)]\n    }\n\n    // TODO: Create a publisher to push into the webview\n    // TODO: Hook in local embeddings\n    // TODO: Hook in cloud embeddings\n    // TODO: Hook in symf\n    // TODO: Hook in graph\n    // TODO: Hook in the Cody: building code index ... notification pusher's\n    // state\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/common.ts:50-74","content":"\n/**\n * Create and open a new chat panel, and close the enhanced context settings window.\n * Returns the chat panel frame locator.\n */\nexport async function createEmptyChatPanel(page: Page): Promise<[FrameLocator, Locator]> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    const chatFrame = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n    await page.keyboard.press('Escape')\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    return [chatFrame, chatInput]\n}\n\n/**\n * Gets the chat context cell. If {@link counts} is specified, then validates that the context\n * exactly matches the specified file and line counts.\n */\nexport function getContextCell(\n    chatPanel: FrameLocator,\n    counts?: { files: number; lines: number }\n): Locator {\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/EnhancedContext.tsx:4-6","content":"export function useEnhancedContextEnabled(): boolean {\n    return React.useContext(EnhancedContextEnabled)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40","content":"/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n"}]

 class: Find logic
