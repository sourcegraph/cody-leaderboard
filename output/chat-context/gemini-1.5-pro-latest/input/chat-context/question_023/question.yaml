 question: Where is the code that enforces the context length limit?
# CHAT
# CHAT_QUESTION Where is the code that enforces the context length limit?

# CHAT_REPLY Based on your provided code snippets, the context length limit is enforced in a few key areas:
# CHAT_REPLY 
# CHAT_REPLY **1. `cody_test/lib/shared/src/prompt/truncation.ts`:**
# CHAT_REPLY 
# CHAT_REPLY - **`truncateTextNearestLine`**: This function truncates text content to a maximum number of bytes, ensuring it ends at a line boundary. This is likely used to fit context items within a specific size limit.
# CHAT_REPLY 
# CHAT_REPLY **2. `mocked/codebase_context/limit.go`:**
# CHAT_REPLY 
# CHAT_REPLY - **`limitMatches`**: This function appears to limit the number of matches returned for a file, potentially based on lines or chunks.
# CHAT_REPLY - **`limitLineMatches`**: This function specifically limits the number of line fragments within each line match.
# CHAT_REPLY - **`limitChunkMatches`**: This function limits the number of ranges within each chunk match, also adjusting content and symbol information accordingly.
# CHAT_REPLY 
# CHAT_REPLY **3. `cody_test/vscode/src/completions/providers/provider.ts`:**
# CHAT_REPLY 
# CHAT_REPLY - **`standardContextSizeHints`**: This function calculates context size hints based on a maximum token count. It allocates proportions for the prefix, suffix, and total characters, likely influencing how much context is gathered.
# CHAT_REPLY 
# CHAT_REPLY **4. `cody_test/lib/shared/src/token/constants.ts`:**
# CHAT_REPLY 
# CHAT_REPLY - This file defines various token budget constants, such as `CHAT_INPUT_TOKEN_BUDGET`, `FAST_CHAT_INPUT_TOKEN_BUDGET`, and `ENHANCED_CONTEXT_ALLOCATION`. These constants likely determine the overall limits for different context components.
# CHAT_REPLY 
# CHAT_REPLY **5. Other Relevant Snippets:**
# CHAT_REPLY 
# CHAT_REPLY - **`cody_test/vscode/src/chat/utils.ts`**: `getContextWindowLimitInBytes` likely calculates the context window limit, potentially considering message history and a maximum character count.
# CHAT_REPLY - **`cody_test/vscode/src/chat/chat-view/prompt.ts`**: This code snippet suggests that transcript messages and user-specified context items are added until a certain limit is reached.
# CHAT_REPLY 
# CHAT_REPLY **In Summary:**
# CHAT_REPLY 
# CHAT_REPLY The context length limit enforcement is a combination of:
# CHAT_REPLY 
# CHAT_REPLY - **Token-based limits:** Defined in `constants.ts` and used for calculating context size hints.
# CHAT_REPLY - **Character/Byte limits:** Used in `truncateTextNearestLine` and potentially in other areas to truncate content.
# CHAT_REPLY - **Match/Item limits:** Implemented in `limit.go` to restrict the number of matches or items returned.
# CHAT_REPLY 
# CHAT_REPLY The specific implementation details and how these mechanisms interact might require further investigation within the codebase.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:164-169","content":"type updateOnErrorLimiter struct {\n\tlogger log.Logger\n\tactor  *Actor\n\n\tnextLimiter limiter.Limiter\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/directory.ts:49-74","content":"\n                // check file size before opening the file. skip file if it's larger than 1MB\n                const fileSize = await vscode.workspace.fs.stat(fileUri)\n                if (fileSize.size > 1000000 || !fileSize.size) {\n                    continue\n                }\n\n                const bytes = await vscode.workspace.fs.readFile(fileUri)\n                const content = new TextDecoder('utf-8').decode(bytes)\n                const range = new vscode.Range(0, 0, content.split('\\n').length - 1 || 0, 0)\n                const size = TokenCounter.countTokens(content)\n\n                contextFiles.push({\n                    type: 'file',\n                    uri: fileUri,\n                    content,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                })\n\n                // Limit the number of files to 10\n                const maxResults = 10\n                if (contextFiles.length >= maxResults) {\n                    return contextFiles\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:132-134","content":"func (l *concurrencyLimiter) Usage(ctx context.Context) (int, time.Time, error) {\n\treturn l.nextLimiter.Usage(ctx)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:91-122","content":"            ),\n            rangeIncludingLineBreak: new vscode_shim.Range(\n                new vscode_shim.Position(line, 0),\n                new vscode_shim.Position(line, text.length + this.offsets.newlineLength(line))\n            ),\n            text,\n        }\n    }\n\n    public offsetAt(position: vscode.Position | protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public protocolOffsetAt(position: protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public positionAt(offset: number): vscode.Position {\n        const { line, character } = this.offsets.position(offset)\n        return new vscode_shim.Position(line, character)\n    }\n\n    public getText(range?: vscode.Range | undefined): string {\n        if (range === undefined) {\n            return this.content\n        }\n        const start = this.offsets.offset(range.start)\n        const end = this.offsets.offset(range.end)\n        const text = this.content.slice(start, end)\n        return text\n    }\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:61-63","content":"func (r *RateLimit) IsValid() bool {\n\treturn r != nil && r.Interval > 0 && r.Limit > 0 && len(r.AllowedModels) > 0\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88","content":"\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:80-125","content":"func limitChunkMatches(file *FileMatch, limit int) int {\n\tfor i := range file.ChunkMatches {\n\t\tcm := &file.ChunkMatches[i]\n\t\tif len(cm.Ranges) > limit {\n\t\t\t// We potentially need to effect the limit upon 3 different fields:\n\t\t\t// Ranges, SymbolInfo, and Content.\n\n\t\t\t// Content is the most complicated: we need to remove the last N\n\t\t\t// lines from it, where N is the difference between the line number\n\t\t\t// of the end of the old last Range and that of the new last Range.\n\t\t\t// This calculation is correct in the presence of both context lines\n\t\t\t// and multiline Ranges, taking into account that Content never has\n\t\t\t// a trailing newline.\n\t\t\tn := cm.Ranges[len(cm.Ranges)-1].End.LineNumber - cm.Ranges[limit-1].End.LineNumber\n\t\t\tif n > 0 {\n\t\t\t\tfor b := len(cm.Content) - 1; b >= 0; b-- {\n\t\t\t\t\tif cm.Content[b] == '\\n' {\n\t\t\t\t\t\tn -= 1\n\t\t\t\t\t}\n\t\t\t\t\tif n == 0 {\n\t\t\t\t\t\tcm.Content = cm.Content[:b]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\t// Should be impossible.\n\t\t\t\t\tlog.Panicf(\"Failed to find enough newlines when truncating Content, %d left over, %d ranges\", n, len(cm.Ranges))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcm.Ranges = cm.Ranges[:limit]\n\t\t\tif cm.SymbolInfo != nil {\n\t\t\t\t// When non-nil, SymbolInfo is specified to have the same length\n\t\t\t\t// as Ranges.\n\t\t\t\tcm.SymbolInfo = cm.SymbolInfo[:limit]\n\t\t\t}\n\t\t}\n\t\tif len(cm.Ranges) == limit {\n\t\t\tfile.ChunkMatches = file.ChunkMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(cm.Ranges)\n\t}\n\treturn limit\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40","content":"/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:129-143","content":"func limitLineMatches(file *FileMatch, limit int) int {\n\tfor i := range file.LineMatches {\n\t\tlm := &file.LineMatches[i]\n\t\tif len(lm.LineFragments) > limit {\n\t\t\tlm.LineFragments = lm.LineFragments[:limit]\n\t\t}\n\t\tif len(lm.LineFragments) == limit {\n\t\t\tfile.LineMatches = file.LineMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(lm.LineFragments)\n\t}\n\treturn limit\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/file-path.ts:0-43","content":"import {\n    type ContextItem,\n    ContextItemSource,\n    TokenCounter,\n    logError,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\n/**\n * Generate ContextFile for a file URI.\n */\nexport async function getContextFileFromUri(file: URI, range?: vscode.Range): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.filePath', async span => {\n        try {\n            const doc = await vscode.workspace.openTextDocument(file)\n            const content = doc?.getText(range).trim()\n            if (!content) {\n                throw new Error('No file content')\n            }\n\n            const startLine = range?.start?.line ?? 0\n            range = new vscode.Range(startLine, 0, startLine + content.split('\\n').length, 0)\n            const size = TokenCounter.countTokens(content)\n\n            return [\n                {\n                    type: 'file',\n                    content,\n                    uri: file,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                },\n            ] satisfies ContextItem[]\n        } catch (error) {\n            logError('getContextFileFromUri', 'failed', { verbose: error })\n            return []\n        }\n    })\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:85-99","content":"type concurrencyLimiter struct {\n\tlogger  log.Logger\n\tactor   *Actor\n\tfeature codygateway.Feature\n\n\t// redis must be a prefixed store\n\tredis limiter.RedisStore\n\n\tconcurrentRequests int\n\tconcurrentInterval time.Duration\n\n\tnextLimiter limiter.Limiter\n\n\tnowFunc func() time.Time\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/workspace.ts:22-51","content":"\n        const contextFiles: ContextItem[] = []\n\n        // set cancellation token to time out after 20s\n        const token = new CancellationTokenSource()\n        setTimeout(() => {\n            token.cancel()\n        }, 20000)\n\n        try {\n            const results = await workspace.findFiles(globalPattern, excluded, maxResults, token.token)\n\n            for (const result of results) {\n                const decoded = await getDocText(result)\n                const contextFile = await createContextFile(result, decoded)\n\n                if (contextFile) {\n                    contextFiles.push(contextFile)\n                }\n            }\n\n            return contextFiles\n        } catch (error) {\n            logError('getWorkspaceFilesContext failed', `${error}`)\n\n            return contextFiles\n        }\n    })\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:20-36","content":"type RateLimit struct {\n\t// AllowedModels is a set of models in Cody Gateway's model configuration\n\t// format, \"$PROVIDER/$MODEL_NAME\". A single-item slice with value '*' means\n\t// that all models in the 'master allowlist' are allowed.\n\t//\n\t// DO NOT USE DIRECTLY when enforcing permissions: use EvaluateAllowedModels(...)\n\t// instead.\n\tAllowedModels []string `json:\"allowedModels\"`\n\n\tLimit    int64         `json:\"limit\"`\n\tInterval time.Duration `json:\"interval\"`\n\n\t// ConcurrentRequests, ConcurrentRequestsInterval are generally applied\n\t// with NewRateLimitWithPercentageConcurrency.\n\tConcurrentRequests         int           `json:\"concurrentRequests\"`\n\tConcurrentRequestsInterval time.Duration `json:\"concurrentRequestsInterval\"`\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:175-199","content":"        }\n\n        for (let snippetsToInclude = 0; snippetsToInclude < snippets.length + 1; snippetsToInclude++) {\n            if (snippetsToInclude > 0) {\n                const snippet = snippets[snippetsToInclude - 1]\n                const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n                if (contextPrompts.symbol) {\n                    intro.push(\n                        ps`Additional documentation for \\`${contextPrompts.symbol}\\`:\\n\\n${contextPrompts.content}`\n                    )\n                } else {\n                    intro.push(\n                        ps`Here is a reference snippet of code from ${PromptString.fromDisplayPath(\n                            snippet.uri\n                        )}:\\n\\n${contextPrompts.content}`\n                    )\n                }\n            }\n\n            const introString = ps`${PromptString.join(\n                PromptString.join(intro, ps`\\n\\n`)\n                    .split('\\n')\n                    .map(line => ps`${languageConfig ? languageConfig.commentStart : ps`// `}${line}`),\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/context.ts:39-61","content":"    const truncatedPrecedingText = truncatePromptStringStart(precedingText, MAX_CURRENT_FILE_TOKENS)\n    const truncatedFollowingText = truncatePromptString(followingText, MAX_CURRENT_FILE_TOKENS)\n\n    // Disable no case declarations because we get better type checking with a switch case\n    switch (intent) {\n        /**\n         * The context for the test intent is handled by the executeTestEditCommand function,\n         * we don't need to add additional context here to avoid duplication.\n         */\n        case 'test':\n            return []\n        /**\n         * Very broad set of possible instructions.\n         * Fetch context from the users' instructions and use context from current file.\n         * Include the following code from the current file.\n         * The preceding code is already included as part of the response to better guide the output.\n         */\n        case 'add': {\n            return [\n                {\n                    speaker: 'human',\n                    text: populateCodeGenerationContextTemplate(\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:62-76","content":"func limitMatches(files []FileMatch, limit int, chunkMatches bool) ([]FileMatch, int) {\n\tvar limiter func(file *FileMatch, limit int) int\n\tif chunkMatches {\n\t\tlimiter = limitChunkMatches\n\t} else {\n\t\tlimiter = limitLineMatches\n\t}\n\tfor i := range files {\n\t\tlimit = limiter(&files[i], limit)\n\t\tif limit <= 0 {\n\t\t\treturn files[:i+1], 0\n\t\t}\n\t}\n\treturn files, limit\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/provider.ts:27-57","content":"\n    /**\n     * A string identifier for the provider config used in event logs.\n     */\n    identifier: string\n\n    /**\n     * Defines which model is used with the respective provider.\n     */\n    model: string\n}\n\ninterface ProviderContextSizeHints {\n    /** Total max length of all context (prefix + suffix + snippets). */\n    totalChars: number\n\n    /** Max length of the document prefix (text before the cursor). */\n    prefixChars: number\n\n    /** Max length of the document suffix (text after the cursor). */\n    suffixChars: number\n}\n\nexport function standardContextSizeHints(maxContextTokens: number): ProviderContextSizeHints {\n    return {\n        totalChars: Math.floor(tokensToChars(0.9 * maxContextTokens)), // keep 10% margin for preamble, etc.\n        prefixChars: Math.floor(tokensToChars(0.6 * maxContextTokens)),\n        suffixChars: Math.floor(tokensToChars(0.1 * maxContextTokens)),\n    }\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57","content":"import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/truncation.ts:25-60","content":" * which should be ignored anyway).\n */\nexport function truncateTextNearestLine(\n    text: string,\n    maxBytes: number\n): { truncated: string; range?: RangeData } {\n    if (text.length <= maxBytes) {\n        return { truncated: text }\n    }\n    const textMaxBytes = text.slice(0, maxBytes)\n    const textMaxBytesLines = textMaxBytes.split('\\n')\n    if (text.at(maxBytes) === '\\n' || text.at(maxBytes - 1) === '\\n') {\n        return {\n            truncated: textMaxBytes,\n            range: {\n                start: { line: 0, character: 0 },\n                end: { line: textMaxBytesLines.length, character: 0 },\n            },\n        }\n    }\n\n    const truncated = textMaxBytesLines.slice(0, -1).join('\\n')\n    return {\n        truncated,\n        range: {\n            start: { line: 0, character: 0 },\n            end: { line: textMaxBytesLines.length - 1, character: 0 },\n        },\n    }\n}\n\n/**\n * Truncates text to the given number of tokens, keeping the end of the text.\n */\nexport function truncateTextStart(text: string, maxTokens: number): string {\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21","content":"export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:152-163","content":"                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203","content":"import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:57-80","content":"                throw new Error(\n                    `Preamble length exceeded context window size ${chat.contextWindow.input}`\n                )\n            }\n\n            // Add existing chat transcript messages\n            const reverseTranscript: ChatMessage[] = [...chat.getMessages()].reverse()\n            const transcriptLimitReached = promptBuilder.tryAddMessages(reverseTranscript)\n            if (transcriptLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    `Ignored ${transcriptLimitReached} transcript messages due to context limit`\n                )\n            }\n\n            // NOTE: Only display excluded context from user-specifed context items\n            const newContextIgnored: ContextItem[] = []\n            const newContextUsed: ContextItem[] = []\n\n            // Add context from new user-specified context items, e.g. @-mentions, @-uri\n            sortContextItems(this.explicitContext)\n            const {\n                limitReached: userLimitReached,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73","content":"import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\"presentation\"] div[class*=\"squiggly-error\"]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/utils.ts:104-135","content":"        return 1\n    }\n\n    return 0 // zero refers to the legacy, unversioned, Cody API\n}\n\n/**\n * Counts the total number of bytes used in a list of chat messages.\n *\n * This function is exported and can be used to calculate the byte usage\n * of chat messages for storage/bandwidth purposes.\n *\n * @param messages - The list of chat messages to count bytes for\n * @returns The total number of bytes used in the messages\n */\nexport function countBytesInChatMessages(messages: ChatMessage[]): number {\n    if (messages.length === 0) {\n        return 0\n    }\n    return messages.reduce((acc, msg) => acc + msg.speaker.length + (msg.text?.length || 0) + 3, 0)\n}\n\n/**\n * Gets the context window limit in bytes for chat messages, taking into\n * account the maximum allowed character count. Returns 0 if the used bytes\n * exceeds the limit.\n * @param messages - The chat messages\n * @param maxChars - The maximum allowed character count\n * @returns The context window limit in bytes\n */\nexport function getContextWindowLimitInBytes(messages: ChatMessage[], maxChars: number): number {\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/jaccard-similarity/jaccard-similarity-retriever.ts:0-22","content":"import * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\nimport { getContextRange } from '../../../doc-context-getters'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\nimport { baseLanguageId } from '../../utils'\nimport { type DocumentHistory, VSCodeDocumentHistory } from './history'\n\nimport { lastNLines } from '../../../text-processing'\nimport { type JaccardMatch, bestJaccardMatches } from './bestJaccardMatch'\n\n/**\n * The size of the Jaccard distance match window in number of lines. It determines how many\n * lines of the 'matchText' are considered at once when searching for a segment\n * that is most similar to the 'targetText'. In essence, it sets the maximum number\n * of lines that the best match can be. A larger 'windowSize' means larger potential matches\n */\nconst SNIPPET_WINDOW_SIZE = 50\n\n/**\n * Limits the number of jaccard windows that are fetched for a single file. This is mostly added to\n * avoid large files taking up too much compute time and to avoid a single file to take up too much\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:138-138","content":"\tlimit      int\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33","content":"import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n"}]

 class: Find logic
