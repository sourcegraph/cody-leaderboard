 question: Where all is symf used as a context source for different Cody features?
# CHAT
# CHAT_QUESTION Where all is symf used as a context source for different Cody features?

# CHAT_REPLY Based on the provided codebase context, here's where symf is used as a context source for different Cody features:
# CHAT_REPLY 
# CHAT_REPLY - **Chat**
# CHAT_REPLY     - The `cody.experimental.symfContext` setting (default: true) enables symf code search context for chat. This suggests symf is used to fetch relevant code snippets from the codebase to provide context to Cody during chat conversations. 
# CHAT_REPLY     - The `ChatPanelsManager.ts` file imports `SymfRunner`, indicating its involvement in managing chat panels and potentially using symf for context there.
# CHAT_REPLY     - The `getEnhancedContextOptions` interface in `chat-view/context.ts` includes `symf: SymfRunner | null`, suggesting symf is used as a potential context provider for enhancing chat context.
# CHAT_REPLY 
# CHAT_REPLY - **Command Execution**
# CHAT_REPLY     - While not explicitly stated, the use of `SymfRunner` in `ChatPanelsManager` and the shared context fetching mechanisms between chat and commands suggest that symf might also be used for providing context during Cody command execution.
# CHAT_REPLY 
# CHAT_REPLY **In summary:** symf primarily acts as a code search engine to provide relevant code context within Cody's chat feature. It's likely also used for command execution, though this is not explicitly confirmed in the provided code snippets.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30","content":"export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33","content":"import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:0-643","content":"import { execFile as _execFile, spawn } from 'node:child_process'\nimport fs, { access, rename, rm, writeFile } from 'node:fs/promises'\nimport os from 'node:os'\nimport { promisify } from 'node:util'\n\nimport { Mutex } from 'async-mutex'\nimport { mkdirp } from 'mkdirp'\nimport * as vscode from 'vscode'\n\nimport {\n    type FileURI,\n    type IndexedKeywordContextFetcher,\n    type PromptString,\n    type Result,\n    type SourcegraphCompletionsClient,\n    assertFileURI,\n    isFileURI,\n    isWindows,\n    uriBasename,\n    uriDirname,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\nimport { getSymfPath } from './download-symf'\nimport { symfExpandQuery } from './symfExpandQuery'\n\nconst execFile = promisify(_execFile)\nconst oneDayMillis = 1000 * 60 * 60 * 24\n\ninterface CorpusDiff {\n    maybeChangedFiles?: boolean\n    changedFiles?: string[]\n    millisElapsed?: number\n}\n\nfunction parseJSONToCorpusDiff(json: string): CorpusDiff {\n    const obj = JSON.parse(json)\n    if (obj.maybeChangedFiles === undefined && obj.changedFiles === undefined) {\n        throw new Error(`malformed CorpusDiff: ${json}`)\n    }\n    return obj as CorpusDiff\n}\n\ninterface IndexOptions {\n    retryIfLastAttemptFailed: boolean\n    ignoreExisting: boolean\n}\n\nexport class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n}\n\nexport interface IndexStartEvent {\n    scopeDir: FileURI\n    cancel: () => void\n    done: Promise<void>\n}\n\ninterface IndexEndEvent {\n    scopeDir: FileURI\n}\n\nclass IndexStatus implements vscode.Disposable {\n    private startEmitter = new vscode.EventEmitter<IndexStartEvent>()\n    private stopEmitter = new vscode.EventEmitter<IndexEndEvent>()\n    private inProgressDirs = new Set<string /* uri.toString() */>()\n\n    public dispose(): void {\n        this.startEmitter.dispose()\n        this.stopEmitter.dispose()\n    }\n\n    public didStart(event: IndexStartEvent): void {\n        this.inProgressDirs.add(event.scopeDir.toString())\n        this.startEmitter.fire(event)\n    }\n\n    public didEnd(event: IndexEndEvent): void {\n        this.inProgressDirs.delete(event.scopeDir.toString())\n        this.stopEmitter.fire(event)\n    }\n\n    public onDidStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.startEmitter.event(cb)\n    }\n\n    public onDidEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.stopEmitter.event(cb)\n    }\n\n    public isInProgress(scopeDir: FileURI): boolean {\n        return this.inProgressDirs.has(scopeDir.toString())\n    }\n}\n\nasync function fileExists(file: vscode.Uri): Promise<boolean> {\n    if (!isFileURI(file)) {\n        throw new Error('only file URIs are supported')\n    }\n    try {\n        await access(file.fsPath, fs.constants.F_OK)\n        return true\n    } catch {\n        return false\n    }\n}\n\nfunction parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n}\n\n/**\n * A simple read-write lock.\n *\n * Note: it is possible for an overlapping succession of readers to starve out\n * any writers that are waiting for the mutex to be released. In practice, this\n * is not an issue, because we don't expect the user to issue neverending\n * while trying to update the index.\n */\nclass RWLock {\n    /**\n     * Invariants:\n     * - if readers > 0, then mu is locked\n     * - if readers === 0 and mu is locked, then a writer is holding the lock\n     */\n    private readers = 0\n    private mu = new Mutex()\n\n    public async withRead<T>(fn: () => Promise<T>): Promise<T> {\n        while (this.readers === 0) {\n            if (this.mu.isLocked()) {\n                // If mu is locked at this point, it must be held by the writer.\n                // We spin in this case, rather than try to acquire the lock,\n                // because multiple readers blocked on acquiring the lock will\n                // execute serially when the writer releases the lock (whereas\n                // we want all reads to be concurrent).\n                await new Promise(resolve => setTimeout(resolve, 100))\n                continue\n            }\n            // No readers or writers: acquire lock for readers\n            await this.mu.acquire()\n            break\n        }\n        this.readers++\n        try {\n            return await fn()\n        } finally {\n            this.readers--\n            if (this.readers === 0) {\n                this.mu.release()\n            }\n        }\n    }\n\n    public async withWrite<T>(fn: () => Promise<T>): Promise<T> {\n        return this.mu.runExclusive(fn)\n    }\n}\n\nfunction toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \"cody.experimental.symf.path\" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:0-27","content":"import * as vscode from 'vscode'\n\nimport {\n    type AuthStatus,\n    type ChatClient,\n    type Configuration,\n    type ConfigurationWithAccessToken,\n    type FeatureFlagProvider,\n    type Guardrails,\n    ModelProvider,\n    ModelUsage,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport type { MessageProviderOptions } from '../MessageProvider'\nimport type { ExtensionMessage } from '../protocol'\n\nimport type { EnterpriseContextFactory } from '../../context/enterprise-context-factory'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport { chatHistory } from './ChatHistoryManager'\nimport { CodyChatPanelViewType } from './ChatManager'\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77","content":"        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:0-32","content":"import * as vscode from 'vscode'\n\nimport {\n    type ConfigurationUseContext,\n    type ContextItem,\n    ContextItemSource,\n    MAX_BYTES_PER_FILE,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    type PromptString,\n    type Result,\n    isFileURI,\n    truncateTextNearestLine,\n    uriBasename,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { RemoteSearch } from '../../context/remote-search'\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug, logError } from '../../log'\n\ninterface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125","content":"async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32","content":"\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162","content":"async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993","content":"        \"cody.experimental.simpleChatContext\": {\n          \"order\": 99,\n          \"type\": \"boolean\",\n          \"markdownDescription\": \"Uses the new simplifed chat context fetcher\",\n          \"default\": true\n        },\n        \"cody.experimental.ollamaChat\": {\n          \"order\": 99,\n          \"type\": \"boolean\",\n          \"markdownDescription\": \"Enable local Ollama models for chat and commands\",\n          \"default\": false\n        },\n        \"cody.experimental.symfContext\": {\n          \"order\": 99,\n          \"type\": \"boolean\",\n          \"markdownDescription\": \"Enable symf code search context for chat\",\n          \"default\": true\n        },\n        \"cody.experimental.symf.path\": {\n          \"order\": 99,\n          \"type\": \"string\",\n          \"markdownDescription\": \"Path to symf binary\",\n          \"default\": \"\"\n        },\n        \"cody.experimental.tracing\": {\n          \"order\": 99,\n          \"type\": \"boolean\",\n          \"markdownDescription\": \"Enable OpenTelemetry tracing\",\n          \"default\": false\n        },\n        \"cody.debug.verbose\": {\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121","content":"\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \"from\" the human. (In the future, this could be from \"system\" for\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14","content":"const symfVersion = 'v0.0.9'\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25","content":"import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:98-111","content":"    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/provider.ts:0-22","content":"import { type CodyCommand, type ContextItem, featureFlagProvider } from '@sourcegraph/cody-shared'\n\nimport * as vscode from 'vscode'\nimport { CodyCommandMenuItems } from '..'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getContextFileFromShell } from '../context/shell'\nimport { showCommandMenu } from '../menus'\nimport type { CodyCommandArgs } from '../types'\nimport { getDefaultCommandsMap } from '../utils/get-commands'\nimport { CustomCommandsManager, openCustomCommandDocsLink } from './custom-commands'\n\nconst vscodeDefaultCommands = getDefaultCommandsMap(CodyCommandMenuItems as CodyCommand[])\n\n/**\n * Provides management and interaction capabilities for both default and custom Cody commands.\n *\n * It is responsible for initializing, grouping, and refreshing command sets,\n * as well as handling command menus and execution.\n */\nexport class CommandsProvider implements vscode.Disposable {\n    private disposables: vscode.Disposable[] = []\n    protected readonly defaultCommands = vscodeDefaultCommands\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/context/chatContext.ts:70-75","content":"export async function isURLContextFeatureFlagEnabled(): Promise<boolean> {\n    return (\n        vscode.workspace.getConfiguration('cody').get<boolean>('experimental.urlContext') === true ||\n        (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.URLContext))\n    )\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/types.ts:0-46","content":"import type { CodyCommand, ContextItem, EventSource, PromptString } from '@sourcegraph/cody-shared'\n\nimport type { Range, Uri } from 'vscode'\nimport type { ExecuteEditArguments } from '../edit/execute'\n\n/**\n * The name of the file for configuring Custom Commands.\n */\nexport enum ConfigFiles {\n    // Cody Commands config file location in VS CODE\n    // TODO: Migrate to use the one in /.cody\n    VSCODE = '.vscode/cody.json',\n    // Cody Commands config file location for all clients\n    COMMAND = '.cody/commands.json',\n}\n\n/**\n * Creates a CodyCommandArgs object with default values.\n * Generates a random requestID if one is not provided.\n * Merges any provided args with the defaults.\n */\nexport interface CodyCommandsFile {\n    // A set of reusable commands where instructions (prompts) and context can be configured.\n    commands: Map<string, CodyCommand>\n}\n\nexport interface CodyCommandArgs extends ExecuteEditArguments {\n    // for tracing the life of the request\n    requestID: string\n    // where the command was triggered from\n    source?: EventSource\n    // runs the command in chat mode, even if it's an edit command\n    runInChatMode?: boolean\n    // current context to add on top of the command context\n    userContextFiles?: ContextItem[]\n    additionalInstruction?: PromptString\n\n    /**\n     * Editor Context\n     */\n    // The URI of the file in the editor\n    uri?: Uri\n    // The range of the selection in the editor\n    range?: Range\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1085-1094","content":"- Increased autocomplete debounce time feature flag support. [pull/733](https://github.com/sourcegraph/cody/pull/733)\n- Show an update notice after extension updates. [pull/746](https://github.com/sourcegraph/cody/pull/746)\n- Experimental user setting `cody.experimental.localSymbols` to enable inclusion of symbol definitions in the LLM context window. [pull/692](https://github.com/sourcegraph/cody/pull/692)\n- Experimental command `/symf`, which uses a local keyword index to perform searches for symbols. Requires setting `cody.experimental.symf.path` and `cody.experimental.symf.anthropicKey`. [pull/728](https://github.com/sourcegraph/cody/pull/728).\n\n### Fixed\n\n- Inline Chat: Fix issue where state was not being set correctly, causing Cody Commands to use the selection range from the last created Inline Chat instead of the current selection. [pull/602](https://github.com/sourcegraph/cody/pull/602)\n- Cody Commands: Commands that use the current file as context now correctly generate context message for the current file instead of using codebase context generated from current selection. [pull/683](https://github.com/sourcegraph/cody/pull/683)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/agentContextSorting.ts:0-21","content":"import { type ContextItem, ContextItemSource } from '@sourcegraph/cody-shared'\n\nconst isAgentTesting = process.env.CODY_SHIM_TESTING === 'true'\n\n/**\n * Sorts the provided `ContextItem` array in a deterministic order for stable tests.\n * This function is only used when the `CODY_SHIM_TESTING` environment variable is\n * set to `'true'`, which indicates that the agent is running in a testing environment.\n *\n * NOTE: Agent tests require deterministic ordering of context files for consistent results across different file systems\n * These helper functions should be called before we pass context items/files to a prompt builder.\n * This is necessary to get the tests passing in CI because we need the prompts to be stable for the HTTP replay mode to succeed.\n *\n * @param files - The array of `ContextItem` objects to sort.\n */\nexport function sortContextItems(files: ContextItem[]): void {\n    if (!isAgentTesting) {\n        return\n    }\n    // Sort results for deterministic ordering for stable tests. Ideally, we\n    // could sort by some numerical score from symf based on how relevant\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65","content":"function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32","content":"// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:260-277","content":"    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4","content":"# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70","content":"                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n"}]

 class: Find logic
