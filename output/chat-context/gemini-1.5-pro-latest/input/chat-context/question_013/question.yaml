 question: Where is the functionality for calling the Sourcegraph API?
# CHAT
# CHAT_QUESTION Where is the functionality for calling the Sourcegraph API?

# CHAT_REPLY The functionality for calling the Sourcegraph API is primarily located in the `SourcegraphGraphQLAPIClient` class, defined in  `lib/shared/src/sourcegraph-api/graphql/client.ts`. 
# CHAT_REPLY 
# CHAT_REPLY Here's a breakdown:
# CHAT_REPLY 
# CHAT_REPLY - **`SourcegraphGraphQLAPIClient`**: This class provides methods for interacting with the Sourcegraph GraphQL API. 
# CHAT_REPLY - **`fetchSourcegraphAPI`**: This private method is the core function used to make requests to the Sourcegraph API. It handles constructing the request URL, setting headers (including authorization), and parsing the response.
# CHAT_REPLY - **Other methods**: The `SourcegraphGraphQLAPIClient` class exposes various public methods like `getSiteVersion`, `getCodyConfigFeatures`, `getRepoList`, `contextSearch`, etc., which internally utilize `fetchSourcegraphAPI` to interact with specific API endpoints.
# CHAT_REPLY 
# CHAT_REPLY In addition to this central class, other files like `browserClient.ts` and `nodeClient.ts` in the same directory define client implementations for different environments (browser and Node.js) that ultimately use the `SourcegraphGraphQLAPIClient` for API communication.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:54-82","content":"    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n                    break\n                }\n                case 'error': {\n                    const error = new Error(event.error)\n                    if (span) {\n                        recordErrorToSpan(span, error)\n                    }\n                    this.errorEncountered = true\n                    cb.onError(error)\n                    break\n                }\n                case 'done': {\n                    if (!this.errorEncountered) {\n                        cb.onComplete()\n                    }\n                    // reset errorEncountered for next request\n                    this.errorEncountered = false\n                    span?.end()\n                    break\n                }\n            }\n        }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:170-198","content":"            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?CurrentSiteCodyLlmConfiguration\n      response:\n        bodySize: 215\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 215\n          text: \"[\\\"H4sIAAAAAAAAA4TOMQ7CMAxA0bt4bkXajaxdm40LWElKI4JdNS4CVbk7ShdQBpgsWd9P3\\\n            sGhIOgdUhBfpmX3GkczME3huq0ogenYzyiGnY+gAUnmlZdgTzbi\\\",\\\"5nzbQ/MJDD4\\\n            vfPOUQHe9UqqBCZMMv+4DJUGStoMq/rLOB2X5vkRfnvqLPYpW9ZWXc85vAAAA//8DAC\\\n            mc8DoDAQAA\\\"]\"\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:34:09 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \"true\"\n          - name: access-control-allow-origin\n            value: \"\"\n          - name: cache-control\n            value: no-cache, max-age=0\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/browserClient.ts:8-85","content":"export class SourcegraphBrowserCompletionsClient extends SourcegraphCompletionsClient {\n    protected _streamWithCallbacks(\n        params: CompletionParameters,\n        apiVersion: number,\n        cb: CompletionCallbacks,\n        signal?: AbortSignal\n    ): void {\n        const url = new URL(this.completionsEndpoint)\n        if (apiVersion >= 1) {\n            url.searchParams.append('api-version', '' + apiVersion)\n        }\n\n        const abort = dependentAbortController(signal)\n        const headersInstance = new Headers(this.config.customHeaders as HeadersInit)\n        addCustomUserAgent(headersInstance)\n        headersInstance.set('Content-Type', 'application/json; charset=utf-8')\n        if (this.config.accessToken) {\n            headersInstance.set('Authorization', `token ${this.config.accessToken}`)\n        }\n        const parameters = new URLSearchParams(window.location.search)\n        const trace = parameters.get('trace')\n        if (trace) {\n            headersInstance.set('X-Sourcegraph-Should-Trace', 'true')\n        }\n        // Disable gzip compression since the sg instance will start to batch\n        // responses afterwards.\n        headersInstance.set('Accept-Encoding', 'gzip;q=0')\n        fetchEventSource(url.toString(), {\n            method: 'POST',\n            headers: Object.fromEntries(headersInstance.entries()),\n            body: JSON.stringify(params),\n            signal: abort.signal,\n            openWhenHidden: isRunningInWebWorker, // otherwise tries to call document.addEventListener\n            async onopen(response) {\n                if (!response.ok && response.headers.get('content-type') !== 'text/event-stream') {\n                    let errorMessage: null | string = null\n                    try {\n                        errorMessage = await response.text()\n                    } catch (error) {\n                        // We show the generic error message in this case\n                        console.error(error)\n                    }\n                    const error = new Error(\n                        errorMessage === null || errorMessage.length === 0\n                            ? `Request failed with status code ${response.status}`\n                            : errorMessage\n                    )\n                    cb.onError(error, response.status)\n                    abort.abort()\n                    return\n                }\n            },\n            onmessage: message => {\n                try {\n                    const data: Event = { ...JSON.parse(message.data), type: message.event }\n                    this.sendEvents([data], cb)\n                } catch (error: any) {\n                    cb.onError(error.message)\n                    abort.abort()\n                    console.error(error)\n                    // throw the error for not retrying\n                    throw error\n                }\n            },\n            onerror(error) {\n                cb.onError(error.message)\n                abort.abort()\n                console.error(error)\n                // throw the error for not retrying\n                throw error\n            },\n        }).catch(error => {\n            cb.onError(error.message)\n            abort.abort()\n            console.error(error)\n        })\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.vscode/extensions.json:0-10","content":"{\n  \"recommendations\": [\n    \"sourcegraph.cody-ai\",\n    \"editorconfig.editorconfig\",\n    \"ecmel.vscode-html-css\",\n    \"biomejs.biome\",\n    \"stylelint.vscode-stylelint\"\n  ]\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:182-216","content":"\n                  ```\n\n                  client/web/node_modules\n\n                  client/web-sveltekit/node_modules\n\n                  client/wildcard/node_modules\n\n                  dev/release/node_modules\n\n\n                  cmd/symbols/squirrel/test_repos/starlark\n\n\n                  # Generated by local tools\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /client/shared/src/codeintel/legacy-extensions/search/providers.ts\n                  in repository github.com/sourcegraph/sourcegraph:\n\n                  ```typescript\n\n                  import { getConfig } from './config'\n\n                  import { type Result, resultToLocation, searchResultToResults } from './conversion'\n\n                  import { findDocstring } from './docstrings'\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:32-60","content":"/**\n * Access the chat based LLM APIs via a Sourcegraph server instance.\n *\n * ðŸš¨ SECURITY: It is the caller's responsibility to ensure context from\n * all cody ignored files are removed before sending requests to the server.\n */\nexport abstract class SourcegraphCompletionsClient {\n    private errorEncountered = false\n\n    constructor(\n        protected config: CompletionsClientConfig,\n        protected logger?: CompletionLogger\n    ) {}\n\n    public onConfigurationChange(newConfig: CompletionsClientConfig): void {\n        this.config = newConfig\n    }\n\n    protected get completionsEndpoint(): string {\n        return new URL('/.api/completions/stream', this.config.serverEndpoint).href\n    }\n\n    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:297-870","content":"export class SourcegraphGraphQLAPIClient {\n    private dotcomUrl = DOTCOM_URL\n    public anonymousUserID: string | undefined\n\n    /**\n     * Should be set on extension activation via `localStorage.onConfigurationChange(config)`\n     * Done to avoid passing the graphql client around as a parameter and instead\n     * access it as a singleton via the module import.\n     */\n    private _config: GraphQLAPIClientConfig | null = null\n\n    private get config(): GraphQLAPIClientConfig {\n        if (!this._config) {\n            throw new Error('GraphQLAPIClientConfig is not set')\n        }\n\n        return this._config\n    }\n\n    constructor(config: GraphQLAPIClientConfig | null = null) {\n        this._config = config\n    }\n\n    public onConfigurationChange(newConfig: GraphQLAPIClientConfig): void {\n        this._config = newConfig\n    }\n\n    /**\n     * If set, anonymousUID is trasmitted as 'X-Sourcegraph-Actor-Anonymous-UID'\n     * which is automatically picked up by Sourcegraph backends 5.2+\n     */\n    public setAnonymousUserID(anonymousUID: string): void {\n        this.anonymousUserID = anonymousUID\n    }\n\n    public isDotCom(): boolean {\n        return isDotCom(this.config.serverEndpoint)\n    }\n\n    // Gets the server endpoint for this client.\n    public get endpoint(): string {\n        return this.config.serverEndpoint\n    }\n\n    public async getSiteVersion(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteVersionResponse>>(\n            CURRENT_SITE_VERSION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => data.site?.productVersion ?? new Error('site version not found')\n            )\n        )\n    }\n\n    public async getSiteIdentification(): Promise<{ siteid: string; hashedLicenseKey: string } | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<SiteIdentificationResponse>>(\n            CURRENT_SITE_IDENTIFICATION,\n            {}\n        )\n        return extractDataOrError(response, data =>\n            data.site?.siteID\n                ? data.site?.productSubscription?.license?.hashedKey\n                    ? {\n                          siteid: data.site?.siteID,\n                          hashedLicenseKey: data.site?.productSubscription?.license?.hashedKey,\n                      }\n                    : new Error('site hashed license key not found')\n                : new Error('site ID not found')\n        )\n    }\n\n    public async getSiteHasIsCodyEnabledField(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteGraphqlFieldsResponse>>(\n            CURRENT_SITE_GRAPHQL_FIELDS_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => !!data.__type?.fields?.find(field => field.name === 'isCodyEnabled')\n            )\n        )\n    }\n\n    public async getSiteHasCodyEnabled(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteHasCodyEnabledResponse>>(\n            CURRENT_SITE_HAS_CODY_ENABLED_QUERY,\n            {}\n        ).then(response => extractDataOrError(response, data => data.site?.isCodyEnabled ?? false))\n    }\n\n    public async getCurrentUserId(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserIdResponse>>(\n            CURRENT_USER_ID_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? data.currentUser.id : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodyProEnabled(): Promise<{ codyProEnabled: boolean } | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodyProEnabledResponse>>(\n            CURRENT_USER_CODY_PRO_ENABLED_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodySubscription(): Promise<CurrentUserCodySubscription | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodySubscriptionResponse>>(\n            CURRENT_USER_CODY_SUBSCRIPTION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser?.codySubscription\n                    ? data.currentUser.codySubscription\n                    : new Error('current user subscription data not found')\n            )\n        )\n    }\n\n    public async getCurrentUserInfo(): Promise<CurrentUserInfo | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserInfoResponse>>(\n            CURRENT_USER_INFO_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    /**\n     * Fetches the Site Admin enabled/disable Cody config features for the current instance.\n     */\n    public async getCodyConfigFeatures(): Promise<CodyConfigFeatures | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<CodyConfigFeaturesResponse>>(\n            CURRENT_SITE_CODY_CONFIG_FEATURES,\n            {}\n        )\n        return extractDataOrError(\n            response,\n            data => data.site?.codyConfigFeatures ?? new Error('cody config not found')\n        )\n    }\n\n    public async getCodyLLMConfiguration(): Promise<undefined | CodyLLMSiteConfiguration | Error> {\n        // fetch Cody LLM provider separately for backward compatability\n        const [configResponse, providerResponse] = await Promise.all([\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationResponse>>(\n                CURRENT_SITE_CODY_LLM_CONFIGURATION\n            ),\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationProviderResponse>>(\n                CURRENT_SITE_CODY_LLM_PROVIDER\n            ),\n        ])\n\n        const config = extractDataOrError(\n            configResponse,\n            data => data.site?.codyLLMConfiguration || undefined\n        )\n        if (!config || isError(config)) {\n            return config\n        }\n\n        let provider: string | undefined\n        const llmProvider = extractDataOrError(\n            providerResponse,\n            data => data.site?.codyLLMConfiguration?.provider\n        )\n        if (llmProvider && !isError(llmProvider)) {\n            provider = llmProvider\n        }\n\n        return { ...config, provider }\n    }\n\n    /**\n     * Gets a subset of the list of repositories from the Sourcegraph instance.\n     * @param first the number of repositories to retrieve.\n     * @param after the last repository retrieved, if any, to continue enumerating the list.\n     * @returns the list of repositories. If `endCursor` is null, this is the end of the list.\n     */\n    public async getRepoList(first: number, after?: string): Promise<RepoListResponse | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepoListResponse>>(REPOSITORY_LIST_QUERY, {\n            first,\n            after: after || null,\n        }).then(response => extractDataOrError(response, data => data))\n    }\n\n    public async getRepoId(repoName: string): Promise<string | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdResponse>>(REPOSITORY_ID_QUERY, {\n            name: repoName,\n        }).then(response =>\n            extractDataOrError(response, data => (data.repository ? data.repository.id : null))\n        )\n    }\n\n    public async getRepoIds(\n        names: string[],\n        first: number\n    ): Promise<{ name: string; id: string }[] | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdsResponse>>(REPOSITORY_IDS_QUERY, {\n            names,\n            first,\n        }).then(response => extractDataOrError(response, data => data.repositories?.nodes || []))\n    }\n\n    public async contextSearch(\n        repos: Set<string>,\n        query: string\n    ): Promise<ContextSearchResult[] | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<ContextSearchResponse>>(CONTEXT_SEARCH_QUERY, {\n            repos: [...repos],\n            query,\n            codeResultsCount: 15,\n            textResultsCount: 5,\n        }).then(response =>\n            extractDataOrError(response, data =>\n                (data.getCodyContext || []).map(item => ({\n                    commit: item.blob.commit.oid,\n                    repoName: item.blob.repository.name,\n                    path: item.blob.path,\n                    uri: URI.parse(\n                        `${item.blob.url.startsWith('/') ? this.endpoint : ''}${item.blob.url}?L${\n                            item.startLine + 1\n                        }-${item.endLine}`\n                    ),\n                    startLine: item.startLine,\n                    endLine: item.endLine,\n                    content: item.chunkContent,\n                }))\n            )\n        )\n    }\n\n    public async contextFilters(): Promise<ContextFiltersResult | null | Error> {\n        const response =\n            await this.fetchSourcegraphAPI<APIResponse<ContextFiltersResult | null>>(\n                CONTEXT_FILTERS_QUERY\n            )\n\n        const result = extractDataOrError(response, data => data)\n\n        if (result instanceof Error) {\n            // Ignore errors caused by outdated Sourcegraph API instances.\n            if (hasOutdatedAPIErrorMessages(result)) {\n                return INCLUDE_EVERYTHING_CONTEXT_FILTERS\n            }\n\n            // Exclude everything in case of an unexpected error.\n            return EXCLUDE_EVERYTHING_CONTEXT_FILTERS\n        }\n\n        return result\n    }\n\n    /**\n     * Checks if Cody is enabled on the current Sourcegraph instance.\n     * @returns\n     * enabled: Whether Cody is enabled.\n     * version: The Sourcegraph version.\n     *\n     * This method first checks the Sourcegraph version using `getSiteVersion()`.\n     * If the version is before 5.0.0, Cody is disabled.\n     * If the version is 5.0.0 or newer, it checks for the existence of the `isCodyEnabled` field using `getSiteHasIsCodyEnabledField()`.\n     * If the field exists, it calls `getSiteHasCodyEnabled()` to check its value.\n     * If the field does not exist, Cody is assumed to be enabled for versions between 5.0.0 - 5.1.0.\n     */\n    public async isCodyEnabled(): Promise<{ enabled: boolean; version: string }> {\n        // Check site version.\n        const siteVersion = await this.getSiteVersion()\n        if (isError(siteVersion)) {\n            return { enabled: false, version: 'unknown' }\n        }\n        const insiderBuild = siteVersion.length > 12 || siteVersion.includes('dev')\n        if (insiderBuild) {\n            return { enabled: true, version: siteVersion }\n        }\n        // NOTE: Cody does not work on versions older than 5.0\n        const versionBeforeCody = siteVersion < '5.0.0'\n        if (versionBeforeCody) {\n            return { enabled: false, version: siteVersion }\n        }\n        // Beta version is betwewen 5.0.0 - 5.1.0 and does not have isCodyEnabled field\n        const betaVersion = siteVersion >= '5.0.0' && siteVersion < '5.1.0'\n        const hasIsCodyEnabledField = await this.getSiteHasIsCodyEnabledField()\n        // The isCodyEnabled field does not exist before version 5.1.0\n        if (!betaVersion && !isError(hasIsCodyEnabledField) && hasIsCodyEnabledField) {\n            const siteHasCodyEnabled = await this.getSiteHasCodyEnabled()\n            return { enabled: !isError(siteHasCodyEnabled) && siteHasCodyEnabled, version: siteVersion }\n        }\n        return { enabled: insiderBuild || betaVersion, version: siteVersion }\n    }\n\n    /**\n     * recordTelemetryEvents uses the new Telemetry API to record events that\n     * gets exported: https://sourcegraph.com/docs/dev/background-information/telemetry\n     *\n     * Only available on Sourcegraph 5.2.0 and later.\n     *\n     * DO NOT USE THIS DIRECTLY - use an implementation of implementation\n     * TelemetryRecorder from '@sourcegraph/telemetry' instead.\n     */\n    public async recordTelemetryEvents(events: TelemetryEventInput[]): Promise<unknown | Error> {\n        for (const event of events) {\n            this.anonymizeTelemetryEventInput(event)\n        }\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<unknown>>(\n            RECORD_TELEMETRY_EVENTS_MUTATION,\n            {\n                events,\n            }\n        )\n        return extractDataOrError(initialResponse, data => data)\n    }\n\n    /**\n     * logEvent is the legacy event-logging mechanism.\n     * @deprecated use an implementation of implementation TelemetryRecorder\n     * from '@sourcegraph/telemetry' instead.\n     */\n    public async logEvent(event: event, mode: LogEventMode): Promise<LogEventResponse | Error> {\n        if (process.env.CODY_TESTING === 'true') {\n            return this.sendEventLogRequestToTestingAPI(event)\n        }\n        if (this.config?.telemetryLevel === 'off') {\n            return {}\n        }\n        /**\n         * If connected to dotcom, just log events to the instance, as it means\n         * the same thing.\n         */\n        if (this.isDotCom()) {\n            return this.sendEventLogRequestToAPI(event)\n        }\n\n        switch (process.env.CODY_LOG_EVENT_MODE) {\n            case 'connected-instance-only':\n                mode = 'connected-instance-only'\n                break\n            case 'dotcom-only':\n                mode = 'dotcom-only'\n                break\n            case 'all':\n                mode = 'all'\n                break\n            default:\n                if (process.env.CODY_LOG_EVENT_MODE) {\n                    logDebug(\n                        'SourcegraphGraphQLAPIClient.logEvent',\n                        'unknown mode',\n                        process.env.CODY_LOG_EVENT_MODE\n                    )\n                }\n        }\n\n        switch (mode) {\n            /**\n             * Only log events to dotcom, not the connected instance. Used when\n             * another mechanism delivers event logs the instance (i.e. the\n             * new telemetry clients)\n             */\n            case 'dotcom-only':\n                return this.sendEventLogRequestToDotComAPI(event)\n\n            /**\n             * Only log events to the connected instance, not dotcom. Used when\n             * another mechanism handles reporting to dotcom (i.e. the old\n             * client and/or the new telemetry framework, which exports events\n             * from all instances: https://sourcegraph.com/docs/dev/background-information/telemetry)\n             */\n            case 'connected-instance-only':\n                return this.sendEventLogRequestToAPI(event)\n\n            case 'all': // continue to default handling\n        }\n\n        /**\n         * Otherwise, send events to the connected instance AND to dotcom (default)\n         */\n        const responses = await Promise.all([\n            this.sendEventLogRequestToAPI(event),\n            this.sendEventLogRequestToDotComAPI(event),\n        ])\n        if (isError(responses[0]) && isError(responses[1])) {\n            return new Error(\n                `Errors logging events: ${responses[0].toString()}, ${responses[1].toString()}`\n            )\n        }\n        if (isError(responses[0])) {\n            return responses[0]\n        }\n        if (isError(responses[1])) {\n            return responses[1]\n        }\n        return {}\n    }\n\n    private anonymizeTelemetryEventInput(event: TelemetryEventInput): void {\n        if (isAgentTesting) {\n            event.timestamp = undefined\n            event.parameters.interactionID = undefined\n            event.parameters.billingMetadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.privateMetadata = {}\n        }\n    }\n\n    private anonymizeEvent(event: event): void {\n        if (isAgentTesting) {\n            event.publicArgument = undefined\n            event.argument = undefined\n            event.userCookieID = 'ANONYMOUS_USER_COOKIE_ID'\n            event.hashedLicenseKey = undefined\n        }\n    }\n\n    private async sendEventLogRequestToDotComAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const response = await this.fetchSourcegraphDotcomAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        return extractDataOrError(response, data => data)\n    }\n\n    private async sendEventLogRequestToAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n                LOG_EVENT_MUTATION_DEPRECATED,\n                event\n            )\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    private async sendEventLogRequestToTestingAPI(event: event): Promise<LogEventResponse | Error> {\n        const initialResponse =\n            await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse =\n                await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    public async searchAttribution(snippet: string): Promise<SearchAttributionResults | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SearchAttributionResponse>>(\n            SEARCH_ATTRIBUTION_QUERY,\n            {\n                snippet,\n            }\n        ).then(response => extractDataOrError(response, data => data.snippetAttribution))\n    }\n\n    public async getEvaluatedFeatureFlags(): Promise<Record<string, boolean> | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluatedFeatureFlagsResponse>>(\n            GET_FEATURE_FLAGS_QUERY,\n            {}\n        ).then(response => {\n            return extractDataOrError(response, data =>\n                data.evaluatedFeatureFlags.reduce((acc: Record<string, boolean>, { name, value }) => {\n                    acc[name] = value\n                    return acc\n                }, {})\n            )\n        })\n    }\n\n    public async evaluateFeatureFlag(flagName: string): Promise<boolean | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluateFeatureFlagResponse>>(\n            EVALUATE_FEATURE_FLAG_QUERY,\n            {\n                flagName,\n            }\n        ).then(response => extractDataOrError(response, data => data.evaluateFeatureFlag))\n    }\n\n    private fetchSourcegraphAPI<T>(\n        query: string,\n        variables: Record<string, any> = {}\n    ): Promise<T | Error> {\n        const headers = new Headers(this.config.customHeaders as HeadersInit)\n        headers.set('Content-Type', 'application/json; charset=utf-8')\n        if (this.config.accessToken) {\n            headers.set('Authorization', `token ${this.config.accessToken}`)\n        }\n        if (this.anonymousUserID) {\n            headers.set('X-Sourcegraph-Actor-Anonymous-UID', this.anonymousUserID)\n        }\n\n        addTraceparent(headers)\n        addCustomUserAgent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.config.serverEndpoint })\n        return wrapInActiveSpan(`graphql.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => {\n                    return new Error(`accessing Sourcegraph GraphQL API: ${error} (${url})`)\n                })\n        )\n    }\n\n    // make an anonymous request to the dotcom API\n    private fetchSourcegraphDotcomAPI<T>(\n        query: string,\n        variables: Record<string, any>\n    ): Promise<T | Error> {\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.dotcomUrl.href })\n        const headers = new Headers()\n        addCustomUserAgent(headers)\n        addTraceparent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        return wrapInActiveSpan(`graphql.dotcom.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => new Error(`error fetching Sourcegraph GraphQL API: ${error} (${url})`))\n        )\n    }\n\n    // make an anonymous request to the Testing API\n    private fetchSourcegraphTestingAPI<T>(body: Record<string, any>): Promise<T | Error> {\n        const url = 'http://localhost:49300/.test/testLogging'\n        const headers = new Headers({\n            'Content-Type': 'application/json',\n        })\n        addCustomUserAgent(headers)\n\n        return fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n        })\n            .then(verifyResponseCode)\n            .then(response => response.json() as T)\n            .catch(error => new Error(`error fetching Testing Sourcegraph API: ${error} (${url})`))\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5","content":"\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:91-141","content":"    public stream(\n        params: CompletionParameters,\n        apiVersion: number,\n        signal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        // Provide default stop sequence for starchat models.\n        if (!params.stopSequences && params?.model?.startsWith('openaicompatible/starchat')) {\n            params.stopSequences = ['<|end|>']\n        }\n\n        // This is a technique to convert a function that takes callbacks to an async generator.\n        const values: Promise<CompletionGeneratorValue>[] = []\n        let resolve: ((value: CompletionGeneratorValue) => void) | undefined\n        values.push(\n            new Promise(r => {\n                resolve = r\n            })\n        )\n\n        const send = (value: CompletionGeneratorValue): void => {\n            resolve!(value)\n            values.push(\n                new Promise(r => {\n                    resolve = r\n                })\n            )\n        }\n        const callbacks: CompletionCallbacks = {\n            onChange(text) {\n                send({ type: 'change', text })\n            },\n            onComplete() {\n                send({ type: 'complete' })\n            },\n            onError(error, statusCode) {\n                send({ type: 'error', error, statusCode })\n            },\n        }\n        this._streamWithCallbacks(params, apiVersion, callbacks, signal)\n\n        return (async function* () {\n            for (let i = 0; ; i++) {\n                const val = await values[i]\n                delete values[i]\n                yield val\n                if (val.type === 'complete' || val.type === 'error') {\n                    break\n                }\n            }\n        })()\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/nodeClient.ts:209-234","content":"                        'Could not connect to Cody. Please ensure that you are connected to the Sourcegraph server.'\n                    )\n                }\n                log?.onError(error.message, e)\n                onErrorOnce(error)\n            })\n\n            // If the connection is closed and we did neither:\n            //\n            // - Receive an error HTTP code\n            // - Or any request body\n            //\n            // We still want to close the request.\n            request.on('close', () => {\n                if (!didReceiveAnyEvent) {\n                    logError(\n                        'SourcegraphNodeCompletionsClient',\n                        \"request.on('close')\",\n                        'Connection closed without receiving any events',\n                        { verbose: { bufferText } }\n                    )\n                    onErrorOnce(new Error('Connection closed without receiving any events'))\n                }\n                if (!didSendMessage) {\n                    onErrorOnce(new Error('Connection unexpectedly closed'))\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:954-956","content":"function hasOutdatedAPIErrorMessages(error: Error): boolean {\n    return error.message.includes('Cannot query field')\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:780-795","content":"\n### Changed\n\n- Move decision about which autocomplete deployment to use for StarCoder to the server. [pull/1845](https://github.com/sourcegraph/cody/pull/1845)\n\n## [0.16.0]\n\n### Added\n\n- Chat: A new chat model selection dropdown that allows selecting between different chat models when connected to the sourcegraph.com instance. [pull/1676](https://github.com/sourcegraph/cody/pull/1676)\n- Chat: New button in editor title for restarting chat session in current chat panel (non-sidebar chat view). [pull/1687](https://github.com/sourcegraph/cody/pull/1687)\n- Chat: New `@` command that allows you to attach files via the chat input box. [pull/1631](https://github.com/sourcegraph/cody/pull/1631)\n- Edit: Added a specific, faster, response flow for fixes when triggered directly from code actions. [pull/1639](https://github.com/sourcegraph/cody/pull/1639)\n- Edit: Improved context fetching for quick fixes to better include code related to the problem. [pull/1723](https://github.com/sourcegraph/cody/pull/1723)\n- Chat: Added option to configure whether to add enhanced context from codebase for chat question in the new chat panel. [pull/1738](https://github.com/sourcegraph/cody/pull/1738)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:46-49","content":"interface APIResponse<T> {\n    data?: T\n    errors?: { message: string; path?: string[] }[]\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804","content":"            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \"[\\\"H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\",\\\"PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\"]\"\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \"true\"\n          - name: access-control-allow-origin\n            value: \"\"\n          - name: cache-control\n            value: no-cache, max-age=0\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/VSCodeApi.ts:21-21","content":"let api: VSCodeWrapper\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23","content":"# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:21-44","content":" *   Sourcegraph instance).\n * @param location The absolute URI to convert to a display path.\n */\nexport function displayPath(location: URI): string {\n    const result = _displayPath(location, checkEnvInfo())\n    return typeof result === 'string' ? result : result.toString()\n}\n\n/**\n * Dirname of the location's display path, to display to the user. Similar to\n * `dirname(displayPath(location))`, but it uses the right path separators in `dirname` ('\\' for\n * file URIs on Windows, '/' otherwise).\n *\n * The returned path string MUST ONLY be used for display purposes. It MUST NOT be used to identify\n * or locate files.\n *\n * Use this instead of other seemingly simpler techniques to avoid a few subtle\n * bugs/inconsistencies:\n *\n * - On Windows, Node's `dirname(uri.fsPath)` breaks on a non-`file` URI on Windows because\n *   `dirname` would use '\\' path separators but the URI would have '/' path separators.\n * - In a single-root workspace, Node's `dirname(uri.fsPath)` would return the root directory name,\n *   which is usually superfluous for display purposes. For example, if VS Code is open to a\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:694-705","content":"  sign in to Sourcegraph.com directly. The extension will do this automatically if\n  possible but you may need to sign in again. If you have set up embeddings in\n  Cody App, VScode will now search your local embeddings automatically: You no\n  longer need to have the Cody App open. Note, the sidebar chat indicator may\n  say embeddings were not found while we work on improving chat.\n  [pull/2099](https://github.com/sourcegraph/cody/pull/2099)\n- Commands: Expose commands in the VS Code command palette and clean up the context menu. [pull/1209](https://github.com/sourcegraph/cody/pull/2109)\n- Search: Style and UX improvements to the search panel. [pull/2138](https://github.com/sourcegraph/cody/pull/2138)\n- Chat: Reduce size of chats list blank copy. [pull/2137](https://github.com/sourcegraph/cody/pull/2137)\n- Chat: Update message input placeholder to mention slash commands. [pull/2142](https://github.com/sourcegraph/cody/pull/2142)\n- Inline Chat will soon be deprecated in favor of the improved chat and command experience. It is now disabled by default and does not work when the new chat panel is enabled. [pull/1797](https://github.com/sourcegraph/cody/pull/1797)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:167-203","content":"export type { CompletionLogger, CompletionsClientConfig } from './sourcegraph-api/completions/client'\nexport type {\n    CompletionParameters,\n    CompletionResponse,\n    Event,\n} from './sourcegraph-api/completions/types'\nexport { DOTCOM_URL, LOCAL_APP_URL, isDotCom } from './sourcegraph-api/environments'\nexport {\n    AbortError,\n    NetworkError,\n    RateLimitError,\n    TimeoutError,\n    TracedError,\n    isAbortError,\n    isAuthError,\n    isNetworkError,\n    isRateLimitError,\n} from './sourcegraph-api/errors'\nexport { SourcegraphGraphQLAPIClient, graphqlClient } from './sourcegraph-api/graphql'\nexport {\n    ConfigFeaturesSingleton,\n    addCustomUserAgent,\n    customUserAgent,\n    isNodeResponse,\n    setUserAgent,\n    type BrowserOrNodeResponse,\n    type GraphQLAPIClientConfig,\n    type LogEventMode,\n    type ContextFiltersResult,\n    type CodyContextFilterItem,\n    type RepoListResponse,\n} from './sourcegraph-api/graphql/client'\nexport type {\n    CodyLLMSiteConfiguration,\n    ContextSearchResult,\n    EmbeddingsSearchResult,\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/protocol.ts:273-292","content":"    )\n}\n\nexport type AuthMethod = 'dotcom' | 'github' | 'gitlab' | 'google'\n\n// Provide backward compatibility for the old token regex\n// Details: https://docs.sourcegraph.com/dev/security/secret_formats\nconst sourcegraphTokenRegex =\n    /(sgp_(?:[a-fA-F0-9]{16}|local)|sgp_)?[a-fA-F0-9]{40}|(sgd|slk|sgs)_[a-fA-F0-9]{64}/\n\n/**\n * Checks if the given text matches the regex for a Sourcegraph access token.\n *\n * @param text - The text to check against the regex.\n * @returns Whether the text matches the Sourcegraph token regex.\n */\nexport function isSourcegraphToken(text: string): boolean {\n    return sourcegraphTokenRegex.test(text)\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645","content":"                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \"[\\\"H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\",\\\"X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\"]\"\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \"true\"\n          - name: access-control-allow-origin\n            value: \"\"\n          - name: cache-control\n"}]

 class: Find logic
