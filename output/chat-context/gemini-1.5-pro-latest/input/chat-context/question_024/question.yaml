 question: Where is the logic for opening a new chat window?
# CHAT
# CHAT_QUESTION Where is the logic for opening a new chat window?

# CHAT_REPLY The logic for opening a new chat window in the codebase you provided is spread across multiple files and functions. Here's a breakdown:
# CHAT_REPLY 
# CHAT_REPLY **1. User Interaction:**
# CHAT_REPLY 
# CHAT_REPLY - The user can trigger the "New Chat" action from multiple places in the UI, such as the command menu (`command-menu.test.ts`) or a button in the chat view (`Chat.tsx`).
# CHAT_REPLY 
# CHAT_REPLY **2. Command Handling:**
# CHAT_REPLY 
# CHAT_REPLY - These UI interactions ultimately trigger the `cody.chat.panel.new` command, which is registered in `ChatManager.ts`.
# CHAT_REPLY 
# CHAT_REPLY **3. Chat Manager:**
# CHAT_REPLY 
# CHAT_REPLY - The `ChatManager` class handles the `cody.chat.panel.new` command by calling the `createNewWebviewPanel()` method.
# CHAT_REPLY - Inside `createNewWebviewPanel()`, it uses a debounce function to avoid creating multiple panels in quick succession.
# CHAT_REPLY - The debounced function calls `createWebviewPanel()` on the `chatPanelsManager`.
# CHAT_REPLY 
# CHAT_REPLY **4. Chat Panels Manager:**
# CHAT_REPLY 
# CHAT_REPLY - The `ChatPanelsManager` class is responsible for managing all open chat panels.
# CHAT_REPLY - Its `createWebviewPanel()` method first checks if there's an existing empty "New Chat" panel it can reuse (`ChatPanelsManager.ts`).
# CHAT_REPLY - If not, it creates a new webview panel using VS Code's API and sets up the necessary components for the chat interface.
# CHAT_REPLY 
# CHAT_REPLY **5. Simple Chat Panel Provider:**
# CHAT_REPLY 
# CHAT_REPLY - The actual creation and setup of the webview panel is delegated to the `SimpleChatPanelProvider` class.
# CHAT_REPLY - This class handles loading the chat view HTML, setting up message listeners, and managing the chat session state.
# CHAT_REPLY 
# CHAT_REPLY **In short:** The process starts with a user action, gets translated to a command, handled by the Chat Manager, which delegates the panel creation to the Chat Panels Manager, and finally, the Simple Chat Panel Provider sets up the new chat window.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/helpers.ts:391-394","content":"export async function newChat(page: Page): Promise<FrameLocator> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    return page.frameLocator('iframe.webview').last().frameLocator('iframe')\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:77-95","content":"            vscode.commands.registerCommand('cody.chat.history.clear', () => this.clearHistory()),\n            vscode.commands.registerCommand('cody.chat.history.delete', item => this.clearHistory(item)),\n            vscode.commands.registerCommand('cody.chat.history.edit', item =>\n                this.editChatHistory(item)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.new', () => this.createNewWebviewPanel()),\n            vscode.commands.registerCommand('cody.chat.panel.restore', (id, chat) =>\n                this.restorePanel(id, chat)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.reset', () =>\n                this.chatPanelsManager.resetPanel()\n            ),\n            vscode.commands.registerCommand(CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID, (...args) =>\n                this.passthroughVsCodeOpen(...args)\n            ),\n            vscode.commands.registerCommand('cody.chat.context.add', () => this.sendSelectionToChat())\n        )\n    }\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/open-telemetry/OpenTelemetryService.node.ts:0-95","content":"import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\nimport { registerInstrumentations } from '@opentelemetry/instrumentation'\nimport { HttpInstrumentation } from '@opentelemetry/instrumentation-http'\nimport { Resource } from '@opentelemetry/resources'\nimport { NodeTracerProvider } from '@opentelemetry/sdk-trace-node'\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\n\nimport {\n    type ConfigurationWithAccessToken,\n    FeatureFlag,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport { DiagConsoleLogger, DiagLogLevel, diag } from '@opentelemetry/api'\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { version } from '../../version'\nimport { ConsoleBatchSpanExporter } from './console-batch-span-exporter'\n\nexport type OpenTelemetryServiceConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'experimentalTracing' | 'debugVerbose'\n>\n\nexport class OpenTelemetryService {\n    private tracerProvider?: NodeTracerProvider\n    private unloadInstrumentations?: () => void\n\n    private lastTraceUrl: string | undefined\n    // We use a single promise object that we chain on to, to avoid multiple reconfigure calls to\n    // be run in parallel\n    private reconfigurePromiseMutex: Promise<void> = Promise.resolve()\n\n    constructor(protected config: OpenTelemetryServiceConfig) {\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    public onConfigurationChange(newConfig: OpenTelemetryServiceConfig): void {\n        this.config = newConfig\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    private async reconfigure(): Promise<void> {\n        const isEnabled =\n            this.config.experimentalTracing ||\n            (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.CodyAutocompleteTracing))\n\n        if (!isEnabled) {\n            return\n        }\n\n        const traceUrl = new URL('/-/debug/otlp/v1/traces', this.config.serverEndpoint).toString()\n        if (this.lastTraceUrl === traceUrl) {\n            return\n        }\n        this.lastTraceUrl = traceUrl\n\n        const logLevel = this.config.debugVerbose ? DiagLogLevel.INFO : DiagLogLevel.ERROR\n        diag.setLogger(new DiagConsoleLogger(), logLevel)\n\n        await this.reset()\n\n        this.unloadInstrumentations = registerInstrumentations({\n            instrumentations: [new HttpInstrumentation()],\n        })\n        this.configureTracerProvider(traceUrl)\n    }\n\n    public configureTracerProvider(traceUrl: string): void {\n        this.tracerProvider = new NodeTracerProvider({\n            resource: new Resource({\n                [SemanticResourceAttributes.SERVICE_NAME]: 'cody-client',\n                [SemanticResourceAttributes.SERVICE_VERSION]: version,\n            }),\n        })\n\n        // Add the default tracer exporter used in production.\n        this.tracerProvider.addSpanProcessor(\n            new BatchSpanProcessor(\n                new OTLPTraceExporter({ url: traceUrl, httpAgentOptions: { rejectUnauthorized: false } })\n            )\n        )\n\n        // Add the console exporter used in development for verbose logging and debugging.\n        if (process.env.NODE_ENV === 'development' || this.config.debugVerbose) {\n            this.tracerProvider.addSpanProcessor(new BatchSpanProcessor(new ConsoleBatchSpanExporter()))\n        }\n\n        this.tracerProvider.register()\n    }\n\n    public async reset(): Promise<void> {\n        await this.tracerProvider?.shutdown()\n        this.unloadInstrumentations?.()\n    }\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:776-807","content":"            },\n        })\n    }\n\n    /**\n     * Low-level utility to post a message to the webview, pending initialization.\n     *\n     * cody-invariant: this.webview?.postMessage should never be invoked directly\n     * except within this method.\n     */\n    private postMessage(message: ExtensionMessage): Thenable<boolean | undefined> {\n        return this.initDoer.do(() => this.webview?.postMessage(message))\n    }\n\n    private postChatTitle(): void {\n        if (this.webviewPanel) {\n            this.webviewPanel.title = this.chatModel.getChatTitle()\n        }\n    }\n\n    // #endregion\n    // =======================================================================\n    // #region chat request lifecycle methods\n    // =======================================================================\n\n    /**\n     * Constructs the prompt and updates the UI with the context used in the prompt.\n     */\n    private async buildPrompt(\n        prompter: IPrompter,\n        sendTelemetry?: (contextSummary: any, privateContextStats?: any) => void\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.test.ts:0-46","content":"import { describe, expect, test } from 'vitest'\n\nimport { getChatPanelTitle } from './chat-helpers'\n\ndescribe('getChatPanelTitle', () => {\n    test('returns default title when no lastDisplayText', () => {\n        const result = getChatPanelTitle()\n        expect(result).toEqual('New Chat')\n    })\n\n    test('long titles will be truncated', () => {\n        const longTitle = 'This is a very long title that should get truncated by the function'\n        const result = getChatPanelTitle(longTitle)\n        expect(result).toEqual('This is a very long title...')\n    })\n\n    test('keeps command key', () => {\n        const title = '/explain this symbol'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain this symbol')\n    })\n\n    test('keeps command key with file path', () => {\n        const title = '/explain [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain @a.ts')\n    })\n\n    test('removes markdown links', () => {\n        const title = 'Summarize this file [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Summarize this file @a.ts')\n    })\n\n    test('removes multiple markdown links', () => {\n        const title = '[_@a.py_](a.py) [_@b.py_](b.py) explain'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('@a.py @b.py explain')\n    })\n\n    test('truncates long title with multiple markdown links', () => {\n        const title = 'Explain the relationship...'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Explain the relationship....')\n    })\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:23-48","content":"\n    const heyTreeItem = page.getByRole('treeitem', { name: 'Hey' })\n    const holaTreeItem = page.getByRole('treeitem', { name: 'Hola' })\n\n    const [chatPanelFrame, chatInput] = await createEmptyChatPanel(page)\n\n    await chatInput.fill('Hey')\n    await chatInput.press('Enter')\n\n    // Check if chat shows up in sidebar chat history tree view\n    await expect(heyTreeItem).toBeVisible()\n\n    // Wait at least 1 second to ensure that the 2 chats have different IDs (which are currently\n    // created using `new Date(Date.now()).toUTCString()`, so they are the same if they are\n    // generated in the same second).\n    //\n    // TODO(sqs): investigate and fix the underlying bug here\n    await page.waitForTimeout(1000)\n\n    // Clear and restart chat session\n    // All current messages should be removed, and the panel name should be updated to 'New Chat'\n    await chatInput.fill('/reset')\n    await chatInput.press('Enter')\n    await expect(chatPanelFrame.getByText('Hey')).not.toBeVisible()\n    await expect(page.getByRole('tab', { name: 'New Chat' })).toBeVisible()\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.ts:0-39","content":"import * as vscode from 'vscode'\n\nimport type { RangeData } from '@sourcegraph/cody-shared'\n\nexport async function openFile(\n    uri: vscode.Uri,\n    range?: RangeData,\n    currentViewColumn?: vscode.ViewColumn\n): Promise<void> {\n    let viewColumn = vscode.ViewColumn.Beside\n    if (currentViewColumn) {\n        viewColumn = currentViewColumn - 1 || currentViewColumn + 1\n    }\n    const doc = await vscode.workspace.openTextDocument(uri)\n    // +1 because selection range starts at 0 while editor line starts at 1\n    const selection = range && new vscode.Range(range.start.line, 0, range.end.line + 1, 0)\n    await vscode.window.showTextDocument(doc, {\n        selection,\n        viewColumn,\n        preserveFocus: true,\n        preview: true,\n    })\n}\n\nexport function getChatPanelTitle(lastHumanText?: string, truncateTitle = true): string {\n    if (!lastHumanText) {\n        return 'New Chat'\n    }\n\n    let text = lastHumanText\n    // Regex to remove the markdown formatted links with this format: '[_@FILENAME_]()'\n    const MARKDOWN_LINK_REGEX = /\\[_(.+?)_]\\((.+?)\\)/g\n    text = text.replaceAll(MARKDOWN_LINK_REGEX, '$1')?.trim()\n    if (!truncateTitle) {\n        return text\n    }\n    // truncate title that is too long\n    return text.length > 25 ? `${text.slice(0, 25).trim()}...` : text\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1017-1043","content":"\n    // #endregion\n    // =======================================================================\n    // #region session management\n    // =======================================================================\n\n    // A unique identifier for this SimpleChatPanelProvider instance used to identify\n    // it when a handle to this specific panel provider is needed.\n    public get sessionID(): string {\n        return this.chatModel.sessionID\n    }\n\n    // Sets the provider up for a new chat that is not being restored from a\n    // saved session.\n    public async newSession(): Promise<void> {\n        // Set the remote search's selected repos to the workspace repo list\n        // by default.\n        this.remoteSearch?.setRepos(\n            (await this.repoPicker?.getDefaultRepos()) || [],\n            RepoInclusion.Manual\n        )\n    }\n\n    // Attempts to restore the chat to the given sessionID, if it exists in\n    // history. If it does, then saves the current session and cancels the\n    // current in-progress completion. If the chat does not exist, then this\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:48-533","content":"export const Chat: React.FunctionComponent<React.PropsWithChildren<ChatboxProps>> = ({\n    welcomeMessage,\n    messageInProgress,\n    transcript,\n    vscodeAPI,\n    telemetryService,\n    isTranscriptError,\n    chatEnabled,\n    userInfo,\n    guardrails,\n    chatIDHistory,\n    isWebviewActive,\n    isNewInstall,\n    userContextFromSelection,\n}) => {\n    const [messageBeingEdited, setMessageBeingEdited] = useState<number | undefined>(undefined)\n\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n            }\n            const editorValue = editorRef.current.getSerializedValue()\n            if (!editorValue.text.trim()) {\n                throw new Error('Chat message cannot be empty')\n            }\n            // Handle edit requests\n            if (submitType === 'edit') {\n                if (messageBeingEdited === undefined) {\n                    throw new Error('unexpected: messageBeingEdited is undefined')\n                }\n                vscodeAPI.postMessage({\n                    command: 'edit',\n                    index: messageBeingEdited!,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            } else {\n                vscodeAPI.postMessage({\n                    command: 'submit',\n                    submitType,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            }\n        },\n        [addEnhancedContext, messageBeingEdited, vscodeAPI]\n    )\n\n    const feedbackButtonsOnSubmit = useCallback(\n        (text: string) => {\n            const eventData = {\n                value: text,\n                lastChatUsedEmbeddings: Boolean(\n                    transcript.at(-1)?.contextFiles?.some(file => file.source === 'embeddings')\n                ),\n                transcript: '',\n            }\n\n            if (userInfo.isDotComUser) {\n                eventData.transcript = JSON.stringify(transcript)\n            }\n\n            telemetryService.log(`CodyVSCodeExtension:codyFeedback:${text}`, eventData)\n        },\n        [telemetryService, transcript, userInfo]\n    )\n\n    const copyButtonOnSubmit = useCallback(\n        (text: string, eventType: 'Button' | 'Keydown' = 'Button') => {\n            const op = 'copy'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const insertButtonOnSubmit = useCallback(\n        (text: string, newFile = false) => {\n            const op = newFile ? 'newFile' : 'insert'\n            const eventType = 'Button'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const postMessage = useCallback<ApiPostMessage>(msg => vscodeAPI.postMessage(msg), [vscodeAPI])\n\n    const setInputFocus = useCallback((focus: boolean): void => {\n        editorRef.current?.setFocus(focus)\n    }, [])\n\n    // When New Chat Mode is enabled, all non-edit questions will be asked in a new chat session\n    // Users can toggle this feature via \"shift\" + \"Meta(Mac)/Control\" keys\n    const [enableNewChatMode, setEnableNewChatMode] = useState(false)\n\n    const lastHumanMessageIndex = useMemo<number | undefined>(() => {\n        if (!transcript?.length) {\n            return undefined\n        }\n        const index = transcript.findLastIndex(msg => msg.speaker === 'human')\n\n        return index\n    }, [transcript])\n\n    /**\n     * Sets the state to edit a message at the given index in the transcript.\n     * Checks that the index is valid, then gets the display text  to set as the\n     * form input.\n     *\n     * An undefined index number means there is no message being edited.\n     */\n    const setEditMessageState = useCallback(\n        (index?: number): void => {\n            // When a message is no longer being edited\n            // we will reset the form input fill to empty state\n            if (index === undefined && index !== messageBeingEdited) {\n                setEditorState(null)\n            }\n            setMessageBeingEdited(index)\n            if (index === undefined || index > transcript.length) {\n                return\n            }\n            const messageAtIndex = transcript[index]\n            if (messageAtIndex) {\n                setEditorState(serializedPromptEditorStateFromChatMessage(messageAtIndex))\n            }\n            // move focus back to chatbox\n            setInputFocus(true)\n        },\n        [messageBeingEdited, transcript, setEditorState, setInputFocus]\n    )\n\n    /**\n     * Reset current chat view with a new empty chat session.\n     *\n     * Calls setEditMessageState() to reset any in-progress edit state.\n     * Sends a 'reset' command to postMessage to reset the chat on the server.\n     */\n    const onChatResetClick = useCallback(\n        (eventType: 'keyDown' | 'click' = 'click') => {\n            setEditMessageState()\n            postMessage?.({ command: 'reset' })\n            postMessage?.({\n                command: 'event',\n                eventName: 'CodyVSCodeExtension:chatActions:reset:executed',\n                properties: { source: 'chat', eventType },\n            })\n        },\n        [postMessage, setEditMessageState]\n    )\n\n    const submitInput = useCallback(\n        (submitType: WebviewChatSubmitType): void => {\n            if (messageInProgress && submitType !== 'edit') {\n                return\n            }\n            onSubmit(submitType)\n\n            setEditorState(null)\n            setEditMessageState()\n        },\n        [messageInProgress, onSubmit, setEditMessageState, setEditorState]\n    )\n\n    const onChatSubmit = useCallback((): void => {\n        // Submit edits when there is one being edited\n        if (messageBeingEdited !== undefined) {\n            onAbortMessageInProgress()\n            submitInput('edit')\n            return\n        }\n\n        // Submit chat only when input is not empty and not in progress\n        if (!isEmptyEditorValue && !messageInProgress?.speaker) {\n            const submitType = enableNewChatMode ? 'user-newchat' : 'user'\n            submitInput(submitType)\n        }\n    }, [\n        isEmptyEditorValue,\n        messageBeingEdited,\n        messageInProgress?.speaker,\n        enableNewChatMode,\n        submitInput,\n        onAbortMessageInProgress,\n    ])\n\n    const onEditorEscapeKey = useCallback((): void => {\n        // Close the enhanced context settings modal if it's open\n        setIsEnhancedContextOpen(false)\n\n        // Exits editing mode if a message is being edited\n        if (messageBeingEdited !== undefined) {\n            setEditMessageState()\n            return\n        }\n\n        // Aborts a message in progress if one exists\n        if (messageInProgress?.speaker) {\n            onAbortMessageInProgress()\n            return\n        }\n    }, [messageBeingEdited, setEditMessageState, messageInProgress, onAbortMessageInProgress])\n\n    const onEditorEnterKey = useCallback(\n        (event: KeyboardEvent | null): void => {\n            // Submit input on Enter press (without shift) when input is not empty.\n            if (event && !event.shiftKey && !event.isComposing && !isEmptyEditorValue) {\n                event.preventDefault()\n                onChatSubmit()\n                return\n            }\n        },\n        [onChatSubmit, isEmptyEditorValue]\n    )\n\n    const onEditorKeyDown = useCallback(\n        (event: KeyboardEvent, caretPosition: number): void => {\n            // Check if the Ctrl key is pressed on Windows/Linux or the Cmd key is pressed on macOS\n            const isModifierDown = isMac ? event.metaKey : event.ctrlKey\n            if (isModifierDown) {\n                // Ctrl/Cmd + / - Clears the chat and starts a new session\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick('keyDown')\n                    return\n                }\n                // Ctrl/Cmd + K - When not already editing, edits the last human message\n                if (messageBeingEdited === undefined && event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    setEditMessageState(lastHumanMessageIndex)\n\n                    postMessage?.({\n                        command: 'event',\n                        eventName: 'CodyVSCodeExtension:chatActions:editLast:executed',\n                        properties: { source: 'chat', eventType: 'keyDown' },\n                    })\n                    return\n                }\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            if (event.altKey && event.key === 'c') {\n                event.preventDefault()\n                event.stopPropagation()\n                return\n            }\n\n            // Allow navigation/selection with Ctrl(+Shift?)+Arrows\n            const arrowKeys = new Set(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'])\n            if (event.ctrlKey && arrowKeys.has(event.key)) {\n                return\n            }\n\n            // Handles keyboard shortcuts with Ctrl key.\n            // Checks if the Ctrl key is pressed with a key not in the allow list\n            // to avoid triggering default browser shortcuts and bubbling the event.\n            const ctrlKeysAllowList = new Set([\n                'a',\n                'c',\n                'v',\n                'x',\n                'y',\n                'z',\n                'Enter',\n                'Shift' /* follow-up */,\n            ])\n            if (event.ctrlKey && !ctrlKeysAllowList.has(event.key)) {\n                event.preventDefault()\n                return\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            const vscodeCodyShortcuts = new Set(['Slash', 'KeyC'])\n            if (event.altKey && vscodeCodyShortcuts.has(event.code)) {\n                event.preventDefault()\n                return\n            }\n\n            // TODO (bee) - Update to use Option key instead\n            // TODO (bee) - remove once updated to use Option key\n            // Toggles between new chat mode and regular chat mode\n            if (event.altKey && event.shiftKey && isModifierDown) {\n                // use as a temporary block for this key combination\n                event.preventDefault()\n                setEnableNewChatMode(!enableNewChatMode)\n                return\n            }\n\n            // If there's no input and ArrowUp is pressed, edit the last message.\n            if (event.key === 'ArrowUp' && isEmptyEditorValue) {\n                setEditMessageState(lastHumanMessageIndex)\n            }\n        },\n        [\n            messageBeingEdited,\n            isEmptyEditorValue,\n            onChatResetClick,\n            setEditMessageState,\n            lastHumanMessageIndex,\n            enableNewChatMode,\n            postMessage,\n        ]\n    )\n\n    // Set up the message listener for adding new context from user's editor to chat.\n    // Turns the new context into @-mentions token in chat.\n    useEffect(() => {\n        if (!userContextFromSelection.length) {\n            return\n        }\n        editorRef.current?.addContextItemAsToken(userContextFromSelection)\n    }, [userContextFromSelection])\n\n    // Focus the textarea when the webview (re)gains focus (unless there is text selected or a modal\n    // is open). This makes it so that the user can immediately start typing to Cody after invoking\n    // `Cody: Focus on Chat View` with the keyboard.\n    useEffect(() => {\n        // Focus the input when the enhanced context settings modal is closed\n        setInputFocus(!isEnhancedContextOpen)\n        // Add window focus event listener to focus the input when the window is focused\n        const handleFocus = (): void => {\n            if (document.getSelection()?.isCollapsed && !isEnhancedContextOpen) {\n                setInputFocus(true)\n            }\n        }\n        window.addEventListener('focus', handleFocus)\n        return () => {\n            window.removeEventListener('focus', handleFocus)\n        }\n    }, [setInputFocus, isEnhancedContextOpen])\n\n    const onCancelEditClick = useCallback(() => setEditMessageState(), [setEditMessageState])\n    const onEditLastMessageClick = useCallback(\n        () => setEditMessageState(lastHumanMessageIndex),\n        [setEditMessageState, lastHumanMessageIndex]\n    )\n\n    const onRestoreLastChatClick = useMemo(\n        () =>\n            // Display the restore button if there is a previous chat id in current window\n            // And the current chat window is new\n            chatIDHistory.length > 1\n                ? () =>\n                      postMessage?.({\n                          command: 'restoreHistory',\n                          chatID: chatIDHistory.at(-2),\n                      })\n                : undefined,\n        [chatIDHistory, postMessage]\n    )\n\n    // biome-ignore lint/correctness/useExhaustiveDependencies: We don't want to re-run this effect.\n    const onEnhancedContextTogglerClick = useCallback((open: boolean) => {\n        if (!isEnhancedContextOpen && !open) {\n            setInputFocus(true)\n        }\n        setIsEnhancedContextOpen(open)\n    }, [])\n\n    const [isEditorFocused, setIsEditorFocused] = useState(false)\n\n    const isNewChat = transcript.length === 0\n    const TIPS = '(@ for files, @# for symbols)'\n    const placeholder = chatEnabled\n        ? isNewChat\n            ? `Message ${TIPS}`\n            : `Follow-Up Message ${TIPS}`\n        : 'Chat has been disabled by your Enterprise instance site administrator'\n\n    return (\n        <div className={classNames(styles.innerContainer)}>\n            {\n                <Transcript\n                    transcript={transcript}\n                    welcomeMessage={welcomeMessage}\n                    messageInProgress={messageInProgress}\n                    messageBeingEdited={messageBeingEdited}\n                    setMessageBeingEdited={setEditMessageState}\n                    className={styles.transcriptContainer}\n                    feedbackButtonsOnSubmit={feedbackButtonsOnSubmit}\n                    copyButtonOnSubmit={copyButtonOnSubmit}\n                    insertButtonOnSubmit={insertButtonOnSubmit}\n                    isTranscriptError={isTranscriptError}\n                    userInfo={userInfo}\n                    postMessage={postMessage}\n                    guardrails={guardrails}\n                />\n            }\n            <form className={classNames(styles.inputRow)}>\n                {/* Don't show chat action buttons on empty chat session unless it's a new cha*/}\n\n                <ChatActions\n                    setInputFocus={setInputFocus}\n                    isWebviewActive={isWebviewActive}\n                    isEmptyChat={transcript.length < 1}\n                    isMessageInProgress={!!messageInProgress?.speaker}\n                    isEditing={transcript.length > 1 && messageBeingEdited !== undefined}\n                    isEmptyEditorValue={isEmptyEditorValue}\n                    isEditorFocused={isEditorFocused}\n                    onChatResetClick={onChatResetClick}\n                    onCancelEditClick={onCancelEditClick}\n                    onEditLastMessageClick={onEditLastMessageClick}\n                    onRestoreLastChatClick={onRestoreLastChatClick}\n                />\n\n                <div className={styles.textAreaContainer}>\n                    <div className={styles.editorOuterContainer}>\n                        <PromptEditor\n                            placeholder={placeholder}\n                            onChange={onEditorChange}\n                            onFocusChange={setIsEditorFocused}\n                            disabled={!chatEnabled}\n                            onKeyDown={onEditorKeyDown}\n                            onEnterKey={onEditorEnterKey}\n                            onEscapeKey={onEditorEscapeKey}\n                            editorRef={editorRef}\n                        />\n                        <div className={styles.contextButton}>\n                            <EnhancedContextSettings\n                                isOpen={isEnhancedContextOpen}\n                                setOpen={onEnhancedContextTogglerClick}\n                                presentationMode={userInfo.isDotComUser ? 'consumer' : 'enterprise'}\n                                isNewInstall={isNewInstall}\n                            />\n                        </div>\n                    </div>\n                    <SubmitButton\n                        type={\n                            messageBeingEdited === undefined\n                                ? enableNewChatMode\n                                    ? 'user-newchat'\n                                    : 'user'\n                                : 'edit'\n                        }\n                        className={styles.submitButton}\n                        onClick={onChatSubmit}\n                        disabled={isEmptyEditorValue && !messageInProgress}\n                        onAbortMessageInProgress={\n                            messageInProgress ? onAbortMessageInProgress : undefined\n                        }\n                    />\n                </div>\n            </form>\n        </div>\n    )\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/command-menu.test.ts:20-35","content":"\n    // Submit a chat question via command menu using \"New Chat\" option in Command Menu\n    await page.getByRole('button', { name: /Commands \\(.*/ }).dblclick()\n    const commandInputBox = page.getByPlaceholder(/Search for a command or enter/)\n    await expect(commandInputBox).toBeVisible()\n    await commandInputBox.fill('new chat submitted from command menu')\n    // this will fail if more than 1 New Chat item in the menu is found\n    await page.getByLabel('comment  New Chat, Start a new chat', { exact: true }).hover()\n    await expect(page.getByLabel('comment  New Chat, Start a new chat', { exact: true })).toBeVisible()\n    await page.getByLabel('wand  Edit Code, Start a code edit', { exact: true }).hover()\n    await expect(page.getByLabel('wand  Edit Code, Start a code edit', { exact: true })).toBeVisible()\n    await page.getByLabel('Start a new chat').locator('a').click()\n\n    // the question should show up in the chat panel on submit\n    const chatPanel = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:56-80","content":"\n    private options: ChatPanelProviderOptions\n\n    // Tree view for chat history\n    public treeViewProvider = new TreeViewProvider('chat', featureFlagProvider)\n    public treeView\n\n    public supportTreeViewProvider = new TreeViewProvider('support', featureFlagProvider)\n\n    // We keep track of the currently authenticated account and dispose open chats when it changes\n    private currentAuthAccount: undefined | { endpoint: string; primaryEmail: string; username: string }\n\n    protected disposables: vscode.Disposable[] = []\n\n    constructor(\n        { extensionUri, ...options }: SidebarViewOptions,\n        private chatClient: ChatClient,\n        private readonly localEmbeddings: LocalEmbeddingsController | null,\n        private readonly contextRanking: ContextRankingController | null,\n        private readonly symf: SymfRunner | null,\n        private readonly enterpriseContext: EnterpriseContextFactory | null,\n        private readonly guardrails: Guardrails\n    ) {\n        logDebug('ChatPanelsManager:constructor', 'init')\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:238-257","content":"    private async passthroughVsCodeOpen(...args: unknown[]): Promise<void> {\n        if (args[1] && (args[1] as any).viewColumn === vscode.ViewColumn.Beside) {\n            // Make vscode.ViewColumn.Beside work as expected from a webview: open it to the side,\n            // instead of always opening a new editor to the right.\n            //\n            // If the active editor is undefined, that means the chat panel is the active editor, so\n            // we will open the file in the first visible editor instead.\n            const textEditor = vscode.window.activeTextEditor || vscode.window.visibleTextEditors[0]\n            ;(args[1] as any).viewColumn = textEditor ? textEditor.viewColumn : vscode.ViewColumn.Beside\n        }\n        if (args[1] && Array.isArray((args[1] as any).selection)) {\n            // Fix a weird issue where the selection was getting encoded as a JSON array, not an\n            // object.\n            ;(args[1] as any).selection = new vscode.Selection(\n                (args[1] as any).selection[0],\n                (args[1] as any).selection[1]\n            )\n        }\n        await vscode.commands.executeCommand('vscode.open', ...args)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287","content":"\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the “Chats” panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the “Chats” panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the “Chats” panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the “Chats” panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \"Enhanced Context\" icon next to the chat input.\n- [ ] Verify that \"Enhanced Context\" is enabled by default.\n\n### Consumer\n\nSet up steps:\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:266-276","content":"    private async createNewWebviewPanel(): Promise<ChatSession | undefined> {\n        const debounceCreatePanel = debounce(() => this.chatPanelsManager.createWebviewPanel(), 250, {\n            leading: true,\n            trailing: true,\n        })\n\n        if (this.chatPanelsManager) {\n            return debounceCreatePanel()\n        }\n        return undefined\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:138-165","content":"        // Check if any existing panel is available\n        // NOTE: Never reuse webviews when running inside the agent.\n        if (this.activePanelProvider && !this.options.config.isRunningInsideAgent) {\n            return this.activePanelProvider\n        }\n\n        const provider = await this.createWebviewPanel()\n        return provider\n    }\n\n    /**\n     * Creates a new webview panel for chat.\n     */\n    public async createWebviewPanel(\n        chatID?: string,\n        chatQuestion?: string,\n        panel?: vscode.WebviewPanel\n    ): Promise<SimpleChatPanelProvider> {\n        if (chatID && this.panelProviders.map(p => p.sessionID).includes(chatID)) {\n            const provider = this.panelProviders.find(p => p.sessionID === chatID)\n            if (provider?.webviewPanel) {\n                provider.webviewPanel?.reveal()\n                this.activePanelProvider = provider\n                void this.selectTreeItem(chatID)\n                return provider\n            }\n        }\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:124-127","content":"    public async getNewChatPanel(): Promise<SimpleChatPanelProvider> {\n        const provider = await this.createWebviewPanel()\n        return provider\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:89-117","content":"                // Ctrl/Cmd + K: edits the last human message\n                if (event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onEditLastMessageClick()\n                    return\n                }\n\n                // Ctrl/Cmd + /: starts a new chat\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick()\n                    return\n                }\n            }\n        }\n        document.addEventListener('keydown', onKeyDown)\n    }, [onEditLastMessageClick, onChatResetClick, isMac])\n\n    useEffect(() => {\n        // Focus on the Edit button after a question has been submitted\n        // This allows users to edit the message they just submitted right away\n        if (!isEditing && isMessageInProgress) {\n            setInputFocus(false)\n            buttonRef?.current?.focus()\n        }\n        // Remove focus on the Edit button when stream ends\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1254-1272","content":"function newChatModelFromSerializedChatTranscript(\n    json: SerializedChatTranscript,\n    modelID: string\n): SimpleChatModel {\n    return new SimpleChatModel(\n        json.chatModel || modelID,\n        json.interactions.flatMap((interaction: SerializedChatInteraction): ChatMessage[] =>\n            [\n                PromptString.unsafe_deserializeChatMessage(interaction.humanMessage),\n                interaction.assistantMessage\n                    ? PromptString.unsafe_deserializeChatMessage(interaction.assistantMessage)\n                    : null,\n            ].filter(isDefined)\n        ),\n        json.id,\n        json.chatTitle,\n        json.enhancedContext?.selectedRepos\n    )\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/llm-providers/groq/index.ts:24-52","content":" */\ninterface GroqChatMessage extends OpenAIMessage {\n    name?: string\n    seed?: number\n}\n\n/**\n * Default context window sizes for various Groq models.\n *\n * @see https://console.groq.com/docs/models\n */\nexport const GROQ_DEFAULT_CONTEXT_WINDOW = {\n    mixtral: 32768,\n    llama2: 4096,\n    gemma: 8192,\n}\n\n/**\n * Represents the response from the Groq Chat Completion API.\n *\n * @property {string} model - The model used for the completion.\n * @property {GroqCompletionsError} [error] - Any error that occurred during the completion.\n * @property {Object[]} [choices] - The completion choices returned by the API.\n * @property {string} [choices[].finish_reason] - The reason the completion finished.\n * @property {string|null} [choices[].logprobs] - The log probabilities of the tokens in the completion.\n * @property {GroqChatMessage} [choices[].message] - The completion message.\n * @property {boolean} done - Indicates whether the completion is done.\n * @property {GroqCompletionsResponseUsage} [usage] - Usage information for the completion.\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.test.ts:0-128","content":"import { describe, expect, it } from 'vitest'\nimport { URI } from 'vscode-uri'\n\nimport { convertFileUriToTestFileUri, createDefaultTestFile } from './new-test-file'\n\ndescribe('createDefaultTestFile', () => {\n    it.each([\n        ['/path/to/file.java', '/path/to/fileTest.java'],\n        ['/path/to/file.js', '/path/to/file.test.js'],\n        ['/path/to/file.go', '/path/to/file_test.go'],\n        ['/path/to/test_file.py', '/path/to/test_file.py'],\n        ['/path/to/test-file.js', '/path/to/test-file.test.js'],\n        ['/path/to/node_modules/file.js', '/path/to/node_modules/file.test.js'],\n        ['/path/to/node_modules/file_test.ts', '/path/to/node_modules/file_test.ts'],\n        ['/path/to/fileTest.js', '/path/to/fileTest.js'],\n        ['test_example.py', 'test_example.py'],\n        ['example.cpp', 'exampleTest.cpp'],\n        ['example.test.js', 'example.test.js'],\n        ['Example.java', 'ExampleTest.java'],\n        ['ExampleTest.java', 'ExampleTest.java'],\n        ['example.rb', 'example_spec.rb'],\n        ['Example.cs', 'ExampleTest.cs'],\n        ['ExampleTest.php', 'ExampleTest.php'],\n        ['ExampleSpec.scala', 'ExampleSpec.scala'],\n        ['file.rb', 'file_spec.rb'],\n        ['contest.ts', 'contest.test.ts'],\n    ])('for file %j it returns %j', (file, test) => {\n        expect(createDefaultTestFile(URI.file(file)).toString()).toBe(URI.file(test).toString())\n    })\n})\n\ndescribe('convertFileUriToTestFileUri', () => {\n    it('should return the current file uri if it is already a test file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.test.ts')).toString()).toBe(\n            URI.file('/path/to/testFile.test.ts').toString()\n        )\n    })\n\n    it('should return the current file uri if it is already a spec file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.spec.rb')).toString()).toBe(\n            URI.file('/path/to/testFile.spec.rb').toString()\n        )\n    })\n\n    it('should generate a test file uri from a non-test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate the default spec file uri from a non-test file uri for ruby', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.rb'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_spec.rb').toString())\n    })\n\n    it('should follow an existing test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/existingTestFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should respect test file with different naming conventions', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should handle a non-alphanumeric character at the test character index', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/test-ExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.py'),\n                URI.file('/path/to/testFile_test.py')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_test.py').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python when no existing test path provided', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/test-file.py')).toString()).toBe(\n            URI.file('/path/to/test-file_test.py').toString()\n        )\n    })\n\n    it('should generate the default spec file uri for ruby when no existing test files is found', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/file.rb'), undefined).toString()).toBe(\n            URI.file('/path/to/file_spec.rb').toString()\n        )\n    })\n\n    it('should generate the corrent test file uri for window files', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\path\\\\to\\\\file.ts'),\n                URI.file('\\\\path\\\\to\\\\testFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('\\\\path\\\\to\\\\file.test.ts').toString())\n    })\n\n    it('should follow an existing test file uri format to generate new test file uri on windows', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\server\\\\c$\\\\folder\\\\current-file.go'),\n                URI.file('\\\\path\\\\to\\\\file_test.go')\n            ).toString()\n        ).toBe(URI.file('\\\\server\\\\c$\\\\folder\\\\current-file_test.go').toString())\n    })\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40","content":"/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.ts:0-94","content":"import { type URI, Utils } from 'vscode-uri'\n\nimport { uriBasename, uriExtname, uriParseNameAndExtension } from '@sourcegraph/cody-shared'\n\nimport { isValidTestFile } from './test-commands'\n\n// Language extension that uses '.test' suffix for test files\nconst TEST_FILE_DOT_SUFFIX_EXTENSIONS = new Set(['js', 'ts', 'jsx', 'tsx'])\n// language extension that uses '_test' suffix for test files\nconst TEST_FILE_DASH_SUFFIX_EXTENSIONS = new Set(['py', 'go'])\n// language extension that uses '_spec' suffix for most unit test files\nconst TEST_FILE_SPEC_SUFFIX_EXTENSIONS = new Set(['rb'])\n\n/**\n * NOTE: This is only being used as fallback when test files cannot be found in current workspace\n *\n * Generates a generic test file name and path for the given file\n * based on conventions for the file extension.\n * @param file - The original file URI\n * @returns The generated test file URI\n */\nexport function createDefaultTestFile(file: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(file)) {\n        return file\n    }\n\n    const extWithDot = uriExtname(file)\n    const fileName = uriBasename(file, extWithDot)\n    const ext = extWithDot.slice(1)\n\n    let testFileName = `${fileName}Test.${ext}`\n    if (TEST_FILE_DOT_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}.test.${ext}`\n    }\n    if (TEST_FILE_DASH_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_test.${ext}`\n    }\n    if (TEST_FILE_SPEC_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_spec.${ext}`\n    }\n\n    return Utils.joinPath(file, '..', testFileName)\n}\n\n/**\n * Converts a file URI to a corresponding test file URI using conventions based on file extension.\n *\n * If not a test file, generates a default test file name based on file extension conventions.\n *\n * If existing test file URI provided, attempts to match its naming convention.\n * Falls back to default test file name if naming does not follow conventions.\n * @param currentFile - Original file to convert\n * @param testFile - Optional existing test file to match naming with\n * @returns The converted test file\n */\nexport function convertFileUriToTestFileUri(currentFile: URI, testFile?: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(currentFile)) {\n        return currentFile\n    }\n\n    // If there is an existing test file, create the test file following its naming convention\n    if (testFile?.path && isValidTestFile(testFile)) {\n        const parsedCurrentFile = uriParseNameAndExtension(currentFile)\n        const parsedTestFile = uriParseNameAndExtension(testFile)\n        if (parsedCurrentFile.ext === parsedTestFile.ext) {\n            const testFileName = parsedTestFile.name\n            const index = testFileName.lastIndexOf('test') || testFileName.lastIndexOf('spec')\n            const endsWithCapitalTest = testFileName.endsWith('Test') || testFileName.endsWith('Spec')\n            // This checks if the existing test file has a non-alphanumeric character at the test character index\n            // e.g. \"_test\", \".test\", \"test_\"\n            // This is because files with 'test' in the name are not always a test file, while\n            // file with non-alphanumeric character before 'test' are more likely to be test files\n            // e.g. \"testPath\" or \"test-helper\" are not likely test files\n            const hasVerifiedTestPath = index > -1 && !/^[\\da-z]$/i.test(testFileName[index - 1])\n            // If yes, generate a test file by replacing existing test file name with current file name\n            if (endsWithCapitalTest || hasVerifiedTestPath) {\n                // Remove everything after the test character index from the existing test file name\n                // then replace it with the current file name\n                // e.g. \"current_file\" & \"existing_test\" => \"current_file_test\"\n                const strippedTestFileName = testFileName.slice(0, index - 1)\n                const newTestFileName = testFileName.replace(\n                    strippedTestFileName,\n                    parsedCurrentFile.name\n                )\n                return Utils.joinPath(currentFile, '..', `${newTestFileName}${parsedCurrentFile.ext}`)\n            }\n        }\n    }\n\n    // else, generate a generic test file\n    return createDefaultTestFile(currentFile)\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-input.test.ts:76-94","content":"\n    // Submit a new chat question from the command menu.\n    await page.getByLabel(/Commands \\(/).hover()\n    await page.getByLabel(/Commands \\(/).click()\n    await page.waitForTimeout(100)\n    // HACK: The 'delay' command is used to make sure the response is streamed 400ms after\n    // the command is sent. This provides us with a small window to move the cursor\n    // from the new opened chat window back to the editor, before the chat has finished\n    // streaming its response.\n    await chatInput.fill('delay')\n    await chatInput.press('Enter')\n    await expect(chatInput).toBeFocused()\n\n    // Ensure equal-width columns so we can be sure the code we're about to click is in view (and is\n    // not out of the editor's scroll viewport). This became required due to new (undocumented)\n    // behavior in VS Code 1.88.0 where the Cody panel would take up ~80% of the width when it was\n    // focused, meaning that the buzz.ts editor tab would take up ~20% and the text we intend to\n    // click would be only partially visible, making the click() call fail.\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/chat/chat.ts:25-59","content":"    public chat(\n        messages: Message[],\n        params: Partial<ChatParameters> & Pick<ChatParameters, 'maxTokensToSample'>,\n        abortSignal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        const authStatus = this.getAuthStatus()\n        const useApiV1 = authStatus.codyApiVersion >= 1 && params.model?.includes('claude-3')\n        const isLastMessageFromHuman = messages.length > 0 && messages.at(-1)!.speaker === 'human'\n\n        const augmentedMessages =\n            params?.model?.startsWith('fireworks/') || useApiV1\n                ? sanitizeMessages(messages)\n                : isLastMessageFromHuman\n                  ? messages.concat([{ speaker: 'assistant' }])\n                  : messages\n\n        // We only want to send up the speaker and prompt text, regardless of whatever other fields\n        // might be on the messages objects (`file`, `displayText`, `contextFiles`, etc.).\n        const messagesToSend = augmentedMessages.map(({ speaker, text }) => ({\n            text,\n            speaker,\n        }))\n\n        const completionParams = {\n            ...DEFAULT_CHAT_COMPLETION_PARAMETERS,\n            ...params,\n            messages: messagesToSend,\n        }\n\n        return this.completions.stream(\n            completionParams,\n            useApiV1 ? authStatus.codyApiVersion : 0,\n            abortSignal\n        )\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:165-184","content":"\n        // Reuse existing \"New Chat\" panel if there is an empty one\n        const emptyNewChatProvider = this.panelProviders.find(p => p.webviewPanel?.title === 'New Chat')\n        if (\n            !this.options.config.isRunningInsideAgent && // Don't reuse panels in the agent\n            !chatID &&\n            !panel &&\n            this.panelProviders.length &&\n            emptyNewChatProvider\n        ) {\n            emptyNewChatProvider.webviewPanel?.reveal()\n            this.activePanelProvider = emptyNewChatProvider\n            this.options.contextProvider.webview = emptyNewChatProvider.webview\n            void this.selectTreeItem(emptyNewChatProvider.sessionID)\n            return emptyNewChatProvider\n        }\n\n        // Get the view column of the current active chat panel so that we can open a new one on top of it\n        const activePanelViewColumn = this.activePanelProvider?.webviewPanel?.viewColumn\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:798-813","content":"### Fixed\n\n- Edit: Updated the fixup create task to just use the previous command text. [pull/1615](https://github.com/sourcegraph/cody/pull/1615)\n- Fixed an issue that would cause an aborted chat message to show an error \"Cody did not respond with any text\". [pull/1668](https://github.com/sourcegraph/cody/pull/1668)\n- Chat: Opening files from the new chat panel will now show up beside the chat panel instead of on top of the chat panel. [pull/1677](https://github.com/sourcegraph/cody/pull/1677)\n- Chat: Prevented default events on certain key combos when chat box is focused. [pull/1690](https://github.com/sourcegraph/cody/pull/1690)\n- Command: Fixed an issue that opened a new chat window when running `/doc` and `/edit` commands from the command palette. [pull/1678](https://github.com/sourcegraph/cody/pull/1678)\n- Chat: Prevent sidebar from opening when switching editor chat panels. [pull/1691](https://github.com/sourcegraph/cody/pull/1691)\n- Chat: Prevent `\"command 'cody.chat'panel.new' not found\"` error when the new chat panel UI is disabled. [pull/1696](https://github.com/sourcegraph/cody/pull/1696)\n- Autocomplete: Improved the multiline completions truncation logic. [pull/1709](https://github.com/sourcegraph/cody/pull/1709)\n- Autocomplete: Fix an issue where typing as suggested causes the completion to behave unexpectedly. [pull/1701](https://github.com/sourcegraph/cody/pull/1701)\n- Chat: Forbid style tags in DOMPurify config to prevent code block rendering issues. [pull/1747](https://github.com/sourcegraph/cody/pull/1747)\n- Edit: Fix `selectedCode` and `problemCode` sometimes being added to the document after an edit. [pull/1765](https://github.com/sourcegraph/cody/pull/1765)\n- Edit: Fix the code lens containing options to diff, undo and retry being automatically dismissed for users who have `autoSave` enabled. [pull/1767](https://github.com/sourcegraph/cody/pull/1767)\n\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:48-73","content":"\n    // Submit a new message and check if both sessions are showing up in the sidebar\n    await chatInput.fill('Hola')\n    await chatInput.press('Enter')\n    await expect(holaTreeItem).toBeVisible()\n    await expect(heyTreeItem).toBeVisible()\n\n    // The panel name is now updated to the last submitted message\n    await expect(page.getByRole('tab', { name: 'Hola' })).toBeVisible()\n\n    // Click on the previous chat session to open the chat panel in editor\n    // Both chat panels should be visible as tabs in the editor\n    await page\n        .getByRole('treeitem', { name: 'Hey' })\n        .locator('div')\n        .filter({ hasText: 'Hey' })\n        .nth(3)\n        .click()\n    await expect(page.getByRole('tab', { name: 'Hey' })).toBeVisible()\n\n    // NOTE: Action buttons may only appear when we're hovering a chat.\n    // Deleting a chat should also close its associated chat panel\n    await heyTreeItem.hover()\n    await heyTreeItem.getByLabel('Delete Chat').hover()\n    await heyTreeItem.getByLabel('Delete Chat').click()\n"}]

 class: Find logic
