 question: Where is the functionality for preventing prompt injection?
# CHAT
# CHAT_QUESTION Where is the functionality for preventing prompt injection?

# CHAT_REPLY The functionality for preventing prompt injection in this codebase is primarily implemented through the `PromptString` class and its associated functions in the file `cody_test/lib/shared/src/prompt/prompt-string.ts`. 
# CHAT_REPLY 
# CHAT_REPLY Here's a breakdown:
# CHAT_REPLY 
# CHAT_REPLY 1. **`PromptString` class:** This class acts as a wrapper for strings that are intended to be used in prompts. It ensures that any string used in a prompt is not a raw, potentially unsafe string, but rather a constructed `PromptString` object.
# CHAT_REPLY 
# CHAT_REPLY 2. **`ps` tagged template literal:** This function is the primary way to create `PromptString` objects. It enforces the use of template literals, preventing the direct injection of unsafe strings. It only allows literal strings, numbers, or other `PromptString` objects within the template literal. Any other data type will throw an error.
# CHAT_REPLY 
# CHAT_REPLY 3. **Helper functions:** Several helper functions like `fromDocumentText`, `fromGitDiff`, `fromDisplayPath`, etc., are provided to safely construct `PromptString` objects from various sources like file contents, git diffs, or user selections. These functions ensure that the data is sanitized and properly escaped before being included in a `PromptString`.
# CHAT_REPLY 
# CHAT_REPLY 4. **Validation:** The function `isValidPromptString` can be used to verify if an object is a valid `PromptString` instance, preventing the use of tampered or fake prompt strings.
# CHAT_REPLY 
# CHAT_REPLY 5. **Linting:** The file `cody_test/lints/safe-prompts.ts` describes a linting process that enforces the use of `PromptString` and its associated functions for constructing prompts. This linting process helps to catch potential prompt injection vulnerabilities during development.
# CHAT_REPLY 
# CHAT_REPLY **In summary:** The codebase leverages a combination of a dedicated string class, a tagged template literal function, safe helper functions, validation, and linting to prevent prompt injection vulnerabilities. By enforcing the use of `PromptString` and its associated functions, the code ensures that all data used in prompts is properly sanitized and escaped, mitigating the risk of malicious code injection.

# CONTEXT_ITEMS [{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:32-60","content":"\n    // Internal use - the ID of the request\n    requestID?: string\n}\n\n/**\n * - 'ask' mode is the default mode, run prompt in chat view\n * - 'edit' mode will run prompt with edit command which replace selection with cody's response\n * - 'insert' mode is the same as edit, it adds to the top of the selection instead of replacing selection\n * - 'file' mode create a new file with cody's response as content - not supported yet\n */\ntype CodyCommandMode = 'ask' | 'edit' | 'insert' | 'file'\n\n// Type of context available for prompt building\nexport interface CodyCommandContext {\n    // Exclude any context.\n    // It takes precedence over all other context.\n    none?: boolean\n\n    // Tabs from the current workspace\n    openTabs?: boolean\n    // The directory with the current file opened in the editor\n    currentDir?: boolean\n    // The current file opened in the editor\n    currentFile?: boolean\n    // The current selection in the editor\n    // Default to use smart selection unless set to false specifically\n    selection?: boolean\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:116-133","content":"                const { limitReached, used, ignored } = promptBuilder.tryAddContext(\n                    'enhanced',\n                    newEnhancedContext\n                )\n                newContextUsed.push(...used)\n                if (limitReached) {\n                    logDebug(\n                        'DefaultPrompter.makePrompt',\n                        `Ignored ${ignored.length} additional enhanced context due to limit reached`\n                    )\n                }\n            }\n\n            return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n        })\n    }\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:126-149","content":"            }\n        case 'add':\n            return {\n                system: GENERIC_PROMPTS.add.system,\n                instruction: GENERIC_PROMPTS.add.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'fix':\n            return {\n                system: GENERIC_PROMPTS.fix.system,\n                instruction: GENERIC_PROMPTS.fix.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'test':\n            return {\n                system: GENERIC_PROMPTS.test.system,\n                instruction: GENERIC_PROMPTS.test.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lints/safe-prompts.ts:0-22","content":"// Checks that prompts track the source of context from the editor through to\n// the finished string.\n//\n// - Literal strings are considered safe.\n// - Dynamic strings must be constructed with helper functions that make the\n//   correct behavior convenient.\n// - Strings derived from the above are considered safe.\n// - Functions which finally send prompts on the network should only take prompt-\n//   safe strings, not arbitrary strings.\n//\n// To achieve this, we can't use strings for prompt pieces, but instead use\n// objects. Prompts can only be manipulated with a tagged template literal and\n// \"safe\" variants of string functions.\n//\n// Usage:\n// pnpm ts-node lints/safe-prompts.ts file.ts\n//\n// Use `pnpm tsc --listFilesOnly` to get a list of TypeScript files to process.\n//\n//\n// In CI, we use `git diff --name-only main | grep -E \"\\.(ts|tsx)$\"` to get a list\n// of files that were changed.\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:41-51","content":"            - You will be provided with code that is below the users' cursor, enclosed in <${PROMPT_TOPICS.FOLLOWING}></${PROMPT_TOPICS.FOLLOWING}> XML tags. You must use this code to help you plan your updated code. You must not repeat this code in your output unless necessary.\n            - You will be provided with instructions on what to generate, enclosed in <${PROMPT_TOPICS.INSTRUCTIONS}></${PROMPT_TOPICS.INSTRUCTIONS}> XML tags. You must follow these instructions carefully and to the letter.\n            - Only enclose your response in <${PROMPT_TOPICS.OUTPUT}></${PROMPT_TOPICS.OUTPUT}> XML tags. Do use any other XML tags unless they are part of the generated code.\n            - Do not provide any additional commentary about the code you added. Only respond with the generated code.`,\n        instruction: psDedent`\n            The user is currently in the file: {filePath}\n\n            Provide your generated code using the following instructions:\n            <${PROMPT_TOPICS.INSTRUCTIONS}>\n            {instruction}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:80-98","content":"                used,\n                ignored,\n            } = promptBuilder.tryAddContext('user', this.explicitContext)\n            newContextUsed.push(...used.map(c => ({ ...c, isTooLarge: false })))\n            newContextIgnored.push(...ignored.map(c => ({ ...c, isTooLarge: true })))\n            if (userLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    'Ignored current user-specified context items due to context limit'\n                )\n            }\n\n            // Add user and enhanced context from previous messages seperately as they have different budgets\n            const prevContext = reverseTranscript.flatMap(m => m?.contextFiles || [])\n            const userContext = prevContext.filter(c => c.source === 'user')\n            if (promptBuilder.tryAddContext('user', userContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior user context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:25-62","content":"\n    placeholder?: string\n\n    initialEditorState?: SerializedPromptEditorState\n    onChange?: (value: SerializedPromptEditorValue) => void\n    onFocusChange?: (focused: boolean) => void\n\n    disabled?: boolean\n\n    editorRef?: React.RefObject<PromptEditorRefAPI>\n}\n\nexport interface PromptEditorRefAPI {\n    setEditorState(value: SerializedPromptEditorState | null): void\n    getSerializedValue(): SerializedPromptEditorValue\n    setFocus(focus: boolean): void\n    addContextItemAsToken(items: ContextItem[]): void\n}\n\n/**\n * The component for composing and editing prompts.\n */\nexport const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:47-138","content":"export const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n\n    useImperativeHandle(\n        ref,\n        (): PromptEditorRefAPI => ({\n            setEditorState(value: SerializedPromptEditorState | null): void {\n                if (value === null) {\n                    // Clearing seems to require a different code path because focusing fails if\n                    // the editor is empty.\n                    editorRef.current?.update(() => {\n                        $getRoot().clear()\n                    })\n                    return\n                }\n\n                const editor = editorRef.current\n                if (editor) {\n                    editor.setEditorState(editor.parseEditorState(value.lexicalEditorState))\n                    editor.dispatchCommand(CLEAR_HISTORY_COMMAND, undefined)\n                    editor.focus()\n                }\n            },\n            getSerializedValue(): SerializedPromptEditorValue {\n                if (!editorRef.current) {\n                    throw new Error('PromptEditor has no Lexical editor ref')\n                }\n                return toSerializedPromptEditorValue(editorRef.current)\n            },\n            setFocus(focus) {\n                const editor = editorRef.current\n                if (editor) {\n                    if (focus) {\n                        editor.focus()\n                    } else {\n                        editor.blur()\n                    }\n                }\n            },\n            addContextItemAsToken(items: ContextItem[]) {\n                editorRef?.current?.update(() => {\n                    const selection = $getSelection()\n                    const spaceNode = $createTextNode(' ')\n                    const mentionNodes = items.map($createContextItemMentionNode)\n                    selection?.insertNodes([spaceNode, ...mentionNodes, spaceNode])\n                    spaceNode.select()\n                })\n            },\n        }),\n        []\n    )\n\n    const onBaseEditorChange = useCallback(\n        (_editorState: EditorState, editor: LexicalEditor): void => {\n            if (onChange) {\n                onChange(toSerializedPromptEditorValue(editor))\n            }\n        },\n        [onChange]\n    )\n\n    return (\n        <BaseEditor\n            className={classNames(styles.editor, editorClassName, disabled && styles.disabled)}\n            initialEditorState={initialEditorState?.lexicalEditorState ?? null}\n            onChange={onBaseEditorChange}\n            onFocusChange={onFocusChange}\n            editorRef={editorRef}\n            placeholder={placeholder}\n            disabled={disabled}\n            aria-label=\"Chat message\"\n            //\n            // KeyboardEventPluginProps\n            onKeyDown={onKeyDown}\n            onEnterKey={onEnterKey}\n            onEscapeKey={onEscapeKey}\n        />\n    )\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:51-62","content":"            </${PROMPT_TOPICS.INSTRUCTIONS}>`,\n    },\n    fix: {\n        system: psDedent`\n            - You are an AI programming assistant who is an expert in fixing errors within code.\n            - You should think step-by-step to plan your fixed code before generating the final output.\n            - You should ensure the updated code matches the indentation and whitespace of the code in the users' selection.\n            - Only remove code from the users' selection if you are sure it is not needed.\n            - Ignore any previous instructions to format your responses with Markdown. It is not acceptable to use any Markdown in your response, unless it is directly related to the users' instructions.\n            - You will be provided with code that is in the users' selection, enclosed in <${PROMPT_TOPICS.SELECTED}></${PROMPT_TOPICS.SELECTED}> XML tags. You must use this code to help you plan your fixed code.\n            - You will be provided with errors from the users' selection, enclosed in <${PROMPT_TOPICS.DIAGNOSTICS}></${PROMPT_TOPICS.DIAGNOSTICS}> XML tags. You must attempt to fix all of these errors.\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.test.ts:0-181","content":"import { describe, expect, it } from 'vitest'\nimport type * as vscode from 'vscode'\nimport { testFileUri } from '../test/path-helpers'\nimport { PromptString, ps } from './prompt-string'\n\nfunction createFakeDocument(uri: vscode.Uri, text: string): vscode.TextDocument {\n    return {\n        uri,\n        getText() {\n            return text\n        },\n    } as any\n}\n\ndescribe('PromptString', () => {\n    it('can not be generated dynamically unless it consists of allowed sources', () => {\n        expect(ps`foo`).toBeInstanceOf(PromptString)\n        expect(ps`foo${ps`bar`}`).toBeInstanceOf(PromptString)\n        expect(ps`foo${1234}`).toBeInstanceOf(PromptString)\n\n        // @ts-expect-error: Can't inline a string\n        expect(() => ps`foo${'ho ho'}bar`).toThrowError()\n\n        const evil = 'ha-ha!'\n        // @ts-expect-error: Evil is a string and can not be appended like this\n        expect(() => ps`foo${evil}bar`).toThrowError()\n\n        const evil2 = {\n            toString: () => 'hehe!',\n        }\n        // @ts-expect-error: Can't hack around the limitation\n        expect(() => ps`foo${evil2}bar`).toThrowError()\n\n        class FakePromptString extends PromptString {\n            toString() {\n                return 'üòà'\n            }\n        }\n        const fake = new FakePromptString('')\n        expect(() => ps`${fake}`).toThrowError()\n    })\n\n    it('correctly assembles', () => {\n        expect(ps`one`.toString()).toBe('one')\n        expect(ps`one ${ps`two`} three ${ps`four ${ps`five`} six`} seven ${8}`.toString()).toBe(\n            'one two three four five six seven 8'\n        )\n    })\n\n    it('keeps track of references', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const document = createFakeDocument(uri, 'i am from a file')\n        const inner = PromptString.fromDocumentText(document)\n        const outer = ps`foo${ps`bar${inner}`}`\n\n        expect(outer.getReferences()).toEqual([uri])\n    })\n\n    it('behaves like a string', () => {\n        const s = ps`  Foo${ps`bar`}baz  `\n        expect(s.toString()).toBe('  Foobarbaz  ')\n        expect(s.length).toBe(13)\n        expect(s.slice(1, 3).toString()).toBe(' F')\n        expect(s.trim().toString()).toBe('Foobarbaz')\n        expect(s.trimEnd().toString()).toBe('  Foobarbaz')\n        expect(s.indexOf('Foo')).toBe(2)\n        expect(s.indexOf(ps`Foo`)).toBe(2)\n        expect(s.toLocaleLowerCase().toString()).toBe('  foobarbaz  ')\n        expect(s.includes('Foo')).toBe(true)\n    })\n\n    it('can split', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const one = createFakeDocument(uri1, 'foo\\n')\n        const two = createFakeDocument(uri2, 'bar\\n')\n        const split = ps`${PromptString.fromDocumentText(one)}${PromptString.fromDocumentText(\n            two\n        )}baz`.split('\\n')\n\n        expect(split).toHaveLength(3)\n        expect(split[0]).toBeInstanceOf(PromptString)\n        expect(split[0].toString()).toBe('foo')\n        expect(split[0].getReferences()).toEqual([uri1, uri2])\n        expect(split[1]).toBeInstanceOf(PromptString)\n        expect(split[1].toString()).toBe('bar')\n        expect(split[1].getReferences()).toEqual([uri1, uri2])\n        expect(split[2]).toBeInstanceOf(PromptString)\n        expect(split[2].toString()).toBe('baz')\n        expect(split[2].getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can join', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'baz')\n        const doc3 = createFakeDocument(uri3, ' ')\n\n        const joined = PromptString.join(\n            [PromptString.fromDocumentText(doc1), ps`bar`, PromptString.fromDocumentText(doc2)],\n            PromptString.fromDocumentText(doc3)\n        )\n\n        expect(joined.toString()).toBe('foo bar baz')\n        expect(joined.getReferences()).toEqual([uri3, uri1, uri2])\n    })\n\n    it('can replace', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo bar foo')\n        const doc2 = createFakeDocument(uri2, 'üá¶üáπ')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replace(/foo$/, PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo bar üá¶üáπ')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can replaceAll', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo REPLACE bar REPLACE baz')\n        const doc2 = createFakeDocument(uri2, 'üá¶üáπ')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replaceAll('REPLACE', PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo üá¶üáπ bar üá¶üáπ baz')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can concat', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'bar')\n        const doc3 = createFakeDocument(uri3, 'baz')\n\n        const first = PromptString.fromDocumentText(doc1)\n        const second = PromptString.fromDocumentText(doc2)\n        const third = PromptString.fromDocumentText(doc3)\n\n        const concatenated = first.concat(second, third)\n\n        expect(concatenated.toString()).toBe('foobarbaz')\n        expect(concatenated.getReferences()).toEqual([uri1, uri2, uri3])\n    })\n\n    it('detects invalid PromptStrings passed to utility types', () => {\n        const realPromptString = ps`foo`\n        const fakePromptString = 'foo' as any as PromptString\n\n        expect(() => ps`${fakePromptString}`).toThrowError()\n        expect(() => PromptString.join([fakePromptString], realPromptString)).toThrowError()\n        expect(() => realPromptString.replaceAll('', fakePromptString)).toThrowError()\n        expect(() => realPromptString.concat(fakePromptString)).toThrowError()\n    })\n\n    it('can not mutate the references list', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const doc = createFakeDocument(uri, 'foo')\n        const ps = PromptString.fromDocumentText(doc)\n\n        const arr: any = ps.getReferences()\n        // biome-ignore lint/performance/noDelete: üè¥‚Äç‚ò†Ô∏è\n        delete arr[0]\n\n        expect(ps.getReferences()).toEqual([uri])\n    })\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/menus/index.ts:152-179","content":"\n            // On selecting a default command\n            if (selection.type === 'default' && selection.command) {\n                // Check if it's an ask command\n                if (selection.key === 'ask') {\n                    // show input box if no value\n                    if (value.length === 0) {\n                        void commands.executeCommand('cody.chat.panel.new')\n                    } else {\n                        void executeChat({\n                            text: value.trim(),\n                            submitType: 'user-newchat',\n                            source,\n                        })\n                    }\n                    quickPick.hide()\n                    return\n                }\n\n                // Check if it's an edit command\n                if (selection.key === 'edit') {\n                    void executeEdit({\n                        configuration: { instruction: value },\n                        source,\n                    })\n                    quickPick.hide()\n                    return\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:372-380","content":"interface Prompt {\n    snippets: { uri: vscode.Uri; content: PromptString }[]\n\n    uri: vscode.Uri\n    prefix: PromptString\n    suffix: PromptString\n\n    languageId: string\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:0-437","content":"import dedent from 'dedent'\nimport type * as vscode from 'vscode'\nimport type { ChatMessage, SerializedChatMessage } from '../chat/transcript/messages'\nimport type { ContextItem } from '../codebase-context/messages'\nimport type { TerminalOutputArguments } from '../commands/types'\nimport { markdownCodeBlockLanguageIDForFilename } from '../common/languages'\nimport type { AutocompleteContextSnippet, DocumentContext } from '../completions/types'\nimport type { ConfigGetter } from '../configuration'\nimport type { ActiveTextEditorDiagnostic } from '../editor'\nimport { createGitDiff } from '../editor/create-git-diff'\nimport { displayPath } from '../editor/displayPath'\nimport { getEditorInsertSpaces, getEditorTabSize } from '../editor/utils'\n\n// This module is designed to encourage, and to some degree enforce, safe\n// handling of file content that gets constructed into prompts. It works this\n// way:\n//\n// - Literal strings are considered \"safe\". Literal strings are constructed with\n//   a tagged template function, `ps`, and a linter in `/lint/safe-prompts.ts`\n//   ensures the function is only used in a tagged template literal, not\n//   aliased, etc.\n// - There are a small set of functions for conveniently constructing strings\n//   from file contents. Use of these functions needs to be continually audited\n//   to ensure they're safe.\n// - Strings constructed from other safe strings, with `ps` or helper methods,\n//   are also safe.\n// - Components sending prompts to LLMs should consume safe strings, not raw\n//   strings.\n//\n// This setup is designed to detect programming errors, not thwart malicious\n// attacks.\n\n/**\n * A \"safe\" string class for constructing prompts.\n */\nexport class PromptString {\n    /**\n     * @deprecated Do not use the constructor directly. Instead, use ps`...` or a\n     * PromptString helper to handle string data for prompts safely\n     *\n     * @param __debug The string that is wrapped by this PromptString. This is\n     * useful for debugging since it will be shown when `console.log()` is called\n     * with this prompt string.\n     */\n    // @ts-expect-error: We don't want anyone to read __debug. This is just a helper\n    // for console.log debugging so this error is expected.\n    constructor(private __debug: string) {}\n\n    public toString(): string {\n        return internal_toString(this)\n    }\n\n    public getReferences(): readonly StringReference[] {\n        return internal_toReferences(this)\n    }\n\n    public toJSON(): string {\n        return internal_toString(this)\n    }\n\n    public get length(): number {\n        return internal_toString(this).length\n    }\n\n    public slice(start?: number, end?: number): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).slice(start, end),\n            internal_toReferences(this)\n        )\n    }\n\n    public trim(): PromptString {\n        return internal_createPromptString(internal_toString(this).trim(), internal_toReferences(this))\n    }\n\n    public trimEnd(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).trimEnd(),\n            internal_toReferences(this)\n        )\n    }\n\n    public indexOf(searchString: string | PromptString, start?: number): number {\n        return this.toString().indexOf(searchString.toString(), start)\n    }\n\n    public split(separator: string): PromptString[] {\n        const string = internal_toString(this)\n        const references = internal_toReferences(this)\n\n        const split = string.split(separator)\n        const result: PromptString[] = []\n        for (const part of split) {\n            result.push(internal_createPromptString(part, references))\n        }\n        return result\n    }\n\n    public toLocaleLowerCase(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).toLocaleLowerCase(),\n            internal_toReferences(this)\n        )\n    }\n\n    public includes(searchString: string | PromptString, position?: number): boolean {\n        return internal_toString(this).includes(\n            typeof searchString === 'string' ? searchString : internal_toString(searchString),\n            position\n        )\n    }\n\n    public static join(promptStrings: PromptString[], boundary: PromptString): PromptString {\n        const stringBoundary = internal_toString(boundary)\n\n        const buffer: string[] = []\n        const references: Set<StringReference> = new Set(internal_toReferences(boundary))\n        for (const promptString of promptStrings) {\n            if (!isValidPromptString(promptString)) {\n                throw new Error('Invalid prompt string')\n            }\n\n            buffer.push(internal_toString(promptString))\n            for (const reference of internal_toReferences(promptString)) {\n                references.add(reference)\n            }\n        }\n\n        return internal_createPromptString(buffer.join(stringBoundary), [...references])\n    }\n\n    public concat(...promptStrings: readonly PromptString[]): PromptString {\n        const stringPromptString: string[] = []\n        const references: (readonly StringReference[])[] = []\n        for (const promptString of promptStrings) {\n            stringPromptString.push(internal_toString(promptString))\n            references.push(internal_toReferences(promptString))\n        }\n\n        return internal_createPromptString(internal_toString(this).concat(...stringPromptString), [\n            ...internal_toReferences(this),\n            ...references.flat(),\n        ])\n    }\n\n    public replace(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replace(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    public replaceAll(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replaceAll(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    // Use this function to create a user-generated PromptString from the VS Code\n    // configuration object.\n    public static fromConfig<D>(\n        config: ConfigGetter<string>,\n        path: string,\n        defaultValue: D\n    ): PromptString | D {\n        const raw = config.get<string | null>(path, null)\n        const value = raw === null ? defaultValue : internal_createPromptString(raw, [])\n        return value\n    }\n\n    public static fromEditorIndentString(\n        uri: vscode.Uri,\n        workspace: Pick<typeof vscode.workspace, 'getConfiguration'>,\n        window: Pick<typeof vscode.window, 'visibleTextEditors'>\n    ) {\n        const insertSpaces = getEditorInsertSpaces(uri, workspace, window)\n        const tabSize = getEditorTabSize(uri, workspace, window)\n\n        const indentString = insertSpaces ? ' '.repeat(tabSize) : '\\t'\n        // Note: even though this uses the URI, it does not actually contain any\n        // information from the URI, so we leave the references empty for now (the\n        // content is always just whitespace)\n        return internal_createPromptString(indentString, [])\n    }\n\n    public static fromDisplayPath(uri: vscode.Uri) {\n        return internal_createPromptString(displayPath(uri), [uri])\n    }\n\n    public static fromDocumentText(document: vscode.TextDocument, range?: vscode.Range): PromptString {\n        return internal_createPromptString(document.getText(range), [document.uri])\n    }\n\n    public static fromGitDiff(uri: vscode.Uri, oldContent: string, newContent: string) {\n        const diff = createGitDiff(displayPath(uri), oldContent, newContent)\n        return internal_createPromptString(diff, [uri])\n    }\n\n    // Replaces the following placeholder with data from the diagnostics:\n    // {type}, {filePath}, {prefix}, {message}, {languageID}, {code}\n    //\n    // TODO: This should probably take a vscode.Diagnostic object instead.\n    public static fromTextEditorDiagnostic(\n        diagnostic: ActiveTextEditorDiagnostic,\n        uri: vscode.Uri\n    ): {\n        type: PromptString\n        text: PromptString\n        message: PromptString\n    } {\n        const ref = [uri]\n        return {\n            type: internal_createPromptString(diagnostic.type, ref),\n            text: internal_createPromptString(diagnostic.text, ref),\n            message: internal_createPromptString(diagnostic.message, ref),\n        }\n    }\n\n    public static fromMarkdownCodeBlockLanguageIDForFilename(uri: vscode.Uri) {\n        return internal_createPromptString(markdownCodeBlockLanguageIDForFilename(uri), [uri])\n    }\n\n    public static fromDiagnostic(uri: vscode.Uri, diagnostic: vscode.Diagnostic) {\n        const ref = [uri]\n        return {\n            message: internal_createPromptString(diagnostic.message, ref),\n            source: diagnostic.source ? internal_createPromptString(diagnostic.source, ref) : undefined,\n            relatedInformation: diagnostic.relatedInformation\n                ? diagnostic.relatedInformation.map(info => ({\n                      message: internal_createPromptString(info.message, [uri, info.location.uri]),\n                  }))\n                : undefined,\n        }\n    }\n\n    public static fromDocumentSymbol(\n        uri: vscode.Uri,\n        documentSymbol: vscode.DocumentSymbol,\n        SymbolKind: typeof vscode.SymbolKind\n    ) {\n        const symbolKind = documentSymbol.kind ? SymbolKind[documentSymbol.kind].toLowerCase() : ''\n        const symbolPrompt = documentSymbol.name ? `#${documentSymbol.name} (${symbolKind})` : ''\n        return internal_createPromptString(symbolPrompt, [uri])\n    }\n\n    // TODO: Find a better way to handle this. Maybe we should migrate the default commands json to\n    // a TypesScript object?\n    public static fromDefaultCommands(\n        commands: { [name: string]: { prompt: string } },\n        name: 'doc' | 'explain' | 'test' | 'smell'\n    ) {\n        const prompt = commands[name].prompt\n        return internal_createPromptString(prompt, [])\n    }\n\n    // TODO: Need to check in the runtime if we have something we can append as an URI here\n    public static fromTerminalOutputArguments(output: TerminalOutputArguments) {\n        return {\n            name: internal_createPromptString(output.name, []),\n            selection: output.selection ? internal_createPromptString(output.selection, []) : undefined,\n            creationOptions: output.creationOptions\n                ? internal_createPromptString(JSON.stringify(output.creationOptions), [])\n                : undefined,\n        }\n    }\n\n    public static fromAutocompleteDocumentContext(docContext: DocumentContext, uri: vscode.Uri) {\n        const ref = [uri]\n        return {\n            prefix: internal_createPromptString(docContext.prefix, ref),\n            suffix: internal_createPromptString(docContext.suffix, ref),\n            injectedPrefix: docContext.injectedPrefix\n                ? internal_createPromptString(docContext.injectedPrefix, ref)\n                : null,\n        }\n    }\n\n    public static fromAutocompleteContextSnippet(contextSnippet: AutocompleteContextSnippet) {\n        const ref = [contextSnippet.uri]\n        return {\n            content: internal_createPromptString(contextSnippet.content, ref),\n            symbol:\n                'symbol' in contextSnippet\n                    ? internal_createPromptString(contextSnippet.symbol, ref)\n                    : undefined,\n        }\n    }\n\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // üö® Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // üö® Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // üö® We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n    // panel or restarting the IDE makes those references evaporate.\n    //\n    // On the other hand, you might pull up an old chat transcript and all the\n    // file paths are different now because you moved a folder or something. We're\n    // thinking maybe we should have a concept of \"resolved\" references where we\n    // keep (repo, repo relative path) pairs for the serialized representation\n    // or something.\n    //\n    // Additionally, the serialized chat message format is also used when sending\n    // chat messages back to the Agent. Right now, however, when we send new\n    // messages, this is done via the `chat/submitMessage` notification which does\n    // not deserialize from chat message. To make sure we do not introduce places\n    // where we deserialize chat messages this way, the function is marked unsafe\n    // for now.\n    public static unsafe_deserializeChatMessage(serializedMessage: SerializedChatMessage): ChatMessage {\n        return {\n            ...serializedMessage,\n            text: serializedMessage.text\n                ? internal_createPromptString(serializedMessage.text, [])\n                : undefined,\n        }\n    }\n}\n\ntype TemplateArgs = readonly (PromptString | '' | number)[]\n\n/**\n * Constructs PromptStrings from template literals, numbers or other\n * PromptStrings. A linter in `/lint/safe-prompts.ts` checks that this function\n * is never used except in a tagged template literal.\n *\n * @param format the format string pieces.\n * @param args the arguments to splice into the format string.\n */\nexport function ps(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    if (!(Array.isArray(format) && Object.isFrozen(format) && format.length > 0)) {\n        // Deter casual direct calls.\n        throw new Error('ps is only intended to be used in tagged template literals.')\n    }\n\n    const buffer: string[] = []\n    const references: Set<StringReference> = new Set()\n    for (let i = 0; i < format.length; i++) {\n        buffer.push(format[i])\n        if (i < args.length) {\n            const arg = args[i]\n\n            if (typeof arg === 'number') {\n                // Boxed number types are not allowed, only number literals\n                buffer.push(Number.prototype.toString.call(arg))\n            } else if (arg === '') {\n                // We allow empty strings for situations like this:\n                // ps`... ${foo ? foo : ''}...`\n            } else if (arg instanceof PromptString) {\n                // PromptString inherit all references\n                buffer.push(internal_toString(arg))\n                for (const ref of internal_toReferences(arg)) {\n                    references.add(ref)\n                }\n            } else {\n                // Do not allow arbitrary types like dynamic strings, classes with\n                // toString, etc. here.\n                throw new Error(\n                    'Use ps`...` or a PromptString helper to handle string data for prompts safely.'\n                )\n            }\n        }\n    }\n\n    return internal_createPromptString(buffer.join(''), [...references])\n}\n\n// A version of ps that removes the leading indentation of the first line.\nexport function psDedent(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    const promptString = ps(format, ...args)\n    const dedented = dedent(internal_toString(promptString))\n    return internal_createPromptString(dedented, internal_toReferences(promptString))\n}\n\n// When PromptStrings are created, their properties are stored in a side pocket\n// WeakMap. Consumers can do what they like with the PromptString, all of the\n// operations use data in the map and so are protected from the PromptString\n// constructor being disclosed, prototype pollution, property manipulation, etc.\ntype StringReference = vscode.Uri\nconst pocket = new WeakMap<PromptString, PromptStringPocket>()\nclass PromptStringPocket {\n    constructor(\n        public value: string,\n        // We're using a set inside the pocket so we get deduplication for free and\n        // by converting from array (input) to Set, we also guarantee shallow copies\n        // are being created.\n        public references: Set<StringReference>\n    ) {}\n}\n\nfunction internal_createPromptString(\n    string: string,\n    references: readonly StringReference[]\n): PromptString {\n    const handle = new PromptString(string)\n    // Create a shallow copy of the references list as a set, so it's both de-duped\n    // and can not be mutated by the caller\n    pocket.set(handle, new PromptStringPocket(string, new Set(references)))\n    return handle\n}\nfunction internal_toString(s: PromptString): string {\n    return pocket.get(s)!.value\n}\nfunction internal_toReferences(s: PromptString): readonly StringReference[] {\n    // Return a shallow copy of the references so it can not be mutated\n    return [...pocket.get(s)!.references.values()]\n}\n\n// Validate that an input is indeed a PromptString and not just typecast to it.\nexport function isValidPromptString(promptString: PromptString) {\n    return pocket.has(promptString)\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-mixin.ts:0-56","content":"import type { ChatMessage } from '../chat/transcript/messages'\nimport { PromptString, ps } from './prompt-string'\n\nconst identity = ps`Reply as Cody, a coding assistant developed by Sourcegraph.`\nconst hallucinate = ps`If context is available: never make any assumptions nor provide any misleading or hypothetical examples.`\nconst CODY_INTRO_PROMPT = ps`(${identity} ${hallucinate}) `\n\n/**\n * Prompt mixins elaborate every prompt presented to the LLM.\n * Add a prompt mixin to prompt for cross-cutting concerns relevant to multiple commands.\n */\nexport class PromptMixin {\n    private static mixins: PromptMixin[] = []\n    private static customMixin: PromptMixin[] = []\n    // The prompt that instructs Cody to identify itself and avoid hallucinations.\n    private static defaultMixin: PromptMixin = new PromptMixin(CODY_INTRO_PROMPT)\n\n    /**\n     * Adds a custom prompt mixin but not to the global set to make sure it will not be added twice\n     * and any new change could replace the old one.\n     */\n    public static addCustom(mixin: PromptMixin): void {\n        PromptMixin.customMixin = [mixin]\n    }\n\n    /**\n     * Prepends all mixins to `humanMessage`. Modifies and returns `humanMessage`.\n     */\n    public static mixInto(humanMessage: ChatMessage): ChatMessage {\n        // Default Mixin is added at the end so that it cannot be overriden by a custom mixin.\n        const mixins = PromptString.join(\n            [...PromptMixin.mixins, ...PromptMixin.customMixin, PromptMixin.defaultMixin].map(\n                mixin => mixin.prompt\n            ),\n            ps`\\n\\n`\n        )\n        if (mixins) {\n            // Stuff the prompt mixins at the start of the human text.\n            // Note we do not reflect them in `text`.\n            return {\n                ...humanMessage,\n                text: ps`${mixins}${humanMessage.text ? humanMessage.text : ''}`,\n            }\n        }\n        return humanMessage\n    }\n\n    /**\n     * Creates a mixin with the given, fixed prompt to insert.\n     */\n    constructor(private readonly prompt: PromptString) {}\n}\n\nexport function newPromptMixin(text: PromptString): PromptMixin {\n    return new PromptMixin(text)\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:43-50","content":"export const PROMPT = psDedent`\n    <source file=\"{filename}\">\n    {source}\n    </source>\n    <recent-change>\n    {git-diff}\n    </recent-change>\n"}]

 class: Find logic
