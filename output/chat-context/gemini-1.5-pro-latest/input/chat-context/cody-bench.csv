LANGUAGEID,WORKSPACE,FIXTURE,STRATEGY,FILEPATH,REVISION,MULTILINE,COMPLETION_INTENT,AUTOCOMPLETE_KIND,RANGE_START_LINE,RANGE_START_CHARACTER,RANGE_END_LINE,RANGE_END_CHARACTER,RESULT_TIMEOUT,RESULT_ERROR,RESULT_EMPTY,RESULT_EXACT,RESULT_TYPECHECKS,RESULT_PARSES,RESULT_TEXT,RESULT_CHAR_COUNT,RESULT_NON_INSERT_PATCH,EDIT_DIFF,CHAT_REPLY,CHAT_QUESTION,CONTEXT_ITEMS,QUESTION_CLASS,FIX_AFTER_DIAGNOSTIC,FIX_BEFORE_DIAGNOSTIC,LLM_JUDGE_SCORE,LLM_JUDGE_REASONING,CONCISENESS_SCORE,HEDGES,PROVIDER_IDENTIFIER,PROVIDER_MODEL,STOP_REASON,CONTEXT_BFG_RETRIEVED_COUNT,CONTEXT_BFG_SUGGESTED_COUNT,CONTEXT_BFG_DURATION_MS,EVENT,TEST_FILENAME,TEST_EXPECTED_FILENAME,TEST_GENERATED,TEST_USED_EXPECTED_TEST_FRAMEWORK,TEST_USED_CORRECT_APPEND_OPERATION,TEST_INPUT_FILENAME,TEST_LANGUAGE,TEST_NAME,TEST_DIAGNOSTICS
yaml,chat-context,gemini-1.5-pro-latest,chat,question_000/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided codebase context, here's where symf is used as a context source for different Cody features:

- **Chat**
    - The `cody.experimental.symfContext` setting (default: true) enables symf code search context for chat. This suggests symf is used to fetch relevant code snippets from the codebase to provide context to Cody during chat conversations. 
    - The `ChatPanelsManager.ts` file imports `SymfRunner`, indicating its involvement in managing chat panels and potentially using symf for context there.
    - The `getEnhancedContextOptions` interface in `chat-view/context.ts` includes `symf: SymfRunner | null`, suggesting symf is used as a potential context provider for enhancing chat context.

- **Command Execution**
    - While not explicitly stated, the use of `SymfRunner` in `ChatPanelsManager` and the shared context fetching mechanisms between chat and commands suggest that symf might also be used for providing context during Cody command execution.

**In summary:** symf primarily acts as a code search engine to provide relevant code context within Cody's chat feature. It's likely also used for command execution, though this is not explicitly confirmed in the provided code snippets.",Where all is symf used as a context source for different Cody features?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:0-643"",""content"":""import { execFile as _execFile, spawn } from 'node:child_process'\nimport fs, { access, rename, rm, writeFile } from 'node:fs/promises'\nimport os from 'node:os'\nimport { promisify } from 'node:util'\n\nimport { Mutex } from 'async-mutex'\nimport { mkdirp } from 'mkdirp'\nimport * as vscode from 'vscode'\n\nimport {\n    type FileURI,\n    type IndexedKeywordContextFetcher,\n    type PromptString,\n    type Result,\n    type SourcegraphCompletionsClient,\n    assertFileURI,\n    isFileURI,\n    isWindows,\n    uriBasename,\n    uriDirname,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\nimport { getSymfPath } from './download-symf'\nimport { symfExpandQuery } from './symfExpandQuery'\n\nconst execFile = promisify(_execFile)\nconst oneDayMillis = 1000 * 60 * 60 * 24\n\ninterface CorpusDiff {\n    maybeChangedFiles?: boolean\n    changedFiles?: string[]\n    millisElapsed?: number\n}\n\nfunction parseJSONToCorpusDiff(json: string): CorpusDiff {\n    const obj = JSON.parse(json)\n    if (obj.maybeChangedFiles === undefined && obj.changedFiles === undefined) {\n        throw new Error(`malformed CorpusDiff: ${json}`)\n    }\n    return obj as CorpusDiff\n}\n\ninterface IndexOptions {\n    retryIfLastAttemptFailed: boolean\n    ignoreExisting: boolean\n}\n\nexport class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n}\n\nexport interface IndexStartEvent {\n    scopeDir: FileURI\n    cancel: () => void\n    done: Promise<void>\n}\n\ninterface IndexEndEvent {\n    scopeDir: FileURI\n}\n\nclass IndexStatus implements vscode.Disposable {\n    private startEmitter = new vscode.EventEmitter<IndexStartEvent>()\n    private stopEmitter = new vscode.EventEmitter<IndexEndEvent>()\n    private inProgressDirs = new Set<string /* uri.toString() */>()\n\n    public dispose(): void {\n        this.startEmitter.dispose()\n        this.stopEmitter.dispose()\n    }\n\n    public didStart(event: IndexStartEvent): void {\n        this.inProgressDirs.add(event.scopeDir.toString())\n        this.startEmitter.fire(event)\n    }\n\n    public didEnd(event: IndexEndEvent): void {\n        this.inProgressDirs.delete(event.scopeDir.toString())\n        this.stopEmitter.fire(event)\n    }\n\n    public onDidStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.startEmitter.event(cb)\n    }\n\n    public onDidEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.stopEmitter.event(cb)\n    }\n\n    public isInProgress(scopeDir: FileURI): boolean {\n        return this.inProgressDirs.has(scopeDir.toString())\n    }\n}\n\nasync function fileExists(file: vscode.Uri): Promise<boolean> {\n    if (!isFileURI(file)) {\n        throw new Error('only file URIs are supported')\n    }\n    try {\n        await access(file.fsPath, fs.constants.F_OK)\n        return true\n    } catch {\n        return false\n    }\n}\n\nfunction parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n}\n\n/**\n * A simple read-write lock.\n *\n * Note: it is possible for an overlapping succession of readers to starve out\n * any writers that are waiting for the mutex to be released. In practice, this\n * is not an issue, because we don't expect the user to issue neverending\n * while trying to update the index.\n */\nclass RWLock {\n    /**\n     * Invariants:\n     * - if readers > 0, then mu is locked\n     * - if readers === 0 and mu is locked, then a writer is holding the lock\n     */\n    private readers = 0\n    private mu = new Mutex()\n\n    public async withRead<T>(fn: () => Promise<T>): Promise<T> {\n        while (this.readers === 0) {\n            if (this.mu.isLocked()) {\n                // If mu is locked at this point, it must be held by the writer.\n                // We spin in this case, rather than try to acquire the lock,\n                // because multiple readers blocked on acquiring the lock will\n                // execute serially when the writer releases the lock (whereas\n                // we want all reads to be concurrent).\n                await new Promise(resolve => setTimeout(resolve, 100))\n                continue\n            }\n            // No readers or writers: acquire lock for readers\n            await this.mu.acquire()\n            break\n        }\n        this.readers++\n        try {\n            return await fn()\n        } finally {\n            this.readers--\n            if (this.readers === 0) {\n                this.mu.release()\n            }\n        }\n    }\n\n    public async withWrite<T>(fn: () => Promise<T>): Promise<T> {\n        return this.mu.runExclusive(fn)\n    }\n}\n\nfunction toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:0-27"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type AuthStatus,\n    type ChatClient,\n    type Configuration,\n    type ConfigurationWithAccessToken,\n    type FeatureFlagProvider,\n    type Guardrails,\n    ModelProvider,\n    ModelUsage,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport type { MessageProviderOptions } from '../MessageProvider'\nimport type { ExtensionMessage } from '../protocol'\n\nimport type { EnterpriseContextFactory } from '../../context/enterprise-context-factory'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport { chatHistory } from './ChatHistoryManager'\nimport { CodyChatPanelViewType } from './ChatManager'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77"",""content"":""        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type ConfigurationUseContext,\n    type ContextItem,\n    ContextItemSource,\n    MAX_BYTES_PER_FILE,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    type PromptString,\n    type Result,\n    isFileURI,\n    truncateTextNearestLine,\n    uriBasename,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { RemoteSearch } from '../../context/remote-search'\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug, logError } from '../../log'\n\ninterface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:98-111"",""content"":""    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/provider.ts:0-22"",""content"":""import { type CodyCommand, type ContextItem, featureFlagProvider } from '@sourcegraph/cody-shared'\n\nimport * as vscode from 'vscode'\nimport { CodyCommandMenuItems } from '..'\nimport { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport { getContextFileFromShell } from '../context/shell'\nimport { showCommandMenu } from '../menus'\nimport type { CodyCommandArgs } from '../types'\nimport { getDefaultCommandsMap } from '../utils/get-commands'\nimport { CustomCommandsManager, openCustomCommandDocsLink } from './custom-commands'\n\nconst vscodeDefaultCommands = getDefaultCommandsMap(CodyCommandMenuItems as CodyCommand[])\n\n/**\n * Provides management and interaction capabilities for both default and custom Cody commands.\n *\n * It is responsible for initializing, grouping, and refreshing command sets,\n * as well as handling command menus and execution.\n */\nexport class CommandsProvider implements vscode.Disposable {\n    private disposables: vscode.Disposable[] = []\n    protected readonly defaultCommands = vscodeDefaultCommands\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/context/chatContext.ts:70-75"",""content"":""export async function isURLContextFeatureFlagEnabled(): Promise<boolean> {\n    return (\n        vscode.workspace.getConfiguration('cody').get<boolean>('experimental.urlContext') === true ||\n        (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.URLContext))\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/types.ts:0-46"",""content"":""import type { CodyCommand, ContextItem, EventSource, PromptString } from '@sourcegraph/cody-shared'\n\nimport type { Range, Uri } from 'vscode'\nimport type { ExecuteEditArguments } from '../edit/execute'\n\n/**\n * The name of the file for configuring Custom Commands.\n */\nexport enum ConfigFiles {\n    // Cody Commands config file location in VS CODE\n    // TODO: Migrate to use the one in /.cody\n    VSCODE = '.vscode/cody.json',\n    // Cody Commands config file location for all clients\n    COMMAND = '.cody/commands.json',\n}\n\n/**\n * Creates a CodyCommandArgs object with default values.\n * Generates a random requestID if one is not provided.\n * Merges any provided args with the defaults.\n */\nexport interface CodyCommandsFile {\n    // A set of reusable commands where instructions (prompts) and context can be configured.\n    commands: Map<string, CodyCommand>\n}\n\nexport interface CodyCommandArgs extends ExecuteEditArguments {\n    // for tracing the life of the request\n    requestID: string\n    // where the command was triggered from\n    source?: EventSource\n    // runs the command in chat mode, even if it's an edit command\n    runInChatMode?: boolean\n    // current context to add on top of the command context\n    userContextFiles?: ContextItem[]\n    additionalInstruction?: PromptString\n\n    /**\n     * Editor Context\n     */\n    // The URI of the file in the editor\n    uri?: Uri\n    // The range of the selection in the editor\n    range?: Range\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1085-1094"",""content"":""- Increased autocomplete debounce time feature flag support. [pull/733](https://github.com/sourcegraph/cody/pull/733)\n- Show an update notice after extension updates. [pull/746](https://github.com/sourcegraph/cody/pull/746)\n- Experimental user setting `cody.experimental.localSymbols` to enable inclusion of symbol definitions in the LLM context window. [pull/692](https://github.com/sourcegraph/cody/pull/692)\n- Experimental command `/symf`, which uses a local keyword index to perform searches for symbols. Requires setting `cody.experimental.symf.path` and `cody.experimental.symf.anthropicKey`. [pull/728](https://github.com/sourcegraph/cody/pull/728).\n\n### Fixed\n\n- Inline Chat: Fix issue where state was not being set correctly, causing Cody Commands to use the selection range from the last created Inline Chat instead of the current selection. [pull/602](https://github.com/sourcegraph/cody/pull/602)\n- Cody Commands: Commands that use the current file as context now correctly generate context message for the current file instead of using codebase context generated from current selection. [pull/683](https://github.com/sourcegraph/cody/pull/683)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/agentContextSorting.ts:0-21"",""content"":""import { type ContextItem, ContextItemSource } from '@sourcegraph/cody-shared'\n\nconst isAgentTesting = process.env.CODY_SHIM_TESTING === 'true'\n\n/**\n * Sorts the provided `ContextItem` array in a deterministic order for stable tests.\n * This function is only used when the `CODY_SHIM_TESTING` environment variable is\n * set to `'true'`, which indicates that the agent is running in a testing environment.\n *\n * NOTE: Agent tests require deterministic ordering of context files for consistent results across different file systems\n * These helper functions should be called before we pass context items/files to a prompt builder.\n * This is necessary to get the tests passing in CI because we need the prompts to be stable for the HTTP replay mode to succeed.\n *\n * @param files - The array of `ContextItem` objects to sort.\n */\nexport function sortContextItems(files: ContextItem[]): void {\n    if (!isAgentTesting) {\n        return\n    }\n    // Sort results for deterministic ordering for stable tests. Ideally, we\n    // could sort by some numerical score from symf based on how relevant\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:260-277"",""content"":""    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_001/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_002/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the code and my understanding of Cody's functionality, here are the different context ranking logics implemented:

**1. Local Context Ranking with Language Model:**

* This approach leverages a language model running in a local child process (""cody-engine"").
* It computes features for code files in the workspace to enable semantic similarity comparisons.
* When a user requests context (e.g., for a chat message or code completion), it ranks available context items (code snippets, files, etc.) based on their relevance to the user's query.
* This ranking is done by sending the query and context items to the ""context-ranking"" service running in the child process.
* The service returns a ranked list of context item IDs, which are then used to reorder the original context items.

**2. Embedding-Based Context Retrieval:**

* This approach uses pre-computed embeddings of code and text.
* When a user requests context, their query is embedded into the same vector space as the pre-computed embeddings.
* The most similar embeddings (representing the most relevant code snippets) are retrieved and returned as context.
* This method is particularly useful for large codebases where real-time ranking with a language model might be too slow.

**3. Model-Specific Embeddings for Chat:**

* This approach appears to be specifically designed for enhancing chat functionality.
* It uses a dedicated model (""sentence-transformers/multi-qa-mpnet-base-dot-v1"") for generating embeddings.
* When a user asks a question in chat, this model is used to retrieve relevant code snippets from the codebase based on semantic similarity.

**4. Default Ranking (No Ranking):**

* If the user is not on a supported platform (e.g., not using VS Code) or if the context ranking service is not available or initialized, Cody falls back to using the context items in their original order.
* This means no ranking is applied, and the context is provided as is.

**Additional Notes:**

* Cody allows users to customize the context window size for chat, influencing how much context is considered.
* The specific models and ranking algorithms used by Cody can be updated and improved over time.
* The choice of which context ranking logic to use might depend on factors like the user's query, the available computing resources, and the configuration of the Cody extension.",What different context ranking logics are implemented in Cody?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/keyboard.md:0-19"",""content"":""## Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can also update these bindings in the `Keyboard Shortcuts Editor`.\n\n### Keyboard Shortcuts Editor\n\nThe `Keyboard Shortcuts Editor` allows you to easily update the default bindings (keyboard shortcuts). This is particularly useful if the default key bindings conflict with your current or preferred key bindings. By accessing the `Keyboard Shortcuts Editor`, you can search for specific commands, reassign keybindings, and customize your keyboard shortcuts to suit your workflow.\n\n### Getting Started\n\nTo get started: \n1. Click on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**` to open the `Keyboard Shortcuts Editor`.\n2. In the `Keyboard Shortcuts Editor`, you can search for a specific command by typing in the search bar.\n3. Once you have found the command you want to reassign keybindings for, click on it to select it.\n4. Follow the instruction on screen to assign a new keybinding.\n\n** Pro-tips for assigning keyboard shortcuts for Cody**\n<br> You can assign key bindings (keyboard shortcuts) to individual custom commands.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:985-1005"",""content"":""\n## [0.12.1]\n\n### Added\n\n### Fixed\n\n- Fixes an issue that caused the `cody-autocomplete-claude-instant-infill` feature flag to have no effect. [pull/1132](https://github.com/sourcegraph/cody/pull/1132)\n\n### Changed\n\n## [0.12.0]\n\n### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:0-16"",""content"":""# Cody quality tools\n\nThis section documents the tools we have to assess the quality of Cody in different scenarios.\n\nAs Cody is a BYOLLM product (Bring-your-own-LLM), when we introduce/use a new LLM (for example, a customer's own LLM model that they developed/trained themselves) we have a need to be able to quantify how well Cody is working with it.\n\n## Autocompletion\n\n### Influencing autocomplete performance\n\nCody autocompletion (code completions in your editor) can be powered by two types of models:\n\n1. Chat-based models, where we \""tell\"" the LLM it supposed to perform code completion in plain English, give it a code snippet, and extract the response code snippet from its (otherwise English) response.\n2. An actual code-based model, these are LLMs that are trained to produce code only and can't produce English responses, they speak only code.\n\nFor chat-based models, we can influence the performance by altering the prompting AND context. For code-based models, we can typically influence the performance by adjusting the amount and relevancy of context only, as there is no prompting to adjust.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:151-166"",""content"":""- Command: Enhanced the context provided to the Test command to help the language model determine the appropriate testing framework to use. [pull/3344](https://github.com/sourcegraph/cody/pull/3344)\n- Document: Upgraded to use a faster model. [pull/3275](https://github.com/sourcegraph/cody/pull/3275)\n- Properly throw an error when attempting to parse an incomplete SSE stream with the nodeClient. [pull/3479](https://github.com/sourcegraph/cody/pull/3479)\n\n## [1.8.3]\n\n### Fixed\n\n- Fix crash upon initialization in the stable build if a prerelease version of the VS Code extension was used for chat after 2024-03-08. [pull/3394](https://github.com/sourcegraph/cody/pull/3394)\n\n## [1.8.2]\n\n### Added\n\n- Debug: Added new commands (`Cody Debug: Enable Debug Mode` and `Cody Debug: Open Output Channel`) to the editor Command Palette and the `Settings & Support` sidebar to streamline the process of getting started with debugging Cody. [pull/3342](https://github.com/sourcegraph/cody/pull/3342)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:0-24"",""content"":""# Changelog\n\nThis is a log of all notable changes to Cody for VS Code. [Unreleased] changes are included in the nightly pre-release builds.\n\n## [Unreleased]\n\n### Added\n\n### Fixed\n\n- Chat: Fixed an issue where Cody's responses were not visible in small windows. [pull/3859](https://github.com/sourcegraph/cody/pull/3859)\n- Edit: Fixed an issue where an Edit task would not correctly respin when an irresolvable conflict is encountered. [pull/3872](https://github.com/sourcegraph/cody/pull/3872)\n- Chat: Fixed an issue where older chats were displaying as 'N months ago' instead of the number in the Chat History sidebar. [pull/3864](https://github.com/sourcegraph/cody/pull/3864)\n\n### Changed\n\n- Debug: Removed the `cody.debug.enabled` setting. Baseline debugging is now enabled by default [pull/3873](https://github.com/sourcegraph/cody/pull/3873)\n\n\n## [1.14.0]\n\n### Added\n\n- Chat: Add highlighted code to Cody Chat as `@-mentions` context by right-clicking on the code and selecting `Cody Chat: Add context`. [pull/3713](https://github.com/sourcegraph/cody/pull/3713)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/doc/keyboard.md:0-18"",""content"":""# Keyboard Shortcuts\n\nCody offers an extensive set of default key bindings (keyboard shortcuts) to make it easy for you to perform various actions using the keyboard. You can easily update these bindings in the `Keyboard Shortcuts editor`, which you can access by clicking on the **Keyboard Shortcuts** icon in the Cody sidebar under `**SETTINGS AND SUPPORT**`.\n\nThis feature can be particularly useful if the default key bindings conflict with your current or preferred key bindings.\n\n## Keyboard Shortcuts Editor\n\nThe Keyboard Shortcuts editor allows you to easily update the key bindings for any of the Cody commands. To open the `Keyboard Shortcuts Editor`:\n1. Open the Cody sidebar and expand the `**SETTINGS AND SUPPORT**` section.\n2. Click on the `**Keyboard Shortcuts**` icon.\n\n## Custom Commands\n\n![editor](images/keyboard_editor.png)\n\nYou have the option to assign key bindings (keyboard shortcuts) to individual custom commands:\n1. In the Cody sidebar under `**SETTINGS AND SUPPORT**`, click on the `**Keyboard Shortcuts**` icon to open the Keyboard Shortcuts editor.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:0-32"",""content"":""// The default Cody Commands\nexport type DefaultCodyCommands = DefaultChatCommands | DefaultEditCommands\n\n// Default Cody Commands that runs as a Chat request\nexport enum DefaultChatCommands {\n    Explain = 'explain', // Explain code\n    Unit = 'unit', // Generate unit tests in Chat\n    Smell = 'smell', // Generate code smell report in Chat\n}\n\n// Default Cody Commands that runs as an Inline Edit command\nexport enum DefaultEditCommands {\n    Test = 'test', // Generate unit tests with inline edit\n    Doc = 'doc', // Generate documentation with inline edit\n    Edit = 'edit', // Edit code with inline edit\n}\n\n// The blueprint of a Cody Custom Command\nexport interface CodyCommand {\n    /**\n     * @deprecated Use 'commandKey' instead.\n     */\n    slashCommand?: string\n    /**\n     * key of the command, e.g. 'smell' for Code Smell\n     */\n    key: string\n    prompt: string\n    description?: string\n    context?: CodyCommandContext\n    type?: CodyCommandType\n    mode?: CodyCommandMode\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:0-313"",""content"":""import * as fspromises from 'node:fs/promises'\nimport * as path from 'node:path'\nimport {\n    type ConfigurationWithAccessToken,\n    type ContextItem,\n    ContextItemSource,\n    type EmbeddingsSearchResult,\n    type FileURI,\n    type PromptString,\n    isDotCom,\n    isFileURI,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport { URI } from 'vscode-uri'\nimport type { RankContextItem, RankerPrediction } from '../jsonrpc/context-ranking-protocol'\nimport type { MessageHandler } from '../jsonrpc/jsonrpc'\nimport { logDebug } from '../log'\nimport { captureException } from '../services/sentry/sentry'\nimport { CodyEngineService } from './cody-engine'\n\ninterface ContextRanker {\n    rankContextItems(query: PromptString, contextItems: ContextItem[]): Promise<ContextItem[]>\n}\n\nexport function createContextRankingController(\n    context: vscode.ExtensionContext,\n    config: ContextRankerConfig\n): ContextRankingController {\n    return new ContextRankingController(context, config)\n}\n\nexport type ContextRankerConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & { experimentalChatContextRanker: boolean | undefined }\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/context-ranking`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/context-ranking`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\context-ranking`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\nexport class ContextRankingController implements ContextRanker {\n    // The cody-engine child process, if starting or started.\n    private service: Promise<MessageHandler> | undefined\n    // True if the service has finished starting and been initialized.\n    private serviceStarted = false\n    // Whether the account is a consumer account.\n    private endpointIsDotcom = false\n    private accessToken: string | undefined\n    private readonly indexLibraryPath: FileURI | undefined\n\n    constructor(\n        private readonly context: vscode.ExtensionContext,\n        config: ContextRankerConfig\n    ) {\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n        this.accessToken = config.accessToken || undefined\n        logDebug('ContextRankingController', 'constructor')\n    }\n\n    public async start(): Promise<void> {\n        logDebug('ContextRankingController', 'start')\n        await this.getService()\n\n        const repoUri = this.getRepoUri()\n        if (repoUri && isFileURI(repoUri)) {\n            this.computeFeatures(repoUri)\n        }\n    }\n\n    public async setAccessToken(serverEndpoint: string, token: string | null): Promise<void> {\n        const endpointIsDotcom = isDotCom(serverEndpoint)\n        logDebug(\n            'ContextRankingController',\n            'setAccessToken',\n            endpointIsDotcom ? 'is dotcom' : 'not dotcom'\n        )\n        this.endpointIsDotcom = endpointIsDotcom\n        if (token === this.accessToken) {\n            return Promise.resolve()\n        }\n        this.accessToken = token || undefined\n    }\n\n    private getRepoUri(): vscode.Uri | undefined {\n        return vscode.workspace.workspaceFolders?.[0]?.uri\n    }\n\n    // Tries to compute the index at the start of the service.\n    private async computeFeatures(repoDir: FileURI): Promise<void> {\n        try {\n            await (await this.getService()).request('context-ranking/compute-features', {\n                repoPath: repoDir.fsPath,\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in feature preCompute call',\n                captureException(error),\n                JSON.stringify(error)\n            )\n        }\n    }\n\n    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n    }\n\n    private async createLogsFile(dirPath: string): Promise<string> {\n        await fspromises.mkdir(dirPath, { recursive: true })\n        const fileName = 'ranker-payload.jsonl'\n        const filePath = path.join(dirPath, fileName)\n        if (\n            !(await fspromises\n                .access(filePath)\n                .then(() => true)\n                .catch(() => false))\n        ) {\n            await fspromises.writeFile(filePath, '')\n        }\n        return filePath\n    }\n\n    private setupContextRankingService = async (service: MessageHandler): Promise<void> => {\n        // The payload is very big to print on console. SKipping print on console for now until we start logging in BQ.\n        service.registerNotification(\n            'context-ranking/rank-items-logger-payload',\n            async (payload: string) => {\n                const indexPath = getIndexLibraryPath()\n                const logsFile = await this.createLogsFile(path.join(indexPath.fsPath, 'ranker-logs'))\n                fspromises.appendFile(logsFile, payload + '\\n')\n                logDebug(\n                    'ContextRankingController',\n                    'rank-items-logger-payload',\n                    'appending logs at the path',\n                    logsFile\n                )\n            }\n        )\n        let indexPath = getIndexLibraryPath()\n        // Tests may override the index library path\n        if (this.indexLibraryPath) {\n            indexPath = this.indexLibraryPath\n        }\n        if (this.accessToken) {\n            await service.request('context-ranking/initialize', {\n                indexPath: indexPath.fsPath,\n                accessToken: this.accessToken,\n            })\n            this.serviceStarted = true\n        } else {\n            logDebug('ContextRankingController', 'setupContextRankingService', 'no access token found')\n        }\n    }\n\n    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n    }\n\n    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n    }\n\n    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n            return []\n        }\n    }\n\n    public async precomputeContextRankingFeatures(query: PromptString): Promise<void> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return\n        }\n        try {\n            const service = await this.getService()\n            await service.request('context-ranking/precompute-query-embedding', {\n                query: query.toString(),\n            })\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n                captureException(error)\n            )\n        }\n    }\n\n    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-56"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""}]",Gather information,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_003/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided code snippets, Cody context uses these CodeSearch services:

* **Remote Search:** This service allows Cody to search across your entire codebase on Sourcegraph. It's used for features like finding file references, understanding how components are used across projects, and providing context-aware code completions. (`cody_test/vscode/src/context/remote-search.ts`)
* **Local Search:** This service allows Cody to search within your locally opened files and workspace. It's used for features like finding symbol definitions, understanding the structure of your current file, and providing basic code intelligence. This is implied by the existence of `RemoteSearch` and the need for both local and remote context.

Let me know if you have more questions about Cody's context or any other part of the codebase!",What all different CodeSearch services are being used by Cody context?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1466-1491"",""content"":""\n## [0.1.5]\n\n### Added\n\n### Fixed\n\n- Inline Assist broken decorations for Inline-Fixup tasks [pull/52322](https://github.com/sourcegraph/sourcegraph/pull/52322)\n\n### Changed\n\n- Various Cody completions related improvements [pull/52365](https://github.com/sourcegraph/sourcegraph/pull/52365)\n\n## [0.1.4]\n\n### Added\n\n- Added support for local keyword search on Windows. [pull/52251](https://github.com/sourcegraph/sourcegraph/pull/52251)\n\n### Fixed\n\n- Setting `cody.useContext` to `none` will now limit Cody to using only the currently open file. [pull/52126](https://github.com/sourcegraph/sourcegraph/pull/52126)\n- Fixes race condition in telemetry. [pull/52279](https://github.com/sourcegraph/sourcegraph/pull/52279)\n- Don't search for file paths if no file paths to validate. [pull/52267](https://github.com/sourcegraph/sourcegraph/pull/52267)\n- Fix handling of embeddings search backward compatibility. [pull/52286](https://github.com/sourcegraph/sourcegraph/pull/52286)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/enterprise-context-factory.ts:39-41"",""content"":""    public createRemoteSearch(): RemoteSearch {\n        return new RemoteSearch()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/index.ts:0-25"",""content"":""import * as vscode from 'vscode'\n\nimport { type CodyCommandContext, type ContextItem, isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\nimport { Utils } from 'vscode-uri'\nimport { logDebug } from '../../log'\nimport { getContextFileFromCurrentFile } from './current-file'\nimport { getContextFileFromDirectory } from './directory'\nimport { getContextFileFromUri } from './file-path'\nimport { getContextFileFromTabs } from './open-tabs'\nimport { getContextFileFromCursor } from './selection'\n\n/**\n * Gets the context files for a Cody command based on the given configuration.\n *\n * This handles getting context files from the selection, current file,\n * file path, directories, and open tabs based on the `config` object passed in.\n *\n * Context from context.command is added during the initial step in CommandController.\n *\n * The returned context files are filtered to remove any files ignored by Cody.\n */\nexport const getCommandContextFiles = async (config: CodyCommandContext): Promise<ContextItem[]> => {\n    try {\n        const contextFiles: ContextItem[] = []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:92-108"",""content"":""\n### Document\n\n- [ ] Verify that the option to run the `Document Code` command is available in the following locations:\n  - [ ] Sidebar `Document Code`\n  - [ ] Context (right-click) menu `Cody > Document Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Document Code`\n  - [ ] Cody Command Menu (option+c, `Document Code`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Document Code` command.\n- [ ] Verify that an icon appears above the highlighted code with \""Cody is working...\"" while Cody generates documentation.\n- [ ] Verify that you can see a diff view of the generated documentation in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the documentation by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Document Code` command again.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1214-1234"",""content"":""\n### Fixed\n\n### Changed\n\n- The setting `cody.autocomplete.experimental.triggerMoreEagerly` (which causes autocomplete to trigger earlier, before you type a space or other non-word character) now defaults to `true`.\n- If you run the `Trigger Inline Suggestion` VS Code action, 3 suggestions instead of just 1 will be shown.\n\n## [0.6.1]\n\n### Added\n\n- A new experimental user setting `cody.autocomplete.experimental.triggerMoreEagerly` causes autocomplete to trigger earlier, before you type a space or other non-word character.\n- [Internal Only] `Custom Recipe`: Support context type selection when creating a new recipe via UI. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n- New `/open` command for opening workspace files from chat box. [pull/327](https://github.com/sourcegraph/cody/pull/327)\n\n### Fixed\n\n- Insert at Cusor now inserts the complete code snippets at cursor position. [pull/282](https://github.com/sourcegraph/cody/pull/282)\n- Minimizing the change of Cody replying users with response related to the language-uage prompt. [pull/279](https://github.com/sourcegraph/cody/pull/279)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:113-119"",""content"":""    private getService(): Promise<MessageHandler> {\n        if (!this.service) {\n            const instance = CodyEngineService.getInstance(this.context)\n            this.service = instance.getService(this.setupContextRankingService)\n        }\n        return this.service\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1412-1423"",""content"":""- Cody Inline Assist: Decorations for `/fix` errors. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Open file paths from Cody's responses in workspace. [pull/53069](https://github.com/sourcegraph/sourcegraph/pull/53069)\n- Help & Getting Started: Walkthrough to help users get setup with Cody and discover new features. [pull/52560](https://github.com/sourcegraph/sourcegraph/pull/52560)\n\n### Fixed\n\n- Cody Inline Assist: Decorations for `/fix` on light theme. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Use more than 1 context file for `/touch`. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody Inline Assist: Fixes cody processing indefinitely issue. [pull/52796](https://github.com/sourcegraph/sourcegraph/pull/52796)\n- Cody completions: Various fixes for completion analytics. [pull/52935](https://github.com/sourcegraph/sourcegraph/pull/52935)\n- Cody Inline Assist: Indentation on `/fix` [pull/53068](https://github.com/sourcegraph/sourcegraph/pull/53068)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:29-162"",""content"":""export class RemoteSearch implements ContextStatusProvider, IRemoteSearch {\n    public static readonly MAX_REPO_COUNT = 10\n\n    private statusChangedEmitter = new vscode.EventEmitter<ContextStatusProvider>()\n\n    // Repositories we are including automatically because of the workspace.\n    private reposAuto: Map<string, DisplayRepo> = new Map()\n\n    // Repositories the user has added manually.\n    private reposManual: Map<string, DisplayRepo> = new Map()\n\n    public dispose(): void {\n        this.statusChangedEmitter.dispose()\n    }\n\n    // #region ContextStatusProvider implementation.\n\n    public onDidChangeStatus(callback: (provider: ContextStatusProvider) => void): Disposable {\n        return this.statusChangedEmitter.event(callback)\n    }\n\n    public get status(): ContextGroup[] {\n        return [...this.getRepoIdSet()].map(id => {\n            const auto = this.reposAuto.get(id)\n            const manual = this.reposManual.get(id)\n            const displayName = auto?.displayName || manual?.displayName || '?'\n            return {\n                displayName,\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id,\n                        inclusion: auto ? 'auto' : 'manual',\n                    },\n                ],\n            }\n        })\n    }\n\n    // #endregion\n\n    // Removes a manually included repository.\n    public removeRepo(repoId: string): void {\n        if (this.reposManual.delete(repoId)) {\n            this.statusChangedEmitter.fire(this)\n        }\n    }\n\n    // Sets the repos to search. RepoInclusion.Automatic is for repositories added\n    // automatically based on the workspace; these are presented differently\n    // and can't be removed by the user. RepoInclusion.Manual is for repositories\n    // added manually by the user.\n    public setRepos(repos: repofetcher.Repo[], inclusion: RepoInclusion): void {\n        const repoMap: Map<string, DisplayRepo> = new Map(\n            repos.map(repo => [repo.id, { displayName: repo.name }])\n        )\n        switch (inclusion) {\n            case RepoInclusion.Automatic: {\n                this.reposAuto = repoMap\n                break\n            }\n            case RepoInclusion.Manual: {\n                this.reposManual = repoMap\n                break\n            }\n        }\n        this.statusChangedEmitter.fire(this)\n    }\n\n    public getRepos(inclusion: RepoInclusion): repofetcher.Repo[] {\n        return [\n            ...(inclusion === RepoInclusion.Automatic ? this.reposAuto : this.reposManual).entries(),\n        ].map(([id, repo]) => ({ id, name: repo.displayName }))\n    }\n\n    // Gets the set of all repositories to search.\n    public getRepoIdSet(): Set<string> {\n        return new Set([...this.reposAuto.keys(), ...this.reposManual.keys()])\n    }\n\n    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n    }\n\n    // IRemoteSearch implementation. This is only used for inline edit context.\n\n    public async setWorkspaceUri(uri: URI): Promise<void> {\n        const codebase = getCodebaseFromWorkspaceUri(uri)\n        if (!codebase) {\n            this.setRepos([], RepoInclusion.Automatic)\n            return\n        }\n        const repos = await graphqlClient.getRepoIds([codebase], 10)\n        if (isError(repos)) {\n            throw repos\n        }\n        this.setRepos(repos, RepoInclusion.Automatic)\n    }\n\n    public async search(query: PromptString): Promise<ContextItemFile[]> {\n        const results = await this.query(query)\n        if (isError(results)) {\n            throw results\n        }\n        return (results || []).map(\n            result =>\n                ({\n                    type: 'file',\n                    uri: result.uri,\n                    repoName: result.repoName,\n                    revision: result.commit,\n                    source: ContextItemSource.Unified,\n                    content: result.content,\n                    range: {\n                        start: {\n                            line: result.startLine,\n                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:993-1016"",""content"":""          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enables verbose debug output. Debug messages may contain more details if the invocation includes verbose information.\""\n        },\n        \""cody.debug.filter\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Regular expression to filter debug output. If empty, defaults to '.*', which prints all messages.\""\n        },\n        \""cody.telemetry.level\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""enum\"": [\""all\"", \""off\""],\n          \""enumDescriptions\"": [\""Sends usage data and errors.\"", \""Disables all extension telemetry.\""],\n          \""markdownDescription\"": \""Controls the telemetry about Cody usage and errors. See [Cody usage and privacy notice](https://about.sourcegraph.com/terms/cody-notice).\"",\n          \""default\"": \""all\""\n        },\n        \""cody.autocomplete.advanced.provider\"": {\n          \""type\"": \""string\"",\n          \""default\"": null,\n          \""enum\"": [\n            null,\n            \""anthropic\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1050-1068"",""content"":""          \""markdownDescription\"": \""Prevent autocomplete requests while inside code comments.\""\n        },\n        \""cody.experimental.foldingRanges\"": {\n          \""type\"": \""string\"",\n          \""enum\"": [\""lsp\"", \""indentation-based\""],\n          \""enumDescriptions\"": [\n            \""Use folding ranges that are enabled by default in VS Code, and are usually powered by LSP\"",\n            \""Use custom implementation of folding ranges that is indentation based. This is the implementation that is used by other Cody clients like the JetBrains plugin\""\n          ],\n          \""markdownDescription\"": \""Determines the algorithm Cody uses to detect folding ranges. Cody uses folding ranges for several features like the 'Document code' command\"",\n          \""default\"": \""all\""\n        },\n        \""cody.experimental.hoverCommands\"": {\n          \""type\"": \""boolean\"",\n          \""default\"": true,\n          \""markdownDescription\"": \""Display commands in hover tooltips for code elements.\"",\n          \""description\"": \""%config.experimental.hoverCommands%\"",\n          \""tags\"": [\""experimental\"", \""feature-flag\""]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:1123-1136"",""content"":""\n- Cody Commands: Add tab-to-complete & enter-to-complete behavior. [pull/606](https://github.com/sourcegraph/cody/pull/606)\n- Option to toggle `cody.experimental.editorTitleCommandIcon` setting through status bar. [pull/611](https://github.com/sourcegraph/cody/pull/611)\n- New walkthrough for Cody Commands. [pull/648](https://github.com/sourcegraph/cody/pull/648)\n\n### Fixed\n\n- Update file link color to match buttons. [pull/600](https://github.com/sourcegraph/cody/pull/600)\n- Handle `socket hung up` errors that are not caused by the `stop generating` button. [pull/598](https://github.com/sourcegraph/cody/pull/598)\n- Fix \""Reload Window\"" appearing in all VS Code views. [pull/603](https://github.com/sourcegraph/cody/pull/603)\n- Fixes issues where in some instances, suggested autocomplete events were under counted. [pull/649](https://github.com/sourcegraph/cody/pull/649)\n- Various smaller tweaks to autocomplete analytics. [pull/644](https://github.com/sourcegraph/cody/pull/644)\n- Includes the correct pre-release version in analytics events. [pull/641](https://github.com/sourcegraph/cody/pull/641)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1016-1033"",""content"":""            \""fireworks\"",\n            \""unstable-openai\"",\n            \""experimental-ollama\"",\n            \""experimental-openaicompatible\""\n          ],\n          \""markdownDescription\"": \""The provider used for code autocomplete. Most providers other than `anthropic` require the `cody.autocomplete.advanced.serverEndpoint` and `cody.autocomplete.advanced.accessToken` settings to also be set. Check the Cody output channel for error messages if autocomplete is not working as expected.\""\n        },\n        \""cody.autocomplete.advanced.serverEndpoint\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The server endpoint used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.accessToken\"": {\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""The access token used for code autocomplete. This is only supported with a provider other than `anthropic`.\""\n        },\n        \""cody.autocomplete.advanced.model\"": {\n          \""type\"": \""string\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:940-962"",""content"":""          \""examples\"": [\""Answer all my questions in Spanish.\""]\n        },\n        \""cody.edit.preInstruction\"": {\n          \""order\"": 7,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the end of all instructions for edit commands (e.g. \\\""Write all unit tests with Jest instead of detected framework.\\\"")\"",\n          \""examples\"": [\""Write all unit tests with Jest instead of detected framework.\""]\n        },\n        \""cody.codeActions.enabled\"": {\n          \""order\"": 11,\n          \""title\"": \""Cody Code Actions\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Add Cody options to Quick Fix menus for fixing, explaining, documenting, and editing code.\"",\n          \""default\"": true\n        },\n        \""cody.commandHints.enabled\"": {\n          \""order\"": 12,\n          \""title\"": \""Cody Command Hints\"",\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable hints for Cody commands such as \\\""Opt+K to Edit\\\"" or \\\""Opt+D to Document\\\""\"",\n          \""default\"": true\n        },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/cody-ignore.ts:0-229"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    CODY_IGNORE_POSIX_GLOB,\n    type ConfigurationWithAccessToken,\n    type IgnoreFileContent,\n    ignores,\n} from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\nimport { telemetryService } from './telemetry'\nimport { telemetryRecorder } from './telemetry-v2'\n\nconst utf8 = new TextDecoder('utf-8')\n\n/**\n * Parses `.code/ignore` files from the workspace and sets up a watcher to refresh\n * whenever the files change.\n *\n * NOTE: Execute ONCE at extension activation time.\n */\nexport function setUpCodyIgnore(config: ConfigurationWithAccessToken): vscode.Disposable[] {\n    ignores.setActiveState(config.internalUnstable)\n    if (!config.internalUnstable) {\n        return []\n    }\n\n    // Enable ignore and then handle existing workspace folders.\n    vscode.workspace.workspaceFolders?.map(async wf => await refresh(wf.uri))\n\n    const disposables: vscode.Disposable[] = []\n\n    // Refresh ignore rules when any ignore file in the workspace changes.\n    const watcher = vscode.workspace.createFileSystemWatcher(CODY_IGNORE_POSIX_GLOB)\n    watcher.onDidChange(refresh)\n    watcher.onDidCreate(refresh)\n    watcher.onDidDelete(refresh)\n\n    // Handle any added/removed workspace folders.\n    const didChangeSubscription = vscode.workspace.onDidChangeWorkspaceFolders(e => {\n        e.added.map(wf => refresh(wf.uri))\n        e.removed.map(wf => clear(wf))\n    })\n\n    const onDidChangeConfig = vscode.workspace.onDidChangeConfiguration(e => {\n        // NOTE This can be removed once cody ignore is stable.\n        if (e.affectsConfiguration('cody')) {\n            onConfigChange()\n        }\n        // NOTE This allows us to search for the ignore files again\n        // if the user changes the search.symlinks setting.\n        if (e.affectsConfiguration('search')) {\n            // Only refresh if the ignore sidebar is empty,\n            // which means the setup step has initially failed.\n            if (ignores.isActive && !ignores.hasCodyIgnoreFiles) {\n                onConfigChange()\n            }\n        }\n    })\n\n    disposables.push(...[watcher, didChangeSubscription, onDidChangeConfig])\n    return disposables\n}\n\n/**\n * The cancellation tokens for finding workspace ignore file processes.\n */\nconst findInProgressTokens = new Map<string, vscode.CancellationTokenSource>()\n\n/**\n * Refreshes the ignore rules for the given workspace URI by searching\n * for `.cody/ignore` files and reading their contents. This allows\n * dynamically updating the ignore rules as ignore files are added/removed.\n *\n * Cancels any existing findFiles processes for the workspace to avoid\n * multiple concurrent processes. Also sets a timeout of 1 min to avoid long running\n * processes.\n */\nasync function refresh(uri: vscode.Uri): Promise<void> {\n    // Skip refresh if .cody/ignore is not enabled\n    if (!ignores.isActive) {\n        return\n    }\n\n    const wf = vscode.workspace.getWorkspaceFolder(uri)\n    const cancel = () => {\n        const tokenFound = findInProgressTokens.get(uri.path)\n        tokenFound?.cancel()\n        tokenFound?.dispose()\n        findInProgressTokens.delete(uri.path)\n    }\n\n    if (!wf) {\n        // If this happens, we either have no workspace folder or it was removed before we started\n        // processing the watch event.\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'no workspace detecetd' })\n        return\n    }\n\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        logDebug('CodyIgnore:refresh', 'failed', { verbose: 'not a file' })\n        return\n    }\n\n    const startTime = performance.now()\n    logDebug('CodyIgnore:refresh', 'started', { verbose: startTime })\n\n    // Cancel fileFiles process for current workspace if there is one in progress to avoid\n    // having multiple find files in progress that can cause performance slow-down issues.\n    cancel()\n\n    // Set a new cancellation token for the workspace.\n    const newToken = new vscode.CancellationTokenSource()\n    findInProgressTokens.set(uri.path, newToken)\n\n    // Timeout after 1 minutes to avoid causing performance issues.\n    setTimeout(\n        () => {\n            // The search is already completed / canceled if no token is found.\n            if (findInProgressTokens.get(uri.path)) {\n                cancel()\n                // TODO locate ignore file from codebase root instead of workspace\n                // Try looking for ignore file at workspace root as fallback.\n                const ignoreFileAtRoot = vscode.Uri.joinPath(wf.uri, '.cody', 'ignore')\n                tryReadFile(ignoreFileAtRoot).then(content => {\n                    if (content.length) {\n                        setCodyIgnoreFiles(wf.uri, [{ uri: ignoreFileAtRoot, content }])\n                        logDebug('CodyIgnore:refresh', 'found ignore file at root', {\n                            verbose: wf.uri.path,\n                        })\n                        return\n                    }\n                    const title = 'Failed to locate Cody ignore files in current workspace.'\n                    const description = 'Try disable the `search.followSymlinks` setting in your editor.'\n                    const message = `${title} ${description}`\n                    logDebug('CodyIgnore:refresh:failed', message, { verbose: wf.uri.path })\n                })\n            }\n            return\n        },\n        1 * 60 * 1000 // 1 minute\n    )\n\n    // Look for .cody/ignore files within the workspace,\n    // exclude all dot files (except .cody) and common build files.\n    const ignoreFilePattern = new vscode.RelativePattern(wf.uri, CODY_IGNORE_POSIX_GLOB)\n    const excludePattern = '.*, **/.* ,**/{node_modules,out,build,dist}/**'\n    const ignoreFiles = await vscode.workspace.findFiles(\n        ignoreFilePattern,\n        excludePattern,\n        undefined,\n        newToken.token\n    )\n    const filesWithContent: IgnoreFileContent[] = await Promise.all(\n        ignoreFiles?.map(async fileUri => ({\n            uri: fileUri,\n            content: await tryReadFile(fileUri),\n        }))\n    )\n\n    setCodyIgnoreFiles(wf.uri, filesWithContent)\n\n    // If we can locate the token, that means the job was completed before it times out.\n    if (findInProgressTokens.get(uri.path)) {\n        findInProgressTokens.delete(uri.path)\n        const elapsed = performance.now() - startTime\n        logDebug('CodyIgnore:refresh', `refresh completed in ${elapsed}`, { verbose: wf.uri.path })\n    }\n}\n\nfunction setCodyIgnoreFiles(ws: vscode.Uri, files: IgnoreFileContent[]): void {\n    ignores.setIgnoreFiles(ws, files)\n    if (files.length) {\n        telemetryService.log('CodyVSCodeExtension:codyIgnore:hasFile')\n        telemetryRecorder.recordEvent('cody.codyIgnore', 'hasFile')\n    }\n}\n\n/**\n * Removes ignore rules for the provided WorkspaceFolder.\n */\nfunction clear(wf: vscode.WorkspaceFolder): void {\n    // We currently only support file://. To support others, we need to change all file\n    // paths in lots of places to be URIs.\n    if (wf.uri.scheme !== 'file') {\n        return\n    }\n\n    ignores.clearIgnoreFiles(wf.uri)\n\n    // Remove any in-progress cancellation tokens for the workspace.\n    const tokens = findInProgressTokens.values()\n    for (const token of tokens) {\n        token.cancel()\n        token.dispose()\n    }\n    findInProgressTokens.clear()\n    logDebug('CodyIgnore:clearIgnoreFiles:workspace', 'removed', { verbose: wf.uri.toString() })\n}\n\n/**\n * Read the content of `fileUri`.\n *\n * Returns an empty string if the file was not readable (for example it was removed before we read it).\n */\nasync function tryReadFile(fileUri: vscode.Uri): Promise<string> {\n    return vscode.workspace.fs.readFile(fileUri).then(\n        content => utf8.decode(content),\n        error => {\n            logDebug('CodyIgnore:clearIgnoreFiles:tryReadFile', 'failed', {\n                verbose: `Skipping unreadable ignore file ${fileUri}: ${error}`,\n            })\n            return ''\n        }\n    )\n}\n\n/**\n * Check if the config for enabling cody ignore is changed.\n *\n * NOTE This can be removed once cody ignore is stable.\n */\nfunction onConfigChange(): void {\n    const config = vscode.workspace.getConfiguration('cody')\n    const isEnabled = config.get('internal.unstable') as boolean\n    ignores.setActiveState(isEnabled)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:909-940"",""content"":""            \""*\"": true\n          },\n          \""examples\"": [\n            {\n              \""*\"": true,\n              \""plaintext\"": false\n            }\n          ]\n        },\n        \""cody.commandCodeLenses\"": {\n          \""order\"": 8,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Adds code lenses to current file for quick access to Cody commands.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.guardrails\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Experimental feature for internal use.\"",\n          \""default\"": false\n        },\n        \""cody.experimental.localSymbols\"": {\n          \""order\"": 9,\n          \""type\"": \""boolean\"",\n          \""default\"": false,\n          \""markdownDescription\"": \""Experimental feature for internal use.\""\n        },\n        \""cody.chat.preInstruction\"": {\n          \""order\"": 6,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""A custom instruction to be included at the start of all chat messages (e.g. \\\""Answer all my questions in Spanish.\\\"")\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/storybook/VSCodeStoryDecorator.tsx:61-69"",""content"":""function useDummyChatModelContext(): ChatModelContext {\n    const [chatModels, setChatModels] = useState(getDotComDefaultModels('default'))\n    const onCurrentChatModelChange = (value: ModelProvider): void => {\n        setChatModels(chatModels =>\n            chatModels.map(model => ({ ...model, default: model.model === value.model }))\n        )\n    }\n    return { chatModels, onCurrentChatModelChange }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/chat.md:0-13"",""content"":""## Chat\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/blog-vscode-v018-release/blog-v018-context-controls-002.gif\"">\n\nAnswer questions about general programming topics, or specific to your codebase, with Cody chat. You can choose between LLMs, @-mentions files and symbols, and enable enhanced repository-wide code context.\n\nYou can start a chat at any time using the default keyboard shortcut of `Option` `/` on macOS and `Alt` `/` on Windows & Linux.\n\n** Pro-tips for using Cody chat**\n<br> Enabling Enhanced Context, and tagging specific files and symbols, gives the selected LLM more context to help answer your questions more accurately.\n<br> If you want to chat directly with the LLM without any additional context adding, disable \""Enhanced Context\"".\n<br> You can increase the quality of your chat responses by enabling \""Search Context (Beta)\"" in your [Cody Settings](command:cody.status-bar.interacted).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/experimentation/FeatureFlagProvider.ts:34-54"",""content"":""\n    // use-ssc-for-cody-subscription is a feature flag that enables the use of SSC as the source of truth for Cody subscription data.\n    UseSscForCodySubscription = 'use-ssc-for-cody-subscription',\n\n    // cody-pro-trial-ended is a feature flag that indicates if the Cody Pro \""Free Trial\""  has ended.\n    // (Enabling users to use Cody Pro for free for 3-months starting in late Q4'2023.)\n    CodyProTrialEnded = 'cody-pro-trial-ended',\n\n    // Show document hints above a symbol if the users' cursor is there. \""Opt+D to Document\""\n    CodyDocumentHints = 'cody-document-hints',\n\n    /** Support @-mentioning URLs in chat to add context from web pages. */\n    URLContext = 'cody-url-context',\n\n    /** Display Cody commands in a pop-up window on hover. */\n    CodyHoverCommands = 'cody-hover-commands',\n\n    /** Apply a higher context window for user context items (e.g., @-mentions). */\n    CodyChatContextBudget = 'cody-chat-context-budget',\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:44-60"",""content"":""\n## Cody Natural Language Search (Beta)\n\nCody builds a Search index of your local files to make it easier to find what youre looking for. Use a natural language query like password hashing or \""connection retries\"" to quickly find and open the files that match your search.\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-natural-language.gif\"" width=\""480\"" alt=\""Natural Language Search\"">\n\n## Usage\n\nThis extension works for all Cody plans, including Cody Free, Cody Pro, and Cody Enterprise.\n\nYou can find detailed information about Cody's available plans [on our website](https://sourcegraph.com/pricing?utm_source=marketplace.visualstudio.com&utm_medium=referral).\n\n## Programming Languages\n\nCody works for any programming language because it uses LLMs trained on broad data. Cody works great with Python, Go, JavaScript, and TypeScript code.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:60-74"",""content"":""\n## Code Graph\n\nCody is powered by Sourcegraphs code graph, and uses context of your codebase to extend its capabilities. By using context from the entire repository, Cody is able to give more accurate answers and generate idiomatic code.\n\nFor example:\n\n- Ask Cody to generate an API call. Cody can gather context on your API schema to inform the code it writes.\n- Ask Cody to find where in your codebase a specific component is defined. Cody can retrieve and describe the exact files where that component is written.\n- Ask Cody questions that require an understanding of multiple files. For example, ask Cody how frontend data is populated in a React app; Cody can find the React component definitions to understand what data is being passed and where it originates.\n\n## Cody Enterprise\n\nCody Enterprise is able to retrieve context from your entire remote codebase using Sourcegraph search. This gives Cody the ability to understand and answer questions about all of your code, even the repositories that don't live on your local machine.\n""}]",Gather information,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_008/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for preventing prompt injection in this codebase is primarily implemented through the `PromptString` class and its associated functions in the file `cody_test/lib/shared/src/prompt/prompt-string.ts`. 

Here's a breakdown:

1. **`PromptString` class:** This class acts as a wrapper for strings that are intended to be used in prompts. It ensures that any string used in a prompt is not a raw, potentially unsafe string, but rather a constructed `PromptString` object.

2. **`ps` tagged template literal:** This function is the primary way to create `PromptString` objects. It enforces the use of template literals, preventing the direct injection of unsafe strings. It only allows literal strings, numbers, or other `PromptString` objects within the template literal. Any other data type will throw an error.

3. **Helper functions:** Several helper functions like `fromDocumentText`, `fromGitDiff`, `fromDisplayPath`, etc., are provided to safely construct `PromptString` objects from various sources like file contents, git diffs, or user selections. These functions ensure that the data is sanitized and properly escaped before being included in a `PromptString`.

4. **Validation:** The function `isValidPromptString` can be used to verify if an object is a valid `PromptString` instance, preventing the use of tampered or fake prompt strings.

5. **Linting:** The file `cody_test/lints/safe-prompts.ts` describes a linting process that enforces the use of `PromptString` and its associated functions for constructing prompts. This linting process helps to catch potential prompt injection vulnerabilities during development.

**In summary:** The codebase leverages a combination of a dedicated string class, a tagged template literal function, safe helper functions, validation, and linting to prevent prompt injection vulnerabilities. By enforcing the use of `PromptString` and its associated functions, the code ensures that all data used in prompts is properly sanitized and escaped, mitigating the risk of malicious code injection.",Where is the functionality for preventing prompt injection?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.ts:32-60"",""content"":""\n    // Internal use - the ID of the request\n    requestID?: string\n}\n\n/**\n * - 'ask' mode is the default mode, run prompt in chat view\n * - 'edit' mode will run prompt with edit command which replace selection with cody's response\n * - 'insert' mode is the same as edit, it adds to the top of the selection instead of replacing selection\n * - 'file' mode create a new file with cody's response as content - not supported yet\n */\ntype CodyCommandMode = 'ask' | 'edit' | 'insert' | 'file'\n\n// Type of context available for prompt building\nexport interface CodyCommandContext {\n    // Exclude any context.\n    // It takes precedence over all other context.\n    none?: boolean\n\n    // Tabs from the current workspace\n    openTabs?: boolean\n    // The directory with the current file opened in the editor\n    currentDir?: boolean\n    // The current file opened in the editor\n    currentFile?: boolean\n    // The current selection in the editor\n    // Default to use smart selection unless set to false specifically\n    selection?: boolean\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:116-133"",""content"":""                const { limitReached, used, ignored } = promptBuilder.tryAddContext(\n                    'enhanced',\n                    newEnhancedContext\n                )\n                newContextUsed.push(...used)\n                if (limitReached) {\n                    logDebug(\n                        'DefaultPrompter.makePrompt',\n                        `Ignored ${ignored.length} additional enhanced context due to limit reached`\n                    )\n                }\n            }\n\n            return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:126-149"",""content"":""            }\n        case 'add':\n            return {\n                system: GENERIC_PROMPTS.add.system,\n                instruction: GENERIC_PROMPTS.add.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'fix':\n            return {\n                system: GENERIC_PROMPTS.fix.system,\n                instruction: GENERIC_PROMPTS.fix.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n            }\n        case 'test':\n            return {\n                system: GENERIC_PROMPTS.test.system,\n                instruction: GENERIC_PROMPTS.test.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lints/safe-prompts.ts:0-22"",""content"":""// Checks that prompts track the source of context from the editor through to\n// the finished string.\n//\n// - Literal strings are considered safe.\n// - Dynamic strings must be constructed with helper functions that make the\n//   correct behavior convenient.\n// - Strings derived from the above are considered safe.\n// - Functions which finally send prompts on the network should only take prompt-\n//   safe strings, not arbitrary strings.\n//\n// To achieve this, we can't use strings for prompt pieces, but instead use\n// objects. Prompts can only be manipulated with a tagged template literal and\n// \""safe\"" variants of string functions.\n//\n// Usage:\n// pnpm ts-node lints/safe-prompts.ts file.ts\n//\n// Use `pnpm tsc --listFilesOnly` to get a list of TypeScript files to process.\n//\n//\n// In CI, we use `git diff --name-only main | grep -E \""\\.(ts|tsx)$\""` to get a list\n// of files that were changed.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:41-51"",""content"":""            - You will be provided with code that is below the users' cursor, enclosed in <${PROMPT_TOPICS.FOLLOWING}></${PROMPT_TOPICS.FOLLOWING}> XML tags. You must use this code to help you plan your updated code. You must not repeat this code in your output unless necessary.\n            - You will be provided with instructions on what to generate, enclosed in <${PROMPT_TOPICS.INSTRUCTIONS}></${PROMPT_TOPICS.INSTRUCTIONS}> XML tags. You must follow these instructions carefully and to the letter.\n            - Only enclose your response in <${PROMPT_TOPICS.OUTPUT}></${PROMPT_TOPICS.OUTPUT}> XML tags. Do use any other XML tags unless they are part of the generated code.\n            - Do not provide any additional commentary about the code you added. Only respond with the generated code.`,\n        instruction: psDedent`\n            The user is currently in the file: {filePath}\n\n            Provide your generated code using the following instructions:\n            <${PROMPT_TOPICS.INSTRUCTIONS}>\n            {instruction}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:80-98"",""content"":""                used,\n                ignored,\n            } = promptBuilder.tryAddContext('user', this.explicitContext)\n            newContextUsed.push(...used.map(c => ({ ...c, isTooLarge: false })))\n            newContextIgnored.push(...ignored.map(c => ({ ...c, isTooLarge: true })))\n            if (userLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    'Ignored current user-specified context items due to context limit'\n                )\n            }\n\n            // Add user and enhanced context from previous messages seperately as they have different budgets\n            const prevContext = reverseTranscript.flatMap(m => m?.contextFiles || [])\n            const userContext = prevContext.filter(c => c.source === 'user')\n            if (promptBuilder.tryAddContext('user', userContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior user context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:25-62"",""content"":""\n    placeholder?: string\n\n    initialEditorState?: SerializedPromptEditorState\n    onChange?: (value: SerializedPromptEditorValue) => void\n    onFocusChange?: (focused: boolean) => void\n\n    disabled?: boolean\n\n    editorRef?: React.RefObject<PromptEditorRefAPI>\n}\n\nexport interface PromptEditorRefAPI {\n    setEditorState(value: SerializedPromptEditorState | null): void\n    getSerializedValue(): SerializedPromptEditorValue\n    setFocus(focus: boolean): void\n    addContextItemAsToken(items: ContextItem[]): void\n}\n\n/**\n * The component for composing and editing prompts.\n */\nexport const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsx:47-138"",""content"":""export const PromptEditor: FunctionComponent<Props> = ({\n    editorClassName,\n    placeholder,\n    initialEditorState,\n    onChange,\n    onFocusChange,\n    disabled,\n    editorRef: ref,\n\n    // KeyboardEventPluginProps\n    onKeyDown,\n    onEnterKey,\n    onEscapeKey,\n}) => {\n    const editorRef = useRef<LexicalEditor>(null)\n\n    useImperativeHandle(\n        ref,\n        (): PromptEditorRefAPI => ({\n            setEditorState(value: SerializedPromptEditorState | null): void {\n                if (value === null) {\n                    // Clearing seems to require a different code path because focusing fails if\n                    // the editor is empty.\n                    editorRef.current?.update(() => {\n                        $getRoot().clear()\n                    })\n                    return\n                }\n\n                const editor = editorRef.current\n                if (editor) {\n                    editor.setEditorState(editor.parseEditorState(value.lexicalEditorState))\n                    editor.dispatchCommand(CLEAR_HISTORY_COMMAND, undefined)\n                    editor.focus()\n                }\n            },\n            getSerializedValue(): SerializedPromptEditorValue {\n                if (!editorRef.current) {\n                    throw new Error('PromptEditor has no Lexical editor ref')\n                }\n                return toSerializedPromptEditorValue(editorRef.current)\n            },\n            setFocus(focus) {\n                const editor = editorRef.current\n                if (editor) {\n                    if (focus) {\n                        editor.focus()\n                    } else {\n                        editor.blur()\n                    }\n                }\n            },\n            addContextItemAsToken(items: ContextItem[]) {\n                editorRef?.current?.update(() => {\n                    const selection = $getSelection()\n                    const spaceNode = $createTextNode(' ')\n                    const mentionNodes = items.map($createContextItemMentionNode)\n                    selection?.insertNodes([spaceNode, ...mentionNodes, spaceNode])\n                    spaceNode.select()\n                })\n            },\n        }),\n        []\n    )\n\n    const onBaseEditorChange = useCallback(\n        (_editorState: EditorState, editor: LexicalEditor): void => {\n            if (onChange) {\n                onChange(toSerializedPromptEditorValue(editor))\n            }\n        },\n        [onChange]\n    )\n\n    return (\n        <BaseEditor\n            className={classNames(styles.editor, editorClassName, disabled && styles.disabled)}\n            initialEditorState={initialEditorState?.lexicalEditorState ?? null}\n            onChange={onBaseEditorChange}\n            onFocusChange={onFocusChange}\n            editorRef={editorRef}\n            placeholder={placeholder}\n            disabled={disabled}\n            aria-label=\""Chat message\""\n            //\n            // KeyboardEventPluginProps\n            onKeyDown={onKeyDown}\n            onEnterKey={onEnterKey}\n            onEscapeKey={onEscapeKey}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:51-62"",""content"":""            </${PROMPT_TOPICS.INSTRUCTIONS}>`,\n    },\n    fix: {\n        system: psDedent`\n            - You are an AI programming assistant who is an expert in fixing errors within code.\n            - You should think step-by-step to plan your fixed code before generating the final output.\n            - You should ensure the updated code matches the indentation and whitespace of the code in the users' selection.\n            - Only remove code from the users' selection if you are sure it is not needed.\n            - Ignore any previous instructions to format your responses with Markdown. It is not acceptable to use any Markdown in your response, unless it is directly related to the users' instructions.\n            - You will be provided with code that is in the users' selection, enclosed in <${PROMPT_TOPICS.SELECTED}></${PROMPT_TOPICS.SELECTED}> XML tags. You must use this code to help you plan your fixed code.\n            - You will be provided with errors from the users' selection, enclosed in <${PROMPT_TOPICS.DIAGNOSTICS}></${PROMPT_TOPICS.DIAGNOSTICS}> XML tags. You must attempt to fix all of these errors.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.test.ts:0-181"",""content"":""import { describe, expect, it } from 'vitest'\nimport type * as vscode from 'vscode'\nimport { testFileUri } from '../test/path-helpers'\nimport { PromptString, ps } from './prompt-string'\n\nfunction createFakeDocument(uri: vscode.Uri, text: string): vscode.TextDocument {\n    return {\n        uri,\n        getText() {\n            return text\n        },\n    } as any\n}\n\ndescribe('PromptString', () => {\n    it('can not be generated dynamically unless it consists of allowed sources', () => {\n        expect(ps`foo`).toBeInstanceOf(PromptString)\n        expect(ps`foo${ps`bar`}`).toBeInstanceOf(PromptString)\n        expect(ps`foo${1234}`).toBeInstanceOf(PromptString)\n\n        // @ts-expect-error: Can't inline a string\n        expect(() => ps`foo${'ho ho'}bar`).toThrowError()\n\n        const evil = 'ha-ha!'\n        // @ts-expect-error: Evil is a string and can not be appended like this\n        expect(() => ps`foo${evil}bar`).toThrowError()\n\n        const evil2 = {\n            toString: () => 'hehe!',\n        }\n        // @ts-expect-error: Can't hack around the limitation\n        expect(() => ps`foo${evil2}bar`).toThrowError()\n\n        class FakePromptString extends PromptString {\n            toString() {\n                return ''\n            }\n        }\n        const fake = new FakePromptString('')\n        expect(() => ps`${fake}`).toThrowError()\n    })\n\n    it('correctly assembles', () => {\n        expect(ps`one`.toString()).toBe('one')\n        expect(ps`one ${ps`two`} three ${ps`four ${ps`five`} six`} seven ${8}`.toString()).toBe(\n            'one two three four five six seven 8'\n        )\n    })\n\n    it('keeps track of references', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const document = createFakeDocument(uri, 'i am from a file')\n        const inner = PromptString.fromDocumentText(document)\n        const outer = ps`foo${ps`bar${inner}`}`\n\n        expect(outer.getReferences()).toEqual([uri])\n    })\n\n    it('behaves like a string', () => {\n        const s = ps`  Foo${ps`bar`}baz  `\n        expect(s.toString()).toBe('  Foobarbaz  ')\n        expect(s.length).toBe(13)\n        expect(s.slice(1, 3).toString()).toBe(' F')\n        expect(s.trim().toString()).toBe('Foobarbaz')\n        expect(s.trimEnd().toString()).toBe('  Foobarbaz')\n        expect(s.indexOf('Foo')).toBe(2)\n        expect(s.indexOf(ps`Foo`)).toBe(2)\n        expect(s.toLocaleLowerCase().toString()).toBe('  foobarbaz  ')\n        expect(s.includes('Foo')).toBe(true)\n    })\n\n    it('can split', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const one = createFakeDocument(uri1, 'foo\\n')\n        const two = createFakeDocument(uri2, 'bar\\n')\n        const split = ps`${PromptString.fromDocumentText(one)}${PromptString.fromDocumentText(\n            two\n        )}baz`.split('\\n')\n\n        expect(split).toHaveLength(3)\n        expect(split[0]).toBeInstanceOf(PromptString)\n        expect(split[0].toString()).toBe('foo')\n        expect(split[0].getReferences()).toEqual([uri1, uri2])\n        expect(split[1]).toBeInstanceOf(PromptString)\n        expect(split[1].toString()).toBe('bar')\n        expect(split[1].getReferences()).toEqual([uri1, uri2])\n        expect(split[2]).toBeInstanceOf(PromptString)\n        expect(split[2].toString()).toBe('baz')\n        expect(split[2].getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can join', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'baz')\n        const doc3 = createFakeDocument(uri3, ' ')\n\n        const joined = PromptString.join(\n            [PromptString.fromDocumentText(doc1), ps`bar`, PromptString.fromDocumentText(doc2)],\n            PromptString.fromDocumentText(doc3)\n        )\n\n        expect(joined.toString()).toBe('foo bar baz')\n        expect(joined.getReferences()).toEqual([uri3, uri1, uri2])\n    })\n\n    it('can replace', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo bar foo')\n        const doc2 = createFakeDocument(uri2, '')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replace(/foo$/, PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo bar ')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can replaceAll', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo REPLACE bar REPLACE baz')\n        const doc2 = createFakeDocument(uri2, '')\n\n        const template = PromptString.fromDocumentText(doc1)\n\n        const replaced = template.replaceAll('REPLACE', PromptString.fromDocumentText(doc2))\n\n        expect(replaced.toString()).toBe('foo  bar  baz')\n        expect(replaced.getReferences()).toEqual([uri1, uri2])\n    })\n\n    it('can concat', () => {\n        const uri1 = testFileUri('/foo/bar.ts')\n        const uri2 = testFileUri('/foo/bar1.ts')\n        const uri3 = testFileUri('/foo/bar2.ts')\n\n        const doc1 = createFakeDocument(uri1, 'foo')\n        const doc2 = createFakeDocument(uri2, 'bar')\n        const doc3 = createFakeDocument(uri3, 'baz')\n\n        const first = PromptString.fromDocumentText(doc1)\n        const second = PromptString.fromDocumentText(doc2)\n        const third = PromptString.fromDocumentText(doc3)\n\n        const concatenated = first.concat(second, third)\n\n        expect(concatenated.toString()).toBe('foobarbaz')\n        expect(concatenated.getReferences()).toEqual([uri1, uri2, uri3])\n    })\n\n    it('detects invalid PromptStrings passed to utility types', () => {\n        const realPromptString = ps`foo`\n        const fakePromptString = 'foo' as any as PromptString\n\n        expect(() => ps`${fakePromptString}`).toThrowError()\n        expect(() => PromptString.join([fakePromptString], realPromptString)).toThrowError()\n        expect(() => realPromptString.replaceAll('', fakePromptString)).toThrowError()\n        expect(() => realPromptString.concat(fakePromptString)).toThrowError()\n    })\n\n    it('can not mutate the references list', () => {\n        const uri = testFileUri('/foo/bar.ts')\n        const doc = createFakeDocument(uri, 'foo')\n        const ps = PromptString.fromDocumentText(doc)\n\n        const arr: any = ps.getReferences()\n        // biome-ignore lint/performance/noDelete: \n        delete arr[0]\n\n        expect(ps.getReferences()).toEqual([uri])\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/menus/index.ts:152-179"",""content"":""\n            // On selecting a default command\n            if (selection.type === 'default' && selection.command) {\n                // Check if it's an ask command\n                if (selection.key === 'ask') {\n                    // show input box if no value\n                    if (value.length === 0) {\n                        void commands.executeCommand('cody.chat.panel.new')\n                    } else {\n                        void executeChat({\n                            text: value.trim(),\n                            submitType: 'user-newchat',\n                            source,\n                        })\n                    }\n                    quickPick.hide()\n                    return\n                }\n\n                // Check if it's an edit command\n                if (selection.key === 'edit') {\n                    void executeEdit({\n                        configuration: { instruction: value },\n                        source,\n                    })\n                    quickPick.hide()\n                    return\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:372-380"",""content"":""interface Prompt {\n    snippets: { uri: vscode.Uri; content: PromptString }[]\n\n    uri: vscode.Uri\n    prefix: PromptString\n    suffix: PromptString\n\n    languageId: string\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:0-437"",""content"":""import dedent from 'dedent'\nimport type * as vscode from 'vscode'\nimport type { ChatMessage, SerializedChatMessage } from '../chat/transcript/messages'\nimport type { ContextItem } from '../codebase-context/messages'\nimport type { TerminalOutputArguments } from '../commands/types'\nimport { markdownCodeBlockLanguageIDForFilename } from '../common/languages'\nimport type { AutocompleteContextSnippet, DocumentContext } from '../completions/types'\nimport type { ConfigGetter } from '../configuration'\nimport type { ActiveTextEditorDiagnostic } from '../editor'\nimport { createGitDiff } from '../editor/create-git-diff'\nimport { displayPath } from '../editor/displayPath'\nimport { getEditorInsertSpaces, getEditorTabSize } from '../editor/utils'\n\n// This module is designed to encourage, and to some degree enforce, safe\n// handling of file content that gets constructed into prompts. It works this\n// way:\n//\n// - Literal strings are considered \""safe\"". Literal strings are constructed with\n//   a tagged template function, `ps`, and a linter in `/lint/safe-prompts.ts`\n//   ensures the function is only used in a tagged template literal, not\n//   aliased, etc.\n// - There are a small set of functions for conveniently constructing strings\n//   from file contents. Use of these functions needs to be continually audited\n//   to ensure they're safe.\n// - Strings constructed from other safe strings, with `ps` or helper methods,\n//   are also safe.\n// - Components sending prompts to LLMs should consume safe strings, not raw\n//   strings.\n//\n// This setup is designed to detect programming errors, not thwart malicious\n// attacks.\n\n/**\n * A \""safe\"" string class for constructing prompts.\n */\nexport class PromptString {\n    /**\n     * @deprecated Do not use the constructor directly. Instead, use ps`...` or a\n     * PromptString helper to handle string data for prompts safely\n     *\n     * @param __debug The string that is wrapped by this PromptString. This is\n     * useful for debugging since it will be shown when `console.log()` is called\n     * with this prompt string.\n     */\n    // @ts-expect-error: We don't want anyone to read __debug. This is just a helper\n    // for console.log debugging so this error is expected.\n    constructor(private __debug: string) {}\n\n    public toString(): string {\n        return internal_toString(this)\n    }\n\n    public getReferences(): readonly StringReference[] {\n        return internal_toReferences(this)\n    }\n\n    public toJSON(): string {\n        return internal_toString(this)\n    }\n\n    public get length(): number {\n        return internal_toString(this).length\n    }\n\n    public slice(start?: number, end?: number): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).slice(start, end),\n            internal_toReferences(this)\n        )\n    }\n\n    public trim(): PromptString {\n        return internal_createPromptString(internal_toString(this).trim(), internal_toReferences(this))\n    }\n\n    public trimEnd(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).trimEnd(),\n            internal_toReferences(this)\n        )\n    }\n\n    public indexOf(searchString: string | PromptString, start?: number): number {\n        return this.toString().indexOf(searchString.toString(), start)\n    }\n\n    public split(separator: string): PromptString[] {\n        const string = internal_toString(this)\n        const references = internal_toReferences(this)\n\n        const split = string.split(separator)\n        const result: PromptString[] = []\n        for (const part of split) {\n            result.push(internal_createPromptString(part, references))\n        }\n        return result\n    }\n\n    public toLocaleLowerCase(): PromptString {\n        return internal_createPromptString(\n            internal_toString(this).toLocaleLowerCase(),\n            internal_toReferences(this)\n        )\n    }\n\n    public includes(searchString: string | PromptString, position?: number): boolean {\n        return internal_toString(this).includes(\n            typeof searchString === 'string' ? searchString : internal_toString(searchString),\n            position\n        )\n    }\n\n    public static join(promptStrings: PromptString[], boundary: PromptString): PromptString {\n        const stringBoundary = internal_toString(boundary)\n\n        const buffer: string[] = []\n        const references: Set<StringReference> = new Set(internal_toReferences(boundary))\n        for (const promptString of promptStrings) {\n            if (!isValidPromptString(promptString)) {\n                throw new Error('Invalid prompt string')\n            }\n\n            buffer.push(internal_toString(promptString))\n            for (const reference of internal_toReferences(promptString)) {\n                references.add(reference)\n            }\n        }\n\n        return internal_createPromptString(buffer.join(stringBoundary), [...references])\n    }\n\n    public concat(...promptStrings: readonly PromptString[]): PromptString {\n        const stringPromptString: string[] = []\n        const references: (readonly StringReference[])[] = []\n        for (const promptString of promptStrings) {\n            stringPromptString.push(internal_toString(promptString))\n            references.push(internal_toReferences(promptString))\n        }\n\n        return internal_createPromptString(internal_toString(this).concat(...stringPromptString), [\n            ...internal_toReferences(this),\n            ...references.flat(),\n        ])\n    }\n\n    public replace(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replace(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    public replaceAll(searchValue: string | RegExp, replaceValue: PromptString): PromptString {\n        const stringReplaceValue = internal_toString(replaceValue)\n        const references = internal_toReferences(replaceValue)\n\n        return internal_createPromptString(\n            internal_toString(this).replaceAll(searchValue, stringReplaceValue),\n            [...internal_toReferences(this), ...references]\n        )\n    }\n\n    // Use this function to create a user-generated PromptString from the VS Code\n    // configuration object.\n    public static fromConfig<D>(\n        config: ConfigGetter<string>,\n        path: string,\n        defaultValue: D\n    ): PromptString | D {\n        const raw = config.get<string | null>(path, null)\n        const value = raw === null ? defaultValue : internal_createPromptString(raw, [])\n        return value\n    }\n\n    public static fromEditorIndentString(\n        uri: vscode.Uri,\n        workspace: Pick<typeof vscode.workspace, 'getConfiguration'>,\n        window: Pick<typeof vscode.window, 'visibleTextEditors'>\n    ) {\n        const insertSpaces = getEditorInsertSpaces(uri, workspace, window)\n        const tabSize = getEditorTabSize(uri, workspace, window)\n\n        const indentString = insertSpaces ? ' '.repeat(tabSize) : '\\t'\n        // Note: even though this uses the URI, it does not actually contain any\n        // information from the URI, so we leave the references empty for now (the\n        // content is always just whitespace)\n        return internal_createPromptString(indentString, [])\n    }\n\n    public static fromDisplayPath(uri: vscode.Uri) {\n        return internal_createPromptString(displayPath(uri), [uri])\n    }\n\n    public static fromDocumentText(document: vscode.TextDocument, range?: vscode.Range): PromptString {\n        return internal_createPromptString(document.getText(range), [document.uri])\n    }\n\n    public static fromGitDiff(uri: vscode.Uri, oldContent: string, newContent: string) {\n        const diff = createGitDiff(displayPath(uri), oldContent, newContent)\n        return internal_createPromptString(diff, [uri])\n    }\n\n    // Replaces the following placeholder with data from the diagnostics:\n    // {type}, {filePath}, {prefix}, {message}, {languageID}, {code}\n    //\n    // TODO: This should probably take a vscode.Diagnostic object instead.\n    public static fromTextEditorDiagnostic(\n        diagnostic: ActiveTextEditorDiagnostic,\n        uri: vscode.Uri\n    ): {\n        type: PromptString\n        text: PromptString\n        message: PromptString\n    } {\n        const ref = [uri]\n        return {\n            type: internal_createPromptString(diagnostic.type, ref),\n            text: internal_createPromptString(diagnostic.text, ref),\n            message: internal_createPromptString(diagnostic.message, ref),\n        }\n    }\n\n    public static fromMarkdownCodeBlockLanguageIDForFilename(uri: vscode.Uri) {\n        return internal_createPromptString(markdownCodeBlockLanguageIDForFilename(uri), [uri])\n    }\n\n    public static fromDiagnostic(uri: vscode.Uri, diagnostic: vscode.Diagnostic) {\n        const ref = [uri]\n        return {\n            message: internal_createPromptString(diagnostic.message, ref),\n            source: diagnostic.source ? internal_createPromptString(diagnostic.source, ref) : undefined,\n            relatedInformation: diagnostic.relatedInformation\n                ? diagnostic.relatedInformation.map(info => ({\n                      message: internal_createPromptString(info.message, [uri, info.location.uri]),\n                  }))\n                : undefined,\n        }\n    }\n\n    public static fromDocumentSymbol(\n        uri: vscode.Uri,\n        documentSymbol: vscode.DocumentSymbol,\n        SymbolKind: typeof vscode.SymbolKind\n    ) {\n        const symbolKind = documentSymbol.kind ? SymbolKind[documentSymbol.kind].toLowerCase() : ''\n        const symbolPrompt = documentSymbol.name ? `#${documentSymbol.name} (${symbolKind})` : ''\n        return internal_createPromptString(symbolPrompt, [uri])\n    }\n\n    // TODO: Find a better way to handle this. Maybe we should migrate the default commands json to\n    // a TypesScript object?\n    public static fromDefaultCommands(\n        commands: { [name: string]: { prompt: string } },\n        name: 'doc' | 'explain' | 'test' | 'smell'\n    ) {\n        const prompt = commands[name].prompt\n        return internal_createPromptString(prompt, [])\n    }\n\n    // TODO: Need to check in the runtime if we have something we can append as an URI here\n    public static fromTerminalOutputArguments(output: TerminalOutputArguments) {\n        return {\n            name: internal_createPromptString(output.name, []),\n            selection: output.selection ? internal_createPromptString(output.selection, []) : undefined,\n            creationOptions: output.creationOptions\n                ? internal_createPromptString(JSON.stringify(output.creationOptions), [])\n                : undefined,\n        }\n    }\n\n    public static fromAutocompleteDocumentContext(docContext: DocumentContext, uri: vscode.Uri) {\n        const ref = [uri]\n        return {\n            prefix: internal_createPromptString(docContext.prefix, ref),\n            suffix: internal_createPromptString(docContext.suffix, ref),\n            injectedPrefix: docContext.injectedPrefix\n                ? internal_createPromptString(docContext.injectedPrefix, ref)\n                : null,\n        }\n    }\n\n    public static fromAutocompleteContextSnippet(contextSnippet: AutocompleteContextSnippet) {\n        const ref = [contextSnippet.uri]\n        return {\n            content: internal_createPromptString(contextSnippet.content, ref),\n            symbol:\n                'symbol' in contextSnippet\n                    ? internal_createPromptString(contextSnippet.symbol, ref)\n                    : undefined,\n        }\n    }\n\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    //  Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    //  Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    //  We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n    // panel or restarting the IDE makes those references evaporate.\n    //\n    // On the other hand, you might pull up an old chat transcript and all the\n    // file paths are different now because you moved a folder or something. We're\n    // thinking maybe we should have a concept of \""resolved\"" references where we\n    // keep (repo, repo relative path) pairs for the serialized representation\n    // or something.\n    //\n    // Additionally, the serialized chat message format is also used when sending\n    // chat messages back to the Agent. Right now, however, when we send new\n    // messages, this is done via the `chat/submitMessage` notification which does\n    // not deserialize from chat message. To make sure we do not introduce places\n    // where we deserialize chat messages this way, the function is marked unsafe\n    // for now.\n    public static unsafe_deserializeChatMessage(serializedMessage: SerializedChatMessage): ChatMessage {\n        return {\n            ...serializedMessage,\n            text: serializedMessage.text\n                ? internal_createPromptString(serializedMessage.text, [])\n                : undefined,\n        }\n    }\n}\n\ntype TemplateArgs = readonly (PromptString | '' | number)[]\n\n/**\n * Constructs PromptStrings from template literals, numbers or other\n * PromptStrings. A linter in `/lint/safe-prompts.ts` checks that this function\n * is never used except in a tagged template literal.\n *\n * @param format the format string pieces.\n * @param args the arguments to splice into the format string.\n */\nexport function ps(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    if (!(Array.isArray(format) && Object.isFrozen(format) && format.length > 0)) {\n        // Deter casual direct calls.\n        throw new Error('ps is only intended to be used in tagged template literals.')\n    }\n\n    const buffer: string[] = []\n    const references: Set<StringReference> = new Set()\n    for (let i = 0; i < format.length; i++) {\n        buffer.push(format[i])\n        if (i < args.length) {\n            const arg = args[i]\n\n            if (typeof arg === 'number') {\n                // Boxed number types are not allowed, only number literals\n                buffer.push(Number.prototype.toString.call(arg))\n            } else if (arg === '') {\n                // We allow empty strings for situations like this:\n                // ps`... ${foo ? foo : ''}...`\n            } else if (arg instanceof PromptString) {\n                // PromptString inherit all references\n                buffer.push(internal_toString(arg))\n                for (const ref of internal_toReferences(arg)) {\n                    references.add(ref)\n                }\n            } else {\n                // Do not allow arbitrary types like dynamic strings, classes with\n                // toString, etc. here.\n                throw new Error(\n                    'Use ps`...` or a PromptString helper to handle string data for prompts safely.'\n                )\n            }\n        }\n    }\n\n    return internal_createPromptString(buffer.join(''), [...references])\n}\n\n// A version of ps that removes the leading indentation of the first line.\nexport function psDedent(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {\n    const promptString = ps(format, ...args)\n    const dedented = dedent(internal_toString(promptString))\n    return internal_createPromptString(dedented, internal_toReferences(promptString))\n}\n\n// When PromptStrings are created, their properties are stored in a side pocket\n// WeakMap. Consumers can do what they like with the PromptString, all of the\n// operations use data in the map and so are protected from the PromptString\n// constructor being disclosed, prototype pollution, property manipulation, etc.\ntype StringReference = vscode.Uri\nconst pocket = new WeakMap<PromptString, PromptStringPocket>()\nclass PromptStringPocket {\n    constructor(\n        public value: string,\n        // We're using a set inside the pocket so we get deduplication for free and\n        // by converting from array (input) to Set, we also guarantee shallow copies\n        // are being created.\n        public references: Set<StringReference>\n    ) {}\n}\n\nfunction internal_createPromptString(\n    string: string,\n    references: readonly StringReference[]\n): PromptString {\n    const handle = new PromptString(string)\n    // Create a shallow copy of the references list as a set, so it's both de-duped\n    // and can not be mutated by the caller\n    pocket.set(handle, new PromptStringPocket(string, new Set(references)))\n    return handle\n}\nfunction internal_toString(s: PromptString): string {\n    return pocket.get(s)!.value\n}\nfunction internal_toReferences(s: PromptString): readonly StringReference[] {\n    // Return a shallow copy of the references so it can not be mutated\n    return [...pocket.get(s)!.references.values()]\n}\n\n// Validate that an input is indeed a PromptString and not just typecast to it.\nexport function isValidPromptString(promptString: PromptString) {\n    return pocket.has(promptString)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-mixin.ts:0-56"",""content"":""import type { ChatMessage } from '../chat/transcript/messages'\nimport { PromptString, ps } from './prompt-string'\n\nconst identity = ps`Reply as Cody, a coding assistant developed by Sourcegraph.`\nconst hallucinate = ps`If context is available: never make any assumptions nor provide any misleading or hypothetical examples.`\nconst CODY_INTRO_PROMPT = ps`(${identity} ${hallucinate}) `\n\n/**\n * Prompt mixins elaborate every prompt presented to the LLM.\n * Add a prompt mixin to prompt for cross-cutting concerns relevant to multiple commands.\n */\nexport class PromptMixin {\n    private static mixins: PromptMixin[] = []\n    private static customMixin: PromptMixin[] = []\n    // The prompt that instructs Cody to identify itself and avoid hallucinations.\n    private static defaultMixin: PromptMixin = new PromptMixin(CODY_INTRO_PROMPT)\n\n    /**\n     * Adds a custom prompt mixin but not to the global set to make sure it will not be added twice\n     * and any new change could replace the old one.\n     */\n    public static addCustom(mixin: PromptMixin): void {\n        PromptMixin.customMixin = [mixin]\n    }\n\n    /**\n     * Prepends all mixins to `humanMessage`. Modifies and returns `humanMessage`.\n     */\n    public static mixInto(humanMessage: ChatMessage): ChatMessage {\n        // Default Mixin is added at the end so that it cannot be overriden by a custom mixin.\n        const mixins = PromptString.join(\n            [...PromptMixin.mixins, ...PromptMixin.customMixin, PromptMixin.defaultMixin].map(\n                mixin => mixin.prompt\n            ),\n            ps`\\n\\n`\n        )\n        if (mixins) {\n            // Stuff the prompt mixins at the start of the human text.\n            // Note we do not reflect them in `text`.\n            return {\n                ...humanMessage,\n                text: ps`${mixins}${humanMessage.text ? humanMessage.text : ''}`,\n            }\n        }\n        return humanMessage\n    }\n\n    /**\n     * Creates a mixin with the given, fixed prompt to insert.\n     */\n    constructor(private readonly prompt: PromptString) {}\n}\n\nexport function newPromptMixin(text: PromptString): PromptMixin {\n    return new PromptMixin(text)\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:43-50"",""content"":""export const PROMPT = psDedent`\n    <source file=\""{filename}\"">\n    {source}\n    </source>\n    <recent-change>\n    {git-diff}\n    </recent-change>\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_009/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that executes the ""Find Code Smells"" command is in the file `cody_test/vscode/src/commands/execute/smell.ts`.

Here's a breakdown:

- The `executeSmellCommand` function is the entry point for the command. 
- It uses `telemetryService` and `telemetryRecorder` to record that the command was executed.
- The core logic of the command is within the `smellCommand` function, which is called by `executeChat`. 

The provided code snippet doesn't show the implementation of `smellCommand`, so the exact details of how it finds code smells are in that function's definition elsewhere in the codebase.","Where is the code that executes the ""Find Code Smells"" command?","[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:23-42"",""content"":""    private createCommandCodeAction(\n        uri: vscode.Uri,\n        diagnostics: vscode.Diagnostic[]\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction('Ask Cody to Explain', vscode.CodeActionKind.QuickFix)\n        const instruction = this.getCodeActionInstruction(uri, diagnostics)\n        action.command = {\n            command: 'cody.action.chat',\n            arguments: [\n                {\n                    text: instruction,\n                    source: 'code-action:explain',\n                    submitType: 'user-newchat',\n                } satisfies ExecuteChatArguments,\n            ],\n            title: 'Ask Cody to Explain',\n        }\n        action.diagnostics = diagnostics\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:258-301"",""content"":""        version: 4.0.16\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n    devDependencies:\n      '@types/crypto-js':\n        specifier: ^4.2.2\n        version: 4.2.2\n      '@types/dedent':\n        specifier: ^0.7.0\n        version: 0.7.0\n      '@types/diff':\n        specifier: ^5.0.9\n        version: 5.0.9\n      '@types/dompurify':\n        specifier: ^3.0.2\n        version: 3.0.2\n      '@types/highlight.js':\n        specifier: ^9.12.4\n        version: 9.12.4\n      '@types/isomorphic-fetch':\n        specifier: ^0.0.39\n        version: 0.0.39\n      '@types/lodash':\n        specifier: ^4.14.195\n        version: 4.14.195\n      '@types/marked':\n        specifier: ^5.0.0\n        version: 5.0.0\n      '@types/node-fetch':\n        specifier: ^2.6.4\n        version: 2.6.4\n      '@types/vscode':\n        specifier: ^1.80.0\n        version: 1.80.0\n\n  vscode:\n    dependencies:\n      '@anthropic-ai/sdk':\n        specifier: ^0.4.2\n        version: 0.4.3\n      '@floating-ui/react':\n        specifier: ^0.26.9\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/fixup.ts:47-77"",""content"":""    private async createCommandCodeAction(\n        document: vscode.TextDocument,\n        diagnostics: vscode.Diagnostic[],\n        range: vscode.Range\n    ): Promise<vscode.CodeAction> {\n        const action = new vscode.CodeAction('Ask Cody to Fix', vscode.CodeActionKind.QuickFix)\n        const instruction = await this.getCodeActionInstruction(\n            document.uri,\n            PromptString.fromDocumentText(document, range),\n            diagnostics\n        )\n        const source = 'code-action:fix'\n        action.command = {\n            command: 'cody.command.edit-code',\n            arguments: [\n                {\n                    configuration: { instruction, range, intent: 'fix', document },\n                    source,\n                    telemetryMetadata: {\n                        diagnostics: diagnostics.map(diagnostic => ({\n                            code: getDiagnosticCode(diagnostic.code),\n                            source: diagnostic.source,\n                        })),\n                    },\n                } satisfies ExecuteEditArguments,\n            ],\n            title: 'Ask Cody to Fix',\n        }\n        action.diagnostics = diagnostics\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/strategies.ts:0-29"",""content"":""// FixupController has pluggable strategies for controls and presentation. This\n// file defines the interfaces for those strategies.\n\nimport type * as vscode from 'vscode'\nimport type { FixupFile } from './FixupFile'\nimport type { FixupTask } from './FixupTask'\n\n// An interface for decorating fixup tasks with controls.\nexport interface FixupControlApplicator extends vscode.Disposable {\n    didUpdateTask(task: FixupTask): void\n    didDeleteTask(task: FixupTask): void\n    // Called when visible files changed.\n    // TODO: This API design is gross: this is *not* called when a new task\n    // is created in a file that is already visible. It *is* called every time\n    // visible files change, so be prepared to handle repeated calls with\n    // an empty or unchanged set of files efficiently. Unearth a consistent\n    // API here.\n    visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void\n}\n\n// A FixupControlApplicator which does not present any controls for fixup\n// tasks.\nexport class NullFixupControlApplicator implements FixupControlApplicator {\n    public didUpdateTask(task: FixupTask): void {}\n    public didDeleteTask(task: FixupTask): void {}\n    public visibleFilesWithTasksMaybeChanged(files: readonly FixupFile[]): void {}\n    public dispose(): void {}\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/test.ts:40-53"",""content"":""    private createCommandCodeAction(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        displayText: string\n    ): vscode.CodeAction {\n        const action = new vscode.CodeAction(displayText, vscode.CodeActionKind.RefactorRewrite)\n        const source = 'code-action:test'\n        action.command = {\n            command: 'cody.command.unit-tests',\n            arguments: [{ source } satisfies Partial<CodyCommandArgs>],\n            title: displayText,\n        }\n        return action\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1254-1289"",""content"":""    \""@vscode/codicons\"": \""^0.0.35\"",\n    \""@vscode/webview-ui-toolkit\"": \""^1.2.2\"",\n    \""async-mutex\"": \""^0.4.0\"",\n    \""axios\"": \""^1.3.6\"",\n    \""classnames\"": \""^2.3.2\"",\n    \""crypto-js\"": \""^4.2.0\"",\n    \""detect-indent\"": \""^7.0.1\"",\n    \""diff\"": \""^5.2.0\"",\n    \""fast-xml-parser\"": \""^4.3.2\"",\n    \""glob\"": \""^7.2.3\"",\n    \""ini\"": \""^4.1.2\"",\n    \""isomorphic-fetch\"": \""^3.0.0\"",\n    \""js-levenshtein\"": \""^1.1.6\"",\n    \""lexical\"": \""^0.13.1\"",\n    \""lodash\"": \""^4.17.21\"",\n    \""lru-cache\"": \""^10.0.0\"",\n    \""mkdirp\"": \""^3.0.1\"",\n    \""os-browserify\"": \""^0.3.0\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""proxy-agent\"": \""^6.4.0\"",\n    \""re2-wasm\"": \""^1.0.2\"",\n    \""semver\"": \""^7.5.4\"",\n    \""socks-proxy-agent\"": \""^8.0.1\"",\n    \""unzipper\"": \""^0.10.14\"",\n    \""uuid\"": \""^9.0.0\"",\n    \""vscode-languageserver-textdocument\"": \""^1.0.8\"",\n    \""vscode-uri\"": \""^3.0.7\"",\n    \""web-tree-sitter\"": \""^0.21.0\"",\n    \""wink-nlp-utils\"": \""^2.1.0\""\n  },\n  \""devDependencies\"": {\n    \""@google-cloud/pubsub\"": \""^3.7.3\"",\n    \""@playwright/test\"": \""1.39.0\"",\n    \""@pollyjs/adapter-node-http\"": \""^6.0.6\"",\n    \""@pollyjs/core\"": \""^6.0.6\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:144-164"",""content"":""- [ ] Verify that the chat executed by running the command appears in the chat list in the left hand panel.\n\n#### Editing\n\n- [ ] Highlight a section of code.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Cody: Edit Code`.\n- [ ] Provide instructions for how Cody should edit the selected code.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies edits to the selected code, per the users instructions\n- [ ] Verify that you can see a diff view of the edit in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the edit by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Generating code\n\n- [ ] Move the cursor to an empty line, do not highlight any selection.\n- [ ] Click the Code Action lightbulb icon in the project file.\n- [ ] Select `Cody: Generate Code`.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:0-34"",""content"":""{\n  \""actionscript\"": [\""as\""],\n  \""ada\"": [\""adb\"", \""ada\"", \""ads\""],\n  \""apache\"": [\""apacheconf\""],\n  \""apex\"": [\""cls\"", \""apex\"", \""trigger\""],\n  \""applescript\"": [\""applescript\"", \""scpt\""],\n  \""beancount\"": [\""beancount\""],\n  \""bibtex\"": [\""bib\""],\n  \""clojure\"": [\""clj\"", \""cljs\"", \""cljx\""],\n  \""cmake\"": [\""cmake\"", \""cmake.in\"", \""in\""],\n  \""coffescript\"": [\""coffee\"", \""cake\"", \""cson\"", \""cjsx\"", \""iced\""],\n  \""cpp\"": [\""c\"", \""cc\"", \""cpp\"", \""cxx\"", \""c++\"", \""h++\"", \""hh\"", \""h\"", \""hpp\"", \""pc\"", \""pcc\""],\n  \""csharp\"": [\""cs\"", \""csx\""],\n  \""css\"": [\""css\""],\n  \""cuda\"": [\""cu\"", \""cuh\""],\n  \""d\"": [\""d\""],\n  \""dot\"": [\""dot\""],\n  \""dart\"": [\""dart\""],\n  \""diff\"": [\""diff\"", \""patch\""],\n  \""dockerfile\"": [\""Dockerfile\""],\n  \""django\"": [\""jinja\""],\n  \""dos\"": [\""bat\"", \""cmd\""],\n  \""elixir\"": [\""ex\"", \""exs\""],\n  \""elm\"": [\""elm\""],\n  \""erlang\"": [\""erl\""],\n  \""fortran\"": [\""f\"", \""for\"", \""frt\"", \""fr\"", \""forth\"", \""4th\"", \""fth\""],\n  \""fsharp\"": [\""fs\""],\n  \""go\"": [\""go\""],\n  \""graphql\"": [\""graphql\""],\n  \""groovy\"": [\""groovy\""],\n  \""haml\"": [\""haml\""],\n  \""handlebars\"": [\""hbs\"", \""handlebars\""],\n  \""haskell\"": [\""hs\"", \""hsc\""],\n  \""hcl\"": [\""hcl\"", \""nomad\"", \""tf\"", \""tfvars\"", \""workflow\""],\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-tests/test-data/graph-identifiers.tsx:50-108"",""content"":""\nfunction signature()\n//                |\n\n// ------------------------------------\n\n// comment\n//       |\n\n// ------------------------------------\n\n/**\n * comment\n //      |\n */\n\n// ------------------------------------\n\nfunction functionName() {}\n//                  |\n\n// ------------------------------------\n\nfunction returnStatement() {\n    return\n    //   |\n}\n\n// ------------------------------------\n\nfunction returnStatementValue(value: Agent, flag?: boolean) {\n    return 'asd'\n    //     |\n}\n\n// ------------------------------------\n\ninterface TestInterface {\n    //                  |\n}\n\n// ------------------------------------\n\ntype TestType = {\n    //          |\n}\n\n// ------------------------------------\n\nreturnStatementValue('value')\n//                   |\n\n// ------------------------------------\n\nreturnStatementValue('value', false)\n//                            |\n\n// ------------------------------------\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:0-29"",""content"":""{\n  \""private\"": true,\n  \""name\"": \""@sourcegraph/cody\"",\n  \""description\"": \""Cody, the code AI that writes code, fixes bugs, and answers questions using the code graph\"",\n  \""license\"": \""Apache-2.0\"",\n  \""homepage\"": \""https://cody.dev\"",\n  \""repository\"": {\n    \""type\"": \""git\"",\n    \""url\"": \""https://github.com/sourcegraph/cody\""\n  },\n  \""engines\"": {\n    \""node\"": \""^v20.4.0\"",\n    \""pnpm\"": \""^8.6.7\""\n  },\n  \""browser\"": {\n    \""fs\"": false\n  },\n  \""scripts\"": {\n    \""build\"": \""tsc --build\"",\n    \""watch\"": \""tsc --build --watch\"",\n    \""check\"": \""pnpm run -s biome && pnpm run -s check:css\"",\n    \""check:css\"": \""stylelint --quiet --cache '**/*.css'\"",\n    \""biome\"": \""biome check --apply --error-on-warnings .\"",\n    \""test\"": \""vitest\"",\n    \""test:unit\"": \""vitest run\"",\n    \""test:integration\"": \""pnpm -C vscode test:integration\"",\n    \""test:e2e\"": \""pnpm -C vscode test:e2e\"",\n    \""generate-agent-kotlin-bindings\"": \""pnpm build && pnpm dlx ts-node agent/src/cli/scip-codegen/command.ts --output ../jetbrains/src/main/kotlin/com/sourcegraph/cody/protocol_generated\"",\n    \""update-agent-recordings\"": \""pnpm build && CODY_KEEP_UNUSED_RECORDINGS=false CODY_RECORD_IF_MISSING=true vitest agent/src/index.test.ts\"",\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/fixtures/workspace2/README.md:0-3"",""content"":""This is a second workspace folder included in `multi-root.code-workspace` used by integration\ntests in `test/integration/multi-root` for testing in multi-root workspaces.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/smell.ts:60-89"",""content"":""export async function executeSmellCommand(\n    args?: Partial<CodyCommandArgs>\n): Promise<ChatCommandResult | undefined> {\n    return wrapInActiveSpan('command.smell', async span => {\n        span.setAttribute('sampled', true)\n        logDebug('executeSmellCommand', 'executing', { args })\n        telemetryService.log('CodyVSCodeExtension:command:smell:executed', {\n            useCodebaseContex: false,\n            requestID: args?.requestID,\n            source: args?.source,\n            traceId: span.spanContext().traceId,\n        })\n        telemetryRecorder.recordEvent('cody.command.smell', 'executed', {\n            metadata: {\n                useCodebaseContex: 0,\n            },\n            interactionID: args?.requestID,\n            privateMetadata: {\n                requestID: args?.requestID,\n                source: args?.source,\n                traceId: span.spanContext().traceId,\n            },\n        })\n\n        return {\n            type: 'chat',\n            session: await executeChat(await smellCommand(span, args)),\n        }\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144"",""content"":""\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDEs red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \""Cody is working...\"" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDEs red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:116-145"",""content"":""                : ''\n            return fixPathSep(\n                workspaceDisplayPrefix + uri.path.slice(workspacePrefix.length + 1),\n                isWindows,\n                uri.scheme\n            )\n        }\n    }\n\n    if (uri.scheme === 'file') {\n        // Show the absolute file path because we couldn't find a parent workspace folder.\n        return fixPathSep(uri.fsPath, isWindows, uri.scheme)\n    }\n\n    // Show the full URI for anything else.\n    return uri\n}\n\n/**\n * Fixes the path separators for Windows paths. This makes it possible to write cross-platform\n * tests.\n */\nfunction fixPathSep(fsPath: string, isWindows: boolean, scheme: string): string {\n    return isWindows && scheme === 'file' ? fsPath.replaceAll('/', '\\\\') : fsPath\n}\n\nexport function uriHasPrefix(uri: URI, prefix: URI, isWindows: boolean): boolean {\n    // On Windows, it's common to have drive letter casing mismatches (VS Code's APIs tend to normalize\n    // to lowercase, but many other tools use uppercase and we don't know where the context file came\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32"",""content"":""## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/gradlew.bat:0-25"",""content"":""@rem\n@rem Copyright 2015 the original author or authors.\n@rem\n@rem Licensed under the Apache License, Version 2.0 (the \""License\"");\n@rem you may not use this file except in compliance with the License.\n@rem You may obtain a copy of the License at\n@rem\n@rem      https://www.apache.org/licenses/LICENSE-2.0\n@rem\n@rem Unless required by applicable law or agreed to in writing, software\n@rem distributed under the License is distributed on an \""AS IS\"" BASIS,\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@rem See the License for the specific language governing permissions and\n@rem limitations under the License.\n@rem\n\n@if \""%DEBUG%\""==\""\"" @echo off\n@rem ##########################################################################\n@rem\n@rem  Gradle startup script for Windows\n@rem\n@rem ##########################################################################\n\n@rem Set local scope for the variables with windows NT shell\nif \""%OS%\""==\""Windows_NT\"" setlocal\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:108-123"",""content"":""- [ ] Verify that Cody adds documentation above the function that contains your cursor.\n\n### Smell\n\n- [ ] Verify that the option to run the `Find Code Smells` command is available in the following locations:\n  - [ ] Sidebar `Find Code Smells`\n  - [ ] Context (right-click) menu `Cody > Find Code Smells`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Find Code Smells`\n  - [ ] Cody Command Menu (option+c, `Find Code Smells`)\n- [ ] Highlight a section of code in a file.\n- [ ] Run the `Find Code Smells` command.\n- [ ] Verify that Cody provides suggestion for how to improve the selected code in a new chat window.\n- [ ] Move your cursor inside a function in the file without highlighting code, before running the `Find Code Smells` command again\n- [ ] Verify that Cody provides suggestion for how to improve the function that contains your cursor in a new chat window.\n- [ ] Verify that the chat executed by running the command is added to the sidebar under `Chats`.\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_010/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_011/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The build process and tools are primarily configured in the following files:

- **package.json (root and vscode directories):** These files contain the scripts for building the different parts of the project (agent, vscode extension).  They use tools like `esbuild` and `vite` for bundling.
- **pnpm-lock.yaml:** This file locks down the versions of all dependencies, ensuring consistent builds.

For linting, the configuration is likely in:

- **.stylelintrc.cjs (likely in the root or vscode directory):** This file is a common location for configuring the `stylelint` tool, which is used for linting CSS/SCSS/Less files.

You can find more specific configurations for individual tools within the ""scripts"" section of the `package.json` files. For example, the `_build:esbuild:desktop` script in `vscode/package.json` shows how `esbuild` is configured for building the desktop version of the VS Code extension.",Where are the build and lint tools configured?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:1746-1760"",""content"":""      '@babel/core': 7.24.0\n      '@babel/helper-compilation-targets': 7.23.6\n      '@babel/helper-plugin-utils': 7.24.0\n      '@babel/helper-validator-option': 7.23.5\n      '@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining': 7.23.3(@babel/core@7.24.0)\n      '@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly': 7.23.7(@babel/core@7.24.0)\n      '@babel/plugin-proposal-private-property-in-object': 7.21.0-placeholder-for-preset-env.2(@babel/core@7.24.0)\n      '@babel/plugin-syntax-async-generators': 7.8.4(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-properties': 7.12.13(@babel/core@7.24.0)\n      '@babel/plugin-syntax-class-static-block': 7.14.5(@babel/core@7.24.0)\n      '@babel/plugin-syntax-dynamic-import': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-export-namespace-from': 7.8.3(@babel/core@7.24.0)\n      '@babel/plugin-syntax-import-assertions': 7.23.3(@babel/core@7.24.0)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/common/markdown/contributions.ts:43-72"",""content"":"" */\nexport function registerHighlightContributions(): void {\n    if (registered) {\n        // Don't double-register these. (There is no way to unregister them.)\n        return\n    }\n    registered = true\n    registerLanguage('go', goLang)\n    registerLanguage('javascript', javascript)\n    registerLanguage('typescript', typescript)\n    registerLanguage('java', java)\n    registerLanguage('python', python)\n    registerLanguage('php', php)\n    registerLanguage('bash', bash)\n    registerLanguage('clojure', clojure)\n    // This is a dependency of cpp.\n    registerLanguage('c-like', cLike)\n    registerLanguage('cpp', cpp)\n    registerLanguage('cs', csharp)\n    registerLanguage('csharp', csharp)\n    registerLanguage('css', css)\n    registerLanguage('dockerfile', dockerfile)\n    registerLanguage('elixir', elixir)\n    registerLanguage('haskell', haskell)\n    registerLanguage('html', xml)\n    registerLanguage('lua', lua)\n    registerLanguage('ocaml', ocaml)\n    registerLanguage('r', rLang)\n    registerLanguage('ruby', ruby)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:44-81"",""content"":""      '@testing-library/jest-dom':\n        specifier: ^6.4.2\n        version: 6.4.2(vitest@1.5.0)\n      '@testing-library/react':\n        specifier: ^14.2.2\n        version: 14.2.2(react-dom@18.2.0)(react@18.2.0)\n      '@types/node':\n        specifier: 20.12.7\n        version: 20.12.7\n      '@types/react':\n        specifier: 18.2.79\n        version: 18.2.79\n      '@types/react-dom':\n        specifier: 18.2.25\n        version: 18.2.25\n      '@vitejs/plugin-react':\n        specifier: ^4.2.1\n        version: 4.2.1(vite@5.2.9)\n      esbuild:\n        specifier: ^0.18.20\n        version: 0.18.20\n      happy-dom:\n        specifier: ^14.3.10\n        version: 14.3.10\n      jsdom:\n        specifier: ^22.1.0\n        version: 22.1.0\n      knip:\n        specifier: ^3.13.2\n        version: 3.13.2(@types/node@20.12.7)(typescript@5.4.2)\n      storybook:\n        specifier: ^8.0.5\n        version: 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      stylelint:\n        specifier: ^15.11.0\n        version: 15.11.0(typescript@5.4.2)\n      stylelint-config-standard:\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4219-4245"",""content"":""      '@storybook/csf-tools': 8.0.5\n      '@storybook/global': 5.0.0\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/react-dom-shim': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/theming': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/types': 8.0.5\n      '@types/react': 18.2.79\n      fs-extra: 11.2.0\n      react: 18.2.0\n      react-dom: 18.2.0(react@18.2.0)\n      rehype-external-links: 3.0.0\n      rehype-slug: 6.0.0\n      ts-dedent: 2.2.0\n    transitivePeerDependencies:\n      - encoding\n      - supports-color\n    dev: true\n\n  /@storybook/addon-essentials@8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0):\n    resolution: {integrity: sha512-1yjwf9ibKn2rVqv+fqxACoIjsaUsimSEx8QwjIl2krDNhMULXzFeVubTQ09gXSVEnHUR1nKX3X9qOXJQ2bOFlQ==}\n    dependencies:\n      '@storybook/addon-actions': 8.0.5\n      '@storybook/addon-backgrounds': 8.0.5\n      '@storybook/addon-controls': 8.0.5(@types/react@18.2.79)(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/addon-docs': 8.0.5\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:409-453"",""content"":""        version: 10.0.0\n      mkdirp:\n        specifier: ^3.0.1\n        version: 3.0.1\n      os-browserify:\n        specifier: ^0.3.0\n        version: 0.3.0\n      parse-git-diff:\n        specifier: ^0.0.14\n        version: 0.0.14\n      proxy-agent:\n        specifier: ^6.4.0\n        version: 6.4.0\n      re2-wasm:\n        specifier: ^1.0.2\n        version: 1.0.2\n      semver:\n        specifier: ^7.5.4\n        version: 7.6.0\n      socks-proxy-agent:\n        specifier: ^8.0.1\n        version: 8.0.1\n      unzipper:\n        specifier: ^0.10.14\n        version: 0.10.14\n      uuid:\n        specifier: ^9.0.0\n        version: 9.0.0\n      vscode-languageserver-textdocument:\n        specifier: ^1.0.8\n        version: 1.0.8\n      vscode-uri:\n        specifier: ^3.0.7\n        version: 3.0.7\n      web-tree-sitter:\n        specifier: ^0.21.0\n        version: 0.21.0\n      wink-nlp-utils:\n        specifier: ^2.1.0\n        version: 2.1.0\n    devDependencies:\n      '@google-cloud/pubsub':\n        specifier: ^3.7.3\n        version: 3.7.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:16-24"",""content"":""    \""dev:web\"": \""pnpm run -s build:dev:web && pnpm run -s _dev:vscode-test-web --browserType none\"",\n    \""watch:dev:web\"": \""concurrently \\\""pnpm run -s watch:build:dev:web\\\"" \\\""pnpm run -s _dev:vscode-test-web --browserType none\\\""\"",\n    \""_dev:vscode-test-web\"": \""vscode-test-web --extensionDevelopmentPath=. ${WORKSPACE-test/fixtures/workspace}\"",\n    \""build\"": \""tsc --build && pnpm run -s _build:esbuild:desktop && pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""_build:desktop\"": \""pnpm run -s _build:esbuild:desktop && pnpm run -s _build:webviews --mode production\"",\n    \""_build:web\"": \""pnpm run -s _build:esbuild:web && pnpm run -s _build:webviews --mode production\"",\n    \""build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n    \""build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --alias:@sourcegraph/cody-shared=@sourcegraph/cody-shared/src/index --alias:@sourcegraph/cody-shared/src=@sourcegraph/cody-shared/src\\\"" \\\""pnpm run -s _build:webviews --mode development\\\""\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentWorkspaceConfiguration.ts:8-138"",""content"":""export class AgentWorkspaceConfiguration implements vscode.WorkspaceConfiguration {\n    constructor(\n        private prefix: string[],\n        private clientInfo: () => ClientInfo | undefined,\n        private extensionConfig: () => ExtensionConfiguration | undefined,\n        private dictionary: Record<string, any> = {}\n    ) {}\n\n    public withPrefix(prefix: string): AgentWorkspaceConfiguration {\n        return new AgentWorkspaceConfiguration(\n            this.prefix.concat(prefix),\n            this.clientInfo,\n            this.extensionConfig,\n            this.dictionary\n        )\n    }\n\n    private actualSection(section: string): string {\n        if (this.prefix.length === 0) {\n            return section\n        }\n        return [...this.prefix, section].join('.')\n    }\n\n    private clientNameToIDE(value: string): Configuration['agentIDE'] | undefined {\n        switch (value.toLowerCase()) {\n            case 'vscode':\n                return 'VSCode'\n            case 'jetbrains':\n                return 'JetBrains'\n            case 'emacs':\n                return 'Emacs'\n            case 'neovim':\n                return 'Neovim'\n            default:\n                return undefined\n        }\n    }\n\n    public get(userSection: string, defaultValue?: unknown): any {\n        const section = this.actualSection(userSection)\n\n        const fromDictionary = this.dictionary?.[section]\n        if (fromDictionary !== undefined) {\n            return fromDictionary\n        }\n        const extensionConfig = this.extensionConfig()\n\n        const fromCustomConfiguration = extensionConfig?.customConfiguration?.[section]\n        if (fromCustomConfiguration !== undefined) {\n            return fromCustomConfiguration\n        }\n        switch (section) {\n            case 'cody.serverEndpoint':\n                return extensionConfig?.serverEndpoint\n            case 'cody.proxy':\n                return extensionConfig?.proxy ?? null\n            case 'cody.customHeaders':\n                return extensionConfig?.customHeaders\n            case 'cody.telemetry.level':\n                // Use the dedicated `telemetry/recordEvent` to send telemetry from\n                // agent clients.  The reason we disable telemetry via config is\n                // that we don't want to submit vscode-specific events when\n                // running inside the agent.\n                return 'agent'\n            case 'cody.autocomplete.enabled':\n                return true\n            case 'cody.autocomplete.advanced.provider':\n                return extensionConfig?.autocompleteAdvancedProvider ?? null\n            case 'cody.autocomplete.advanced.model':\n                return extensionConfig?.autocompleteAdvancedModel ?? null\n            case 'cody.advanced.agent.running':\n                return true\n            case 'cody.debug.verbose':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.experimental.tracing':\n                return extensionConfig?.verboseDebug ?? false\n            case 'cody.useContext':\n                // Disable embeddings by default.\n                return 'keyword'\n            case 'cody.codebase':\n                return extensionConfig?.codebase\n            case 'cody.advanced.agent.ide':\n                return this.clientNameToIDE(this.clientInfo()?.name ?? '')\n            case 'editor.insertSpaces':\n                return true // TODO: override from IDE clients\n            default:\n                // VS Code picks up default value in package.json, and only uses\n                // the `defaultValue` parameter if package.json provides no\n                // default.\n                return defaultConfigurationValue(section) ?? defaultValue\n        }\n    }\n\n    public has(section: string): boolean {\n        const actual = this.actualSection(section)\n        for (const key in this.dictionary) {\n            if (key.startsWith(actual)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    public inspect<T>(section: string):\n        | {\n              key: string\n              defaultValue?: T | undefined\n              globalValue?: T | undefined\n              workspaceValue?: T | undefined\n              workspaceFolderValue?: T | undefined\n              defaultLanguageValue?: T | undefined\n              globalLanguageValue?: T | undefined\n              workspaceLanguageValue?: T | undefined\n              workspaceFolderLanguageValue?: T | undefined\n              languageIds?: string[] | undefined\n          }\n        | undefined {\n        return undefined\n    }\n\n    public async update(\n        section: string,\n        value: any,\n        _configurationTarget?: boolean | vscode.ConfigurationTarget | null | undefined,\n        _overrideInLanguage?: boolean | undefined\n    ): Promise<void> {\n        this.dictionary[this.actualSection(section)] = value\n        return Promise.resolve()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/mocks.ts:653-709"",""content"":""            'yaml',\n            'tailwindcss',\n            'editorconfig',\n            'graphql',\n            'vue',\n            'go.mod',\n            'go.work',\n            'go.sum',\n            'gotmpl',\n            'govulncheck',\n            'kotlin',\n            'kotlinscript',\n            'lisp',\n            'toml',\n            'jinja',\n            'pip-requirements',\n            'raw',\n            'prisma',\n            'starlark',\n            'bazel',\n            'bazelrc',\n            'vimrc',\n        ])\n    },\n}\n\nexport enum TextDocumentChangeReason {\n    Undo = 1,\n    Redo = 2,\n}\nexport enum UIKind {\n    Desktop = 1,\n    Web = 2,\n}\n\nexport class FileSystemError extends Error {}\n\nexport const vsCodeMocks = {\n    FileSystemError,\n    FileType,\n    Range,\n    Position,\n    InlineCompletionItem,\n    EventEmitter,\n    EndOfLine,\n    CancellationTokenSource,\n    ThemeColor,\n    ThemeIcon,\n    TreeItem,\n    WorkspaceEdit,\n    UIKind,\n    QuickInputButtons,\n    Uri,\n    languages,\n    env: {\n        uiKind: 1 satisfies vscode_types.UIKind.Desktop,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:93-97"",""content"":""export interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:66-97"",""content"":""} from './commands/types'\nexport { CustomCommandType } from './commands/types'\nexport { type DefaultCodyCommands, DefaultChatCommands, DefaultEditCommands } from './commands/types'\nexport { dedupeWith, isDefined, isErrorLike, pluralize } from './common'\nexport { type RangeData, toRangeData, displayLineRange, displayRange } from './common/range'\nexport {\n    ProgrammingLanguage,\n    languageFromFilename,\n    markdownCodeBlockLanguageIDForFilename,\n    extensionForLanguage,\n} from './common/languages'\nexport { renderMarkdown, escapeHTML } from './common/markdown'\nexport { posixFilePaths, pathFunctionsForURI } from './common/path'\nexport { isWindows, isMacOS } from './common/platform'\nexport {\n    assertFileURI,\n    isFileURI,\n    uriBasename,\n    uriDirname,\n    uriExtname,\n    uriParseNameAndExtension,\n    type FileURI,\n} from './common/uri'\nexport type {\n    AutocompleteTimeouts,\n    Configuration,\n    ConfigurationUseContext,\n    ConfigurationWithAccessToken,\n    OllamaGenerateParameters,\n    OllamaOptions,\n    ConfigGetter,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration-keys.ts:6-9"",""content"":""export function defaultConfigurationValue(key: string): any {\n    const value = (properties as any)[key as any]?.default\n    return value\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1321-1329"",""content"":""    \""ovsx\"": \""^0.8.2\"",\n    \""pako\"": \""^2.1.0\"",\n    \""path-browserify\"": \""^1.0.1\"",\n    \""playwright\"": \""1.39.0\"",\n    \""progress\"": \""^2.0.3\"",\n    \""yaml\"": \""^2.3.4\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:20-86"",""content"":""export interface Configuration {\n    proxy?: string | null\n    codebase?: string\n    debugFilter: RegExp | null\n    debugVerbose: boolean\n    telemetryLevel: 'all' | 'off' | 'agent'\n    useContext: ConfigurationUseContext\n    customHeaders: Record<string, string>\n    chatPreInstruction: PromptString\n    editPreInstruction: PromptString\n    codeActions: boolean\n    commandHints: boolean\n    commandCodeLenses: boolean\n\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/index.md:0-18"",""content"":""## Development\n\n### Setup\n\n1. Install [asdf](https://asdf-vm.com/)\n1. Run `asdf install` (if needed, run `asdf plugin add NAME` for any missing plugins)\n1. Run `pnpm install && pnpm build`\n\n### Build and run the VS Code extension\n\nOpen this repository in VS Code and run the `Launch VS Code Extension (Desktop)` build/debug task (or run `pnpm -C vscode run dev`).\n\nSee [vscode/CONTRIBUTING.md](../../vscode/CONTRIBUTING.md) for more information.\n\n### Other topics\n\n- [Quality tools](quality/index.md)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:28-183"",""content"":""export function getConfiguration(\n    config: ConfigGetter = vscode.workspace.getConfiguration()\n): Configuration {\n    const isTesting = process.env.CODY_TESTING === 'true'\n\n    function getHiddenSetting<T>(configKey: string, defaultValue?: T): T {\n        return config.get<T>(`cody.${configKey}` as any, defaultValue)\n    }\n\n    let debugRegex: RegExp | null = null\n    try {\n        const debugPattern: string | null = config.get<string | null>(CONFIG_KEY.debugFilter, null)\n        if (debugPattern) {\n            if (debugPattern === '*') {\n                debugRegex = /.*/\n            } else {\n                debugRegex = new RegExp(debugPattern)\n            }\n        }\n    } catch (error: any) {\n        void vscode.window.showErrorMessage(\n            \""Error parsing cody.debug.filter regex - using default '*'\"",\n            error\n        )\n        debugRegex = /.*/\n    }\n\n    let autocompleteAdvancedProvider = config.get<\n        | Configuration['autocompleteAdvancedProvider']\n        | 'unstable-ollama'\n        | 'unstable-fireworks'\n        | 'experimental-openaicompatible'\n    >(CONFIG_KEY.autocompleteAdvancedProvider, null)\n\n    // Handle deprecated provider identifiers\n    switch (autocompleteAdvancedProvider) {\n        case 'unstable-fireworks':\n            autocompleteAdvancedProvider = 'fireworks'\n            break\n        case 'unstable-ollama':\n            autocompleteAdvancedProvider = 'experimental-ollama'\n            break\n    }\n\n    // check if the configured enum values are valid\n    const configKeys = [\n        'autocompleteAdvancedProvider',\n        'autocompleteAdvancedModel',\n    ] as (keyof ConfigurationKeysMap)[]\n\n    for (const configVal of configKeys) {\n        const key = configVal.replaceAll(/([A-Z])/g, '.$1').toLowerCase()\n        const value: string | null = config.get(CONFIG_KEY[configVal])\n        checkValidEnumValues(key, value)\n    }\n\n    const autocompleteExperimentalGraphContext: 'bfg' | null = getHiddenSetting(\n        'autocomplete.experimental.graphContext',\n        null\n    )\n\n    return {\n        proxy: config.get<string | null>(CONFIG_KEY.proxy, null),\n        codebase: sanitizeCodebase(config.get(CONFIG_KEY.codebase)),\n        customHeaders: config.get<object>(CONFIG_KEY.customHeaders, {}) as Record<string, string>,\n        useContext: config.get<ConfigurationUseContext>(CONFIG_KEY.useContext) || 'embeddings',\n        debugVerbose: config.get<boolean>(CONFIG_KEY.debugVerbose, false),\n        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n            CONFIG_KEY.autocompleteDisableInsideComments,\n            false\n        ),\n        codeActions: config.get(CONFIG_KEY.codeActionsEnabled, true),\n        commandHints: config.get(CONFIG_KEY.commandHintsEnabled, false),\n\n        /**\n         * Hidden settings for internal use only.\n         */\n\n        internalUnstable: getHiddenSetting('internal.unstable', isTesting),\n\n        autocompleteExperimentalGraphContext,\n        experimentalSimpleChatContext: getHiddenSetting('experimental.simpleChatContext', true),\n        experimentalSymfContext: getHiddenSetting('experimental.symfContext', true),\n\n        experimentalGuardrails: getHiddenSetting('experimental.guardrails', isTesting),\n        experimentalTracing: getHiddenSetting('experimental.tracing', false),\n\n        experimentalOllamaChat: getHiddenSetting('experimental.ollamaChat', false),\n        experimentalSupercompletions: getHiddenSetting('experimental.supercompletions', false),\n\n        experimentalChatContextRanker: getHiddenSetting('experimental.chatContextRanker', false),\n\n        autocompleteExperimentalHotStreak: getHiddenSetting(\n            'autocomplete.experimental.hotStreak',\n            false\n        ),\n        autocompleteExperimentalOllamaOptions: getHiddenSetting(\n            'autocomplete.experimental.ollamaOptions',\n            {\n                url: OLLAMA_DEFAULT_URL,\n                model: 'codellama:7b-code',\n            }\n        ),\n        autocompleteExperimentalFireworksOptions: getHiddenSetting(\n            'autocomplete.experimental.fireworksOptions',\n            undefined\n        ),\n        autocompleteExperimentalSmartThrottle: getHiddenSetting(\n            'autocomplete.experimental.smartThrottle',\n            false\n        ),\n\n        // Note: In spirit, we try to minimize agent-specific code paths in the VSC extension.\n        // We currently use this flag for the agent to provide more helpful error messages\n        // when something goes wrong, and to suppress event logging in the agent.\n        // Rely on this flag sparingly.\n        isRunningInsideAgent: getHiddenSetting('advanced.agent.running', false),\n        agentIDE: getHiddenSetting<'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'>('advanced.agent.ide'),\n        autocompleteTimeouts: {\n            multiline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.multiline',\n                undefined\n            ),\n            singleline: getHiddenSetting<number | undefined>(\n                'autocomplete.advanced.timeout.singleline',\n                undefined\n            ),\n        },\n\n        testingLocalEmbeddingsModel: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.model', undefined)\n            : undefined,\n        testingLocalEmbeddingsEndpoint: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.endpoint', undefined)\n            : undefined,\n        testingLocalEmbeddingsIndexLibraryPath: isTesting\n            ? getHiddenSetting<string | undefined>('testing.localEmbeddings.indexLibraryPath', undefined)\n            : undefined,\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:24-32"",""content"":""    \""watch:build:dev:web\"": \""concurrently \\\""pnpm run -s _build:esbuild:web --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""watch:build:dev:desktop\"": \""concurrently \\\""pnpm run -s _build:esbuild:desktop --watch\\\"" \\\""pnpm run -s _build:webviews --mode development --watch\\\""\"",\n    \""_build:esbuild:desktop\"": \""pnpm download-wasm && esbuild ./src/extension.node.ts --bundle --outfile=dist/extension.node.js --external:vscode --format=cjs --platform=node --sourcemap\"",\n    \""_build:esbuild:web\"": \""esbuild ./src/extension.web.ts --platform=browser --bundle --outfile=dist/extension.web.js --alias:path=path-browserify --alias:node:path=path-browserify --alias:node:os=os-browserify --external:vscode --define:process='{\\\""env\\\"":{}}' --define:window=self --format=cjs --sourcemap\"",\n    \""_build:webviews\"": \""vite -c webviews/vite.config.ts build\"",\n    \""release\"": \""ts-node-transpile-only ./scripts/release.ts\"",\n    \""download-wasm\"": \""ts-node-transpile-only ./scripts/download-wasm-modules.ts\"",\n    \""release:dry-run\"": \""pnpm run download-wasm && CODY_RELEASE_DRY_RUN=1 ts-node ./scripts/release.ts\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/CodePrinter.ts:43-45"",""content"":""    public build(): string {\n        return this.out.join('')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/package.json:64-78"",""content"":""    \""@types/diff\"": \""^5.0.9\"",\n    \""@types/google-protobuf\"": \""3.15.12\"",\n    \""@types/minimatch\"": \""^5.1.2\"",\n    \""@types/uuid\"": \""^9.0.2\"",\n    \""@types/vscode\"": \""^1.80.0\"",\n    \""@types/ws\"": \""^8.5.10\"",\n    \""diff\"": \""^5.2.0\"",\n    \""esbuild\"": \""^0.18.19\"",\n    \""google-protobuf\"": \""^3.21.2\"",\n    \""parse-git-diff\"": \""^0.0.14\"",\n    \""pkg\"": \""^5.8.1\"",\n    \""rimraf\"": \""^5.0.5\""\n  }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/custom-commands.ts:147-174"",""content"":""    public async build(type: CustomCommandType): Promise<Map<string, CodyCommand> | null> {\n        const uri = this.getConfigFileByType(type)\n        if (!uri || (type === CustomCommandType.Workspace && !vscode.workspace.isTrusted)) {\n            return null\n        }\n        try {\n            const content = await getDocText(uri)\n            if (!content.trim()) {\n                return null\n            }\n            const customCommandsMap = buildCodyCommandMap(type, content)\n            this.customCommandsMap = new Map([...this.customCommandsMap, ...customCommandsMap])\n\n            // Register Custom Commands as VS Code commands\n            for (const [key, _command] of customCommandsMap) {\n                this.registeredCommands.push(\n                    vscode.commands.registerCommand(`cody.command.custom.${key}`, () =>\n                        vscode.commands.executeCommand('cody.action.command', key, {\n                            source: 'editor',\n                        })\n                    )\n                )\n            }\n        } catch (error) {\n            console.error('CustomCommandsProvider:build', 'failed', { verbose: error })\n        }\n        return this.customCommandsMap\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/language-file-extensions.json:115-192"",""content"":""    \""ant\"",\n    \""axml\"",\n    \""builds\"",\n    \""ccxml\"",\n    \""clixml\"",\n    \""cproject\"",\n    \""csl\"",\n    \""csproj\"",\n    \""ct\"",\n    \""dita\"",\n    \""ditamap\"",\n    \""ditaval\"",\n    \""dll.config\"",\n    \""dotsettings\"",\n    \""filters\"",\n    \""fsproj\"",\n    \""fxml\"",\n    \""glade\"",\n    \""gml\"",\n    \""grxml\"",\n    \""iml\"",\n    \""ivy\"",\n    \""jelly\"",\n    \""jsproj\"",\n    \""kml\"",\n    \""launch\"",\n    \""mdpolicy\"",\n    \""mjml\"",\n    \""mod\"",\n    \""mxml\"",\n    \""nproj\"",\n    \""nuspec\"",\n    \""odd\"",\n    \""osm\"",\n    \""pkgproj\"",\n    \""plist\"",\n    \""props\"",\n    \""ps1xml\"",\n    \""psc1\"",\n    \""pt\"",\n    \""rdf\"",\n    \""resx\"",\n    \""rss\"",\n    \""scxml\"",\n    \""sfproj\"",\n    \""srdf\"",\n    \""storyboard\"",\n    \""stTheme\"",\n    \""sublime-snippet\"",\n    \""targets\"",\n    \""tmCommand\"",\n    \""tml\"",\n    \""tmLanguage\"",\n    \""tmPreferences\"",\n    \""tmSnippet\"",\n    \""tmTheme\"",\n    \""ui\"",\n    \""urdf\"",\n    \""ux\"",\n    \""vbproj\"",\n    \""vcxproj\"",\n    \""vsixmanifest\"",\n    \""vssettings\"",\n    \""vstemplate\"",\n    \""vxml\"",\n    \""wixproj\"",\n    \""wsdl\"",\n    \""wsf\"",\n    \""wxi\"",\n    \""wxl\"",\n    \""wxs\"",\n    \""x3d\"",\n    \""xacro\"",\n    \""xaml\"",\n    \""xib\"",\n    \""xlf\"",\n    \""xliff\"",\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/prompt-builder/index.ts:39-41"",""content"":""    public build(): Message[] {\n        return this.prefixMessages.concat([...this.reverseMessages].reverse())\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:97-130"",""content"":""} from './configuration'\nexport { NoopEditor } from './editor'\nexport type {\n    ActiveTextEditor,\n    ActiveTextEditorDiagnostic,\n    ActiveTextEditorDiagnosticType,\n    ActiveTextEditorSelection,\n    ActiveTextEditorVisibleContent,\n    Editor,\n} from './editor'\nexport {\n    displayPath,\n    displayPathBasename,\n    displayPathDirname,\n    displayPathWithoutWorkspaceFolderPrefix,\n    setDisplayPathEnvInfo,\n    type DisplayPathEnvInfo,\n} from './editor/displayPath'\nexport { hydrateAfterPostMessage } from './editor/hydrateAfterPostMessage'\nexport * from './editor/utils'\nexport {\n    FeatureFlag,\n    FeatureFlagProvider,\n    featureFlagProvider,\n} from './experimentation/FeatureFlagProvider'\nexport { GuardrailsPost, summariseAttribution } from './guardrails'\nexport type { Attribution, Guardrails } from './guardrails'\nexport { SourcegraphGuardrailsClient } from './guardrails/client'\nexport {\n    CompletionStopReason,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type CompletionResponseGenerator,\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_012/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_013/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for calling the Sourcegraph API is primarily located in the `SourcegraphGraphQLAPIClient` class, defined in  `lib/shared/src/sourcegraph-api/graphql/client.ts`. 

Here's a breakdown:

- **`SourcegraphGraphQLAPIClient`**: This class provides methods for interacting with the Sourcegraph GraphQL API. 
- **`fetchSourcegraphAPI`**: This private method is the core function used to make requests to the Sourcegraph API. It handles constructing the request URL, setting headers (including authorization), and parsing the response.
- **Other methods**: The `SourcegraphGraphQLAPIClient` class exposes various public methods like `getSiteVersion`, `getCodyConfigFeatures`, `getRepoList`, `contextSearch`, etc., which internally utilize `fetchSourcegraphAPI` to interact with specific API endpoints.

In addition to this central class, other files like `browserClient.ts` and `nodeClient.ts` in the same directory define client implementations for different environments (browser and Node.js) that ultimately use the `SourcegraphGraphQLAPIClient` for API communication.",Where is the functionality for calling the Sourcegraph API?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:54-82"",""content"":""    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n                    break\n                }\n                case 'error': {\n                    const error = new Error(event.error)\n                    if (span) {\n                        recordErrorToSpan(span, error)\n                    }\n                    this.errorEncountered = true\n                    cb.onError(error)\n                    break\n                }\n                case 'done': {\n                    if (!this.errorEncountered) {\n                        cb.onComplete()\n                    }\n                    // reset errorEncountered for next request\n                    this.errorEncountered = false\n                    span?.end()\n                    break\n                }\n            }\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:170-198"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?CurrentSiteCodyLlmConfiguration\n      response:\n        bodySize: 215\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 215\n          text: \""[\\\""H4sIAAAAAAAAA4TOMQ7CMAxA0bt4bkXajaxdm40LWElKI4JdNS4CVbk7ShdQBpgsWd9P3\\\n            sGhIOgdUhBfpmX3GkczME3huq0ogenYzyiGnY+gAUnmlZdgTzbi\\\"",\\\""5nzbQ/MJDD4\\\n            vfPOUQHe9UqqBCZMMv+4DJUGStoMq/rLOB2X5vkRfnvqLPYpW9ZWXc85vAAAA//8DAC\\\n            mc8DoDAQAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:34:09 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/browserClient.ts:8-85"",""content"":""export class SourcegraphBrowserCompletionsClient extends SourcegraphCompletionsClient {\n    protected _streamWithCallbacks(\n        params: CompletionParameters,\n        apiVersion: number,\n        cb: CompletionCallbacks,\n        signal?: AbortSignal\n    ): void {\n        const url = new URL(this.completionsEndpoint)\n        if (apiVersion >= 1) {\n            url.searchParams.append('api-version', '' + apiVersion)\n        }\n\n        const abort = dependentAbortController(signal)\n        const headersInstance = new Headers(this.config.customHeaders as HeadersInit)\n        addCustomUserAgent(headersInstance)\n        headersInstance.set('Content-Type', 'application/json; charset=utf-8')\n        if (this.config.accessToken) {\n            headersInstance.set('Authorization', `token ${this.config.accessToken}`)\n        }\n        const parameters = new URLSearchParams(window.location.search)\n        const trace = parameters.get('trace')\n        if (trace) {\n            headersInstance.set('X-Sourcegraph-Should-Trace', 'true')\n        }\n        // Disable gzip compression since the sg instance will start to batch\n        // responses afterwards.\n        headersInstance.set('Accept-Encoding', 'gzip;q=0')\n        fetchEventSource(url.toString(), {\n            method: 'POST',\n            headers: Object.fromEntries(headersInstance.entries()),\n            body: JSON.stringify(params),\n            signal: abort.signal,\n            openWhenHidden: isRunningInWebWorker, // otherwise tries to call document.addEventListener\n            async onopen(response) {\n                if (!response.ok && response.headers.get('content-type') !== 'text/event-stream') {\n                    let errorMessage: null | string = null\n                    try {\n                        errorMessage = await response.text()\n                    } catch (error) {\n                        // We show the generic error message in this case\n                        console.error(error)\n                    }\n                    const error = new Error(\n                        errorMessage === null || errorMessage.length === 0\n                            ? `Request failed with status code ${response.status}`\n                            : errorMessage\n                    )\n                    cb.onError(error, response.status)\n                    abort.abort()\n                    return\n                }\n            },\n            onmessage: message => {\n                try {\n                    const data: Event = { ...JSON.parse(message.data), type: message.event }\n                    this.sendEvents([data], cb)\n                } catch (error: any) {\n                    cb.onError(error.message)\n                    abort.abort()\n                    console.error(error)\n                    // throw the error for not retrying\n                    throw error\n                }\n            },\n            onerror(error) {\n                cb.onError(error.message)\n                abort.abort()\n                console.error(error)\n                // throw the error for not retrying\n                throw error\n            },\n        }).catch(error => {\n            cb.onError(error.message)\n            abort.abort()\n            console.error(error)\n        })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.vscode/extensions.json:0-10"",""content"":""{\n  \""recommendations\"": [\n    \""sourcegraph.cody-ai\"",\n    \""editorconfig.editorconfig\"",\n    \""ecmel.vscode-html-css\"",\n    \""biomejs.biome\"",\n    \""stylelint.vscode-stylelint\""\n  ]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:182-216"",""content"":""\n                  ```\n\n                  client/web/node_modules\n\n                  client/web-sveltekit/node_modules\n\n                  client/wildcard/node_modules\n\n                  dev/release/node_modules\n\n\n                  cmd/symbols/squirrel/test_repos/starlark\n\n\n                  # Generated by local tools\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /client/shared/src/codeintel/legacy-extensions/search/providers.ts\n                  in repository github.com/sourcegraph/sourcegraph:\n\n                  ```typescript\n\n                  import { getConfig } from './config'\n\n                  import { type Result, resultToLocation, searchResultToResults } from './conversion'\n\n                  import { findDocstring } from './docstrings'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:32-60"",""content"":""/**\n * Access the chat based LLM APIs via a Sourcegraph server instance.\n *\n *  SECURITY: It is the caller's responsibility to ensure context from\n * all cody ignored files are removed before sending requests to the server.\n */\nexport abstract class SourcegraphCompletionsClient {\n    private errorEncountered = false\n\n    constructor(\n        protected config: CompletionsClientConfig,\n        protected logger?: CompletionLogger\n    ) {}\n\n    public onConfigurationChange(newConfig: CompletionsClientConfig): void {\n        this.config = newConfig\n    }\n\n    protected get completionsEndpoint(): string {\n        return new URL('/.api/completions/stream', this.config.serverEndpoint).href\n    }\n\n    protected sendEvents(events: Event[], cb: CompletionCallbacks, span?: Span): void {\n        for (const event of events) {\n            switch (event.type) {\n                case 'completion': {\n                    span?.addEvent('yield', { stopReason: event.stopReason })\n                    cb.onChange(event.completion)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:297-870"",""content"":""export class SourcegraphGraphQLAPIClient {\n    private dotcomUrl = DOTCOM_URL\n    public anonymousUserID: string | undefined\n\n    /**\n     * Should be set on extension activation via `localStorage.onConfigurationChange(config)`\n     * Done to avoid passing the graphql client around as a parameter and instead\n     * access it as a singleton via the module import.\n     */\n    private _config: GraphQLAPIClientConfig | null = null\n\n    private get config(): GraphQLAPIClientConfig {\n        if (!this._config) {\n            throw new Error('GraphQLAPIClientConfig is not set')\n        }\n\n        return this._config\n    }\n\n    constructor(config: GraphQLAPIClientConfig | null = null) {\n        this._config = config\n    }\n\n    public onConfigurationChange(newConfig: GraphQLAPIClientConfig): void {\n        this._config = newConfig\n    }\n\n    /**\n     * If set, anonymousUID is trasmitted as 'X-Sourcegraph-Actor-Anonymous-UID'\n     * which is automatically picked up by Sourcegraph backends 5.2+\n     */\n    public setAnonymousUserID(anonymousUID: string): void {\n        this.anonymousUserID = anonymousUID\n    }\n\n    public isDotCom(): boolean {\n        return isDotCom(this.config.serverEndpoint)\n    }\n\n    // Gets the server endpoint for this client.\n    public get endpoint(): string {\n        return this.config.serverEndpoint\n    }\n\n    public async getSiteVersion(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteVersionResponse>>(\n            CURRENT_SITE_VERSION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => data.site?.productVersion ?? new Error('site version not found')\n            )\n        )\n    }\n\n    public async getSiteIdentification(): Promise<{ siteid: string; hashedLicenseKey: string } | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<SiteIdentificationResponse>>(\n            CURRENT_SITE_IDENTIFICATION,\n            {}\n        )\n        return extractDataOrError(response, data =>\n            data.site?.siteID\n                ? data.site?.productSubscription?.license?.hashedKey\n                    ? {\n                          siteid: data.site?.siteID,\n                          hashedLicenseKey: data.site?.productSubscription?.license?.hashedKey,\n                      }\n                    : new Error('site hashed license key not found')\n                : new Error('site ID not found')\n        )\n    }\n\n    public async getSiteHasIsCodyEnabledField(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteGraphqlFieldsResponse>>(\n            CURRENT_SITE_GRAPHQL_FIELDS_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(\n                response,\n                data => !!data.__type?.fields?.find(field => field.name === 'isCodyEnabled')\n            )\n        )\n    }\n\n    public async getSiteHasCodyEnabled(): Promise<boolean | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SiteHasCodyEnabledResponse>>(\n            CURRENT_SITE_HAS_CODY_ENABLED_QUERY,\n            {}\n        ).then(response => extractDataOrError(response, data => data.site?.isCodyEnabled ?? false))\n    }\n\n    public async getCurrentUserId(): Promise<string | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserIdResponse>>(\n            CURRENT_USER_ID_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? data.currentUser.id : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodyProEnabled(): Promise<{ codyProEnabled: boolean } | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodyProEnabledResponse>>(\n            CURRENT_USER_CODY_PRO_ENABLED_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    public async getCurrentUserCodySubscription(): Promise<CurrentUserCodySubscription | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserCodySubscriptionResponse>>(\n            CURRENT_USER_CODY_SUBSCRIPTION_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser?.codySubscription\n                    ? data.currentUser.codySubscription\n                    : new Error('current user subscription data not found')\n            )\n        )\n    }\n\n    public async getCurrentUserInfo(): Promise<CurrentUserInfo | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<CurrentUserInfoResponse>>(\n            CURRENT_USER_INFO_QUERY,\n            {}\n        ).then(response =>\n            extractDataOrError(response, data =>\n                data.currentUser ? { ...data.currentUser } : new Error('current user not found')\n            )\n        )\n    }\n\n    /**\n     * Fetches the Site Admin enabled/disable Cody config features for the current instance.\n     */\n    public async getCodyConfigFeatures(): Promise<CodyConfigFeatures | Error> {\n        const response = await this.fetchSourcegraphAPI<APIResponse<CodyConfigFeaturesResponse>>(\n            CURRENT_SITE_CODY_CONFIG_FEATURES,\n            {}\n        )\n        return extractDataOrError(\n            response,\n            data => data.site?.codyConfigFeatures ?? new Error('cody config not found')\n        )\n    }\n\n    public async getCodyLLMConfiguration(): Promise<undefined | CodyLLMSiteConfiguration | Error> {\n        // fetch Cody LLM provider separately for backward compatability\n        const [configResponse, providerResponse] = await Promise.all([\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationResponse>>(\n                CURRENT_SITE_CODY_LLM_CONFIGURATION\n            ),\n            this.fetchSourcegraphAPI<APIResponse<CodyLLMSiteConfigurationProviderResponse>>(\n                CURRENT_SITE_CODY_LLM_PROVIDER\n            ),\n        ])\n\n        const config = extractDataOrError(\n            configResponse,\n            data => data.site?.codyLLMConfiguration || undefined\n        )\n        if (!config || isError(config)) {\n            return config\n        }\n\n        let provider: string | undefined\n        const llmProvider = extractDataOrError(\n            providerResponse,\n            data => data.site?.codyLLMConfiguration?.provider\n        )\n        if (llmProvider && !isError(llmProvider)) {\n            provider = llmProvider\n        }\n\n        return { ...config, provider }\n    }\n\n    /**\n     * Gets a subset of the list of repositories from the Sourcegraph instance.\n     * @param first the number of repositories to retrieve.\n     * @param after the last repository retrieved, if any, to continue enumerating the list.\n     * @returns the list of repositories. If `endCursor` is null, this is the end of the list.\n     */\n    public async getRepoList(first: number, after?: string): Promise<RepoListResponse | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepoListResponse>>(REPOSITORY_LIST_QUERY, {\n            first,\n            after: after || null,\n        }).then(response => extractDataOrError(response, data => data))\n    }\n\n    public async getRepoId(repoName: string): Promise<string | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdResponse>>(REPOSITORY_ID_QUERY, {\n            name: repoName,\n        }).then(response =>\n            extractDataOrError(response, data => (data.repository ? data.repository.id : null))\n        )\n    }\n\n    public async getRepoIds(\n        names: string[],\n        first: number\n    ): Promise<{ name: string; id: string }[] | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<RepositoryIdsResponse>>(REPOSITORY_IDS_QUERY, {\n            names,\n            first,\n        }).then(response => extractDataOrError(response, data => data.repositories?.nodes || []))\n    }\n\n    public async contextSearch(\n        repos: Set<string>,\n        query: string\n    ): Promise<ContextSearchResult[] | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<ContextSearchResponse>>(CONTEXT_SEARCH_QUERY, {\n            repos: [...repos],\n            query,\n            codeResultsCount: 15,\n            textResultsCount: 5,\n        }).then(response =>\n            extractDataOrError(response, data =>\n                (data.getCodyContext || []).map(item => ({\n                    commit: item.blob.commit.oid,\n                    repoName: item.blob.repository.name,\n                    path: item.blob.path,\n                    uri: URI.parse(\n                        `${item.blob.url.startsWith('/') ? this.endpoint : ''}${item.blob.url}?L${\n                            item.startLine + 1\n                        }-${item.endLine}`\n                    ),\n                    startLine: item.startLine,\n                    endLine: item.endLine,\n                    content: item.chunkContent,\n                }))\n            )\n        )\n    }\n\n    public async contextFilters(): Promise<ContextFiltersResult | null | Error> {\n        const response =\n            await this.fetchSourcegraphAPI<APIResponse<ContextFiltersResult | null>>(\n                CONTEXT_FILTERS_QUERY\n            )\n\n        const result = extractDataOrError(response, data => data)\n\n        if (result instanceof Error) {\n            // Ignore errors caused by outdated Sourcegraph API instances.\n            if (hasOutdatedAPIErrorMessages(result)) {\n                return INCLUDE_EVERYTHING_CONTEXT_FILTERS\n            }\n\n            // Exclude everything in case of an unexpected error.\n            return EXCLUDE_EVERYTHING_CONTEXT_FILTERS\n        }\n\n        return result\n    }\n\n    /**\n     * Checks if Cody is enabled on the current Sourcegraph instance.\n     * @returns\n     * enabled: Whether Cody is enabled.\n     * version: The Sourcegraph version.\n     *\n     * This method first checks the Sourcegraph version using `getSiteVersion()`.\n     * If the version is before 5.0.0, Cody is disabled.\n     * If the version is 5.0.0 or newer, it checks for the existence of the `isCodyEnabled` field using `getSiteHasIsCodyEnabledField()`.\n     * If the field exists, it calls `getSiteHasCodyEnabled()` to check its value.\n     * If the field does not exist, Cody is assumed to be enabled for versions between 5.0.0 - 5.1.0.\n     */\n    public async isCodyEnabled(): Promise<{ enabled: boolean; version: string }> {\n        // Check site version.\n        const siteVersion = await this.getSiteVersion()\n        if (isError(siteVersion)) {\n            return { enabled: false, version: 'unknown' }\n        }\n        const insiderBuild = siteVersion.length > 12 || siteVersion.includes('dev')\n        if (insiderBuild) {\n            return { enabled: true, version: siteVersion }\n        }\n        // NOTE: Cody does not work on versions older than 5.0\n        const versionBeforeCody = siteVersion < '5.0.0'\n        if (versionBeforeCody) {\n            return { enabled: false, version: siteVersion }\n        }\n        // Beta version is betwewen 5.0.0 - 5.1.0 and does not have isCodyEnabled field\n        const betaVersion = siteVersion >= '5.0.0' && siteVersion < '5.1.0'\n        const hasIsCodyEnabledField = await this.getSiteHasIsCodyEnabledField()\n        // The isCodyEnabled field does not exist before version 5.1.0\n        if (!betaVersion && !isError(hasIsCodyEnabledField) && hasIsCodyEnabledField) {\n            const siteHasCodyEnabled = await this.getSiteHasCodyEnabled()\n            return { enabled: !isError(siteHasCodyEnabled) && siteHasCodyEnabled, version: siteVersion }\n        }\n        return { enabled: insiderBuild || betaVersion, version: siteVersion }\n    }\n\n    /**\n     * recordTelemetryEvents uses the new Telemetry API to record events that\n     * gets exported: https://sourcegraph.com/docs/dev/background-information/telemetry\n     *\n     * Only available on Sourcegraph 5.2.0 and later.\n     *\n     * DO NOT USE THIS DIRECTLY - use an implementation of implementation\n     * TelemetryRecorder from '@sourcegraph/telemetry' instead.\n     */\n    public async recordTelemetryEvents(events: TelemetryEventInput[]): Promise<unknown | Error> {\n        for (const event of events) {\n            this.anonymizeTelemetryEventInput(event)\n        }\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<unknown>>(\n            RECORD_TELEMETRY_EVENTS_MUTATION,\n            {\n                events,\n            }\n        )\n        return extractDataOrError(initialResponse, data => data)\n    }\n\n    /**\n     * logEvent is the legacy event-logging mechanism.\n     * @deprecated use an implementation of implementation TelemetryRecorder\n     * from '@sourcegraph/telemetry' instead.\n     */\n    public async logEvent(event: event, mode: LogEventMode): Promise<LogEventResponse | Error> {\n        if (process.env.CODY_TESTING === 'true') {\n            return this.sendEventLogRequestToTestingAPI(event)\n        }\n        if (this.config?.telemetryLevel === 'off') {\n            return {}\n        }\n        /**\n         * If connected to dotcom, just log events to the instance, as it means\n         * the same thing.\n         */\n        if (this.isDotCom()) {\n            return this.sendEventLogRequestToAPI(event)\n        }\n\n        switch (process.env.CODY_LOG_EVENT_MODE) {\n            case 'connected-instance-only':\n                mode = 'connected-instance-only'\n                break\n            case 'dotcom-only':\n                mode = 'dotcom-only'\n                break\n            case 'all':\n                mode = 'all'\n                break\n            default:\n                if (process.env.CODY_LOG_EVENT_MODE) {\n                    logDebug(\n                        'SourcegraphGraphQLAPIClient.logEvent',\n                        'unknown mode',\n                        process.env.CODY_LOG_EVENT_MODE\n                    )\n                }\n        }\n\n        switch (mode) {\n            /**\n             * Only log events to dotcom, not the connected instance. Used when\n             * another mechanism delivers event logs the instance (i.e. the\n             * new telemetry clients)\n             */\n            case 'dotcom-only':\n                return this.sendEventLogRequestToDotComAPI(event)\n\n            /**\n             * Only log events to the connected instance, not dotcom. Used when\n             * another mechanism handles reporting to dotcom (i.e. the old\n             * client and/or the new telemetry framework, which exports events\n             * from all instances: https://sourcegraph.com/docs/dev/background-information/telemetry)\n             */\n            case 'connected-instance-only':\n                return this.sendEventLogRequestToAPI(event)\n\n            case 'all': // continue to default handling\n        }\n\n        /**\n         * Otherwise, send events to the connected instance AND to dotcom (default)\n         */\n        const responses = await Promise.all([\n            this.sendEventLogRequestToAPI(event),\n            this.sendEventLogRequestToDotComAPI(event),\n        ])\n        if (isError(responses[0]) && isError(responses[1])) {\n            return new Error(\n                `Errors logging events: ${responses[0].toString()}, ${responses[1].toString()}`\n            )\n        }\n        if (isError(responses[0])) {\n            return responses[0]\n        }\n        if (isError(responses[1])) {\n            return responses[1]\n        }\n        return {}\n    }\n\n    private anonymizeTelemetryEventInput(event: TelemetryEventInput): void {\n        if (isAgentTesting) {\n            event.timestamp = undefined\n            event.parameters.interactionID = undefined\n            event.parameters.billingMetadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.metadata = undefined\n            event.parameters.privateMetadata = {}\n        }\n    }\n\n    private anonymizeEvent(event: event): void {\n        if (isAgentTesting) {\n            event.publicArgument = undefined\n            event.argument = undefined\n            event.userCookieID = 'ANONYMOUS_USER_COOKIE_ID'\n            event.hashedLicenseKey = undefined\n        }\n    }\n\n    private async sendEventLogRequestToDotComAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const response = await this.fetchSourcegraphDotcomAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        return extractDataOrError(response, data => data)\n    }\n\n    private async sendEventLogRequestToAPI(event: event): Promise<LogEventResponse | Error> {\n        this.anonymizeEvent(event)\n        const initialResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n            LOG_EVENT_MUTATION,\n            event\n        )\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse = await this.fetchSourcegraphAPI<APIResponse<LogEventResponse>>(\n                LOG_EVENT_MUTATION_DEPRECATED,\n                event\n            )\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    private async sendEventLogRequestToTestingAPI(event: event): Promise<LogEventResponse | Error> {\n        const initialResponse =\n            await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n        const initialDataOrError = extractDataOrError(initialResponse, data => data)\n\n        if (isError(initialDataOrError)) {\n            const secondResponse =\n                await this.fetchSourcegraphTestingAPI<APIResponse<LogEventResponse>>(event)\n            return extractDataOrError(secondResponse, data => data)\n        }\n\n        return initialDataOrError\n    }\n\n    public async searchAttribution(snippet: string): Promise<SearchAttributionResults | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<SearchAttributionResponse>>(\n            SEARCH_ATTRIBUTION_QUERY,\n            {\n                snippet,\n            }\n        ).then(response => extractDataOrError(response, data => data.snippetAttribution))\n    }\n\n    public async getEvaluatedFeatureFlags(): Promise<Record<string, boolean> | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluatedFeatureFlagsResponse>>(\n            GET_FEATURE_FLAGS_QUERY,\n            {}\n        ).then(response => {\n            return extractDataOrError(response, data =>\n                data.evaluatedFeatureFlags.reduce((acc: Record<string, boolean>, { name, value }) => {\n                    acc[name] = value\n                    return acc\n                }, {})\n            )\n        })\n    }\n\n    public async evaluateFeatureFlag(flagName: string): Promise<boolean | null | Error> {\n        return this.fetchSourcegraphAPI<APIResponse<EvaluateFeatureFlagResponse>>(\n            EVALUATE_FEATURE_FLAG_QUERY,\n            {\n                flagName,\n            }\n        ).then(response => extractDataOrError(response, data => data.evaluateFeatureFlag))\n    }\n\n    private fetchSourcegraphAPI<T>(\n        query: string,\n        variables: Record<string, any> = {}\n    ): Promise<T | Error> {\n        const headers = new Headers(this.config.customHeaders as HeadersInit)\n        headers.set('Content-Type', 'application/json; charset=utf-8')\n        if (this.config.accessToken) {\n            headers.set('Authorization', `token ${this.config.accessToken}`)\n        }\n        if (this.anonymousUserID) {\n            headers.set('X-Sourcegraph-Actor-Anonymous-UID', this.anonymousUserID)\n        }\n\n        addTraceparent(headers)\n        addCustomUserAgent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.config.serverEndpoint })\n        return wrapInActiveSpan(`graphql.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => {\n                    return new Error(`accessing Sourcegraph GraphQL API: ${error} (${url})`)\n                })\n        )\n    }\n\n    // make an anonymous request to the dotcom API\n    private fetchSourcegraphDotcomAPI<T>(\n        query: string,\n        variables: Record<string, any>\n    ): Promise<T | Error> {\n        const url = buildGraphQLUrl({ request: query, baseUrl: this.dotcomUrl.href })\n        const headers = new Headers()\n        addCustomUserAgent(headers)\n        addTraceparent(headers)\n\n        const queryName = query.match(QUERY_TO_NAME_REGEXP)?.[1]\n\n        return wrapInActiveSpan(`graphql.dotcom.fetch${queryName ? `.${queryName}` : ''}`, () =>\n            fetch(url, {\n                method: 'POST',\n                body: JSON.stringify({ query, variables }),\n                headers,\n            })\n                .then(verifyResponseCode)\n                .then(response => response.json() as T)\n                .catch(error => new Error(`error fetching Sourcegraph GraphQL API: ${error} (${url})`))\n        )\n    }\n\n    // make an anonymous request to the Testing API\n    private fetchSourcegraphTestingAPI<T>(body: Record<string, any>): Promise<T | Error> {\n        const url = 'http://localhost:49300/.test/testLogging'\n        const headers = new Headers({\n            'Content-Type': 'application/json',\n        })\n        addCustomUserAgent(headers)\n\n        return fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(body),\n        })\n            .then(verifyResponseCode)\n            .then(response => response.json() as T)\n            .catch(error => new Error(`error fetching Testing Sourcegraph API: ${error} (${url})`))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/client.ts:91-141"",""content"":""    public stream(\n        params: CompletionParameters,\n        apiVersion: number,\n        signal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        // Provide default stop sequence for starchat models.\n        if (!params.stopSequences && params?.model?.startsWith('openaicompatible/starchat')) {\n            params.stopSequences = ['<|end|>']\n        }\n\n        // This is a technique to convert a function that takes callbacks to an async generator.\n        const values: Promise<CompletionGeneratorValue>[] = []\n        let resolve: ((value: CompletionGeneratorValue) => void) | undefined\n        values.push(\n            new Promise(r => {\n                resolve = r\n            })\n        )\n\n        const send = (value: CompletionGeneratorValue): void => {\n            resolve!(value)\n            values.push(\n                new Promise(r => {\n                    resolve = r\n                })\n            )\n        }\n        const callbacks: CompletionCallbacks = {\n            onChange(text) {\n                send({ type: 'change', text })\n            },\n            onComplete() {\n                send({ type: 'complete' })\n            },\n            onError(error, statusCode) {\n                send({ type: 'error', error, statusCode })\n            },\n        }\n        this._streamWithCallbacks(params, apiVersion, callbacks, signal)\n\n        return (async function* () {\n            for (let i = 0; ; i++) {\n                const val = await values[i]\n                delete values[i]\n                yield val\n                if (val.type === 'complete' || val.type === 'error') {\n                    break\n                }\n            }\n        })()\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/nodeClient.ts:209-234"",""content"":""                        'Could not connect to Cody. Please ensure that you are connected to the Sourcegraph server.'\n                    )\n                }\n                log?.onError(error.message, e)\n                onErrorOnce(error)\n            })\n\n            // If the connection is closed and we did neither:\n            //\n            // - Receive an error HTTP code\n            // - Or any request body\n            //\n            // We still want to close the request.\n            request.on('close', () => {\n                if (!didReceiveAnyEvent) {\n                    logError(\n                        'SourcegraphNodeCompletionsClient',\n                        \""request.on('close')\"",\n                        'Connection closed without receiving any events',\n                        { verbose: { bufferText } }\n                    )\n                    onErrorOnce(new Error('Connection closed without receiving any events'))\n                }\n                if (!didSendMessage) {\n                    onErrorOnce(new Error('Connection unexpectedly closed'))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:954-956"",""content"":""function hasOutdatedAPIErrorMessages(error: Error): boolean {\n    return error.message.includes('Cannot query field')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:780-795"",""content"":""\n### Changed\n\n- Move decision about which autocomplete deployment to use for StarCoder to the server. [pull/1845](https://github.com/sourcegraph/cody/pull/1845)\n\n## [0.16.0]\n\n### Added\n\n- Chat: A new chat model selection dropdown that allows selecting between different chat models when connected to the sourcegraph.com instance. [pull/1676](https://github.com/sourcegraph/cody/pull/1676)\n- Chat: New button in editor title for restarting chat session in current chat panel (non-sidebar chat view). [pull/1687](https://github.com/sourcegraph/cody/pull/1687)\n- Chat: New `@` command that allows you to attach files via the chat input box. [pull/1631](https://github.com/sourcegraph/cody/pull/1631)\n- Edit: Added a specific, faster, response flow for fixes when triggered directly from code actions. [pull/1639](https://github.com/sourcegraph/cody/pull/1639)\n- Edit: Improved context fetching for quick fixes to better include code related to the problem. [pull/1723](https://github.com/sourcegraph/cody/pull/1723)\n- Chat: Added option to configure whether to add enhanced context from codebase for chat question in the new chat panel. [pull/1738](https://github.com/sourcegraph/cody/pull/1738)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/graphql/client.ts:46-49"",""content"":""interface APIResponse<T> {\n    data?: T\n    errors?: { message: string; path?: string[] }[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/utils/VSCodeApi.ts:21-21"",""content"":""let api: VSCodeWrapper\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/editor/displayPath.ts:21-44"",""content"":"" *   Sourcegraph instance).\n * @param location The absolute URI to convert to a display path.\n */\nexport function displayPath(location: URI): string {\n    const result = _displayPath(location, checkEnvInfo())\n    return typeof result === 'string' ? result : result.toString()\n}\n\n/**\n * Dirname of the location's display path, to display to the user. Similar to\n * `dirname(displayPath(location))`, but it uses the right path separators in `dirname` ('\\' for\n * file URIs on Windows, '/' otherwise).\n *\n * The returned path string MUST ONLY be used for display purposes. It MUST NOT be used to identify\n * or locate files.\n *\n * Use this instead of other seemingly simpler techniques to avoid a few subtle\n * bugs/inconsistencies:\n *\n * - On Windows, Node's `dirname(uri.fsPath)` breaks on a non-`file` URI on Windows because\n *   `dirname` would use '\\' path separators but the URI would have '/' path separators.\n * - In a single-root workspace, Node's `dirname(uri.fsPath)` would return the root directory name,\n *   which is usually superfluous for display purposes. For example, if VS Code is open to a\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:694-705"",""content"":""  sign in to Sourcegraph.com directly. The extension will do this automatically if\n  possible but you may need to sign in again. If you have set up embeddings in\n  Cody App, VScode will now search your local embeddings automatically: You no\n  longer need to have the Cody App open. Note, the sidebar chat indicator may\n  say embeddings were not found while we work on improving chat.\n  [pull/2099](https://github.com/sourcegraph/cody/pull/2099)\n- Commands: Expose commands in the VS Code command palette and clean up the context menu. [pull/1209](https://github.com/sourcegraph/cody/pull/2109)\n- Search: Style and UX improvements to the search panel. [pull/2138](https://github.com/sourcegraph/cody/pull/2138)\n- Chat: Reduce size of chats list blank copy. [pull/2137](https://github.com/sourcegraph/cody/pull/2137)\n- Chat: Update message input placeholder to mention slash commands. [pull/2142](https://github.com/sourcegraph/cody/pull/2142)\n- Inline Chat will soon be deprecated in favor of the improved chat and command experience. It is now disabled by default and does not work when the new chat panel is enabled. [pull/1797](https://github.com/sourcegraph/cody/pull/1797)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:167-203"",""content"":""export type { CompletionLogger, CompletionsClientConfig } from './sourcegraph-api/completions/client'\nexport type {\n    CompletionParameters,\n    CompletionResponse,\n    Event,\n} from './sourcegraph-api/completions/types'\nexport { DOTCOM_URL, LOCAL_APP_URL, isDotCom } from './sourcegraph-api/environments'\nexport {\n    AbortError,\n    NetworkError,\n    RateLimitError,\n    TimeoutError,\n    TracedError,\n    isAbortError,\n    isAuthError,\n    isNetworkError,\n    isRateLimitError,\n} from './sourcegraph-api/errors'\nexport { SourcegraphGraphQLAPIClient, graphqlClient } from './sourcegraph-api/graphql'\nexport {\n    ConfigFeaturesSingleton,\n    addCustomUserAgent,\n    customUserAgent,\n    isNodeResponse,\n    setUserAgent,\n    type BrowserOrNodeResponse,\n    type GraphQLAPIClientConfig,\n    type LogEventMode,\n    type ContextFiltersResult,\n    type CodyContextFilterItem,\n    type RepoListResponse,\n} from './sourcegraph-api/graphql/client'\nexport type {\n    CodyLLMSiteConfiguration,\n    ContextSearchResult,\n    EmbeddingsSearchResult,\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/protocol.ts:273-292"",""content"":""    )\n}\n\nexport type AuthMethod = 'dotcom' | 'github' | 'gitlab' | 'google'\n\n// Provide backward compatibility for the old token regex\n// Details: https://docs.sourcegraph.com/dev/security/secret_formats\nconst sourcegraphTokenRegex =\n    /(sgp_(?:[a-fA-F0-9]{16}|local)|sgp_)?[a-fA-F0-9]{40}|(sgd|slk|sgs)_[a-fA-F0-9]{64}/\n\n/**\n * Checks if the given text matches the regex for a Sourcegraph access token.\n *\n * @param text - The text to check against the regex.\n * @returns Whether the text matches the Sourcegraph token regex.\n */\nexport function isSourcegraphToken(text: string): boolean {\n    return sourcegraphTokenRegex.test(text)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_014/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_015/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_016/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on the provided code context, the check for content attribution happens in the `ChatMessageContent.tsx` file. 

Here's a breakdown:

1. **`ChatMessageContent` component:** This component renders the content of a chat message in the Cody chat view.
2. **`useEffect` hook:** Inside this component, an `useEffect` hook is used to add functionality after the component renders.
3. **`guardrails.searchAttribution(preText)`:** This line within the `useEffect` hook is where the actual attribution search happens. It calls the `searchAttribution` method on the `guardrails` object, passing the content of a code block (`preText`) as input.
4. **`GuardrailsStatusController`:** This class (defined in a separate file, likely `GuardrailsStatusController.tsx`) is responsible for displaying the status of the attribution search (pending, success, failure, unavailable) in the UI.

Therefore, the `ChatMessageContent.tsx` file, specifically the `useEffect` hook within it, is where the content attribution check is initiated and its status is managed.",Where do we check for content attribution?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:203-214"",""content"":""function checkValidEnumValues(configName: string, value: string | null): void {\n    const validEnumValues = getConfigEnumValues(`cody.${configName}`)\n    if (value) {\n        if (!validEnumValues.includes(value)) {\n            void vscode.window.showErrorMessage(\n                `Invalid value for ${configName}: ${value}. Valid values are: ${validEnumValues.join(\n                    ', '\n                )}`\n            )\n        }\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:4054-4078"",""content"":""            2n1Tofe+i1bW2ZHXhNA1apTk30hqndqL17plySGZAuO/ijE6yxkED6hm8fHpRnN1d85\\\n            U0Fl9xzhFnlzIk0U01WnbfsaZ+ggLtCTg1vgaeba2Ftnty9VlgYeyasRZaHWuzPYroh\\\n            NXPcXi8sDBeqyj0c78bJM/rORz+8//94VUrS/3Bbt2rP/37lbbFnzsfnL9W/NdPr5X9\\\n            tFdP7f/+sPu03/xf/4gb8+F/fWjeVZt//mr++ue//PO3fz6//tfP/b8VbfFj9fo38+5\\\n            p8/jtXv74f17kj/XT5s1fDn99fFcXPz63/7K7WPz4Xdw0/3hb/Ni+/PX/+Uv9rx/r47\\\n            /++enbv/7zH2/Vj388Fj/+4/j5/Q/vfvrlw9sP5mD+Pv1e/vOP3YcnZz7Yb//n1X/+8\\\n            5///P8BAAD//0QFQV3tCQIA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:32:13 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: retry-after\n            value: \""282\""\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/attribution.test.ts:12-33"",""content"":""const test = baseTest\n    .extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n    .extend<ExpectedEvents>({\n        // list of events we expect this test to log, add to this list as needed\n        expectedEvents: [\n            'CodyInstalled',\n            'CodyVSCodeExtension:auth:clickOtherSignInOptions',\n            'CodyVSCodeExtension:login:clicked',\n            'CodyVSCodeExtension:auth:selectSigninMenu',\n            'CodyVSCodeExtension:auth:fromToken',\n            'CodyVSCodeExtension:Auth:connected',\n            'CodyVSCodeExtension:chat-question:submitted',\n            'CodyVSCodeExtension:chat-question:executed',\n            'CodyVSCodeExtension:chatResponse:hasCode',\n        ],\n    })\n    .extend<ExtraWorkspaceSettings>({\n        extraWorkspaceSettings: {\n            // TODO(#59720): Remove experimental setting.\n            'cody.experimental.guardrails': true,\n        },\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:105-138"",""content"":""      _order: 0\n      cache: {}\n      request:\n        bodySize: 10486\n        cookies: []\n        headers:\n          - name: content-type\n            value: application/json\n          - name: accept-encoding\n            value: gzip;q=0\n          - name: authorization\n            value: token\n              REDACTED_b20717265e7ab1d132874d8ff0be053ab9c1dacccec8dce0bbba76888b6a0a69\n          - name: user-agent\n            value: enterpriseClient / v1\n          - name: host\n            value: demo.sourcegraph.com\n        headersSize: 265\n        httpVersion: HTTP/1.1\n        method: POST\n        postData:\n          mimeType: application/json\n          params: []\n          textJSON:\n            maxTokensToSample: 1000\n            messages:\n              - speaker: human\n                text: You are Cody, an AI coding assistant from Sourcegraph.\n              - speaker: assistant\n                text: I am Cody, an AI coding assistant from Sourcegraph.\n              - speaker: human\n                text: >-\n                  Codebase context from file /agent/README.md in repository\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:7357-7384"",""content"":""            TV68pkB+nxayTnfUxFI4Sug+6FETlcN5vseCqWw5dIsYKxBKg01OJm6s+D7T1NbQBqQ\\\n            BtYz94lGT6PUejuxbG/2wJv7Mk6JUl+MJxEct3461Pyk7GO6O4yONy+fXDayr6VVyAL\\\n            CfoVP1ChiONKzIspRcrOLM251/n8/kPAAAA//8DANaF7gAtBAAA\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:31 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:21-30"",""content"":""interface ChatMessageContentProps {\n    displayMarkdown: string\n    wrapLinksWithCodyCommand: boolean\n\n    copyButtonOnSubmit?: CodeBlockActionsProps['copyButtonOnSubmit']\n    insertButtonOnSubmit?: CodeBlockActionsProps['insertButtonOnSubmit']\n\n    guardrails?: Guardrails\n    className?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:5321-5347"",""content"":""            z//9zYtWVuqDWdsXf/j3C2XKP3bOW3ct3o+fXhfm0654aP/rw/bTbvXnn8JKf/jth+a\\\n            7zeofP+q//vEv//j5H0+v//VD/1vZln/avP5Zf/ewevNqV7z9/3bln+pG/fD79l//+K\\\n            n+6z8/Pa5+eP1m9ebTZvXnj6H880+vVm//0v78j6fvPz5Xrz69+9jzey//+Zf657d/b\\\n            1dvvtWf9Qe97pfMf/7zn//8vwAAAP//7inTaSEHAgA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Mon, 15 Apr 2024 06:38:54 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: content-encoding\n            value: gzip\n          - name: vary\n            value: Accept-Encoding, Authorization, Cookie, Authorization, X-Requested-With,\n              Cookie\n          - name: x-content-type-options\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/workflows/pr-auditor.yml:0-23"",""content"":""# See https://sourcegraph.com/docs/dev/background-information/ci#pr-auditor\nname: pr-auditor\non:\n  pull_request_target:\n    types: [ closed, edited, opened, synchronize, ready_for_review ]\n  workflow_dispatch:\n\njobs:\n  check-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: 'sourcegraph/pr-auditor'\n      - uses: actions/setup-go@v4\n        with: { go-version: '1.21' }\n\n      - run: './check-pr.sh'\n        env:\n          GITHUB_EVENT_PATH: ${{ env.GITHUB_EVENT_PATH }}\n          GITHUB_TOKEN: ${{ secrets.PR_AUDITOR_TOKEN }}\n          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseMainBranchClient_759014996/recording.har.yaml:1776-1804"",""content"":""            value: null\n        url: https://sourcegraph.sourcegraph.com/.api/graphql?SnippetAttribution\n      response:\n        bodySize: 231\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 231\n          text: \""[\\\""H4sIAAAAAAAAA4SNMQrDMAxF76I5aXZv3Tr1AqWD4whHEEvGkqEl+O4lU10IdPt83uPts\\\n            Hjz4HZQppzRrmaF5mokfLwbJbIbGTgrFQdgWVDBPXYomEXJpLzv\\\"",\\\""PiE4iGRrnS9\\\n            B0qRSS8BYfF77DW048Tj/CrNXCmOQBUdiw+3c6mvRUG1KGP2B/ee72Dcz4suQlYQV2r\\\n            O19gEAAP//AwAoEJKNGwEAAA==\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Sat, 27 Jan 2024 14:35:00 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:3616-3645"",""content"":""                - github.com/sourcegraph/sourcegraph\n        queryString:\n          - name: Repositories\n            value: null\n        url: https://demo.sourcegraph.com/.api/graphql?Repositories\n      response:\n        bodySize: 171\n        content:\n          encoding: base64\n          mimeType: application/json\n          size: 171\n          text: \""[\\\""H4sIAAAAAAAAA6pWSkksSVSyqlYqSi3IL84syS/KTC0G8fPyU0CM6GqlvMTcVCUrpfTMk\\\n            ozSJL3k/Fz94vzSouTU9KLEggxktpKOUmaKkpVSaG5YeZKx\\\"",\\\""X0GKu2Vlakh+lW+\\\n            Io61SbWxtbS0AAAD//wMAsuY8XG8AAAA=\\\""]\""\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 06 Mar 2024 08:51:38 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: close\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:138-147"",""content"":""                  github.com/sourcegraph/cody:\n\n                  ```markdown\n\n                  | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n\n                  | `pnpm test agent/src/index.test.ts`                                                                                  | Run agent tests in replay mode                                                                                                                                |\n\n                  | `source agent/scripts/export-cody-http-recording-tokens.sh`                                                          | Export access tokens to enable recording mode                                                                                                                 |\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/rateLimitedClient_2043004676/recording.har.yaml:1047-1076"",""content"":""                siteID: SourcegraphWeb\n        cookies: []\n        headers:\n          - name: date\n            value: Wed, 17 Apr 2024 09:12:26 GMT\n          - name: content-type\n            value: application/json\n          - name: transfer-encoding\n            value: chunked\n          - name: connection\n            value: keep-alive\n          - name: access-control-allow-credentials\n            value: \""true\""\n          - name: access-control-allow-origin\n            value: \""\""\n          - name: cache-control\n            value: no-cache, max-age=0\n          - name: vary\n            value: Cookie,Accept-Encoding,Authorization,Cookie, Authorization,\n              X-Requested-With,Cookie\n          - name: x-content-type-options\n            value: nosniff\n          - name: x-frame-options\n            value: DENY\n          - name: x-xss-protection\n            value: 1; mode=block\n          - name: strict-transport-security\n            value: max-age=31536000; includeSubDomains; preload\n          - name: content-encoding\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupContentStore.ts:9-75"",""content"":""export class ContentProvider implements vscode.TextDocumentContentProvider, vscode.Disposable {\n    // This stores the content of the document for each task ID\n    // The content is initialized by the fixup task with the original content\n    // and then updated by the fixup task with the replacement content\n    private contentStore = new Map<FixupTaskID, fileContent>()\n    // This tracks the task IDs belong toe each file path\n    private tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    private _onDidChange = new vscode.EventEmitter<vscode.Uri>()\n    private _disposables: vscode.Disposable\n\n    constructor() {\n        // TODO: Handle applying fixups to files which are opened and closed.\n        // This is tricky because we need to re-sync the range we are tracking\n        // when the file is opened.\n        this._disposables = vscode.workspace.onDidCloseTextDocument(doc =>\n            this.deleteByFilePath(doc.uri.fsPath)\n        )\n    }\n    // Get content from the content store\n    public provideTextDocumentContent(uri: vscode.Uri): string | null {\n        const id = uri.fragment\n        return this.contentStore.get(id) || null\n    }\n    // Add to store - store origin content by fixup task id\n    public async set(id: string, docUri: vscode.Uri): Promise<void> {\n        const doc = await vscode.workspace.openTextDocument(docUri)\n        this.contentStore.set(id, doc.getText())\n        this.tasksByFilePath.set(docUri.fsPath, [...(this.tasksByFilePath.get(docUri.fsPath) || []), id])\n    }\n\n    // Remove by ID\n    public delete(id: string): void {\n        this.contentStore.delete(id)\n        // remove task from tasksByFilePath\n        for (const [filePath, tasks] of this.tasksByFilePath) {\n            const index = tasks.indexOf(id)\n            if (index > -1) {\n                tasks.splice(index, 1)\n            }\n            if (tasks.length === 0) {\n                this.deleteByFilePath(filePath)\n            }\n        }\n    }\n\n    // Remove by file path\n    private deleteByFilePath(fileName: string): void {\n        const files = this.tasksByFilePath.get(fileName)\n        if (!files) {\n            return\n        }\n        for (const id of files) {\n            this.contentStore.delete(id)\n        }\n    }\n\n    public get onDidChange(): vscode.Event<vscode.Uri> {\n        return this._onDidChange.event\n    }\n\n    public dispose(): void {\n        this._disposables.dispose()\n        this._onDidChange.dispose()\n        this.contentStore = new Map<FixupTaskID, fileContent>()\n        this.tasksByFilePath = new Map<fileName, FixupTaskID[]>()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:156-175"",""content"":""\n    // Updates the extension configuration and returns the new\n    // authentication status, which indicates whether the provided credentials are\n    // valid or not. The agent can't support autocomplete or chat if the credentials\n    // are invalid.\n    'extensionConfiguration/change': [ExtensionConfiguration, AuthStatus | null]\n\n    // Returns the current authentication status without making changes to it.\n    'extensionConfiguration/status': [null, AuthStatus | null]\n\n    // Run attribution search for a code snippet displayed in chat.\n    // Attribution is an enterprise feature which allows to look for code generated\n    // by Cody in an open source code corpus. User is notified if any such attribution\n    // is found.\n    // For more details, please see:\n    // *   PRD: https://docs.google.com/document/d/1c3CLC7ICDaG63NOWjO6zWm-UElwuXkFrKbCKTw-7H6Q/edit\n    // *   RFC: https://docs.google.com/document/d/1zSxFDQPxZcn5b6yKx40etpJayoibVzj_Gnugzln1weI/edit\n    'attribution/search': [\n        { id: string; snippet: string },\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.tsx:235-309"",""content"":""export const ChatMessageContent: React.FunctionComponent<ChatMessageContentProps> = ({\n    displayMarkdown,\n    wrapLinksWithCodyCommand,\n    copyButtonOnSubmit,\n    insertButtonOnSubmit,\n    guardrails,\n    className,\n}) => {\n    const rootRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        const preElements = rootRef.current?.querySelectorAll('pre')\n        if (!preElements?.length || !copyButtonOnSubmit) {\n            return\n        }\n\n        for (const preElement of preElements) {\n            const preText = preElement.textContent\n            if (preText?.trim() && preElement.parentNode) {\n                const buttons = createButtons(preText, copyButtonOnSubmit, insertButtonOnSubmit)\n                if (guardrails) {\n                    const container = document.createElement('div')\n                    container.classList.add(styles.attributionContainer)\n                    buttons.append(container)\n\n                    const g = new GuardrailsStatusController(container)\n                    g.setPending()\n\n                    guardrails\n                        .searchAttribution(preText)\n                        .then(attribution => {\n                            if (isError(attribution)) {\n                                g.setUnavailable(attribution)\n                            } else if (attribution.repositories.length === 0) {\n                                g.setSuccess()\n                            } else {\n                                g.setFailure(\n                                    attribution.repositories.map(r => r.name),\n                                    attribution.limitHit\n                                )\n                            }\n                        })\n                        .catch(error => {\n                            g.setUnavailable(error)\n                            return\n                        })\n                }\n\n                // Insert the buttons after the pre using insertBefore() because there is no insertAfter()\n                preElement.parentNode.insertBefore(buttons, preElement.nextSibling)\n\n                // capture copy events (right click or keydown) on code block\n                preElement.addEventListener('copy', () => {\n                    if (copyButtonOnSubmit) {\n                        copyButtonOnSubmit(preText, 'Keydown')\n                    }\n                })\n            }\n        }\n    }, [copyButtonOnSubmit, insertButtonOnSubmit, guardrails])\n\n    return (\n        <div\n            ref={rootRef}\n            className={classNames(styles.content, className)}\n            // biome-ignore lint/security/noDangerouslySetInnerHtml: the result is run through dompurify\n            dangerouslySetInnerHTML={{\n                // wrapLinksWithCodyCommand opens all links in assistant responses using the\n                // _cody.vscode.open command (but not human messages because those already\n                // have the right URIs and are trusted).\n                __html: renderCodyMarkdown(displayMarkdown, { wrapLinksWithCodyCommand }),\n            }}\n        />\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/index.md:0-8"",""content"":""# Cody documentation\n\n> **Note**\n> We're in the process of moving Cody documentation from the [`sourcegraph/sourcegraph` repository `doc/cody` directory](https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/tree/doc/cody) to this repository.\n\n- [Development](development/index.md)\n- [All other Cody documentation](https://sourcegraph.com/docs/cody)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/README.md:0-4"",""content"":""# Cody shared library\n\nThe `@sourcegraph/cody-shared` package contains code that is shared among Cody clients.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/TextDocumentWithUri.ts:45-47"",""content"":""    public get content(): string | undefined {\n        return this.underlying.content\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/.github/PULL_REQUEST_TEMPLATE.md:0-5"",""content"":""\n## Test plan\n\n<!-- Required. See https://sourcegraph.com/docs/dev/background-information/testing_principles. -->\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:23-25"",""content"":""    public get content(): string {\n        return this.protocolDocument.underlying.content ?? ''\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320"",""content"":""\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    //  Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    //  Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    //  We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/guardrails/index.ts:3-6"",""content"":""export interface Attribution {\n    limitHit: boolean\n    repositories: RepositoryAttribution[]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/ChatMessageContent.module.css:44-100"",""content"":""\n.attribution-container {\n    all: unset;\n    display: flex;\n    margin-left: auto;\n}\n\n\n.attribution-icon-unavailable {\n    color: var(--hl-orange);\n}\n\n.attribution-icon-found {\n    color: var(--hl-dark-red);\n}\n\n.status {\n    display: flex;\n    align-items: center;\n}\n\n.codicon-loading {\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    from { transform: rotate(0deg); }\n    to { transform: rotate(360deg); }\n}\n\n/*\n * Content\n */\n:root {\n    --spacing: 1rem;\n}\n\n.content {\n    word-break: break-word;\n    line-height: 150%;\n    text-wrap: wrap;\n}\n\n/* Style @-file tokens to match TranscriptAction context files */\n.content a[href^=\""vscode://file\""] em,\n.content a[href^=\""vscode-insiders://file\""] em,\n.content a[href^=\""vscodium://file\""] em,\n.content a[href^=\""cursor://file\""] em\n{\n    padding: 1px 2px;\n    box-sizing: border-box;\n    background-color: color-mix(in srgb, var(--vscode-textLink-foreground) 15%, transparent);\n    border-radius: 2px;\n    font-style: normal;\n    word-break: break-all;\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_017/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_018/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The determination of whether to use enhanced context for chat is made in the `getEnhancedContext` function within `cody_test/vscode/src/chat/chat-view/context.ts`.

Here's a breakdown:

1. **Context Ranking:** If a `contextRanking` controller is provided, it indicates that a ranking model is being used to prioritize context. In this case, the `getEnhancedContextFromRanker` function is called, which utilizes the ranking model to determine the most relevant context.

2. **Configuration:** If no `contextRanking` controller is provided, the `strategy` configuration option is checked. This option determines how Cody should gather context:
   - **'none'**: Enhanced context is disabled, and only the content of the visible editor is used.
   - **'keyword'**: Only keyword-based context (from Symf or remote search) is used.
   - **'embeddings'**: Only embeddings-based context is used.
   - **Any other value**: Both embeddings and keyword-based context are used.

Based on the `strategy` setting, different context retrieval methods are called:

- `searchEmbeddingsLocal`: Retrieves context based on local embeddings.
- `searchRemote`: Retrieves context from a remote search provider.
- `searchSymf`: Retrieves context using Symf.

The results from these retrieval methods are then combined and potentially further filtered or ranked before being returned as the enhanced context for the chat.",Where do we determine whether to use enhanced context for chat?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/can-use-partial-completion.ts:0-41"",""content"":""import type { TextDocument } from 'vscode'\n\nimport type { DocumentContext } from '@sourcegraph/cody-shared'\nimport { hasCompleteFirstLine } from './text-processing'\nimport { parseAndTruncateCompletion } from './text-processing/parse-and-truncate-completion'\nimport type { InlineCompletionItemWithAnalytics } from './text-processing/process-inline-completions'\n\ninterface CanUsePartialCompletionParams {\n    document: TextDocument\n    docContext: DocumentContext\n}\n\n/**\n * Evaluates a partial completion response and returns it when we can already use it. This is used\n * to terminate any streaming responses where we can get a token-by-token access to the result and\n * want to terminate as soon as stop conditions are triggered.\n *\n * Right now this handles two cases:\n *  1. When a single line completion is requested, it terminates after the first full line was\n *     received.\n *  2. For a multi-line completion, it terminates when the completion will be truncated based on the\n *     multi-line indentation logic.\n */\nexport function canUsePartialCompletion(\n    partialResponse: string,\n    params: CanUsePartialCompletionParams\n): InlineCompletionItemWithAnalytics | null {\n    const { docContext } = params\n\n    if (!hasCompleteFirstLine(partialResponse)) {\n        return null\n    }\n\n    const item = parseAndTruncateCompletion(partialResponse, params)\n\n    if (docContext.multilineTrigger) {\n        return (item.lineTruncatedCount || 0) > 0 ? item : null\n    }\n\n    return item.insertText.trim() === '' ? null : item\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/counter.ts:26-43"",""content"":""     * Indicates whether the Chat and User-Context share the same token budget.\n     * - If true, all types of messages share the same token budget with Chat.\n     * - If false (Feature Flag required), the User-Context will has a separated budget.\n     * NOTE: Used in remainingTokens for calculating the remaining token budget for each budget type.\n     */\n    private shareChatAndUserBudget = true\n\n    constructor(contextWindow: ModelContextWindow) {\n        // If there is no context window reserved for context.user,\n        // context will share the same token budget with chat.\n        this.shareChatAndUserBudget = !contextWindow.context?.user\n        this.maxChatTokens = contextWindow.input\n        this.maxContextTokens = {\n            user: contextWindow.context?.user ?? contextWindow.input,\n            enhanced: Math.floor(contextWindow.input * ENHANCED_CONTEXT_ALLOCATION),\n        }\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:51-53"",""content"":""function useChatContextClient(): ChatContextClient {\n    return useContext(ChatContextClientContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/editor/active-editor.ts:0-26"",""content"":""import * as vscode from 'vscode'\n\nimport { isCodyIgnoredFile } from '@sourcegraph/cody-shared'\n\n/**\n * Interface for tracking the last active text editor that is not a webview panel for\n * the new Chat Panel UI.\n *\n * active: The current valid active/supported text editor instance.\n * ignored: Whether the active editor is ignored by Cody or not.\n */\ninterface LastActiveTextEditor {\n    active?: vscode.TextEditor\n    ignored?: boolean\n}\n\n/**\n * This returns the current active text editor instance if available,\n * along with a boolean indicating if the text editor is on the Cody ignored list.\n * Returns undefined if no editor is active.\n *\n * NOTE: ALL USERS of chat interface in VS Code should use this to get the correct Active Editor instead of using\n * 'vscode.window.activeTextEditor' as this handles cases where the activeTextEditor API will always return\n * 'undefined' when user is focused on the webview chat panel.\n *\n * NOTE: Users that operate within an actual text editor (non-webview panels) do not need to use this API as calling\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/plugins/atMentions/chatContextClient.tsx:56-108"",""content"":""export function useChatContextItems(query: string | null): ContextItem[] | undefined {\n    const chatContextClient = useChatContextClient()\n    const [results, setResults] = useState<ContextItem[]>()\n    // biome-ignore lint/correctness/useExhaustiveDependencies: we only want to run this when query changes.\n    useEffect(() => {\n        // An empty query is a valid query that we use to get open tabs context,\n        // while a null query means this is not an at-mention query.\n        if (query === null) {\n            setResults(undefined)\n            return\n        }\n\n        // If the query ends with a colon, we will reuse current results but remove the range.\n        if (query.endsWith(':')) {\n            const selected = results?.find(r => displayPath(r.uri) === query.slice(0, -1))\n            setResults(\n                selected\n                    ? [{ ...selected, range: undefined }]\n                    : results?.map(r => ({ ...r, range: undefined }))\n            )\n            return\n        }\n\n        // If user is typing a line range, fetch new chat context items only if there are no results\n        if (results?.length && RANGE_MATCHES_REGEXP.test(query) && !LINE_RANGE_REGEXP.test(query)) {\n            return\n        }\n\n        // Track if the query changed since this request was sent (which would make our results\n        // no longer valid).\n        let invalidated = false\n\n        if (chatContextClient) {\n            chatContextClient\n                .getChatContextItems(query)\n                .then(mentions => {\n                    if (invalidated) {\n                        return\n                    }\n                    setResults(mentions)\n                })\n                .catch(error => {\n                    setResults(undefined)\n                    console.error(error)\n                })\n        }\n\n        return () => {\n            invalidated = true\n        }\n    }, [query])\n    return results\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:98-116"",""content"":""            }\n            const enhancedContext = prevContext.filter(c => c.source !== 'user')\n            if (promptBuilder.tryAddContext('enhanced', enhancedContext).limitReached) {\n                logDebug('DefaultPrompter.makePrompt', 'Ignored prior enhanced context due to limit')\n                return { prompt: promptBuilder.build(), newContextUsed, newContextIgnored }\n            }\n\n            // Add additional context from current editor or broader search when enhanced context is enabled\n            if (this.getEnhancedContext) {\n                const lastMessage = reverseTranscript[0]\n                if (!lastMessage?.text) {\n                    throw new Error('No last message or last message text was empty')\n                }\n                if (lastMessage.speaker === 'assistant') {\n                    throw new Error('Last message in prompt needs speaker \""human\"", but was \""assistant\""')\n                }\n                const newEnhancedContext = await this.getEnhancedContext(lastMessage.text)\n                sortContextItems(newEnhancedContext)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/animal.ts:0-5"",""content"":""interface Animal {\n    name: string;\n    age: number;\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/local-embeddings.test.ts:140-164"",""content"":""    await openFile(page, 'main.c')\n    await sidebarSignin(page, sidebar)\n    const chatFrame = await newChat(page)\n\n    const enableEmbeddingsButton = chatFrame.getByText('Enable Embeddings')\n    // This may take a while, we download and start cody-engine\n    await expect(enableEmbeddingsButton).toBeVisible({ timeout: 60000 })\n    await enableEmbeddingsButton.click()\n\n    await expect(chatFrame.getByText('Embeddings  Indexed')).toBeVisible({\n        timeout: 30000,\n    })\n\n    // Search the embeddings. This test uses the \""stub\"" embedding model, which\n    // is deterministic, but the searches are not semantic.\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    await chatInput.fill('hello world')\n    await chatInput.press('Enter')\n    const contextCell = getContextCell(chatFrame)\n    await expectContextCellCounts(contextCell, {\n        files: 2,\n        timeout: 10000,\n    })\n})\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/squirrel.ts:0-11"",""content"":""interface CodeIntelligence {\n    symbols: string[]\n}\n\n/**\n * Squirrel is a code intelligence API.\n */\ninterface Squirrel {\n    symbolInformation(file: string): CodeIntelligence\n}\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:32-64"",""content"":""    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n}\nexport async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/README.md:0-5"",""content"":""# Cody Agent\n\nThe `@sourcegraph/cody-agent` package implements a JSON-RPC server to interact\nwith Cody via stdout/stdin. This package is intended to be used by\nnon-ECMAScript clients such as the JetBrains and NeoVim plugins.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:682-694"",""content"":""\n### Changed\n\n- Chat: Uses the new Chat UI by default. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Inline Chat is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Fixup Tree View is now deprecated and removed. [pull/2079](https://github.com/sourcegraph/cody/pull/2079)\n- Enhanced Context used to turn off automatically after the first chat. Now it stays enabled until you disable it. [pull/2069](https://github.com/sourcegraph/cody/pull/2069)\n- Chat: Reuse existing New Chat panel to prevent having multiple new chats open at once. [pull/2087](https://github.com/sourcegraph/cody/pull/2087)\n- Chat: Close the Enhanced Context popover on chat input focus. [pull/2091](https://github.com/sourcegraph/cody/pull/2091)\n- Chat: Show onboarding glowy dot guide until first time opening Enhanced Context. [pull/2097](https://github.com/sourcegraph/cody/pull/2097)\n- In 0.12, we simplified the sign-in process and removed the option to sign into\n  Cody App from VScode. If you were still signed in to Cody App, we invite you to\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:67-69"",""content"":""function useEnhancedContextEventHandlers(): EnhancedContextEventHandlersT {\n    return React.useContext(EnhancedContextEventHandlers)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/doc/dev/quality/index.md:16-32"",""content"":""\n## Chat\n\n### Influencing chat performance\n\nThe VS Code extension has _Cody commands_, which are pre-formed prompts you can ask Cody with e.g. the click of a button. There is also an initial pre-text given to the LLM, explaining what Cody is and how it should behave.\n\nRelevant context from many different sources (the open file in your editor, tree-sitter, precise code intel, and more) is included in the prompt when asking Cody a question. Different LLMs handle context in different ways, some LLMs might do better with more context, while that might simply confuse others.\n\nWe can influence chat performance by altering prompting AND context amount/relevancy.\n\n## Testing a new LLM with Cody\n\nThis guide demonstrates how to test LLM models from Google Gemini, Groq, or any OpenAI-compatible APIs using your API keys in Cody.\n\nThis feature is intended solely for internal QA testing and development purposes and is concealed behind an unregistered configuration setting (`cody.dev.models`) that functions exclusively in [Dev/Debug mode](../../../vscode/CONTRIBUTING.md).\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:94-157"",""content"":""async function getEnhancedContextFromRanker({\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    return wrapInActiveSpan('chat.enhancedContextRanker', async span => {\n        // Get all possible context items to rank\n        let searchContext = getVisibleEditorContext(editor)\n\n        const numResults = 50\n        const embeddingsContextItemsPromise = retrieveContextGracefully(\n            searchEmbeddingsLocal(providers.localEmbeddings, text, numResults),\n            'local-embeddings'\n        )\n\n        const modelSpecificEmbeddingsContextItemsPromise = contextRanking\n            ? retrieveContextGracefully(\n                  contextRanking.searchModelSpecificEmbeddings(text, numResults),\n                  'model-specific-embeddings'\n              )\n            : []\n\n        const precomputeQueryEmbeddingPromise = contextRanking?.precomputeContextRankingFeatures(text)\n\n        const localSearchContextItemsPromise = providers.symf\n            ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n            : []\n\n        const remoteSearchContextItemsPromise = providers.remoteSearch\n            ? await retrieveContextGracefully(\n                  searchRemote(providers.remoteSearch, text),\n                  'remote-search'\n              )\n            : []\n\n        const keywordContextItemsPromise = (async () => [\n            ...(await localSearchContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n        ])()\n\n        const [embeddingsContextItems, keywordContextItems, modelEmbeddingContextItems] =\n            await Promise.all([\n                embeddingsContextItemsPromise,\n                keywordContextItemsPromise,\n                modelSpecificEmbeddingsContextItemsPromise,\n                precomputeQueryEmbeddingPromise,\n            ])\n\n        searchContext = searchContext\n            .concat(keywordContextItems)\n            .concat(embeddingsContextItems)\n            .concat(modelEmbeddingContextItems)\n        const editorContext = await getPriorityContext(text, editor, searchContext)\n        const allContext = editorContext.concat(searchContext)\n        if (!contextRanking) {\n            return allContext\n        }\n        const rankedContext = wrapInActiveSpan('chat.enhancedContextRanker.reranking', () =>\n            contextRanking.rankContextItems(text, allContext)\n        )\n        return rankedContext\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121"",""content"":""\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \""from\"" the human. (In the future, this could be from \""system\"" for\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:24-35"",""content"":""interface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n    }\n    contextRanking: ContextRankingController | null\n    // TODO(@philipp-spiess): Add abort controller to be able to cancel expensive retrievers\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/context-settings.test.ts:24-43"",""content"":""\n    // Opening the enhanced context settings should focus the checkbox for toggling it.\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n\n    // Enhanced context should be enabled by default.\n    await expect(enhancedContextCheckbox).toBeChecked()\n    await page.keyboard.press('Space') // Disable enhanced context\n    // The keyboard should toggle the checkbox, but not dismiss the popup.\n    await expect(enhancedContextCheckbox).not.toBeChecked()\n    await expect(enhancedContextCheckbox).toBeVisible()\n\n    // The popup should be dismiss-able with the keyboard.\n    await page.keyboard.press('Escape')\n    // Closing the enhanced context settings should close the dialog...\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    // ... and the focus is moved to the chat input on close.\n    const contextSettingsButton = chatFrame.getByTitle('Configure Enhanced Context')\n    await expect(contextSettingsButton.and(page.locator(':focus'))).not.toBeVisible()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:36-92"",""content"":""export async function getEnhancedContext({\n    strategy,\n    editor,\n    text,\n    providers,\n    contextRanking,\n}: GetEnhancedContextOptions): Promise<ContextItem[]> {\n    if (contextRanking) {\n        return getEnhancedContextFromRanker({\n            strategy,\n            editor,\n            text,\n            providers,\n            contextRanking,\n        })\n    }\n\n    return wrapInActiveSpan('chat.enhancedContext', async () => {\n        // use user attention context only if config is set to none\n        if (strategy === 'none') {\n            logDebug('SimpleChatPanelProvider', 'getEnhancedContext > none')\n            return getVisibleEditorContext(editor)\n        }\n\n        // Get embeddings context if useContext Config is not set to 'keyword' only\n        const embeddingsContextItemsPromise =\n            strategy !== 'keyword'\n                ? retrieveContextGracefully(\n                      searchEmbeddingsLocal(providers.localEmbeddings, text),\n                      'local-embeddings'\n                  )\n                : []\n\n        //  Get search (symf or remote search) context if config is not set to 'embeddings' only\n        const remoteSearchContextItemsPromise =\n            providers.remoteSearch && strategy !== 'embeddings'\n                ? await retrieveContextGracefully(\n                      searchRemote(providers.remoteSearch, text),\n                      'remote-search'\n                  )\n                : []\n        const localSearchContextItemsPromise =\n            providers.symf && strategy !== 'embeddings'\n                ? retrieveContextGracefully(searchSymf(providers.symf, editor, text), 'symf')\n                : []\n\n        // Combine all context sources\n        const searchContext = [\n            ...(await embeddingsContextItemsPromise),\n            ...(await remoteSearchContextItemsPromise),\n            ...(await localSearchContextItemsPromise),\n        ]\n\n        const priorityContext = await getPriorityContext(text, editor, searchContext)\n        return priorityContext.concat(searchContext)\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:13-15"",""content"":""export function useChatModelContext(): ChatModelContext {\n    return useContext(context)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287"",""content"":""\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the Chats panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the Chats panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the Chats panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the Chats panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the Chats panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \""Enhanced Context\"" icon next to the chat input.\n- [ ] Verify that \""Enhanced Context\"" is enabled by default.\n\n### Consumer\n\nSet up steps:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:63-65"",""content"":""function useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:377-385"",""content"":""- We now allocate no more than 60% of the overall LLM context window for enhanced context. This preserves more room for follow-up questions and context. [pull/2768](https://github.com/sourcegraph/cody/pull/2768)\n- Chat: Renamed the \""Restart Chat Session\"" button to \""New Chat Session\"". [pull/2786](https://github.com/sourcegraph/cody/pull/2786)\n- Removed the `cody.experimental.chatPredictions` setting. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Removed support for the `context.codebase` custom command property. [pull/2848](https://github.com/sourcegraph/cody/pull/2848)\n- Autocomplete: Better cancellation of requests that are no longer relevant. [pull/2855](https://github.com/sourcegraph/cody/pull/2855)\n- Updated Enhanced Context popover copy and added a link to the docs. [pull/2864](https://github.com/sourcegraph/cody/pull/2864)\n- Include meta information about unit test files in Autocomplete analytics. [pull/2868](https://github.com/sourcegraph/cody/pull/2868)\n- Moved the Context Limit errors in chat into the deboug log output. [pull/2891](https://github.com/sourcegraph/cody/pull/2891)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.test.ts:0-150"",""content"":""import { describe, expect, it } from 'vitest'\nimport * as vscode from 'vscode'\n\nimport type * as status from '@sourcegraph/cody-shared'\n\nimport { ContextStatusAggregator } from './enhanced-context-status'\n\nclass TestProvider implements status.ContextStatusProvider {\n    public emitter: vscode.EventEmitter<status.ContextStatusProvider> = new vscode.EventEmitter()\n\n    constructor(private status_: status.ContextGroup[] | undefined = undefined) {}\n\n    public onDidChangeStatus(\n        callback: (provider: status.ContextStatusProvider) => void\n    ): vscode.Disposable {\n        return this.emitter.event(callback)\n    }\n\n    public get status(): status.ContextGroup[] {\n        return (\n            this.status_ || [\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'embeddings',\n                            state: 'unconsented',\n                        },\n                    ],\n                },\n            ]\n        )\n    }\n    public set status(status: status.ContextGroup[]) {\n        this.status_ = status\n    }\n}\n\ndescribe('ContextStatusAggregator', () => {\n    it('should fire status changed when providers are added and pass through simple status', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => resolve(provider.status))\n        })\n        aggregator.addProvider(new TestProvider())\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                ],\n            },\n        ])\n        aggregator.dispose()\n    })\n    it('should fire aggregate status from multiple providers', async () => {\n        const aggregator = new ContextStatusAggregator()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        aggregator.addProvider(new TestProvider())\n        aggregator.addProvider(\n            new TestProvider([\n                {\n                    displayName: 'host.example/foo',\n                    providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n                },\n                {\n                    displayName: 'github.com/foo/bar',\n                    providers: [\n                        {\n                            kind: 'search',\n                            type: 'remote',\n                            state: 'ready',\n                            id: 'quux',\n                            inclusion: 'manual',\n                        },\n                    ],\n                },\n            ])\n        )\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'embeddings',\n                        state: 'unconsented',\n                    },\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id: 'quux',\n                        inclusion: 'manual',\n                    },\n                ],\n            },\n            {\n                displayName: 'host.example/foo',\n                providers: [{ kind: 'search', type: 'local', state: 'ready' }],\n            },\n        ])\n        // Not only does it aggregate status, it coalesces update events\n        expect(callbackCount).toBe(1)\n        aggregator.dispose()\n    })\n    it('should respond to child events by firing an event of its own', async () => {\n        const aggregator = new ContextStatusAggregator()\n        const provider = new TestProvider()\n        aggregator.addProvider(provider)\n        // Skip the first update event.\n        await Promise.resolve()\n        let callbackCount = 0\n        const promise = new Promise<status.ContextGroup[]>(resolve => {\n            aggregator.onDidChangeStatus(provider => {\n                callbackCount++\n                resolve(provider.status)\n            })\n        })\n        provider.status = [\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [{ kind: 'search', type: 'local', state: 'indexing' }],\n            },\n        ]\n        provider.emitter.fire(provider)\n\n        expect(await promise).toEqual<status.ContextGroup[]>([\n            {\n                displayName: 'github.com/foo/bar',\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'local',\n                        state: 'indexing',\n                    },\n                ],\n            },\n        ])\n        expect(callbackCount).toBe(1)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:64-89"",""content"":""\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/enhanced-context-status.ts:0-158"",""content"":""import * as vscode from 'vscode'\n\nimport type { ContextGroup, ContextStatusProvider } from '@sourcegraph/cody-shared'\n\nimport { logDebug } from '../log'\n\n// Collects context status from a set of ContextStatusProviders and produces\n// a merged status view.\nexport class ContextStatusAggregator implements vscode.Disposable, ContextStatusProvider {\n    private static TAG = 'ContextStatusAggregator'\n    private disposables: Set<vscode.Disposable> = new Set()\n    private statusEmitter: vscode.EventEmitter<ContextStatusProvider> =\n        new vscode.EventEmitter<ContextStatusProvider>()\n    private providerStatusMap: Map<ContextStatusProvider, ContextGroup[] | 'needs-status'> | undefined =\n        new Map()\n\n    // Whether we have been notified of status changes, but are yet to pass that\n    // notification on. We do this to de-bounce updates from multiple status\n    // providers in one turn of the event loop.\n    private pendingPublish = false\n\n    // Disposes this ContextStatusAggregator.\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.providerStatusMap = undefined\n    }\n\n    // Adds a provider to this ContextStatusAggregator. The aggregator will\n    // subscribe to the provider and aggregate its updates into a merged status.\n    // To remove this provider, dispose of the returned disposable.\n    //\n    // If the provider is disposable, it should dispose of the registration in\n    // its dispose method. Otherwise this ContextStatusAggregator may continue\n    // to poll its status property, and show its status in the aggregate status.\n    public addProvider(provider: ContextStatusProvider): vscode.Disposable {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const disposable = provider.onDidChangeStatus(putativeProvider => {\n            if (provider !== putativeProvider) {\n                logDebug(\n                    ContextStatusAggregator.TAG,\n                    'got onDidChangeStatus event but passed mismatched provider'\n                )\n            }\n            this.providerDidChangeStatus(provider)\n        })\n        this.disposables.add(disposable)\n        this.providerStatusMap.set(provider, 'needs-status')\n        this.providerDidChangeStatus(provider)\n        return {\n            dispose: (): void => {\n                if (this.providerStatusMap) {\n                    this.providerStatusMap.delete(provider)\n                    this.disposables.delete(disposable)\n                    disposable.dispose()\n                    this.publishStatus()\n                }\n            },\n        }\n    }\n\n    // Records that the provider's state is dirty, and schedules an update.\n    private providerDidChangeStatus(provider: ContextStatusProvider): void {\n        if (this.providerStatusMap === undefined) {\n            // We have been disposed\n            return\n        }\n        if (!this.providerStatusMap.has(provider)) {\n            // The provider has been removed. This should not happen if the\n            // providers are following the dispose protocol.\n            return\n        }\n        // Record that we need to get provider status next update.\n        this.providerStatusMap.set(provider, 'needs-status')\n        // Schedule an update.\n        this.publishStatus()\n    }\n\n    // Aggregates and publishes status asynchronously. Multiple context status\n    // providers updating \""at once\"" will be coalesced into one update.\n    private publishStatus(): void {\n        if (this.pendingPublish) {\n            // Coalesce multiple updates.\n            return\n        }\n        this.pendingPublish = true\n        void Promise.resolve().then(() => {\n            this.pendingPublish = false\n            this.statusEmitter.fire(this)\n        })\n    }\n\n    // ContextStatusProvider implementation of onDidChangeStatus. The\n    // ContextStatusAggregator can be stacked to combine per-workspace and\n    // per-chat context status.\n    public onDidChangeStatus(callback: (sender: ContextStatusProvider) => void): vscode.Disposable {\n        return this.statusEmitter.event(callback)\n    }\n\n    // Computes the merged context status. This may throw if any of the\n    // aggregated providers' status throw.\n    public get status(): ContextGroup[] {\n        if (this.providerStatusMap === undefined) {\n            throw new Error('ContextStatusPublisher has been disposed')\n        }\n        const groupBy: { [name: string]: ContextGroup } = {}\n        // Iterate through provider status map entries\n        for (let [provider, status] of this.providerStatusMap.entries()) {\n            if (status === 'needs-status') {\n                // The provider's status is stale; poll it.\n                status = provider.status\n                if (this.providerStatusMap.get(provider) !== 'needs-status') {\n                    logDebug(\n                        ContextStatusAggregator.TAG,\n                        'ContextStatusProvider.status should only report status, not change state',\n                        provider\n                    )\n                }\n                // Deep clone the status object so providers can't continue to change it without notifying.\n                status = JSON.parse(JSON.stringify(status)) as ContextGroup[]\n                // Cache the status so we don't re-poll this provider unless it changes.\n                this.providerStatusMap.set(provider, status)\n            }\n\n            // Collect context groups by name\n            for (const group of status) {\n                if (group.displayName in groupBy) {\n                    // Merge the items in the group.\n                    groupBy[group.displayName].providers.push(...group.providers)\n                } else {\n                    // Create a new group for the merged result.\n                    groupBy[group.displayName] = {\n                        displayName: group.displayName,\n                        providers: [...group.providers],\n                    }\n                }\n            }\n        }\n        // Order sources within the groups by a canonical order\n        for (const groups of Object.values(groupBy)) {\n            // Sort by a fixed locale for consistency. The 'kind' key is not a\n            // localized UI label.\n            groups.providers.sort((a, b) => a.kind.localeCompare(b.kind, 'en-US'))\n        }\n        return [...Object.values(groupBy)]\n    }\n\n    // TODO: Create a publisher to push into the webview\n    // TODO: Hook in local embeddings\n    // TODO: Hook in cloud embeddings\n    // TODO: Hook in symf\n    // TODO: Hook in graph\n    // TODO: Hook in the Cody: building code index ... notification pusher's\n    // state\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/common.ts:50-74"",""content"":""\n/**\n * Create and open a new chat panel, and close the enhanced context settings window.\n * Returns the chat panel frame locator.\n */\nexport async function createEmptyChatPanel(page: Page): Promise<[FrameLocator, Locator]> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    const chatFrame = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n    const enhancedContextCheckbox = chatFrame.locator('#enhanced-context-checkbox')\n    await expect(enhancedContextCheckbox).toBeFocused()\n    await page.keyboard.press('Escape')\n    await expect(enhancedContextCheckbox).not.toBeVisible()\n    const chatInput = chatFrame.getByRole('textbox', { name: 'Chat message' })\n    return [chatFrame, chatInput]\n}\n\n/**\n * Gets the chat context cell. If {@link counts} is specified, then validates that the context\n * exactly matches the specified file and line counts.\n */\nexport function getContextCell(\n    chatPanel: FrameLocator,\n    counts?: { files: number; lines: number }\n): Locator {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/EnhancedContext.tsx:4-6"",""content"":""export function useEnhancedContextEnabled(): boolean {\n    return React.useContext(EnhancedContextEnabled)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_019/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The embeddings model is queried in the `retrieveEmbeddingBasedContext` function in the `cody_test/vscode/src/local-context/context-ranking.ts` file. 

Here's a breakdown:

1. **`retrieveEmbeddingBasedContext` Function:** This function takes the user's query, the desired number of results, and the model name as input.
2. **Service Request:** It makes a request to the language server using the `context-ranking/context-retriever-embedding` endpoint. 
3. **Request Parameters:** The request includes the repository path, the user's query, the model name (`modelName`), and the number of results (`numResults`).
4. **Response Processing:** The response from the language server contains embedding search results. The code then maps these results to create a list of `EmbeddingsSearchResult` objects.

Therefore, the actual query to the embeddings model happens on the language server side, triggered by the `context-ranking/context-retriever-embedding` request.",Where do we query the embeddings model?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/index.ts:132-134"",""content"":""    public static getProviderByModel(modelID: string): ModelProvider | undefined {\n        return ModelProvider.providers.find(m => m.model === modelID)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:502-541"",""content"":""      },\n      {\n        \""command\"": \""cody.embeddings.resolveIssue\"",\n        \""title\"": \""Cody Embeddings\"",\n        \""when\"": \""cody.embeddings.hasIssue\""\n      },\n      {\n        \""command\"": \""cody.debug.export.logs\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Export Logs\""\n      },\n      {\n        \""command\"": \""cody.debug.outputChannel\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Open Output Channel\""\n      },\n      {\n        \""command\"": \""cody.debug.enable.all\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Enable Debug Mode\"",\n        \""when\"": \""!config.cody.debug.verbose\""\n      },\n      {\n        \""command\"": \""cody.debug.reportIssue\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""title\"": \""Report Issue\""\n      },\n      {\n        \""command\"": \""cody.copy.version\"",\n        \""category\"": \""Cody Debug\"",\n        \""group\"": \""Debug\"",\n        \""icon\"": \""$(copy)\"",\n        \""title\"": \""Copy Cody Extension Version\""\n      }\n    ],\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/models/chatModelContext.tsx:4-7"",""content"":""export interface ChatModelContext {\n    chatModels?: ModelProvider[]\n    onCurrentChatModelChange?: (model: ModelProvider) => void\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:103-127"",""content"":""        this.disposables.push(\n            vscode.commands.registerCommand('cody.embeddings.resolveIssue', () =>\n                this.resolveIssueCommand()\n            )\n        )\n\n        // Pick up the initial access token, and whether the account is dotcom.\n        this.accessToken = config.accessToken || undefined\n        this.endpointIsDotcom = isDotCom(config.serverEndpoint)\n\n        this.model = config.testingLocalEmbeddingsModel || 'openai/text-embedding-ada-002'\n        this.endpoint =\n            config.testingLocalEmbeddingsEndpoint || 'https://cody-gateway.sourcegraph.com/v1/embeddings'\n        this.indexLibraryPath = config.testingLocalEmbeddingsIndexLibraryPath\n            ? URI.file(config.testingLocalEmbeddingsIndexLibraryPath)\n            : undefined\n    }\n\n    public dispose(): void {\n        for (const disposable of this.disposables) {\n            disposable.dispose()\n        }\n        this.statusBar?.dispose()\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:40-84"",""content"":""    private async compileQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const languages = [language, ...(grammarInheritance[language] ?? [])]\n        const queryStrings: string[] = []\n        for (const queryLanguage of languages) {\n            const queryPath = path.join(this.queriesDirectory, queryLanguage, `${name}.scm`)\n            try {\n                const stat = await fspromises.stat(queryPath)\n                if (!stat.isFile()) {\n                    continue\n                }\n            } catch {\n                if (this.queryDirectoryExists === undefined) {\n                    try {\n                        this.queryDirectoryExists = (\n                            await fspromises.stat(this.queriesDirectory)\n                        ).isDirectory()\n                        if (!this.queryDirectoryExists) {\n                            throw new Error(\n                                `Query directory ${this.queriesDirectory} is not a directory. To fix this problem, update the value of the flag --queries-directory <path>`\n                            )\n                        }\n                    } catch {\n                        throw new Error(\n                            `Query directory ${this.queriesDirectory} does not exist. To fix this problem, update the value of the flag --queries-directory <path>`\n                        )\n                    }\n                }\n                continue\n            }\n            const queryString = await fspromises.readFile(queryPath)\n            queryStrings.push(queryString.toString())\n        }\n        const uncompiled: UncompiledQuery = {\n            language,\n            queryName: name,\n            queryString: queryStrings.join('\\n\\n'),\n        }\n        const compiled = compileQuery(uncompiled, parser)\n        this.cache.push(compiled)\n        return compiled.compiledQuery\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3000-3017"",""content"":""                writer.writeMessage(22, this.super_type, () => this.super_type.serialize(writer))\n            if (this.has_constant_type)\n                writer.writeMessage(23, this.constant_type, () => this.constant_type.serialize(writer))\n            if (this.has_intersection_type)\n                writer.writeMessage(17, this.intersection_type, () =>\n                    this.intersection_type.serialize(writer)\n                )\n            if (this.has_union_type)\n                writer.writeMessage(18, this.union_type, () => this.union_type.serialize(writer))\n            if (this.has_with_type)\n                writer.writeMessage(19, this.with_type, () => this.with_type.serialize(writer))\n            if (this.has_structural_type)\n                writer.writeMessage(7, this.structural_type, () =>\n                    this.structural_type.serialize(writer)\n                )\n            if (this.has_annotated_type)\n                writer.writeMessage(8, this.annotated_type, () => this.annotated_type.serialize(writer))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/Queries.ts:21-38"",""content"":""    public async loadQuery(\n        parser: WrappedParser,\n        language: SupportedLanguage,\n        name: QueryName\n    ): Promise<Query | undefined> {\n        const fromCache = this.cache.find(\n            compiled => compiled.language === language && compiled.queryName === name\n        )\n        if (fromCache) {\n            return fromCache.compiledQuery\n        }\n        try {\n            return await this.compileQuery(parser, language, name)\n        } catch (error) {\n            console.error(`Queries.loadQuery(): ${language}/${name}`, error)\n            process.exit(1)\n        }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:68-95"",""content"":""\n// Model identifiers can be found in https://docs.fireworks.ai/explore/ and in our internal\n// conversations\nconst MODEL_MAP = {\n    // Virtual model strings. Cody Gateway will map to an actual model\n    starcoder: 'fireworks/starcoder',\n    'starcoder-16b': 'fireworks/starcoder-16b',\n    'starcoder-7b': 'fireworks/starcoder-7b',\n    'starcoder2-15b': 'fireworks/starcoder2-15b',\n    'starcoder2-7b': 'fireworks/starcoder2-7b',\n\n    // Fireworks model identifiers\n    'llama-code-13b': 'fireworks/accounts/fireworks/models/llama-v2-13b-code',\n}\n\ntype FireworksModel =\n    | keyof typeof MODEL_MAP\n    // `starcoder-hybrid` uses the 16b model for multiline requests and the 7b model for single line\n    | 'starcoder-hybrid'\n    // `starcoder2-hybrid` uses the 15b model for multiline requests and the 7b model for single line\n    | 'starcoder2-hybrid'\n\nfunction getMaxContextTokens(model: FireworksModel): number {\n    switch (model) {\n        case 'starcoder':\n        case 'starcoder2-hybrid':\n        case 'starcoder2-15b':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.test.ts:0-46"",""content"":""import { afterEach, describe, expect, it } from 'vitest'\n\nimport { SupportedLanguage } from './grammars'\nimport { resetParsersCache } from './parser'\nimport { getDocumentQuerySDK } from './query-sdk'\nimport { initTreeSitterParser } from './test-helpers'\n\ndescribe('getDocumentQuerySDK', () => {\n    afterEach(() => {\n        resetParsersCache()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.javascript },\n        { languageId: SupportedLanguage.typescript },\n        { languageId: SupportedLanguage.javascriptreact },\n        { languageId: SupportedLanguage.typescriptreact },\n        { languageId: SupportedLanguage.go },\n        { languageId: SupportedLanguage.python },\n    ])('returns valid SDK for $languageId', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk?.queries.intents).toBeTruthy()\n    })\n\n    it.each([\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.cpp },\n        { languageId: SupportedLanguage.csharp },\n        { languageId: SupportedLanguage.php },\n    ])('returns null for $languageId because queries are not defined', async ({ languageId }) => {\n        const nonInitializedSDK = getDocumentQuerySDK(languageId)\n        expect(nonInitializedSDK).toBeNull()\n\n        const parser = await initTreeSitterParser(languageId)\n        expect(parser).toBeTruthy()\n\n        const sdk = getDocumentQuerySDK(languageId)\n        expect(sdk).toBeNull()\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:0-26"",""content"":""// Add anything else here that needs to be used outside of this library.\n\nexport { ModelProvider } from './models'\nexport { type ChatModel, type EditModel, ModelUsage, type ModelContextWindow } from './models/types'\nexport { getDotComDefaultModels } from './models/dotcom'\nexport {\n    getProviderName,\n    getModelInfo,\n} from './models/utils'\nexport { BotResponseMultiplexer } from './chat/bot-response-multiplexer'\nexport { ChatClient } from './chat/chat'\nexport { ignores, isCodyIgnoredFile } from './cody-ignore/context-filter'\nexport {\n    IgnoreHelper,\n    CODY_IGNORE_POSIX_GLOB,\n    type IgnoreFileContent,\n    CODY_IGNORE_URI_PATH,\n} from './cody-ignore/ignore-helper'\nexport { renderCodyMarkdown } from './chat/markdown'\nexport { getSimplePreamble } from './chat/preamble'\nexport type {\n    SerializedChatInteraction,\n    SerializedChatTranscript,\n} from './chat/transcript'\nexport { serializeChatMessage } from './chat/transcript'\nexport { errorToChatError, DEFAULT_EVENT_SOURCE } from './chat/transcript/messages'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/tree-sitter/query-sdk.ts:0-550"",""content"":""import { findLast } from 'lodash'\nimport type { Position, TextDocument } from 'vscode'\nimport type {\n    Language,\n    Point,\n    Query,\n    QueryCapture,\n    SyntaxNode,\n    Tree,\n    default as Parser,\n} from 'web-tree-sitter'\n\nimport { type SupportedLanguage, isSupportedLanguage } from './grammars'\nimport { getCachedParseTreeForDocument } from './parse-tree-cache'\nimport { type WrappedParser, getParser } from './parser'\nimport { type CompletionIntent, type QueryName, intentPriority, languages } from './queries'\n\ninterface ParsedQuery {\n    compiled: Query\n    raw: string\n}\ntype ResolvedQueries = {\n    [name in QueryName]: ParsedQuery\n}\n\nconst QUERIES_LOCAL_CACHE: Partial<Record<SupportedLanguage, ResolvedQueries & QueryWrappers>> = {}\n\n/**\n * Reads all language queries from disk and parses them.\n * Saves queries the local cache for further use.\n */\nexport function initQueries(language: Language, languageId: SupportedLanguage, parser: Parser): void {\n    const cachedQueries = QUERIES_LOCAL_CACHE[languageId]\n    if (cachedQueries) {\n        return\n    }\n\n    const languageQueries = languages[languageId]\n    if (languageQueries === undefined) {\n        return\n    }\n\n    const queryEntries = Object.entries(languageQueries).map(([name, raw]) => {\n        return [\n            name,\n            {\n                raw,\n                compiled: language.query(raw),\n            },\n        ] as const\n    })\n\n    const queries = Object.fromEntries<ParsedQuery>(queryEntries) as ResolvedQueries\n\n    QUERIES_LOCAL_CACHE[languageId] = {\n        ...queries,\n        ...getLanguageSpecificQueryWrappers(queries, parser, languageId),\n    }\n}\n\nexport interface DocumentQuerySDK {\n    parser: WrappedParser\n    queries: ResolvedQueries & QueryWrappers\n    language: SupportedLanguage\n}\n\n/**\n * Returns the query SDK only if the language has queries defined and\n * the relevant language parser is initialized.\n */\nexport function getDocumentQuerySDK(language: string): DocumentQuerySDK | null {\n    if (!isSupportedLanguage(language)) {\n        return null\n    }\n\n    const parser = getParser(language)\n    const queries = QUERIES_LOCAL_CACHE[language]\n\n    if (!parser || !queries) {\n        return null\n    }\n\n    return {\n        parser,\n        queries,\n        language,\n    }\n}\n\nexport interface QueryWrappers {\n    getSinglelineTrigger: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: 'trigger' }]\n    getCompletionIntent: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) => [] | readonly [{ readonly node: SyntaxNode; readonly name: CompletionIntent }]\n    getDocumentableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  insertionPoint?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n    getGraphContextIdentifiers: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getEnclosingFunction: (node: SyntaxNode, start: Point, end?: Point) => QueryCapture[]\n    getTestableNode: (\n        node: SyntaxNode,\n        start: Point,\n        end?: Point\n    ) =>\n        | []\n        | readonly [\n              {\n                  symbol?: QueryCapture\n                  range?: QueryCapture\n                  meta: { showHint: boolean }\n              },\n          ]\n}\n\n/**\n * Query wrappers with custom post-processing logic.\n */\nfunction getLanguageSpecificQueryWrappers(\n    queries: ResolvedQueries,\n    _parser: Parser,\n    languageId: SupportedLanguage\n): QueryWrappers {\n    return {\n        getSinglelineTrigger: (root, start, end) => {\n            const captures = queries.singlelineTriggers.compiled.captures(root, start, end)\n            const { trigger, block } = getTriggerNodeWithBlockStaringAtPoint(captures, start)\n\n            if (!trigger || !block || !isBlockNodeEmpty(block)) {\n                return []\n            }\n\n            return [{ node: trigger, name: 'trigger' }] as const\n        },\n        getCompletionIntent: (root, start, end) => {\n            const captures = queries.intents.compiled.captures(root, start, end)\n\n            const { intentCapture } = getIntentFromCaptures(captures, start)\n\n            if (!intentCapture) {\n                return []\n            }\n\n            return [{ node: intentCapture.node, name: intentCapture.name as CompletionIntent }] as const\n        },\n        getDocumentableNode: (root, start, end) => {\n            const captures = queries.documentableNodes.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const documentableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = documentableRanges.at(-1)\n\n            let insertionPoint: QueryCapture | undefined\n            if (languageId === 'python' && range) {\n                /**\n                 * Python is a special case for generating documentation.\n                 * The insertion point of the documentation should differ if the symbol is a function or class.\n                 * We need to query again for an insertion point, this time using the correct determined range.\n                 *\n                 * See https://peps.python.org/pep-0257/ for the documentation conventions for Python.\n                 */\n                const insertionCaptures = queries.documentableNodes.compiled\n                    .captures(root, range.node.startPosition, range.node.endPosition)\n                    .filter(({ name }) => name.startsWith('insertion'))\n\n                insertionPoint = insertionCaptures.find(\n                    ({ node }) =>\n                        node.startIndex >= range.node.startIndex && node.endIndex <= range.node.endIndex\n                )\n            }\n\n            /**\n             * Modify where we look for a docstring depending on the language and syntax.\n             * For Python functions and classes, we will have a provided `insertionPoint`, use the line below this.\n             * For all other cases, docstrings should be attached above the symbol range, use this.\n             */\n            const docStringLine =\n                languageId === 'python' && insertionPoint\n                    ? insertionPoint.node.startPosition.row + 1\n                    : start.row - 1\n            const docstringCaptures = queries.documentableNodes.compiled\n                .captures(\n                    root,\n                    { row: docStringLine, column: 0 },\n                    { row: docStringLine, column: Number.MAX_SAFE_INTEGER }\n                )\n                .filter(node => node.name.startsWith('comment'))\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one documentable range for this position, we can be confident it makes sense to document. Show the hint.\n             * 2. Otherwise, only show the hint if the symbol is a function\n             * 3. Don't show hint if there is no docstring already present.\n             */\n            const showHint = Boolean(\n                (documentableRanges.length === 1 || symbol?.name.includes('function')) &&\n                    docstringCaptures.length === 0\n            )\n\n            return [\n                {\n                    symbol,\n                    range,\n                    insertionPoint,\n                    meta: { showHint },\n                },\n            ]\n        },\n        getGraphContextIdentifiers: (root, start, end) => {\n            return queries.graphContextIdentifiers.compiled.captures(root, start, end)\n        },\n        getEnclosingFunction: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled\n                .captures(root, start, end)\n                .filter(capture => capture.name.startsWith('range'))\n\n            const firstEnclosingFunction = findLast(captures, ({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            if (!firstEnclosingFunction) {\n                return []\n            }\n\n            return [firstEnclosingFunction]\n        },\n        getTestableNode: (root, start, end) => {\n            const captures = queries.enclosingFunction.compiled.captures(\n                root,\n                { ...start, column: 0 },\n                end ? { ...end, column: Number.MAX_SAFE_INTEGER } : undefined\n            )\n            const symbolCaptures = []\n            const rangeCaptures = []\n\n            for (const capture of captures) {\n                if (capture.name.startsWith('range')) {\n                    rangeCaptures.push(capture)\n                } else if (capture.name.startsWith('symbol')) {\n                    symbolCaptures.push(capture)\n                }\n            }\n\n            const symbol = findLast(symbolCaptures, ({ node }) => {\n                return (\n                    node.startPosition.row === start.row &&\n                    (node.startPosition.column <= start.column || node.startPosition.row < start.row) &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n\n            const testableRanges = rangeCaptures.filter(({ node }) => {\n                return (\n                    node.startPosition.row <= start.row &&\n                    (start.column <= node.endPosition.column || start.row < node.endPosition.row)\n                )\n            })\n            const range = testableRanges.at(-1)\n\n            /**\n             * Heuristic to determine if we should show a prominent hint for the symbol.\n             * 1. If there is only one testable range for this position, we can be confident it makes sense to test. Show the hint.\n             * 2. TODO: Look for usages of this function in test files, if it's already used then don't show the hint.\n             */\n            const showHint = Boolean(testableRanges.length === 1)\n\n            return [\n                {\n                    symbol,\n                    range,\n                    meta: { showHint },\n                },\n            ]\n        },\n    }\n}\n\n// TODO: check if the block parent is empty in the consumer.\n// Tracking: https://github.com/sourcegraph/cody/issues/1452\nfunction getIntentFromCaptures(\n    captures: QueryCapture[],\n    cursor: Point\n): { cursorCapture?: Parser.QueryCapture; intentCapture?: Parser.QueryCapture } {\n    const emptyResult = {\n        cursorCapture: undefined,\n        intentCapture: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    // Find the cursor capture group if exists.\n    const [cursorCapture] = sortByIntentPriority(\n        captures.filter(capture => {\n            const { name, node } = capture\n\n            const matchesCursorPosition =\n                node.startPosition.column === cursor.column && node.startPosition.row === cursor.row\n\n            return name.endsWith('.cursor') && matchesCursorPosition\n        })\n    )\n\n    // Find the corresponding preceding intent capture that matches the cursor capture name.\n    const intentCapture = findLast(captures, capture => {\n        return capture.name === withoutCursorSuffix(cursorCapture?.name)\n    })\n\n    if (cursorCapture && intentCapture) {\n        return { cursorCapture, intentCapture }\n    }\n\n    // If we didn't find a multinode intent, use the most nested atomic capture group.\n    // Atomic capture groups are matches with one node and `!` at the end the capture group name.\n    const atomicCapture = findLast(captures, capture => {\n        const enclosesCursor =\n            (capture.node.startPosition.column <= cursor.column ||\n                capture.node.startPosition.row < cursor.row) &&\n            (cursor.column <= capture.node.endPosition.column ||\n                cursor.row < capture.node.endPosition.row)\n\n        return capture.name.endsWith('!') && enclosesCursor\n    })\n\n    if (atomicCapture) {\n        return {\n            intentCapture: {\n                ...atomicCapture,\n                // Remove `!` from the end of the capture name.\n                name: atomicCapture.name.slice(0, -1),\n            },\n        }\n    }\n\n    return emptyResult\n}\n\nfunction sortByIntentPriority(captures: QueryCapture[]): QueryCapture[] {\n    return captures.sort((a, b) => {\n        return (\n            intentPriority.indexOf(withoutCursorSuffix(a.name) as CompletionIntent) -\n            intentPriority.indexOf(withoutCursorSuffix(b.name) as CompletionIntent)\n        )\n    })\n}\n\nfunction withoutCursorSuffix(name?: string): string | undefined {\n    return name?.split('.').slice(0, -1).join('.')\n}\n\nfunction getTriggerNodeWithBlockStaringAtPoint(\n    captures: QueryCapture[],\n    point: Point\n): { trigger?: SyntaxNode; block?: SyntaxNode } {\n    const emptyResult = {\n        trigger: undefined,\n        block: undefined,\n    }\n\n    if (!captures.length) {\n        return emptyResult\n    }\n\n    const blockStart = getNodeIfMatchesPoint({\n        captures,\n        name: 'block_start',\n        // Taking the last result to get the most nested node.\n        // See https://github.com/tree-sitter/tree-sitter/discussions/2067\n        index: -1,\n        point,\n    })\n\n    const trigger = getCapturedNodeAt({\n        captures,\n        name: 'trigger',\n        index: -1,\n    })\n\n    const block = blockStart?.parent\n\n    if (!blockStart || !block || !trigger) {\n        return emptyResult\n    }\n\n    // Verify that the block node ends at the same position as the trigger node.\n    if (trigger.endIndex !== block?.endIndex) {\n        return emptyResult\n    }\n\n    return { trigger, block }\n}\n\ninterface GetNodeIfMatchesPointParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n    point: Point\n}\n\nfunction getNodeIfMatchesPoint(params: GetNodeIfMatchesPointParams): SyntaxNode | null {\n    const { captures, name, index, point } = params\n\n    const node = getCapturedNodeAt({ captures, name, index })\n\n    if (node && node.startPosition.column === point.column && node.startPosition.row === point.row) {\n        return node\n    }\n\n    return null\n}\n\ninterface GetCapturedNodeAtParams {\n    captures: QueryCapture[]\n    name: string\n    index: number\n}\n\nfunction getCapturedNodeAt(params: GetCapturedNodeAtParams): SyntaxNode | null {\n    const { captures, name, index } = params\n\n    return captures.filter(capture => capture.name === name).at(index)?.node || null\n}\n\n/**\n * Consider a block empty if it does not have any named children or is missing its closing tag.\n */\nfunction isBlockNodeEmpty(node: SyntaxNode | null): boolean {\n    // Consider a node empty if it does not have any named children.\n    const isBlockEmpty = node?.children.filter(c => c.isNamed()).length === 0\n    const isMissingBlockEnd = Boolean(node?.lastChild?.isMissing())\n\n    return isBlockEmpty || isMissingBlockEnd\n}\n\ninterface QueryPoints {\n    startPoint: Point\n    endPoint: Point\n}\n\nexport function positionToQueryPoints(position: Pick<Position, 'line' | 'character'>): QueryPoints {\n    const startPoint = {\n        row: position.line,\n        column: position.character,\n    }\n\n    const endPoint = {\n        row: position.line,\n        // Querying around one character after trigger position.\n        column: position.character + 1,\n    }\n\n    return { startPoint, endPoint }\n}\n\ntype ExecQueryWrapperParams<T> = {\n    queryWrapper: T\n} & (\n    | {\n          document: TextDocument\n          queryPoints: QueryPoints\n      }\n    | {\n          document: TextDocument\n          position: Pick<Position, 'line' | 'character'>\n      }\n    | {\n          tree: Tree\n          languageId: string\n          queryPoints: QueryPoints\n      }\n    | {\n          tree: Tree\n          languageId: string\n          position: Pick<Position, 'line' | 'character'>\n      }\n)\n\nexport function execQueryWrapper<T extends keyof QueryWrappers>(\n    params: ExecQueryWrapperParams<T>\n): ReturnType<QueryWrappers[T]> | never[] {\n    const { queryWrapper } = params\n\n    const treeToQuery =\n        'document' in params ? getCachedParseTreeForDocument(params.document)?.tree : params.tree\n    const languageId = 'document' in params ? params.document.languageId : params.languageId\n    const documentQuerySDK = getDocumentQuerySDK(languageId as SupportedLanguage)\n\n    const queryPoints =\n        'position' in params ? positionToQueryPoints(params.position) : params.queryPoints\n    const { startPoint, endPoint } = queryPoints\n\n    if (documentQuerySDK && treeToQuery) {\n        return documentQuerySDK.queries[queryWrapper](\n            treeToQuery.rootNode,\n            startPoint,\n            endPoint\n        ) as ReturnType<QueryWrappers[T]>\n    }\n\n    return []\n}\n\nexport type { CompletionIntent }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:7525-7552"",""content"":""      '@esbuild/linux-arm64': 0.20.2\n      '@esbuild/linux-ia32': 0.20.2\n      '@esbuild/linux-loong64': 0.20.2\n      '@esbuild/linux-mips64el': 0.20.2\n      '@esbuild/linux-ppc64': 0.20.2\n      '@esbuild/linux-riscv64': 0.20.2\n      '@esbuild/linux-s390x': 0.20.2\n      '@esbuild/linux-x64': 0.20.2\n      '@esbuild/netbsd-x64': 0.20.2\n      '@esbuild/openbsd-x64': 0.20.2\n      '@esbuild/sunos-x64': 0.20.2\n      '@esbuild/win32-arm64': 0.20.2\n      '@esbuild/win32-ia32': 0.20.2\n      '@esbuild/win32-x64': 0.20.2\n    dev: true\n\n  /escalade@3.1.1:\n    resolution: {integrity: sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==}\n    engines: {node: '>=6'}\n\n  /escalade@3.1.2:\n    resolution: {integrity: sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA==}\n    engines: {node: '>=6'}\n    dev: true\n\n  /escape-html@1.0.3:\n    resolution: {integrity: sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/embeddings-protocol.ts:0-125"",""content"":""/**\n * The protocol for communicating between Cody and local embeddings.\n */\n\ninterface InitializeParams {\n    codyGatewayEndpoint: string\n    indexPath: string\n    chunkingPolicy?: ChunkingPolicy\n}\n\ninterface ChunkingPolicy {\n    maxFileSizeBytes: number\n    pathsToExcludeRegexp: string\n}\n\ninterface QueryParams {\n    repoName: string\n    query: string\n    numResults: number\n}\n\nexport interface QueryResultSet {\n    results: QueryResult[]\n}\n\ninterface QueryResult {\n    fileName: string\n    startLine: number\n    endLine: number\n    content: string\n}\n\ninterface IndexHealthRequest {\n    // The name of the repository to scrutinize the index for. Note, this\n    // is a repo name, like github.com/sourcegraph/cody, not a file path.\n    repoName: string\n}\n\ntype IndexHealthResult = IndexHealthResultFound | IndexHealthResultNotFound\n\nexport interface IndexHealthResultFound {\n    type: 'found'\n    repoName: string\n    format: 'App' | 'LocalEmbeddings'\n    commit: string\n    model: string\n    dimension: number\n    numItems: number\n    numItemsDeleted: number\n    numItemsNeedEmbedding: number\n    numItemsFailed: number\n    numFiles: number\n}\n\ninterface IndexHealthResultNotFound {\n    type: 'notFound'\n    repoName: string\n}\n\nexport interface IndexRequest {\n    repoPath: string\n    mode: IndexRequestMode\n}\n\ntype IndexRequestMode = IndexRequestModeNew | IndexRequestModeContinue\n\ninterface IndexRequestModeNew {\n    type: 'new'\n    model: string\n    dimension: number\n}\n\ninterface IndexRequestModeContinue {\n    type: 'continue'\n}\n\ninterface IndexResult {\n    repoName: string\n}\n\ninterface LoadResult {\n    repoName: string\n}\nexport type Requests = {\n    'embeddings/echo': [string, string]\n    // Instruct local embeddings to index the specified repository path.\n    'embeddings/index': [IndexRequest, IndexResult]\n    // Get statistics for the index for a given repository name.\n    'embeddings/index-health': [IndexHealthRequest, IndexHealthResult]\n    // Initializes the local embeddings service. You must call this first.\n    'embeddings/initialize': [InitializeParams, Record<string, never>]\n    // Searches for and loads an index for the specified repository name.\n    'embeddings/load': [string, LoadResult]\n    // Queries loaded index.\n    'embeddings/query': [QueryParams, QueryResultSet]\n    // Sets the Sourcegraph access token.\n    'embeddings/set-token': [string, Record<string, never>]\n    // Shuts down the local embeddings service.\n    'embeddings/shutdown': [Record<string, never>, Record<string, never>]\n}\n\ntype ProgressValue = Progress | ProgressError | ProgressDone\n\ninterface Progress {\n    type: 'progress'\n    currentPath: string\n    repoName: string\n    repoPath: string\n    numItems: number\n    totalItems: number\n}\n\ninterface ProgressDone {\n    type: 'done'\n    repoName: string\n}\n\ninterface ProgressError {\n    type: 'error'\n    repoName: string\n    message: string\n}\nexport type Notifications = {\n    'embeddings/progress': [ProgressValue]\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:962-993"",""content"":""        \""cody.experimental.simpleChatContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Uses the new simplifed chat context fetcher\"",\n          \""default\"": true\n        },\n        \""cody.experimental.ollamaChat\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable local Ollama models for chat and commands\"",\n          \""default\"": false\n        },\n        \""cody.experimental.symfContext\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable symf code search context for chat\"",\n          \""default\"": true\n        },\n        \""cody.experimental.symf.path\"": {\n          \""order\"": 99,\n          \""type\"": \""string\"",\n          \""markdownDescription\"": \""Path to symf binary\"",\n          \""default\"": \""\""\n        },\n        \""cody.experimental.tracing\"": {\n          \""order\"": 99,\n          \""type\"": \""boolean\"",\n          \""markdownDescription\"": \""Enable OpenTelemetry tracing\"",\n          \""default\"": false\n        },\n        \""cody.debug.verbose\"": {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:279-311"",""content"":""    public async searchModelSpecificEmbeddings(\n        text: PromptString,\n        numResults: number\n    ): Promise<ContextItem[]> {\n        return wrapInActiveSpan('chat.context.model-specific-embeddings.local', async () => {\n            logDebug(\n                'SimpleChatPanelProvider',\n                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:111-118"",""content"":""    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/local-embeddings.ts:30-58"",""content"":""\nexport type LocalEmbeddingsConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'accessToken'\n> & {\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nfunction getIndexLibraryPath(): FileURI {\n    switch (process.platform) {\n        case 'darwin':\n            return URI.file(`${process.env.HOME}/Library/Caches/com.sourcegraph.cody/embeddings`)\n        case 'linux':\n            return URI.file(`${process.env.HOME}/.cache/com.sourcegraph.cody/embeddings`)\n        case 'win32':\n            return URI.file(`${process.env.LOCALAPPDATA}\\\\com.sourcegraph.cody\\\\embeddings`)\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`)\n    }\n}\n\ninterface RepoState {\n    repoName: string | false\n    indexable: boolean\n    errorReason: GetFieldType<LocalEmbeddingsProvider, 'errorReason'>\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/testutils/uri.ts:72-74"",""content"":""    public get query(): string {\n        return this.uri.query\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/models/types.ts:0-62"",""content"":""import type { ModelProvider } from '.'\n\nexport enum ModelUsage {\n    Chat = 'chat',\n    Edit = 'edit',\n}\n\n// Utility to narrow a model type to a specific model usage\ntype HasUsage<T, I> = T extends { usage: readonly ModelUsage[] }\n    ? I extends T['usage'][number]\n        ? T\n        : never\n    : never\n\ntype Models = typeof ModelProvider\n\n/**\n * Available models for Edit.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type EditModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Edit>\n      }[keyof Models]['model']\n    | (string & {})\n\n/**\n * Available models for Chat.\n * This is either:\n * - one of the availble options (dotcom)\n * - an unknown `string` (enterprise)\n */\nexport type ChatModel =\n    | {\n          [K in keyof Models]: HasUsage<Models[K], ModelUsage.Chat>\n      }[keyof Models]['model']\n    | (string & {})\n\nexport interface ModelContextWindow {\n    /**\n     * The token limit reserved for chat input.\n     */\n    input: number\n    /**\n     * The maximum number of tokens that the model can respond with in a single request.\n     */\n    output: number\n    /**\n     * The additional tokens reserved for context.\n     * When not defined, context shares the same token limit as input.\n     */\n    context?: {\n        /**\n         * The token limit reserved for user-added context.\n         * Example: @-mentions.\n         */\n        user?: number\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.ts:2-2"",""content"":""export const MODEL = 'anthropic/claude-3-haiku-20240307'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:226-254"",""content"":""    }\n\n    public async retrieveEmbeddingBasedContext(\n        query: PromptString,\n        numResults: number,\n        modelName: string\n    ): Promise<EmbeddingsSearchResult[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return []\n        }\n        try {\n            const service = await this.getService()\n            const resp = await service.request('context-ranking/context-retriever-embedding', {\n                repoPath: repoUri.path,\n                query: query.toString(),\n                modelName: modelName,\n                numResults: numResults,\n            })\n            const model_specific_embedding_items = resp.results.map(result => ({\n                ...result,\n                uri: vscode.Uri.joinPath(repoUri, result.fileName),\n            }))\n            return model_specific_embedding_items\n        } catch (error) {\n            logDebug(\n                'ContextRankingController',\n                'error in fetching embeddings features',\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:286-313"",""content"":""                'getEnhancedContext > searching model specific embeddings'\n            )\n            const contextItems: ContextItem[] = []\n            const modelName = 'sentence-transformers/multi-qa-mpnet-base-dot-v1'\n            const embeddingsResults = await this.retrieveEmbeddingBasedContext(\n                text,\n                numResults,\n                modelName\n            )\n            for (const result of embeddingsResults) {\n                const range = new vscode.Range(\n                    new vscode.Position(result.startLine, 0),\n                    new vscode.Position(result.endLine, 0)\n                )\n\n                contextItems.push({\n                    type: 'file',\n                    uri: result.uri,\n                    range,\n                    content: result.content,\n                    source: ContextItemSource.Embeddings,\n                })\n            }\n            return contextItems\n        })\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/context-ranking-protocol.ts:0-57"",""content"":""import type { QueryResultSet } from './embeddings-protocol'\n\ninterface InitializeParams {\n    indexPath: string\n    accessToken: string\n}\n\ninterface ComputeFeaturesParams {\n    repoPath: string\n}\n\nexport interface RankContextItem {\n    documentId: number\n    filePath?: string\n    content: string\n    source?: string\n}\n\ninterface RankItemsParams {\n    repoPath: string\n    query: string\n    contextItems: RankContextItem[]\n}\n\ninterface RankerPredictions {\n    prediction: RankerPrediction[]\n}\n\nexport interface RankerPrediction {\n    document_id: number\n    score: number\n}\n\nexport interface EmbeddingModelQueryParams {\n    repoPath: string\n    query: string\n    modelName: string\n    numResults: number\n}\n\nexport interface PrecomputeEmbeddingsParams {\n    query: string\n}\n\nexport type Requests = {\n    'context-ranking/echo': [string, string]\n    'context-ranking/initialize': [InitializeParams, string]\n    'context-ranking/compute-features': [ComputeFeaturesParams, string]\n    'context-ranking/rank-items': [RankItemsParams, RankerPredictions]\n    'context-ranking/context-retriever-embedding': [EmbeddingModelQueryParams, QueryResultSet]\n    'context-ranking/precompute-query-embedding': [PrecomputeEmbeddingsParams, string]\n}\n\nexport type Notifications = {\n    'context-ranking/rank-items-logger-payload': [string]\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_020/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The functionality for running `symf` is primarily located in the `SymfRunner` class defined in the file:

```
cody_test/vscode/src/local-context/symf.ts
```

Here's a breakdown of how it works:

1. **Initialization:** The `SymfRunner` constructor takes care of setting up the index root directory and other necessary dependencies.
2. **Configuration:** The `setSourcegraphAuth` method allows updating the Sourcegraph server endpoint and authentication token used by `symf`.
3. **Query Execution:** The `getResults` method is responsible for executing user queries. It expands the query, handles multiple scope directories, and invokes `getResultsForScopeDir` for each directory.
4. **Index Management:** The `ensureIndex`, `deleteIndex`, and `reindexIfStale` methods manage the `symf` index for each scope directory. They handle index creation, deletion, and updates based on freshness.
5. **Querying the Index:** The `unsafeRunQuery` method executes a query against a specific index and returns the raw output from `symf`.
6. **Result Parsing:** The `parseSymfStdout` function parses the raw output from `symf` into a structured `Result` array.

Additionally, the `download-symf.ts` file handles downloading and extracting the `symf` binary if it's not found in the user-specified path or the default installation directory.",Where is the functionality for running symf?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:34-86"",""content"":""export async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n        return null\n    } finally {\n        downloadLock.release()\n    }\n\n    return symfPath\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589"",""content"":""      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:565-582"",""content"":""\n### Changed\n\n- Settings: Relabel \""symf Context\"" as \""Search Context\"". [pull/2285](https://github.com/sourcegraph/cody/pull/2285)\n- Chat: Removed 'Chat Suggestions' setting. [pull/2284](https://github.com/sourcegraph/cody/pull/2284)\n- Edit: Completed edits are no longer scrolled back into view in the active file. [pull/2297](https://github.com/sourcegraph/cody/pull/2297)\n- Chat: Update welcome message. [pull/2298](https://github.com/sourcegraph/cody/pull/2298)\n- Edit: Decorations are no longer shown once an edit has been applied. [pull/2304](https://github.com/sourcegraph/cody/pull/2304)\n\n## [0.18.4]\n\n### Added\n\n### Fixed\n\n- Fixes an issue where the sidebar would not properly load when not signed in. [pull/2267](https://github.com/sourcegraph/cody/pull/2267)\n- Fixes an issue where telemetry events were not properly logged with the new chat experience. [pull/2291](https://github.com/sourcegraph/cody/pull/2291)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30"",""content"":""export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:62-67"",""content"":""\n        onConfigurationChange: setCustomAgent,\n        extensionClient,\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/isRunningInsideAgent.ts:2-4"",""content"":""export function isRunningInsideAgent(): boolean {\n    return vscode.workspace.getConfiguration().get<boolean>('cody.advanced.agent.running', false)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14"",""content"":""const symfVersion = 'v0.0.9'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:543-580"",""content"":""function parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59"",""content"":""import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125"",""content"":""async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:46-62"",""content"":""\n    return activateCommon(context, {\n        createLocalEmbeddingsController: isLocalEmbeddingsDisabled\n            ? undefined\n            : (config: LocalEmbeddingsConfig): LocalEmbeddingsController =>\n                  createLocalEmbeddingsController(context, config),\n        createContextRankingController: (config: ContextRankerConfig) =>\n            createContextRankingController(context, config),\n        createCompletionsClient: (...args) => new SourcegraphNodeCompletionsClient(...args),\n        createCommandsProvider: () => new CommandsProvider(),\n        createSymfRunner: (...args) => new SymfRunner(...args),\n        createBfgRetriever: () => new BfgRetriever(context),\n        createSentryService: (...args) => new NodeSentryService(...args),\n        createOpenTelemetryService: (...args) => new OpenTelemetryService(...args),\n        getRemoteUrlGetters: () => [gitRemoteUrlFromGitCli],\n        startTokenReceiver: (...args) => startTokenReceiver(...args),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162"",""content"":""async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:49-486"",""content"":""export class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:630-642"",""content"":""function toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \""cody.experimental.symf.path\"" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_021/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code that interacts with the `symf` binary is primarily located in the `SymfRunner` class, found in `cody_test/vscode/src/local-context/symf.ts`.

Here's a breakdown of how the interaction happens:

1. **Getting the `symf` path:**
   - The `getSymfPath` function in `cody_test/vscode/src/local-context/download-symf.ts` is responsible for determining the path to the `symf` binary. 
   - It first checks if a user-specified path is set in the settings (`cody.experimental.symf.path`).
   - If not, it attempts to download the appropriate `symf` binary based on the user's OS and architecture.

2. **Using `symf` in `SymfRunner`:**
   - The `SymfRunner` class in `cody_test/vscode/src/local-context/symf.ts` uses the `symf` binary to index the codebase and provide local context for code navigation and search.
   - The `getSymfInfo` function retrieves the `symf` path, access token, and server endpoint.
   - The `indexWorkspace` function spawns a child process using `node` to execute the `symf` command with appropriate arguments.
   - The code then waits for the `symf` process to finish and handles any errors.

3. **Enabling `symf`:**
   - The `main.ts` file in `cody_test/vscode/src/main.ts` shows how `symf` is enabled based on the `config.experimentalSymfContext` setting.
   - If enabled, it creates a `SearchViewProvider` that utilizes the `SymfRunner` for local context.

In summary, the `SymfRunner` class in `symf.ts` is the primary point of interaction with the `symf` binary, using it to index the codebase and provide local context for Cody's features.",Where is the code that interacts with symf  binary ?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/non-stop/FixupTask.ts:59-79"",""content"":""\n    constructor(\n        /**\n         * The file that will be updated by Cody with the replacement text at the end of stream\n         * This is set by the FixupController when creating the task,\n         * and will be updated by the FixupController for tasks using the 'new' mode\n         */\n        public fixupFile: FixupFile,\n        public readonly instruction: PromptString,\n        public readonly userContextItems: ContextItem[],\n        /* The intent of the edit, derived from the source of the command. */\n        public readonly intent: EditIntent,\n        /* The range being edited. This range is tracked and updates as the user (or Cody) edits code. */\n        public selectionRange: vscode.Range,\n        /* The mode indicates how code should be inserted */\n        public readonly mode: EditMode,\n        public readonly model: EditModel,\n        /* the source of the instruction, e.g. 'code-action', 'doc', etc */\n        public source?: EventSource,\n        /* The file to write the edit to. If not provided, the edit will be applied to the fixupFile. */\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61"",""content"":""    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/edit.ts:7-29"",""content"":""    public provideCodeActions(document: vscode.TextDocument): vscode.CodeAction[] {\n        const editor = vscode.window.activeTextEditor\n\n        if (!editor) {\n            return []\n        }\n\n        if (\n            editor.selection.isEmpty &&\n            !document.lineAt(editor.selection.start.line).isEmptyOrWhitespace\n        ) {\n            // Empty selection but a non-empty line, show nothing as the user likely won't want to generate here.\n            return []\n        }\n\n        if (editor.selection.isEmpty) {\n            // Empty selection and empty line, show generate action\n            return [this.createGenerateCodeAction(document, editor.selection)]\n        }\n\n        // Non-empty selection, show edit action\n        return [this.createEditCommandCodeAction(document, editor.selection)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-workspace.yaml:0-6"",""content"":""packages:\n  - agent\n  - cli\n  - lib/*\n  - vscode\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/explain.ts:7-21"",""content"":""    public provideCodeActions(\n        document: vscode.TextDocument,\n        range: vscode.Range,\n        context: vscode.CodeActionContext\n    ): vscode.CodeAction[] {\n        const diagnostics = context.diagnostics.filter(\n            diagnostic =>\n                diagnostic.severity === vscode.DiagnosticSeverity.Error ||\n                diagnostic.severity === vscode.DiagnosticSeverity.Warning\n        )\n        if (diagnostics.length === 0) {\n            return []\n        }\n        return [this.createCommandCodeAction(document.uri, diagnostics)]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/queries/typescript/context.scm:0-12"",""content"":"";; Inherits from javascript/context.scm\n\n((function_declaration\n   name: (_) @name\n   (formal_parameters (_ (type_annotation) @search)))\n (#search! \""type_identifier\""))\n\n((variable_declarator\n  name: (_) @name\n  type: (type_annotation) @search)\n (#search! \""type_identifier\""))\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/test.ts:8-38"",""content"":""    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] {\n        const [testableNode] = execQueryWrapper({\n            document,\n            position: range.start,\n            queryWrapper: 'getTestableNode',\n        })\n        if (!testableNode) {\n            return []\n        }\n\n        const { range: testableRange, symbol: testableSymbol } = testableNode\n        if (!testableSymbol || !testableRange) {\n            return []\n        }\n\n        // Expand the range from the node to include the full line\n        const editorRange = new vscode.Range(\n            testableRange.node.startPosition.row,\n            testableRange.node.startPosition.column,\n            testableRange.node.endPosition.row,\n            testableRange.node.endPosition.column\n        )\n\n        return [\n            this.createCommandCodeAction(\n                document,\n                editorRange,\n                `Cody: Generate Tests for ${testableSymbol.node.text}`\n            ),\n        ]\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:433-461"",""content"":""\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:10-12"",""content"":""interface CodeActionProviderOptions {\n    contextProvider: ContextProvider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183"",""content"":""        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:14-54"",""content"":""export class CodeActionProvider implements vscode.Disposable {\n    private configurationChangeListener: vscode.Disposable\n    private actionProviders: vscode.Disposable[] = []\n\n    constructor(options: CodeActionProviderOptions) {\n        this.registerCodeActions(options.contextProvider.config)\n        this.configurationChangeListener = options.contextProvider.configurationChangeEvent.event(() => {\n            this.registerCodeActions(options.contextProvider.config)\n        })\n    }\n\n    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n    }\n\n    private addActionProvider(ActionType: {\n        new (): vscode.CodeActionProvider\n        providedCodeActionKinds: vscode.CodeActionKind[]\n    }): void {\n        const provider = vscode.languages.registerCodeActionsProvider('*', new ActionType(), {\n            providedCodeActionKinds: ActionType.providedCodeActionKinds,\n        })\n        this.actionProviders.push(provider)\n    }\n\n    public dispose(): void {\n        this.configurationChangeListener.dispose()\n        vscode.Disposable.from(...this.actionProviders).dispose()\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285"",""content"":""    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:91-109"",""content"":""    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:0-27"",""content"":""import * as fs from 'node:fs'\nimport fspromises from 'node:fs/promises'\nimport * as os from 'node:os'\nimport * as path from 'node:path'\n\nimport axios from 'axios'\nimport * as unzipper from 'unzipper'\nimport * as vscode from 'vscode'\n\nimport { Mutex } from 'async-mutex'\nimport { logDebug } from '../log'\nimport { getOSArch } from '../os'\nimport { captureException } from '../services/sentry/sentry'\n\nconst symfVersion = 'v0.0.9'\n\n/**\n * Get the path to `symf`. If the symf binary is not found, download it.\n */\nexport async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/recordings/enterpriseClient_3965582033/recording.har.yaml:153-182"",""content"":""\n\n                  ## Debugging the agent\n\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file\n                  /agent/src/__tests__/example-ts/src/squirrel.ts in repository\n                  github.com/sourcegraph/cody:\n\n                  ```typescript\n\n                  /**\n                   * Squirrel is an interface that mocks something completely unrelated to squirrels.\n                   * It is related to the implementation of precise code navigation in Sourcegraph.\n                   */\n                  export interface Squirrel {}\n\n                  ```\n              - speaker: assistant\n                text: Ok.\n              - speaker: human\n                text: >-\n                  Codebase context from file /.bazelignore in repository\n                  github.com/sourcegraph/sourcegraph:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567"",""content"":""            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70"",""content"":""                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63"",""content"":""    \""update-symf-recordings\"": \""rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\""\n  },\n  \""devDependencies\"": {\n    \""@biomejs/biome\"": \""1.5.2\"",\n    \""@sourcegraph/tsconfig\"": \""^4.0.1\"",\n    \""@storybook/addon-essentials\"": \""^8.0.5\"",\n    \""@storybook/react\"": \""^8.0.5\"",\n    \""@storybook/react-vite\"": \""^8.0.5\"",\n    \""@testing-library/jest-dom\"": \""^6.4.2\"",\n    \""@testing-library/react\"": \""^14.2.2\"",\n    \""@types/node\"": \""20.12.7\"",\n    \""@types/react\"": \""18.2.79\"",\n    \""@types/react-dom\"": \""18.2.25\"",\n    \""@vitejs/plugin-react\"": \""^4.2.1\"",\n    \""esbuild\"": \""^0.18.20\"",\n    \""happy-dom\"": \""^14.3.10\"",\n    \""jsdom\"": \""^22.1.0\"",\n    \""knip\"": \""^3.13.2\"",\n    \""storybook\"": \""^8.0.5\"",\n    \""stylelint\"": \""^15.11.0\"",\n    \""stylelint-config-standard\"": \""^34.0.0\"",\n    \""ts-node\"": \""^10.9.2\"",\n    \""typescript\"": \""^5.4.2\"",\n    \""vite\"": \""^5.2.9\"",\n    \""vitest\"": \""^1.5.0\""\n  },\n  \""dependencies\"": {\n    \""ignore\"": \""^5.3.1\"",\n    \""react\"": \""18.2.0\"",\n    \""react-dom\"": \""18.2.0\""\n  },\n  \""packageManager\"": \""pnpm@8.6.7\"",\n  \""resolutions\"": {\n    \""tslib\"": \""2.1.0\""\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:67-102"",""content"":""\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012"",""content"":""        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80"",""content"":""\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \""${symfPath}\""`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:164-170"",""content"":""async function removeOldSymfBinaries(containingDir: string, currentSymfPath: string): Promise<void> {\n    const symfDirContents = await fspromises.readdir(containingDir)\n    const oldSymfBinaries = symfDirContents.filter(f => f.startsWith('symf-') && f !== currentSymfPath)\n    for (const oldSymfBinary of oldSymfBinaries) {\n        await fspromises.rm(path.join(containingDir, oldSymfBinary))\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55"",""content"":""\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_022/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_023/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"Based on your provided code snippets, the context length limit is enforced in a few key areas:

**1. `cody_test/lib/shared/src/prompt/truncation.ts`:**

- **`truncateTextNearestLine`**: This function truncates text content to a maximum number of bytes, ensuring it ends at a line boundary. This is likely used to fit context items within a specific size limit.

**2. `mocked/codebase_context/limit.go`:**

- **`limitMatches`**: This function appears to limit the number of matches returned for a file, potentially based on lines or chunks.
- **`limitLineMatches`**: This function specifically limits the number of line fragments within each line match.
- **`limitChunkMatches`**: This function limits the number of ranges within each chunk match, also adjusting content and symbol information accordingly.

**3. `cody_test/vscode/src/completions/providers/provider.ts`:**

- **`standardContextSizeHints`**: This function calculates context size hints based on a maximum token count. It allocates proportions for the prefix, suffix, and total characters, likely influencing how much context is gathered.

**4. `cody_test/lib/shared/src/token/constants.ts`:**

- This file defines various token budget constants, such as `CHAT_INPUT_TOKEN_BUDGET`, `FAST_CHAT_INPUT_TOKEN_BUDGET`, and `ENHANCED_CONTEXT_ALLOCATION`. These constants likely determine the overall limits for different context components.

**5. Other Relevant Snippets:**

- **`cody_test/vscode/src/chat/utils.ts`**: `getContextWindowLimitInBytes` likely calculates the context window limit, potentially considering message history and a maximum character count.
- **`cody_test/vscode/src/chat/chat-view/prompt.ts`**: This code snippet suggests that transcript messages and user-specified context items are added until a certain limit is reached.

**In Summary:**

The context length limit enforcement is a combination of:

- **Token-based limits:** Defined in `constants.ts` and used for calculating context size hints.
- **Character/Byte limits:** Used in `truncateTextNearestLine` and potentially in other areas to truncate content.
- **Match/Item limits:** Implemented in `limit.go` to restrict the number of matches or items returned.

The specific implementation details and how these mechanisms interact might require further investigation within the codebase.",Where is the code that enforces the context length limit?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:164-169"",""content"":""type updateOnErrorLimiter struct {\n\tlogger log.Logger\n\tactor  *Actor\n\n\tnextLimiter limiter.Limiter\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/directory.ts:49-74"",""content"":""\n                // check file size before opening the file. skip file if it's larger than 1MB\n                const fileSize = await vscode.workspace.fs.stat(fileUri)\n                if (fileSize.size > 1000000 || !fileSize.size) {\n                    continue\n                }\n\n                const bytes = await vscode.workspace.fs.readFile(fileUri)\n                const content = new TextDecoder('utf-8').decode(bytes)\n                const range = new vscode.Range(0, 0, content.split('\\n').length - 1 || 0, 0)\n                const size = TokenCounter.countTokens(content)\n\n                contextFiles.push({\n                    type: 'file',\n                    uri: fileUri,\n                    content,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                })\n\n                // Limit the number of files to 10\n                const maxResults = 10\n                if (contextFiles.length >= maxResults) {\n                    return contextFiles\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:132-134"",""content"":""func (l *concurrencyLimiter) Usage(ctx context.Context) (int, time.Time, error) {\n\treturn l.nextLimiter.Usage(ctx)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/AgentTextDocument.ts:91-122"",""content"":""            ),\n            rangeIncludingLineBreak: new vscode_shim.Range(\n                new vscode_shim.Position(line, 0),\n                new vscode_shim.Position(line, text.length + this.offsets.newlineLength(line))\n            ),\n            text,\n        }\n    }\n\n    public offsetAt(position: vscode.Position | protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public protocolOffsetAt(position: protocol.Position): number {\n        return this.offsets.offset(position)\n    }\n\n    public positionAt(offset: number): vscode.Position {\n        const { line, character } = this.offsets.position(offset)\n        return new vscode_shim.Position(line, character)\n    }\n\n    public getText(range?: vscode.Range | undefined): string {\n        if (range === undefined) {\n            return this.content\n        }\n        const start = this.offsets.offset(range.start)\n        const end = this.offsets.offset(range.end)\n        const text = this.content.slice(start, end)\n        return text\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:61-63"",""content"":""func (r *RateLimit) IsValid() bool {\n\treturn r != nil && r.Interval > 0 && r.Limit > 0 && len(r.AllowedModels) > 0\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88"",""content"":""\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:80-125"",""content"":""func limitChunkMatches(file *FileMatch, limit int) int {\n\tfor i := range file.ChunkMatches {\n\t\tcm := &file.ChunkMatches[i]\n\t\tif len(cm.Ranges) > limit {\n\t\t\t// We potentially need to effect the limit upon 3 different fields:\n\t\t\t// Ranges, SymbolInfo, and Content.\n\n\t\t\t// Content is the most complicated: we need to remove the last N\n\t\t\t// lines from it, where N is the difference between the line number\n\t\t\t// of the end of the old last Range and that of the new last Range.\n\t\t\t// This calculation is correct in the presence of both context lines\n\t\t\t// and multiline Ranges, taking into account that Content never has\n\t\t\t// a trailing newline.\n\t\t\tn := cm.Ranges[len(cm.Ranges)-1].End.LineNumber - cm.Ranges[limit-1].End.LineNumber\n\t\t\tif n > 0 {\n\t\t\t\tfor b := len(cm.Content) - 1; b >= 0; b-- {\n\t\t\t\t\tif cm.Content[b] == '\\n' {\n\t\t\t\t\t\tn -= 1\n\t\t\t\t\t}\n\t\t\t\t\tif n == 0 {\n\t\t\t\t\t\tcm.Content = cm.Content[:b]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\t// Should be impossible.\n\t\t\t\t\tlog.Panicf(\""Failed to find enough newlines when truncating Content, %d left over, %d ranges\"", n, len(cm.Ranges))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcm.Ranges = cm.Ranges[:limit]\n\t\t\tif cm.SymbolInfo != nil {\n\t\t\t\t// When non-nil, SymbolInfo is specified to have the same length\n\t\t\t\t// as Ranges.\n\t\t\t\tcm.SymbolInfo = cm.SymbolInfo[:limit]\n\t\t\t}\n\t\t}\n\t\tif len(cm.Ranges) == limit {\n\t\t\tfile.ChunkMatches = file.ChunkMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(cm.Ranges)\n\t}\n\treturn limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:129-143"",""content"":""func limitLineMatches(file *FileMatch, limit int) int {\n\tfor i := range file.LineMatches {\n\t\tlm := &file.LineMatches[i]\n\t\tif len(lm.LineFragments) > limit {\n\t\t\tlm.LineFragments = lm.LineFragments[:limit]\n\t\t}\n\t\tif len(lm.LineFragments) == limit {\n\t\t\tfile.LineMatches = file.LineMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(lm.LineFragments)\n\t}\n\treturn limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/file-path.ts:0-43"",""content"":""import {\n    type ContextItem,\n    ContextItemSource,\n    TokenCounter,\n    logError,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\n/**\n * Generate ContextFile for a file URI.\n */\nexport async function getContextFileFromUri(file: URI, range?: vscode.Range): Promise<ContextItem[]> {\n    return wrapInActiveSpan('commands.context.filePath', async span => {\n        try {\n            const doc = await vscode.workspace.openTextDocument(file)\n            const content = doc?.getText(range).trim()\n            if (!content) {\n                throw new Error('No file content')\n            }\n\n            const startLine = range?.start?.line ?? 0\n            range = new vscode.Range(startLine, 0, startLine + content.split('\\n').length, 0)\n            const size = TokenCounter.countTokens(content)\n\n            return [\n                {\n                    type: 'file',\n                    content,\n                    uri: file,\n                    source: ContextItemSource.Editor,\n                    range,\n                    size,\n                },\n            ] satisfies ContextItem[]\n        } catch (error) {\n            logError('getContextFileFromUri', 'failed', { verbose: error })\n            return []\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:85-99"",""content"":""type concurrencyLimiter struct {\n\tlogger  log.Logger\n\tactor   *Actor\n\tfeature codygateway.Feature\n\n\t// redis must be a prefixed store\n\tredis limiter.RedisStore\n\n\tconcurrentRequests int\n\tconcurrentInterval time.Duration\n\n\tnextLimiter limiter.Limiter\n\n\tnowFunc func() time.Time\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/context/workspace.ts:22-51"",""content"":""\n        const contextFiles: ContextItem[] = []\n\n        // set cancellation token to time out after 20s\n        const token = new CancellationTokenSource()\n        setTimeout(() => {\n            token.cancel()\n        }, 20000)\n\n        try {\n            const results = await workspace.findFiles(globalPattern, excluded, maxResults, token.token)\n\n            for (const result of results) {\n                const decoded = await getDocText(result)\n                const contextFile = await createContextFile(result, decoded)\n\n                if (contextFile) {\n                    contextFiles.push(contextFile)\n                }\n            }\n\n            return contextFiles\n        } catch (error) {\n            logError('getWorkspaceFilesContext failed', `${error}`)\n\n            return contextFiles\n        }\n    })\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:20-36"",""content"":""type RateLimit struct {\n\t// AllowedModels is a set of models in Cody Gateway's model configuration\n\t// format, \""$PROVIDER/$MODEL_NAME\"". A single-item slice with value '*' means\n\t// that all models in the 'master allowlist' are allowed.\n\t//\n\t// DO NOT USE DIRECTLY when enforcing permissions: use EvaluateAllowedModels(...)\n\t// instead.\n\tAllowedModels []string `json:\""allowedModels\""`\n\n\tLimit    int64         `json:\""limit\""`\n\tInterval time.Duration `json:\""interval\""`\n\n\t// ConcurrentRequests, ConcurrentRequestsInterval are generally applied\n\t// with NewRateLimitWithPercentageConcurrency.\n\tConcurrentRequests         int           `json:\""concurrentRequests\""`\n\tConcurrentRequestsInterval time.Duration `json:\""concurrentRequestsInterval\""`\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:175-199"",""content"":""        }\n\n        for (let snippetsToInclude = 0; snippetsToInclude < snippets.length + 1; snippetsToInclude++) {\n            if (snippetsToInclude > 0) {\n                const snippet = snippets[snippetsToInclude - 1]\n                const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n                if (contextPrompts.symbol) {\n                    intro.push(\n                        ps`Additional documentation for \\`${contextPrompts.symbol}\\`:\\n\\n${contextPrompts.content}`\n                    )\n                } else {\n                    intro.push(\n                        ps`Here is a reference snippet of code from ${PromptString.fromDisplayPath(\n                            snippet.uri\n                        )}:\\n\\n${contextPrompts.content}`\n                    )\n                }\n            }\n\n            const introString = ps`${PromptString.join(\n                PromptString.join(intro, ps`\\n\\n`)\n                    .split('\\n')\n                    .map(line => ps`${languageConfig ? languageConfig.commentStart : ps`// `}${line}`),\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/context.ts:39-61"",""content"":""    const truncatedPrecedingText = truncatePromptStringStart(precedingText, MAX_CURRENT_FILE_TOKENS)\n    const truncatedFollowingText = truncatePromptString(followingText, MAX_CURRENT_FILE_TOKENS)\n\n    // Disable no case declarations because we get better type checking with a switch case\n    switch (intent) {\n        /**\n         * The context for the test intent is handled by the executeTestEditCommand function,\n         * we don't need to add additional context here to avoid duplication.\n         */\n        case 'test':\n            return []\n        /**\n         * Very broad set of possible instructions.\n         * Fetch context from the users' instructions and use context from current file.\n         * Include the following code from the current file.\n         * The preceding code is already included as part of the response to better guide the output.\n         */\n        case 'add': {\n            return [\n                {\n                    speaker: 'human',\n                    text: populateCodeGenerationContextTemplate(\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/codebase_context/limit.go:62-76"",""content"":""func limitMatches(files []FileMatch, limit int, chunkMatches bool) ([]FileMatch, int) {\n\tvar limiter func(file *FileMatch, limit int) int\n\tif chunkMatches {\n\t\tlimiter = limitChunkMatches\n\t} else {\n\t\tlimiter = limitLineMatches\n\t}\n\tfor i := range files {\n\t\tlimit = limiter(&files[i], limit)\n\t\tif limit <= 0 {\n\t\t\treturn files[:i+1], 0\n\t\t}\n\t}\n\treturn files, limit\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/provider.ts:27-57"",""content"":""\n    /**\n     * A string identifier for the provider config used in event logs.\n     */\n    identifier: string\n\n    /**\n     * Defines which model is used with the respective provider.\n     */\n    model: string\n}\n\ninterface ProviderContextSizeHints {\n    /** Total max length of all context (prefix + suffix + snippets). */\n    totalChars: number\n\n    /** Max length of the document prefix (text before the cursor). */\n    prefixChars: number\n\n    /** Max length of the document suffix (text after the cursor). */\n    suffixChars: number\n}\n\nexport function standardContextSizeHints(maxContextTokens: number): ProviderContextSizeHints {\n    return {\n        totalChars: Math.floor(tokensToChars(0.9 * maxContextTokens)), // keep 10% margin for preamble, etc.\n        prefixChars: Math.floor(tokensToChars(0.6 * maxContextTokens)),\n        suffixChars: Math.floor(tokensToChars(0.1 * maxContextTokens)),\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57"",""content"":""import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/truncation.ts:25-60"",""content"":"" * which should be ignored anyway).\n */\nexport function truncateTextNearestLine(\n    text: string,\n    maxBytes: number\n): { truncated: string; range?: RangeData } {\n    if (text.length <= maxBytes) {\n        return { truncated: text }\n    }\n    const textMaxBytes = text.slice(0, maxBytes)\n    const textMaxBytesLines = textMaxBytes.split('\\n')\n    if (text.at(maxBytes) === '\\n' || text.at(maxBytes - 1) === '\\n') {\n        return {\n            truncated: textMaxBytes,\n            range: {\n                start: { line: 0, character: 0 },\n                end: { line: textMaxBytesLines.length, character: 0 },\n            },\n        }\n    }\n\n    const truncated = textMaxBytesLines.slice(0, -1).join('\\n')\n    return {\n        truncated,\n        range: {\n            start: { line: 0, character: 0 },\n            end: { line: textMaxBytesLines.length - 1, character: 0 },\n        },\n    }\n}\n\n/**\n * Truncates text to the given number of tokens, keeping the end of the text.\n */\nexport function truncateTextStart(text: string, maxTokens: number): string {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21"",""content"":""export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:152-163"",""content"":""                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203"",""content"":""import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.ts:57-80"",""content"":""                throw new Error(\n                    `Preamble length exceeded context window size ${chat.contextWindow.input}`\n                )\n            }\n\n            // Add existing chat transcript messages\n            const reverseTranscript: ChatMessage[] = [...chat.getMessages()].reverse()\n            const transcriptLimitReached = promptBuilder.tryAddMessages(reverseTranscript)\n            if (transcriptLimitReached) {\n                logDebug(\n                    'DefaultPrompter.makePrompt',\n                    `Ignored ${transcriptLimitReached} transcript messages due to context limit`\n                )\n            }\n\n            // NOTE: Only display excluded context from user-specifed context items\n            const newContextIgnored: ContextItem[] = []\n            const newContextUsed: ContextItem[] = []\n\n            // Add context from new user-specified context items, e.g. @-mentions, @-uri\n            sortContextItems(this.explicitContext)\n            const {\n                limitReached: userLimitReached,\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73"",""content"":""import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\""presentation\""] div[class*=\""squiggly-error\""]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/utils.ts:104-135"",""content"":""        return 1\n    }\n\n    return 0 // zero refers to the legacy, unversioned, Cody API\n}\n\n/**\n * Counts the total number of bytes used in a list of chat messages.\n *\n * This function is exported and can be used to calculate the byte usage\n * of chat messages for storage/bandwidth purposes.\n *\n * @param messages - The list of chat messages to count bytes for\n * @returns The total number of bytes used in the messages\n */\nexport function countBytesInChatMessages(messages: ChatMessage[]): number {\n    if (messages.length === 0) {\n        return 0\n    }\n    return messages.reduce((acc, msg) => acc + msg.speaker.length + (msg.text?.length || 0) + 3, 0)\n}\n\n/**\n * Gets the context window limit in bytes for chat messages, taking into\n * account the maximum allowed character count. Returns 0 if the used bytes\n * exceeds the limit.\n * @param messages - The chat messages\n * @param maxChars - The maximum allowed character count\n * @returns The context window limit in bytes\n */\nexport function getContextWindowLimitInBytes(messages: ChatMessage[], maxChars: number): number {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/jaccard-similarity/jaccard-similarity-retriever.ts:0-22"",""content"":""import * as vscode from 'vscode'\nimport type { URI } from 'vscode-uri'\n\nimport { getContextRange } from '../../../doc-context-getters'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\nimport { baseLanguageId } from '../../utils'\nimport { type DocumentHistory, VSCodeDocumentHistory } from './history'\n\nimport { lastNLines } from '../../../text-processing'\nimport { type JaccardMatch, bestJaccardMatches } from './bestJaccardMatch'\n\n/**\n * The size of the Jaccard distance match window in number of lines. It determines how many\n * lines of the 'matchText' are considered at once when searching for a segment\n * that is most similar to the 'targetText'. In essence, it sets the maximum number\n * of lines that the best match can be. A larger 'windowSize' means larger potential matches\n */\nconst SNIPPET_WINDOW_SIZE = 50\n\n/**\n * Limits the number of jaccard windows that are fetched for a single file. This is mostly added to\n * avoid large files taking up too much compute time and to avoid a single file to take up too much\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/mocked/enhanced_context/limit.go:138-138"",""content"":""\tlimit      int\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33"",""content"":""import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_024/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The logic for opening a new chat window in the codebase you provided is spread across multiple files and functions. Here's a breakdown:

**1. User Interaction:**

- The user can trigger the ""New Chat"" action from multiple places in the UI, such as the command menu (`command-menu.test.ts`) or a button in the chat view (`Chat.tsx`).

**2. Command Handling:**

- These UI interactions ultimately trigger the `cody.chat.panel.new` command, which is registered in `ChatManager.ts`.

**3. Chat Manager:**

- The `ChatManager` class handles the `cody.chat.panel.new` command by calling the `createNewWebviewPanel()` method.
- Inside `createNewWebviewPanel()`, it uses a debounce function to avoid creating multiple panels in quick succession.
- The debounced function calls `createWebviewPanel()` on the `chatPanelsManager`.

**4. Chat Panels Manager:**

- The `ChatPanelsManager` class is responsible for managing all open chat panels.
- Its `createWebviewPanel()` method first checks if there's an existing empty ""New Chat"" panel it can reuse (`ChatPanelsManager.ts`).
- If not, it creates a new webview panel using VS Code's API and sets up the necessary components for the chat interface.

**5. Simple Chat Panel Provider:**

- The actual creation and setup of the webview panel is delegated to the `SimpleChatPanelProvider` class.
- This class handles loading the chat view HTML, setting up message listeners, and managing the chat session state.

**In short:** The process starts with a user action, gets translated to a command, handled by the Chat Manager, which delegates the panel creation to the Chat Panels Manager, and finally, the Simple Chat Panel Provider sets up the new chat window.",Where is the logic for opening a new chat window?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/helpers.ts:391-394"",""content"":""export async function newChat(page: Page): Promise<FrameLocator> {\n    await page.getByRole('button', { name: 'New Chat', exact: true }).click()\n    return page.frameLocator('iframe.webview').last().frameLocator('iframe')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:77-95"",""content"":""            vscode.commands.registerCommand('cody.chat.history.clear', () => this.clearHistory()),\n            vscode.commands.registerCommand('cody.chat.history.delete', item => this.clearHistory(item)),\n            vscode.commands.registerCommand('cody.chat.history.edit', item =>\n                this.editChatHistory(item)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.new', () => this.createNewWebviewPanel()),\n            vscode.commands.registerCommand('cody.chat.panel.restore', (id, chat) =>\n                this.restorePanel(id, chat)\n            ),\n            vscode.commands.registerCommand('cody.chat.panel.reset', () =>\n                this.chatPanelsManager.resetPanel()\n            ),\n            vscode.commands.registerCommand(CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID, (...args) =>\n                this.passthroughVsCodeOpen(...args)\n            ),\n            vscode.commands.registerCommand('cody.chat.context.add', () => this.sendSelectionToChat())\n        )\n    }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/open-telemetry/OpenTelemetryService.node.ts:0-95"",""content"":""import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\nimport { registerInstrumentations } from '@opentelemetry/instrumentation'\nimport { HttpInstrumentation } from '@opentelemetry/instrumentation-http'\nimport { Resource } from '@opentelemetry/resources'\nimport { NodeTracerProvider } from '@opentelemetry/sdk-trace-node'\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\n\nimport {\n    type ConfigurationWithAccessToken,\n    FeatureFlag,\n    featureFlagProvider,\n} from '@sourcegraph/cody-shared'\n\nimport { DiagConsoleLogger, DiagLogLevel, diag } from '@opentelemetry/api'\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base'\nimport { version } from '../../version'\nimport { ConsoleBatchSpanExporter } from './console-batch-span-exporter'\n\nexport type OpenTelemetryServiceConfig = Pick<\n    ConfigurationWithAccessToken,\n    'serverEndpoint' | 'experimentalTracing' | 'debugVerbose'\n>\n\nexport class OpenTelemetryService {\n    private tracerProvider?: NodeTracerProvider\n    private unloadInstrumentations?: () => void\n\n    private lastTraceUrl: string | undefined\n    // We use a single promise object that we chain on to, to avoid multiple reconfigure calls to\n    // be run in parallel\n    private reconfigurePromiseMutex: Promise<void> = Promise.resolve()\n\n    constructor(protected config: OpenTelemetryServiceConfig) {\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    public onConfigurationChange(newConfig: OpenTelemetryServiceConfig): void {\n        this.config = newConfig\n        this.reconfigurePromiseMutex = this.reconfigurePromiseMutex.then(() => this.reconfigure())\n    }\n\n    private async reconfigure(): Promise<void> {\n        const isEnabled =\n            this.config.experimentalTracing ||\n            (await featureFlagProvider.evaluateFeatureFlag(FeatureFlag.CodyAutocompleteTracing))\n\n        if (!isEnabled) {\n            return\n        }\n\n        const traceUrl = new URL('/-/debug/otlp/v1/traces', this.config.serverEndpoint).toString()\n        if (this.lastTraceUrl === traceUrl) {\n            return\n        }\n        this.lastTraceUrl = traceUrl\n\n        const logLevel = this.config.debugVerbose ? DiagLogLevel.INFO : DiagLogLevel.ERROR\n        diag.setLogger(new DiagConsoleLogger(), logLevel)\n\n        await this.reset()\n\n        this.unloadInstrumentations = registerInstrumentations({\n            instrumentations: [new HttpInstrumentation()],\n        })\n        this.configureTracerProvider(traceUrl)\n    }\n\n    public configureTracerProvider(traceUrl: string): void {\n        this.tracerProvider = new NodeTracerProvider({\n            resource: new Resource({\n                [SemanticResourceAttributes.SERVICE_NAME]: 'cody-client',\n                [SemanticResourceAttributes.SERVICE_VERSION]: version,\n            }),\n        })\n\n        // Add the default tracer exporter used in production.\n        this.tracerProvider.addSpanProcessor(\n            new BatchSpanProcessor(\n                new OTLPTraceExporter({ url: traceUrl, httpAgentOptions: { rejectUnauthorized: false } })\n            )\n        )\n\n        // Add the console exporter used in development for verbose logging and debugging.\n        if (process.env.NODE_ENV === 'development' || this.config.debugVerbose) {\n            this.tracerProvider.addSpanProcessor(new BatchSpanProcessor(new ConsoleBatchSpanExporter()))\n        }\n\n        this.tracerProvider.register()\n    }\n\n    public async reset(): Promise<void> {\n        await this.tracerProvider?.shutdown()\n        this.unloadInstrumentations?.()\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:776-807"",""content"":""            },\n        })\n    }\n\n    /**\n     * Low-level utility to post a message to the webview, pending initialization.\n     *\n     * cody-invariant: this.webview?.postMessage should never be invoked directly\n     * except within this method.\n     */\n    private postMessage(message: ExtensionMessage): Thenable<boolean | undefined> {\n        return this.initDoer.do(() => this.webview?.postMessage(message))\n    }\n\n    private postChatTitle(): void {\n        if (this.webviewPanel) {\n            this.webviewPanel.title = this.chatModel.getChatTitle()\n        }\n    }\n\n    // #endregion\n    // =======================================================================\n    // #region chat request lifecycle methods\n    // =======================================================================\n\n    /**\n     * Constructs the prompt and updates the UI with the context used in the prompt.\n     */\n    private async buildPrompt(\n        prompter: IPrompter,\n        sendTelemetry?: (contextSummary: any, privateContextStats?: any) => void\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.test.ts:0-46"",""content"":""import { describe, expect, test } from 'vitest'\n\nimport { getChatPanelTitle } from './chat-helpers'\n\ndescribe('getChatPanelTitle', () => {\n    test('returns default title when no lastDisplayText', () => {\n        const result = getChatPanelTitle()\n        expect(result).toEqual('New Chat')\n    })\n\n    test('long titles will be truncated', () => {\n        const longTitle = 'This is a very long title that should get truncated by the function'\n        const result = getChatPanelTitle(longTitle)\n        expect(result).toEqual('This is a very long title...')\n    })\n\n    test('keeps command key', () => {\n        const title = '/explain this symbol'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain this symbol')\n    })\n\n    test('keeps command key with file path', () => {\n        const title = '/explain [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('/explain @a.ts')\n    })\n\n    test('removes markdown links', () => {\n        const title = 'Summarize this file [_@a.ts_](a.ts)'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Summarize this file @a.ts')\n    })\n\n    test('removes multiple markdown links', () => {\n        const title = '[_@a.py_](a.py) [_@b.py_](b.py) explain'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('@a.py @b.py explain')\n    })\n\n    test('truncates long title with multiple markdown links', () => {\n        const title = 'Explain the relationship...'\n        const result = getChatPanelTitle(title)\n        expect(result).toEqual('Explain the relationship....')\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:23-48"",""content"":""\n    const heyTreeItem = page.getByRole('treeitem', { name: 'Hey' })\n    const holaTreeItem = page.getByRole('treeitem', { name: 'Hola' })\n\n    const [chatPanelFrame, chatInput] = await createEmptyChatPanel(page)\n\n    await chatInput.fill('Hey')\n    await chatInput.press('Enter')\n\n    // Check if chat shows up in sidebar chat history tree view\n    await expect(heyTreeItem).toBeVisible()\n\n    // Wait at least 1 second to ensure that the 2 chats have different IDs (which are currently\n    // created using `new Date(Date.now()).toUTCString()`, so they are the same if they are\n    // generated in the same second).\n    //\n    // TODO(sqs): investigate and fix the underlying bug here\n    await page.waitForTimeout(1000)\n\n    // Clear and restart chat session\n    // All current messages should be removed, and the panel name should be updated to 'New Chat'\n    await chatInput.fill('/reset')\n    await chatInput.press('Enter')\n    await expect(chatPanelFrame.getByText('Hey')).not.toBeVisible()\n    await expect(page.getByRole('tab', { name: 'New Chat' })).toBeVisible()\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/chat-helpers.ts:0-39"",""content"":""import * as vscode from 'vscode'\n\nimport type { RangeData } from '@sourcegraph/cody-shared'\n\nexport async function openFile(\n    uri: vscode.Uri,\n    range?: RangeData,\n    currentViewColumn?: vscode.ViewColumn\n): Promise<void> {\n    let viewColumn = vscode.ViewColumn.Beside\n    if (currentViewColumn) {\n        viewColumn = currentViewColumn - 1 || currentViewColumn + 1\n    }\n    const doc = await vscode.workspace.openTextDocument(uri)\n    // +1 because selection range starts at 0 while editor line starts at 1\n    const selection = range && new vscode.Range(range.start.line, 0, range.end.line + 1, 0)\n    await vscode.window.showTextDocument(doc, {\n        selection,\n        viewColumn,\n        preserveFocus: true,\n        preview: true,\n    })\n}\n\nexport function getChatPanelTitle(lastHumanText?: string, truncateTitle = true): string {\n    if (!lastHumanText) {\n        return 'New Chat'\n    }\n\n    let text = lastHumanText\n    // Regex to remove the markdown formatted links with this format: '[_@FILENAME_]()'\n    const MARKDOWN_LINK_REGEX = /\\[_(.+?)_]\\((.+?)\\)/g\n    text = text.replaceAll(MARKDOWN_LINK_REGEX, '$1')?.trim()\n    if (!truncateTitle) {\n        return text\n    }\n    // truncate title that is too long\n    return text.length > 25 ? `${text.slice(0, 25).trim()}...` : text\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1017-1043"",""content"":""\n    // #endregion\n    // =======================================================================\n    // #region session management\n    // =======================================================================\n\n    // A unique identifier for this SimpleChatPanelProvider instance used to identify\n    // it when a handle to this specific panel provider is needed.\n    public get sessionID(): string {\n        return this.chatModel.sessionID\n    }\n\n    // Sets the provider up for a new chat that is not being restored from a\n    // saved session.\n    public async newSession(): Promise<void> {\n        // Set the remote search's selected repos to the workspace repo list\n        // by default.\n        this.remoteSearch?.setRepos(\n            (await this.repoPicker?.getDefaultRepos()) || [],\n            RepoInclusion.Manual\n        )\n    }\n\n    // Attempts to restore the chat to the given sessionID, if it exists in\n    // history. If it does, then saves the current session and cancels the\n    // current in-progress completion. If the chat does not exist, then this\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Chat.tsx:48-533"",""content"":""export const Chat: React.FunctionComponent<React.PropsWithChildren<ChatboxProps>> = ({\n    welcomeMessage,\n    messageInProgress,\n    transcript,\n    vscodeAPI,\n    telemetryService,\n    isTranscriptError,\n    chatEnabled,\n    userInfo,\n    guardrails,\n    chatIDHistory,\n    isWebviewActive,\n    isNewInstall,\n    userContextFromSelection,\n}) => {\n    const [messageBeingEdited, setMessageBeingEdited] = useState<number | undefined>(undefined)\n\n    // Display the enhanced context settings on first chats\n    const [isEnhancedContextOpen, setIsEnhancedContextOpen] = useState(isNewInstall)\n\n    const editorRef = useRef<PromptEditorRefAPI>(null)\n    const setEditorState = useCallback((state: SerializedPromptEditorState | null) => {\n        editorRef.current?.setEditorState(state)\n    }, [])\n\n    // The only PromptEditor state we really need to track in our own state is whether it's empty.\n    const [isEmptyEditorValue, setIsEmptyEditorValue] = useState(true)\n    const onEditorChange = useCallback((value: SerializedPromptEditorValue): void => {\n        setIsEmptyEditorValue(!value?.text?.trim())\n    }, [])\n\n    const onAbortMessageInProgress = useCallback(() => {\n        vscodeAPI.postMessage({ command: 'abort' })\n    }, [vscodeAPI])\n\n    const addEnhancedContext = useEnhancedContextEnabled()\n\n    const onSubmit = useCallback(\n        (submitType: WebviewChatSubmitType) => {\n            if (!editorRef.current) {\n                throw new Error('Chat has no editorRef')\n            }\n            const editorValue = editorRef.current.getSerializedValue()\n            if (!editorValue.text.trim()) {\n                throw new Error('Chat message cannot be empty')\n            }\n            // Handle edit requests\n            if (submitType === 'edit') {\n                if (messageBeingEdited === undefined) {\n                    throw new Error('unexpected: messageBeingEdited is undefined')\n                }\n                vscodeAPI.postMessage({\n                    command: 'edit',\n                    index: messageBeingEdited!,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            } else {\n                vscodeAPI.postMessage({\n                    command: 'submit',\n                    submitType,\n                    text: editorValue.text,\n                    editorState: editorValue.editorState,\n                    contextFiles: editorValue.contextItems,\n                    addEnhancedContext,\n                })\n            }\n        },\n        [addEnhancedContext, messageBeingEdited, vscodeAPI]\n    )\n\n    const feedbackButtonsOnSubmit = useCallback(\n        (text: string) => {\n            const eventData = {\n                value: text,\n                lastChatUsedEmbeddings: Boolean(\n                    transcript.at(-1)?.contextFiles?.some(file => file.source === 'embeddings')\n                ),\n                transcript: '',\n            }\n\n            if (userInfo.isDotComUser) {\n                eventData.transcript = JSON.stringify(transcript)\n            }\n\n            telemetryService.log(`CodyVSCodeExtension:codyFeedback:${text}`, eventData)\n        },\n        [telemetryService, transcript, userInfo]\n    )\n\n    const copyButtonOnSubmit = useCallback(\n        (text: string, eventType: 'Button' | 'Keydown' = 'Button') => {\n            const op = 'copy'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const insertButtonOnSubmit = useCallback(\n        (text: string, newFile = false) => {\n            const op = newFile ? 'newFile' : 'insert'\n            const eventType = 'Button'\n            // remove the additional /n added by the text area at the end of the text\n            const code = eventType === 'Button' ? text.replace(/\\n$/, '') : text\n            // Log the event type and text to telemetry in chat view\n            vscodeAPI.postMessage({\n                command: op,\n                eventType,\n                text: code,\n            })\n        },\n        [vscodeAPI]\n    )\n\n    const postMessage = useCallback<ApiPostMessage>(msg => vscodeAPI.postMessage(msg), [vscodeAPI])\n\n    const setInputFocus = useCallback((focus: boolean): void => {\n        editorRef.current?.setFocus(focus)\n    }, [])\n\n    // When New Chat Mode is enabled, all non-edit questions will be asked in a new chat session\n    // Users can toggle this feature via \""shift\"" + \""Meta(Mac)/Control\"" keys\n    const [enableNewChatMode, setEnableNewChatMode] = useState(false)\n\n    const lastHumanMessageIndex = useMemo<number | undefined>(() => {\n        if (!transcript?.length) {\n            return undefined\n        }\n        const index = transcript.findLastIndex(msg => msg.speaker === 'human')\n\n        return index\n    }, [transcript])\n\n    /**\n     * Sets the state to edit a message at the given index in the transcript.\n     * Checks that the index is valid, then gets the display text  to set as the\n     * form input.\n     *\n     * An undefined index number means there is no message being edited.\n     */\n    const setEditMessageState = useCallback(\n        (index?: number): void => {\n            // When a message is no longer being edited\n            // we will reset the form input fill to empty state\n            if (index === undefined && index !== messageBeingEdited) {\n                setEditorState(null)\n            }\n            setMessageBeingEdited(index)\n            if (index === undefined || index > transcript.length) {\n                return\n            }\n            const messageAtIndex = transcript[index]\n            if (messageAtIndex) {\n                setEditorState(serializedPromptEditorStateFromChatMessage(messageAtIndex))\n            }\n            // move focus back to chatbox\n            setInputFocus(true)\n        },\n        [messageBeingEdited, transcript, setEditorState, setInputFocus]\n    )\n\n    /**\n     * Reset current chat view with a new empty chat session.\n     *\n     * Calls setEditMessageState() to reset any in-progress edit state.\n     * Sends a 'reset' command to postMessage to reset the chat on the server.\n     */\n    const onChatResetClick = useCallback(\n        (eventType: 'keyDown' | 'click' = 'click') => {\n            setEditMessageState()\n            postMessage?.({ command: 'reset' })\n            postMessage?.({\n                command: 'event',\n                eventName: 'CodyVSCodeExtension:chatActions:reset:executed',\n                properties: { source: 'chat', eventType },\n            })\n        },\n        [postMessage, setEditMessageState]\n    )\n\n    const submitInput = useCallback(\n        (submitType: WebviewChatSubmitType): void => {\n            if (messageInProgress && submitType !== 'edit') {\n                return\n            }\n            onSubmit(submitType)\n\n            setEditorState(null)\n            setEditMessageState()\n        },\n        [messageInProgress, onSubmit, setEditMessageState, setEditorState]\n    )\n\n    const onChatSubmit = useCallback((): void => {\n        // Submit edits when there is one being edited\n        if (messageBeingEdited !== undefined) {\n            onAbortMessageInProgress()\n            submitInput('edit')\n            return\n        }\n\n        // Submit chat only when input is not empty and not in progress\n        if (!isEmptyEditorValue && !messageInProgress?.speaker) {\n            const submitType = enableNewChatMode ? 'user-newchat' : 'user'\n            submitInput(submitType)\n        }\n    }, [\n        isEmptyEditorValue,\n        messageBeingEdited,\n        messageInProgress?.speaker,\n        enableNewChatMode,\n        submitInput,\n        onAbortMessageInProgress,\n    ])\n\n    const onEditorEscapeKey = useCallback((): void => {\n        // Close the enhanced context settings modal if it's open\n        setIsEnhancedContextOpen(false)\n\n        // Exits editing mode if a message is being edited\n        if (messageBeingEdited !== undefined) {\n            setEditMessageState()\n            return\n        }\n\n        // Aborts a message in progress if one exists\n        if (messageInProgress?.speaker) {\n            onAbortMessageInProgress()\n            return\n        }\n    }, [messageBeingEdited, setEditMessageState, messageInProgress, onAbortMessageInProgress])\n\n    const onEditorEnterKey = useCallback(\n        (event: KeyboardEvent | null): void => {\n            // Submit input on Enter press (without shift) when input is not empty.\n            if (event && !event.shiftKey && !event.isComposing && !isEmptyEditorValue) {\n                event.preventDefault()\n                onChatSubmit()\n                return\n            }\n        },\n        [onChatSubmit, isEmptyEditorValue]\n    )\n\n    const onEditorKeyDown = useCallback(\n        (event: KeyboardEvent, caretPosition: number): void => {\n            // Check if the Ctrl key is pressed on Windows/Linux or the Cmd key is pressed on macOS\n            const isModifierDown = isMac ? event.metaKey : event.ctrlKey\n            if (isModifierDown) {\n                // Ctrl/Cmd + / - Clears the chat and starts a new session\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick('keyDown')\n                    return\n                }\n                // Ctrl/Cmd + K - When not already editing, edits the last human message\n                if (messageBeingEdited === undefined && event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    setEditMessageState(lastHumanMessageIndex)\n\n                    postMessage?.({\n                        command: 'event',\n                        eventName: 'CodyVSCodeExtension:chatActions:editLast:executed',\n                        properties: { source: 'chat', eventType: 'keyDown' },\n                    })\n                    return\n                }\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            if (event.altKey && event.key === 'c') {\n                event.preventDefault()\n                event.stopPropagation()\n                return\n            }\n\n            // Allow navigation/selection with Ctrl(+Shift?)+Arrows\n            const arrowKeys = new Set(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'])\n            if (event.ctrlKey && arrowKeys.has(event.key)) {\n                return\n            }\n\n            // Handles keyboard shortcuts with Ctrl key.\n            // Checks if the Ctrl key is pressed with a key not in the allow list\n            // to avoid triggering default browser shortcuts and bubbling the event.\n            const ctrlKeysAllowList = new Set([\n                'a',\n                'c',\n                'v',\n                'x',\n                'y',\n                'z',\n                'Enter',\n                'Shift' /* follow-up */,\n            ])\n            if (event.ctrlKey && !ctrlKeysAllowList.has(event.key)) {\n                event.preventDefault()\n                return\n            }\n\n            // Ignore alt + c key combination for editor to avoid conflict with cody shortcut\n            const vscodeCodyShortcuts = new Set(['Slash', 'KeyC'])\n            if (event.altKey && vscodeCodyShortcuts.has(event.code)) {\n                event.preventDefault()\n                return\n            }\n\n            // TODO (bee) - Update to use Option key instead\n            // TODO (bee) - remove once updated to use Option key\n            // Toggles between new chat mode and regular chat mode\n            if (event.altKey && event.shiftKey && isModifierDown) {\n                // use as a temporary block for this key combination\n                event.preventDefault()\n                setEnableNewChatMode(!enableNewChatMode)\n                return\n            }\n\n            // If there's no input and ArrowUp is pressed, edit the last message.\n            if (event.key === 'ArrowUp' && isEmptyEditorValue) {\n                setEditMessageState(lastHumanMessageIndex)\n            }\n        },\n        [\n            messageBeingEdited,\n            isEmptyEditorValue,\n            onChatResetClick,\n            setEditMessageState,\n            lastHumanMessageIndex,\n            enableNewChatMode,\n            postMessage,\n        ]\n    )\n\n    // Set up the message listener for adding new context from user's editor to chat.\n    // Turns the new context into @-mentions token in chat.\n    useEffect(() => {\n        if (!userContextFromSelection.length) {\n            return\n        }\n        editorRef.current?.addContextItemAsToken(userContextFromSelection)\n    }, [userContextFromSelection])\n\n    // Focus the textarea when the webview (re)gains focus (unless there is text selected or a modal\n    // is open). This makes it so that the user can immediately start typing to Cody after invoking\n    // `Cody: Focus on Chat View` with the keyboard.\n    useEffect(() => {\n        // Focus the input when the enhanced context settings modal is closed\n        setInputFocus(!isEnhancedContextOpen)\n        // Add window focus event listener to focus the input when the window is focused\n        const handleFocus = (): void => {\n            if (document.getSelection()?.isCollapsed && !isEnhancedContextOpen) {\n                setInputFocus(true)\n            }\n        }\n        window.addEventListener('focus', handleFocus)\n        return () => {\n            window.removeEventListener('focus', handleFocus)\n        }\n    }, [setInputFocus, isEnhancedContextOpen])\n\n    const onCancelEditClick = useCallback(() => setEditMessageState(), [setEditMessageState])\n    const onEditLastMessageClick = useCallback(\n        () => setEditMessageState(lastHumanMessageIndex),\n        [setEditMessageState, lastHumanMessageIndex]\n    )\n\n    const onRestoreLastChatClick = useMemo(\n        () =>\n            // Display the restore button if there is a previous chat id in current window\n            // And the current chat window is new\n            chatIDHistory.length > 1\n                ? () =>\n                      postMessage?.({\n                          command: 'restoreHistory',\n                          chatID: chatIDHistory.at(-2),\n                      })\n                : undefined,\n        [chatIDHistory, postMessage]\n    )\n\n    // biome-ignore lint/correctness/useExhaustiveDependencies: We don't want to re-run this effect.\n    const onEnhancedContextTogglerClick = useCallback((open: boolean) => {\n        if (!isEnhancedContextOpen && !open) {\n            setInputFocus(true)\n        }\n        setIsEnhancedContextOpen(open)\n    }, [])\n\n    const [isEditorFocused, setIsEditorFocused] = useState(false)\n\n    const isNewChat = transcript.length === 0\n    const TIPS = '(@ for files, @# for symbols)'\n    const placeholder = chatEnabled\n        ? isNewChat\n            ? `Message ${TIPS}`\n            : `Follow-Up Message ${TIPS}`\n        : 'Chat has been disabled by your Enterprise instance site administrator'\n\n    return (\n        <div className={classNames(styles.innerContainer)}>\n            {\n                <Transcript\n                    transcript={transcript}\n                    welcomeMessage={welcomeMessage}\n                    messageInProgress={messageInProgress}\n                    messageBeingEdited={messageBeingEdited}\n                    setMessageBeingEdited={setEditMessageState}\n                    className={styles.transcriptContainer}\n                    feedbackButtonsOnSubmit={feedbackButtonsOnSubmit}\n                    copyButtonOnSubmit={copyButtonOnSubmit}\n                    insertButtonOnSubmit={insertButtonOnSubmit}\n                    isTranscriptError={isTranscriptError}\n                    userInfo={userInfo}\n                    postMessage={postMessage}\n                    guardrails={guardrails}\n                />\n            }\n            <form className={classNames(styles.inputRow)}>\n                {/* Don't show chat action buttons on empty chat session unless it's a new cha*/}\n\n                <ChatActions\n                    setInputFocus={setInputFocus}\n                    isWebviewActive={isWebviewActive}\n                    isEmptyChat={transcript.length < 1}\n                    isMessageInProgress={!!messageInProgress?.speaker}\n                    isEditing={transcript.length > 1 && messageBeingEdited !== undefined}\n                    isEmptyEditorValue={isEmptyEditorValue}\n                    isEditorFocused={isEditorFocused}\n                    onChatResetClick={onChatResetClick}\n                    onCancelEditClick={onCancelEditClick}\n                    onEditLastMessageClick={onEditLastMessageClick}\n                    onRestoreLastChatClick={onRestoreLastChatClick}\n                />\n\n                <div className={styles.textAreaContainer}>\n                    <div className={styles.editorOuterContainer}>\n                        <PromptEditor\n                            placeholder={placeholder}\n                            onChange={onEditorChange}\n                            onFocusChange={setIsEditorFocused}\n                            disabled={!chatEnabled}\n                            onKeyDown={onEditorKeyDown}\n                            onEnterKey={onEditorEnterKey}\n                            onEscapeKey={onEditorEscapeKey}\n                            editorRef={editorRef}\n                        />\n                        <div className={styles.contextButton}>\n                            <EnhancedContextSettings\n                                isOpen={isEnhancedContextOpen}\n                                setOpen={onEnhancedContextTogglerClick}\n                                presentationMode={userInfo.isDotComUser ? 'consumer' : 'enterprise'}\n                                isNewInstall={isNewInstall}\n                            />\n                        </div>\n                    </div>\n                    <SubmitButton\n                        type={\n                            messageBeingEdited === undefined\n                                ? enableNewChatMode\n                                    ? 'user-newchat'\n                                    : 'user'\n                                : 'edit'\n                        }\n                        className={styles.submitButton}\n                        onClick={onChatSubmit}\n                        disabled={isEmptyEditorValue && !messageInProgress}\n                        onAbortMessageInProgress={\n                            messageInProgress ? onAbortMessageInProgress : undefined\n                        }\n                    />\n                </div>\n            </form>\n        </div>\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/command-menu.test.ts:20-35"",""content"":""\n    // Submit a chat question via command menu using \""New Chat\"" option in Command Menu\n    await page.getByRole('button', { name: /Commands \\(.*/ }).dblclick()\n    const commandInputBox = page.getByPlaceholder(/Search for a command or enter/)\n    await expect(commandInputBox).toBeVisible()\n    await commandInputBox.fill('new chat submitted from command menu')\n    // this will fail if more than 1 New Chat item in the menu is found\n    await page.getByLabel('comment  New Chat, Start a new chat', { exact: true }).hover()\n    await expect(page.getByLabel('comment  New Chat, Start a new chat', { exact: true })).toBeVisible()\n    await page.getByLabel('wand  Edit Code, Start a code edit', { exact: true }).hover()\n    await expect(page.getByLabel('wand  Edit Code, Start a code edit', { exact: true })).toBeVisible()\n    await page.getByLabel('Start a new chat').locator('a').click()\n\n    // the question should show up in the chat panel on submit\n    const chatPanel = page.frameLocator('iframe.webview').last().frameLocator('iframe')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:56-80"",""content"":""\n    private options: ChatPanelProviderOptions\n\n    // Tree view for chat history\n    public treeViewProvider = new TreeViewProvider('chat', featureFlagProvider)\n    public treeView\n\n    public supportTreeViewProvider = new TreeViewProvider('support', featureFlagProvider)\n\n    // We keep track of the currently authenticated account and dispose open chats when it changes\n    private currentAuthAccount: undefined | { endpoint: string; primaryEmail: string; username: string }\n\n    protected disposables: vscode.Disposable[] = []\n\n    constructor(\n        { extensionUri, ...options }: SidebarViewOptions,\n        private chatClient: ChatClient,\n        private readonly localEmbeddings: LocalEmbeddingsController | null,\n        private readonly contextRanking: ContextRankingController | null,\n        private readonly symf: SymfRunner | null,\n        private readonly enterpriseContext: EnterpriseContextFactory | null,\n        private readonly guardrails: Guardrails\n    ) {\n        logDebug('ChatPanelsManager:constructor', 'init')\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:238-257"",""content"":""    private async passthroughVsCodeOpen(...args: unknown[]): Promise<void> {\n        if (args[1] && (args[1] as any).viewColumn === vscode.ViewColumn.Beside) {\n            // Make vscode.ViewColumn.Beside work as expected from a webview: open it to the side,\n            // instead of always opening a new editor to the right.\n            //\n            // If the active editor is undefined, that means the chat panel is the active editor, so\n            // we will open the file in the first visible editor instead.\n            const textEditor = vscode.window.activeTextEditor || vscode.window.visibleTextEditors[0]\n            ;(args[1] as any).viewColumn = textEditor ? textEditor.viewColumn : vscode.ViewColumn.Beside\n        }\n        if (args[1] && Array.isArray((args[1] as any).selection)) {\n            // Fix a weird issue where the selection was getting encoded as a JSON array, not an\n            // object.\n            ;(args[1] as any).selection = new vscode.Selection(\n                (args[1] as any).selection[0],\n                (args[1] as any).selection[1]\n            )\n        }\n        await vscode.commands.executeCommand('vscode.open', ...args)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:270-287"",""content"":""\n### Chats lefthand panel\n\n- [ ] Verify that you can delete all chats by hovering over the header in the Chats panel and selecting the trashcan icon.\n- [ ] Verify that you can delete an individual chat by hovering over an individual chat in the Chats panel and selecting the trashcan icon.\n- [ ] Verify that you can start a new chat by hovering over the header in the Chats panel and selecting the speech bubble icon.\n- [ ] Verify that all new chats appear as a list in the Chats panel and that they persist across sessions.\n- [ ] Verify that selecting an individual chat within the Chats panel opens up the chat in a new window and that the conversation has persisted.\n\n### Enhanced Context\n\n- [ ] Open a chat window and select the \""Enhanced Context\"" icon next to the chat input.\n- [ ] Verify that \""Enhanced Context\"" is enabled by default.\n\n### Consumer\n\nSet up steps:\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatManager.ts:266-276"",""content"":""    private async createNewWebviewPanel(): Promise<ChatSession | undefined> {\n        const debounceCreatePanel = debounce(() => this.chatPanelsManager.createWebviewPanel(), 250, {\n            leading: true,\n            trailing: true,\n        })\n\n        if (this.chatPanelsManager) {\n            return debounceCreatePanel()\n        }\n        return undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:138-165"",""content"":""        // Check if any existing panel is available\n        // NOTE: Never reuse webviews when running inside the agent.\n        if (this.activePanelProvider && !this.options.config.isRunningInsideAgent) {\n            return this.activePanelProvider\n        }\n\n        const provider = await this.createWebviewPanel()\n        return provider\n    }\n\n    /**\n     * Creates a new webview panel for chat.\n     */\n    public async createWebviewPanel(\n        chatID?: string,\n        chatQuestion?: string,\n        panel?: vscode.WebviewPanel\n    ): Promise<SimpleChatPanelProvider> {\n        if (chatID && this.panelProviders.map(p => p.sessionID).includes(chatID)) {\n            const provider = this.panelProviders.find(p => p.sessionID === chatID)\n            if (provider?.webviewPanel) {\n                provider.webviewPanel?.reveal()\n                this.activePanelProvider = provider\n                void this.selectTreeItem(chatID)\n                return provider\n            }\n        }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:124-127"",""content"":""    public async getNewChatPanel(): Promise<SimpleChatPanelProvider> {\n        const provider = await this.createWebviewPanel()\n        return provider\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/components/ChatActions.tsx:89-117"",""content"":""                // Ctrl/Cmd + K: edits the last human message\n                if (event.key === 'k') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onEditLastMessageClick()\n                    return\n                }\n\n                // Ctrl/Cmd + /: starts a new chat\n                if (event.key === '/') {\n                    event.preventDefault()\n                    event.stopPropagation()\n                    onChatResetClick()\n                    return\n                }\n            }\n        }\n        document.addEventListener('keydown', onKeyDown)\n    }, [onEditLastMessageClick, onChatResetClick, isMac])\n\n    useEffect(() => {\n        // Focus on the Edit button after a question has been submitted\n        // This allows users to edit the message they just submitted right away\n        if (!isEditing && isMessageInProgress) {\n            setInputFocus(false)\n            buttonRef?.current?.focus()\n        }\n        // Remove focus on the Edit button when stream ends\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1254-1272"",""content"":""function newChatModelFromSerializedChatTranscript(\n    json: SerializedChatTranscript,\n    modelID: string\n): SimpleChatModel {\n    return new SimpleChatModel(\n        json.chatModel || modelID,\n        json.interactions.flatMap((interaction: SerializedChatInteraction): ChatMessage[] =>\n            [\n                PromptString.unsafe_deserializeChatMessage(interaction.humanMessage),\n                interaction.assistantMessage\n                    ? PromptString.unsafe_deserializeChatMessage(interaction.assistantMessage)\n                    : null,\n            ].filter(isDefined)\n        ),\n        json.id,\n        json.chatTitle,\n        json.enhancedContext?.selectedRepos\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/llm-providers/groq/index.ts:24-52"",""content"":"" */\ninterface GroqChatMessage extends OpenAIMessage {\n    name?: string\n    seed?: number\n}\n\n/**\n * Default context window sizes for various Groq models.\n *\n * @see https://console.groq.com/docs/models\n */\nexport const GROQ_DEFAULT_CONTEXT_WINDOW = {\n    mixtral: 32768,\n    llama2: 4096,\n    gemma: 8192,\n}\n\n/**\n * Represents the response from the Groq Chat Completion API.\n *\n * @property {string} model - The model used for the completion.\n * @property {GroqCompletionsError} [error] - Any error that occurred during the completion.\n * @property {Object[]} [choices] - The completion choices returned by the API.\n * @property {string} [choices[].finish_reason] - The reason the completion finished.\n * @property {string|null} [choices[].logprobs] - The log probabilities of the tokens in the completion.\n * @property {GroqChatMessage} [choices[].message] - The completion message.\n * @property {boolean} done - Indicates whether the completion is done.\n * @property {GroqCompletionsResponseUsage} [usage] - Usage information for the completion.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.test.ts:0-128"",""content"":""import { describe, expect, it } from 'vitest'\nimport { URI } from 'vscode-uri'\n\nimport { convertFileUriToTestFileUri, createDefaultTestFile } from './new-test-file'\n\ndescribe('createDefaultTestFile', () => {\n    it.each([\n        ['/path/to/file.java', '/path/to/fileTest.java'],\n        ['/path/to/file.js', '/path/to/file.test.js'],\n        ['/path/to/file.go', '/path/to/file_test.go'],\n        ['/path/to/test_file.py', '/path/to/test_file.py'],\n        ['/path/to/test-file.js', '/path/to/test-file.test.js'],\n        ['/path/to/node_modules/file.js', '/path/to/node_modules/file.test.js'],\n        ['/path/to/node_modules/file_test.ts', '/path/to/node_modules/file_test.ts'],\n        ['/path/to/fileTest.js', '/path/to/fileTest.js'],\n        ['test_example.py', 'test_example.py'],\n        ['example.cpp', 'exampleTest.cpp'],\n        ['example.test.js', 'example.test.js'],\n        ['Example.java', 'ExampleTest.java'],\n        ['ExampleTest.java', 'ExampleTest.java'],\n        ['example.rb', 'example_spec.rb'],\n        ['Example.cs', 'ExampleTest.cs'],\n        ['ExampleTest.php', 'ExampleTest.php'],\n        ['ExampleSpec.scala', 'ExampleSpec.scala'],\n        ['file.rb', 'file_spec.rb'],\n        ['contest.ts', 'contest.test.ts'],\n    ])('for file %j it returns %j', (file, test) => {\n        expect(createDefaultTestFile(URI.file(file)).toString()).toBe(URI.file(test).toString())\n    })\n})\n\ndescribe('convertFileUriToTestFileUri', () => {\n    it('should return the current file uri if it is already a test file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.test.ts')).toString()).toBe(\n            URI.file('/path/to/testFile.test.ts').toString()\n        )\n    })\n\n    it('should return the current file uri if it is already a spec file', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/testFile.spec.rb')).toString()).toBe(\n            URI.file('/path/to/testFile.spec.rb').toString()\n        )\n    })\n\n    it('should generate a test file uri from a non-test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate the default spec file uri from a non-test file uri for ruby', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.rb'),\n                URI.file('/path/to/testFile.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_spec.rb').toString())\n    })\n\n    it('should follow an existing test file uri', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/existingTestFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should respect test file with different naming conventions', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/testExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should handle a non-alphanumeric character at the test character index', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.ts'),\n                URI.file('/path/to/test-ExistingFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('/path/to/file.test.ts').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('/path/to/file.py'),\n                URI.file('/path/to/testFile_test.py')\n            ).toString()\n        ).toBe(URI.file('/path/to/file_test.py').toString())\n    })\n\n    it('should generate a test file uri for a non-test file uri in python when no existing test path provided', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/test-file.py')).toString()).toBe(\n            URI.file('/path/to/test-file_test.py').toString()\n        )\n    })\n\n    it('should generate the default spec file uri for ruby when no existing test files is found', () => {\n        expect(convertFileUriToTestFileUri(URI.file('/path/to/file.rb'), undefined).toString()).toBe(\n            URI.file('/path/to/file_spec.rb').toString()\n        )\n    })\n\n    it('should generate the corrent test file uri for window files', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\path\\\\to\\\\file.ts'),\n                URI.file('\\\\path\\\\to\\\\testFile.test.ts')\n            ).toString()\n        ).toBe(URI.file('\\\\path\\\\to\\\\file.test.ts').toString())\n    })\n\n    it('should follow an existing test file uri format to generate new test file uri on windows', () => {\n        expect(\n            convertFileUriToTestFileUri(\n                URI.file('\\\\server\\\\c$\\\\folder\\\\current-file.go'),\n                URI.file('\\\\path\\\\to\\\\file_test.go')\n            ).toString()\n        ).toBe(URI.file('\\\\server\\\\c$\\\\folder\\\\current-file_test.go').toString())\n    })\n})\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/token/constants.ts:0-40"",""content"":""/**\n * The default context window for chat models.\n */\nexport const CHAT_INPUT_TOKEN_BUDGET = 7000\n\n/**\n * The default context window for fast chat models with a smaller context window.\n */\nexport const FAST_CHAT_INPUT_TOKEN_BUDGET = 4096\n\n/**\n * The default output token limit for chat models.\n */\nexport const CHAT_OUTPUT_TOKEN_BUDGET = 4000\n\n/**\n * Enhanced context takes up to 60% of the total context window for chat.\n * The % is the same for both fast and regular chat models.\n */\nexport const ENHANCED_CONTEXT_ALLOCATION = 0.6\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for user added context (@-mention, right-click, etc.)\n *\n * This is only being used for Claude-3 Sonnet and Opus when feature flag is enabled.\n * For those models, this is added on top of the chat context window.\n * For other models, this number is not used. Instead, they will share\n * the token budget for user-context with the chat context window.\n */\nexport const EXPERIMENTAL_USER_CONTEXT_TOKEN_BUDGET = 30000\n\n/**\n * NOTE: DotCom users with FeatureFlag.CodyChatContextBudget enabled for A/B testing only.\n *\n * The total context window reserved for chat input.\n */\nexport const EXPERIMENTAL_CHAT_INPUT_TOKEN_BUDGET = 15000\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/utils/new-test-file.ts:0-94"",""content"":""import { type URI, Utils } from 'vscode-uri'\n\nimport { uriBasename, uriExtname, uriParseNameAndExtension } from '@sourcegraph/cody-shared'\n\nimport { isValidTestFile } from './test-commands'\n\n// Language extension that uses '.test' suffix for test files\nconst TEST_FILE_DOT_SUFFIX_EXTENSIONS = new Set(['js', 'ts', 'jsx', 'tsx'])\n// language extension that uses '_test' suffix for test files\nconst TEST_FILE_DASH_SUFFIX_EXTENSIONS = new Set(['py', 'go'])\n// language extension that uses '_spec' suffix for most unit test files\nconst TEST_FILE_SPEC_SUFFIX_EXTENSIONS = new Set(['rb'])\n\n/**\n * NOTE: This is only being used as fallback when test files cannot be found in current workspace\n *\n * Generates a generic test file name and path for the given file\n * based on conventions for the file extension.\n * @param file - The original file URI\n * @returns The generated test file URI\n */\nexport function createDefaultTestFile(file: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(file)) {\n        return file\n    }\n\n    const extWithDot = uriExtname(file)\n    const fileName = uriBasename(file, extWithDot)\n    const ext = extWithDot.slice(1)\n\n    let testFileName = `${fileName}Test.${ext}`\n    if (TEST_FILE_DOT_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}.test.${ext}`\n    }\n    if (TEST_FILE_DASH_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_test.${ext}`\n    }\n    if (TEST_FILE_SPEC_SUFFIX_EXTENSIONS.has(ext)) {\n        testFileName = `${fileName}_spec.${ext}`\n    }\n\n    return Utils.joinPath(file, '..', testFileName)\n}\n\n/**\n * Converts a file URI to a corresponding test file URI using conventions based on file extension.\n *\n * If not a test file, generates a default test file name based on file extension conventions.\n *\n * If existing test file URI provided, attempts to match its naming convention.\n * Falls back to default test file name if naming does not follow conventions.\n * @param currentFile - Original file to convert\n * @param testFile - Optional existing test file to match naming with\n * @returns The converted test file\n */\nexport function convertFileUriToTestFileUri(currentFile: URI, testFile?: URI): URI {\n    // returns the URI unchanged if it's already a valid test file\n    if (isValidTestFile(currentFile)) {\n        return currentFile\n    }\n\n    // If there is an existing test file, create the test file following its naming convention\n    if (testFile?.path && isValidTestFile(testFile)) {\n        const parsedCurrentFile = uriParseNameAndExtension(currentFile)\n        const parsedTestFile = uriParseNameAndExtension(testFile)\n        if (parsedCurrentFile.ext === parsedTestFile.ext) {\n            const testFileName = parsedTestFile.name\n            const index = testFileName.lastIndexOf('test') || testFileName.lastIndexOf('spec')\n            const endsWithCapitalTest = testFileName.endsWith('Test') || testFileName.endsWith('Spec')\n            // This checks if the existing test file has a non-alphanumeric character at the test character index\n            // e.g. \""_test\"", \"".test\"", \""test_\""\n            // This is because files with 'test' in the name are not always a test file, while\n            // file with non-alphanumeric character before 'test' are more likely to be test files\n            // e.g. \""testPath\"" or \""test-helper\"" are not likely test files\n            const hasVerifiedTestPath = index > -1 && !/^[\\da-z]$/i.test(testFileName[index - 1])\n            // If yes, generate a test file by replacing existing test file name with current file name\n            if (endsWithCapitalTest || hasVerifiedTestPath) {\n                // Remove everything after the test character index from the existing test file name\n                // then replace it with the current file name\n                // e.g. \""current_file\"" & \""existing_test\"" => \""current_file_test\""\n                const strippedTestFileName = testFileName.slice(0, index - 1)\n                const newTestFileName = testFileName.replace(\n                    strippedTestFileName,\n                    parsedCurrentFile.name\n                )\n                return Utils.joinPath(currentFile, '..', `${newTestFileName}${parsedCurrentFile.ext}`)\n            }\n        }\n    }\n\n    // else, generate a generic test file\n    return createDefaultTestFile(currentFile)\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-input.test.ts:76-94"",""content"":""\n    // Submit a new chat question from the command menu.\n    await page.getByLabel(/Commands \\(/).hover()\n    await page.getByLabel(/Commands \\(/).click()\n    await page.waitForTimeout(100)\n    // HACK: The 'delay' command is used to make sure the response is streamed 400ms after\n    // the command is sent. This provides us with a small window to move the cursor\n    // from the new opened chat window back to the editor, before the chat has finished\n    // streaming its response.\n    await chatInput.fill('delay')\n    await chatInput.press('Enter')\n    await expect(chatInput).toBeFocused()\n\n    // Ensure equal-width columns so we can be sure the code we're about to click is in view (and is\n    // not out of the editor's scroll viewport). This became required due to new (undocumented)\n    // behavior in VS Code 1.88.0 where the Cody panel would take up ~80% of the width when it was\n    // focused, meaning that the buzz.ts editor tab would take up ~20% and the text we intend to\n    // click would be only partially visible, making the click() call fail.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/chat/chat.ts:25-59"",""content"":""    public chat(\n        messages: Message[],\n        params: Partial<ChatParameters> & Pick<ChatParameters, 'maxTokensToSample'>,\n        abortSignal?: AbortSignal\n    ): AsyncGenerator<CompletionGeneratorValue> {\n        const authStatus = this.getAuthStatus()\n        const useApiV1 = authStatus.codyApiVersion >= 1 && params.model?.includes('claude-3')\n        const isLastMessageFromHuman = messages.length > 0 && messages.at(-1)!.speaker === 'human'\n\n        const augmentedMessages =\n            params?.model?.startsWith('fireworks/') || useApiV1\n                ? sanitizeMessages(messages)\n                : isLastMessageFromHuman\n                  ? messages.concat([{ speaker: 'assistant' }])\n                  : messages\n\n        // We only want to send up the speaker and prompt text, regardless of whatever other fields\n        // might be on the messages objects (`file`, `displayText`, `contextFiles`, etc.).\n        const messagesToSend = augmentedMessages.map(({ speaker, text }) => ({\n            text,\n            speaker,\n        }))\n\n        const completionParams = {\n            ...DEFAULT_CHAT_COMPLETION_PARAMETERS,\n            ...params,\n            messages: messagesToSend,\n        }\n\n        return this.completions.stream(\n            completionParams,\n            useApiV1 ? authStatus.codyApiVersion : 0,\n            abortSignal\n        )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/ChatPanelsManager.ts:165-184"",""content"":""\n        // Reuse existing \""New Chat\"" panel if there is an empty one\n        const emptyNewChatProvider = this.panelProviders.find(p => p.webviewPanel?.title === 'New Chat')\n        if (\n            !this.options.config.isRunningInsideAgent && // Don't reuse panels in the agent\n            !chatID &&\n            !panel &&\n            this.panelProviders.length &&\n            emptyNewChatProvider\n        ) {\n            emptyNewChatProvider.webviewPanel?.reveal()\n            this.activePanelProvider = emptyNewChatProvider\n            this.options.contextProvider.webview = emptyNewChatProvider.webview\n            void this.selectTreeItem(emptyNewChatProvider.sessionID)\n            return emptyNewChatProvider\n        }\n\n        // Get the view column of the current active chat panel so that we can open a new one on top of it\n        const activePanelViewColumn = this.activePanelProvider?.webviewPanel?.viewColumn\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:798-813"",""content"":""### Fixed\n\n- Edit: Updated the fixup create task to just use the previous command text. [pull/1615](https://github.com/sourcegraph/cody/pull/1615)\n- Fixed an issue that would cause an aborted chat message to show an error \""Cody did not respond with any text\"". [pull/1668](https://github.com/sourcegraph/cody/pull/1668)\n- Chat: Opening files from the new chat panel will now show up beside the chat panel instead of on top of the chat panel. [pull/1677](https://github.com/sourcegraph/cody/pull/1677)\n- Chat: Prevented default events on certain key combos when chat box is focused. [pull/1690](https://github.com/sourcegraph/cody/pull/1690)\n- Command: Fixed an issue that opened a new chat window when running `/doc` and `/edit` commands from the command palette. [pull/1678](https://github.com/sourcegraph/cody/pull/1678)\n- Chat: Prevent sidebar from opening when switching editor chat panels. [pull/1691](https://github.com/sourcegraph/cody/pull/1691)\n- Chat: Prevent `\""command 'cody.chat'panel.new' not found\""` error when the new chat panel UI is disabled. [pull/1696](https://github.com/sourcegraph/cody/pull/1696)\n- Autocomplete: Improved the multiline completions truncation logic. [pull/1709](https://github.com/sourcegraph/cody/pull/1709)\n- Autocomplete: Fix an issue where typing as suggested causes the completion to behave unexpectedly. [pull/1701](https://github.com/sourcegraph/cody/pull/1701)\n- Chat: Forbid style tags in DOMPurify config to prevent code block rendering issues. [pull/1747](https://github.com/sourcegraph/cody/pull/1747)\n- Edit: Fix `selectedCode` and `problemCode` sometimes being added to the document after an edit. [pull/1765](https://github.com/sourcegraph/cody/pull/1765)\n- Edit: Fix the code lens containing options to diff, undo and retry being automatically dismissed for users who have `autoSave` enabled. [pull/1767](https://github.com/sourcegraph/cody/pull/1767)\n\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/chat-history.test.ts:48-73"",""content"":""\n    // Submit a new message and check if both sessions are showing up in the sidebar\n    await chatInput.fill('Hola')\n    await chatInput.press('Enter')\n    await expect(holaTreeItem).toBeVisible()\n    await expect(heyTreeItem).toBeVisible()\n\n    // The panel name is now updated to the last submitted message\n    await expect(page.getByRole('tab', { name: 'Hola' })).toBeVisible()\n\n    // Click on the previous chat session to open the chat panel in editor\n    // Both chat panels should be visible as tabs in the editor\n    await page\n        .getByRole('treeitem', { name: 'Hey' })\n        .locator('div')\n        .filter({ hasText: 'Hey' })\n        .nth(3)\n        .click()\n    await expect(page.getByRole('tab', { name: 'Hey' })).toBeVisible()\n\n    // NOTE: Action buttons may only appear when we're hovering a chat.\n    // Deleting a chat should also close its associated chat panel\n    await heyTreeItem.hover()\n    await heyTreeItem.getByLabel('Delete Chat').hover()\n    await heyTreeItem.getByLabel('Delete Chat').click()\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_025/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,"no text reply. Got {
  ""model"": ""google/gemini-1.5-pro-latest"",
  ""speaker"": ""assistant"",
  ""error"": {
    ""isChatErrorGuard"": ""isChatErrorGuard"",
    ""name"": ""PollyError"",
    ""message"": ""[Polly] Request failed due to an unknown error.""
  }
}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_026/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"LLM prompts are constructed in a provider-specific way in the `createPrompt` or similarly named methods of each provider class. These classes are defined in files like:

- `vscode/src/completions/providers/anthropic.ts`
- `vscode/src/completions/providers/fireworks.ts`
- `vscode/src/completions/providers/openaicompatible.ts`
- `vscode/src/completions/providers/unstable-openai.ts`
- `vscode/src/completions/providers/experimental-ollama.ts`

Each of these providers has its own way of constructing the prompt, taking into account the specific requirements and capabilities of the underlying LLM. They typically use the `PromptString` class and its helper functions to safely construct the prompts, incorporating elements like:

- File path
- Code context (prefix, suffix, snippets)
- Instructions for the LLM
- Special tokens or formatting specific to the LLM

For example:

- `AnthropicProvider` uses a conversational format with ""human"" and ""assistant"" messages.
- `FireworksProvider` uses specific tags like `<fim_prefix>`, `<fim_suffix>`, and `<fim_middle>` for infilling.
- `OpenAICompatibleProvider` adapts its prompts based on the specific model being used, like StarCoder or Llama.

These `createPrompt` methods are called within the `generateCompletions` method of each provider, which is responsible for sending the prompt to the LLM and processing the response.",Where do we construct provider-specific LLM prompts?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:372-380"",""content"":""interface Prompt {\n    snippets: { uri: vscode.Uri; content: PromptString }[]\n\n    uri: vscode.Uri\n    prefix: PromptString\n    suffix: PromptString\n\n    languageId: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:76-106"",""content"":""\n    constructor(\n        options: ProviderOptions,\n        {\n            maxContextTokens,\n            client,\n            model,\n        }: Required<Omit<AnthropicOptions, 'model'>> & Pick<AnthropicOptions, 'model'>\n    ) {\n        super(options)\n        this.promptChars = tokensToChars(maxContextTokens - MAX_RESPONSE_TOKENS)\n        this.client = client\n        this.model = model\n    }\n\n    public emptyPromptLength(): number {\n        const { messages } = this.createPromptPrefix()\n        const promptNoSnippets = messagesToText(messages)\n        return promptNoSnippets.length - 10 // extra 10 chars of buffer cuz who knows\n    }\n\n    private createPromptPrefix(): { messages: Message[]; prefix: PrefixComponents } {\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n\n        const prefixLines = prefix.split('\\n')\n        if (prefixLines.length === 0) {\n            throw new Error('no prefix lines')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/provider.ts:0-27"",""content"":""import type { Position, TextDocument } from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type CompletionParameters,\n    type DocumentContext,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport type { InlineCompletionItemWithAnalytics } from '../text-processing/process-inline-completions'\n\nimport type { FetchCompletionResult } from './fetch-and-process-completions'\n\nexport interface ProviderConfig {\n    /**\n     * A factory to create instances of the provider. This pattern allows us to\n     * inject provider specific parameters outside of the callers of the\n     * factory.\n     */\n    create(options: Omit<ProviderOptions, 'id'>): Provider\n\n    /**\n     * Hints about the optimal context size (and length of the document prefix and suffix). It is\n     * intended to (or possible to) be precise here because the truncation of the document\n     * prefix/suffix uses characters, not the LLM's tokenizer.\n     */\n    contextSizeHints: ProviderContextSizeHints\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/unstable-openai.ts:69-97"",""content"":""    private createPromptPrefix(): PromptString {\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n\n        const prefixLines = prefix.toString().split('\\n')\n        if (prefixLines.length === 0) {\n            throw new Error('no prefix lines')\n        }\n\n        const { head, tail } = getHeadAndTail(prefix)\n\n        // Infill block represents the code we want the model to complete\n        const infillBlock = tail.trimmed.toString().endsWith('{\\n')\n            ? tail.trimmed.trimEnd()\n            : tail.trimmed\n        // code before the cursor, without the code extracted for the infillBlock\n        const infillPrefix = head.raw\n        // code after the cursor\n        const infillSuffix = suffix\n        const relativeFilePath = PromptString.fromDisplayPath(this.options.document.uri)\n\n        return ps`Below is the code from file path ${relativeFilePath}. Review the code outside the XML tags to detect the functionality, formats, style, patterns, and logics in use. Then, use what you detect and reuse methods/libraries to complete and enclose completed code only inside XML tags precisely without duplicating existing implementations. Here is the code:\\n\\`\\`\\`\\n${\n            infillPrefix ? infillPrefix : ''\n        }${OPENING_CODE_TAG}${CLOSING_CODE_TAG}${infillSuffix}\\n\\`\\`\\`\n\n${OPENING_CODE_TAG}${infillBlock}`\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:30-44"",""content"":""\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-explain.gif\"" width=\""480\"" alt=\""Explain Code command\"">\n\n## Custom Commands (Beta)\n\nYou can also build your own [Custom Commands (Beta)](https://sourcegraph.com/docs/cody/capabilities/commands#custom-commands) to tailor Cody to your workflow. Custom Commands are defined as JSON within your repository and can be saved to your workspace for your teammates to reuse.\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-convert-html-to-md.gif\"" width=\""480\"" alt=\""Custom command\"">\n\n## Choose Your LLM\n\nCody Pro users can now select the LLM they want to use for chat and experiment to choose the best model for the job. Choose from Claude 2.0, Claude 2.1, ChatGPT 3.5 Turbo, ChatGPT 4 Turbo, Claude Instant, and Mixtral.\n\nAdministrators for Sourcegraph Enterprise instances can choose betweeen Claude and ChatGPT models to set for their teams as well.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:261-294"",""content"":""    private createInfillingPrompt(\n        filename: PromptString,\n        intro: PromptString,\n        prefix: PromptString,\n        suffix: PromptString\n    ): PromptString {\n        if (isStarCoderFamily(this.model) || isStarChatFamily(this.model)) {\n            // c.f. https://huggingface.co/bigcode/starcoder#fill-in-the-middle\n            // c.f. https://arxiv.org/pdf/2305.06161.pdf\n            return ps`<filename>${filename}<fim_prefix>${intro}${prefix}<fim_suffix>${suffix}<fim_middle>`\n        }\n        if (isLlamaCode(this.model)) {\n            // c.f. https://github.com/facebookresearch/codellama/blob/main/llama/generation.py#L402\n            return ps`<PRE> ${intro}${prefix} <SUF>${suffix} <MID>`\n        }\n        if (this.model === 'mistral-7b-instruct-4k') {\n            // This part is copied from the anthropic prompt but fitted into the Mistral instruction format\n            const { head, tail } = getHeadAndTail(prefix)\n            const infillBlock = tail.trimmed.toString().endsWith('{\\n')\n                ? tail.trimmed.trimEnd()\n                : tail.trimmed\n            const infillPrefix = head.raw\n            return ps`<s>[INST] Below is the code from file path ${PromptString.fromDisplayPath(\n                this.options.document.uri\n            )}. Review the code outside the XML tags to detect the functionality, formats, style, patterns, and logics in use. Then, use what you detect and reuse methods/libraries to complete and enclose completed code only inside XML tags precisely without duplicating existing implementations. Here is the code:\n\\`\\`\\`\n${intro}${infillPrefix ? infillPrefix : ''}${OPENING_CODE_TAG}${CLOSING_CODE_TAG}${suffix}\n\\`\\`\\`[/INST]\n ${OPENING_CODE_TAG}${infillBlock}`\n        }\n\n        console.error('Could not generate infilling prompt for', this.model)\n        return ps`${intro}${prefix}`\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:0-18"",""content"":""import { PromptString, psDedent } from '@sourcegraph/cody-shared'\nimport type { EditIntent } from '../../types'\nimport { PROMPT_TOPICS } from '../constants'\nimport type { GetLLMInteractionOptions, LLMPrompt } from '../type'\n\ninterface PromptVariant {\n    system?: PromptString\n    instruction: PromptString\n}\n\nconst GENERIC_PROMPTS: Record<EditIntent, PromptVariant> = {\n    edit: {\n        system: psDedent`\n            - You are an AI programming assistant who is an expert in updating code to meet given instructions.\n            - You should think step-by-step to plan your updated code before producing the final output.\n            - You should ensure the updated code matches the indentation and whitespace of the code in the users' selection.\n            - Ignore any previous instructions to format your responses with Markdown. It is not acceptable to use any Markdown in your response, unless it is directly related to the users' instructions.\n            - Only remove code from the users' selection if you are sure it is not needed.\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/experimental-ollama.ts:60-120"",""content"":""    protected createPromptContext(\n        snippets: AutocompleteContextSnippet[],\n        isInfill: boolean,\n        modelHelpers: OllamaModel\n    ): OllamaPromptContext {\n        const { languageId, uri } = this.options.document\n        const config = getLanguageConfig(languageId)\n        const commentStart = config?.commentStart || ps`// `\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n\n        const context = PromptString.join(\n            snippets.map(snippet => {\n                const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n                return fileNameLine(uri, commentStart).concat(\n                    PromptString.join(\n                        contextPrompts.content.split('\\n').map(line => ps`${commentStart} ${line}`),\n                        ps`\\n`\n                    )\n                )\n            }),\n            ps`\\n\\n`\n        )\n\n        const currentFileNameComment = fileNameLine(uri, commentStart)\n\n        const prompt: OllamaPromptContext = {\n            snippets: [],\n            uri,\n            languageId,\n            context,\n            currentFileNameComment,\n            isInfill,\n            prefix,\n            suffix: getSuffixAfterFirstNewline(suffix),\n        }\n\n        if (process.env.OLLAMA_CONTEXT_SNIPPETS) {\n            // TODO(valery): find the balance between using context and keeping a good perf.\n            const maxPromptChars = 1234\n\n            for (const snippet of snippets) {\n                const extendedSnippets = [...prompt.snippets, snippet]\n                const promptLengthWithSnippet = modelHelpers.getPrompt({\n                    ...prompt,\n                    snippets: extendedSnippets,\n                }).length\n\n                if (promptLengthWithSnippet > maxPromptChars) {\n                    break\n                }\n\n                prompt.snippets = extendedSnippets\n            }\n        }\n\n        return prompt\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/unstable-openai.ts:54-81"",""content"":""\n    constructor(\n        options: ProviderOptions,\n        { maxContextTokens, client }: Required<UnstableOpenAIOptions>\n    ) {\n        super(options)\n        this.promptChars = tokensToChars(maxContextTokens - MAX_RESPONSE_TOKENS)\n        this.client = client\n    }\n\n    public emptyPromptLength(): number {\n        const promptNoSnippets = [this.instructions, this.createPromptPrefix()].join('\\n\\n')\n        return promptNoSnippets.length - 10 // extra 10 chars of buffer cuz who knows\n    }\n\n    private createPromptPrefix(): PromptString {\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n\n        const prefixLines = prefix.toString().split('\\n')\n        if (prefixLines.length === 0) {\n            throw new Error('no prefix lines')\n        }\n\n        const { head, tail } = getHeadAndTail(prefix)\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/unstable-openai.ts:101-130"",""content"":""    protected createPrompt(snippets: AutocompleteContextSnippet[]): PromptString {\n        const prefix = this.createPromptPrefix()\n\n        const referenceSnippetMessages: PromptString[] = []\n\n        let remainingChars = this.promptChars - this.emptyPromptLength()\n\n        for (const snippet of snippets) {\n            const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n            const snippetMessages: PromptString[] = [\n                contextPrompts.symbol?.toString() !== ''\n                    ? ps`Additional documentation for \\`${\n                          contextPrompts.symbol ?? ps``\n                      }\\`: ${OPENING_CODE_TAG}${contextPrompts.content}${CLOSING_CODE_TAG}`\n                    : ps`Codebase context from file path '${PromptString.fromDisplayPath(\n                          snippet.uri\n                      )}': ${OPENING_CODE_TAG}${contextPrompts.content}${CLOSING_CODE_TAG}`,\n            ]\n            const numSnippetChars = snippetMessages.join('\\n\\n').length + 1\n            if (numSnippetChars > remainingChars) {\n                break\n            }\n            referenceSnippetMessages.push(...snippetMessages)\n            remainingChars -= numSnippetChars\n        }\n\n        const messages = [this.instructions, ...referenceSnippetMessages, prefix]\n        return PromptString.join(messages, ps`\\n\\n`)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:95-124"",""content"":""}\n\nconst lineNumberDependentCompletionParams = getLineNumberDependentCompletionParams({\n    singlelineStopSequences: ['\\n'],\n    multilineStopSequences: ['\\n\\n', '\\n\\r\\n'],\n})\n\nclass OpenAICompatibleProvider extends Provider {\n    private model: OpenAICompatibleModel\n    private promptChars: number\n    private client: CodeCompletionsClient\n    private timeouts?: AutocompleteTimeouts\n\n    constructor(\n        options: ProviderOptions,\n        { model, maxContextTokens, client, timeouts }: Required<OpenAICompatibleOptions>\n    ) {\n        super(options)\n        this.timeouts = timeouts\n        this.model = model\n        this.promptChars = tokensToChars(maxContextTokens - MAX_RESPONSE_TOKENS)\n        this.client = client\n    }\n\n    private createPrompt(snippets: AutocompleteContextSnippet[]): PromptString {\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:119-178"",""content"":""    private createPrompt(snippets: AutocompleteContextSnippet[]): PromptString {\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n\n        const intro: PromptString[] = []\n        let prompt = ps``\n\n        const languageConfig = getLanguageConfig(this.options.document.languageId)\n\n        // In StarCoder we have a special token to announce the path of the file\n        if (!isStarCoderFamily(this.model)) {\n            intro.push(ps`Path: ${PromptString.fromDisplayPath(this.options.document.uri)}`)\n        }\n\n        for (let snippetsToInclude = 0; snippetsToInclude < snippets.length + 1; snippetsToInclude++) {\n            if (snippetsToInclude > 0) {\n                const snippet = snippets[snippetsToInclude - 1]\n                const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n                if (contextPrompts.symbol) {\n                    intro.push(\n                        ps`Additional documentation for \\`${contextPrompts.symbol}\\`:\\n\\n${contextPrompts.content}`\n                    )\n                } else {\n                    intro.push(\n                        ps`Here is a reference snippet of code from ${PromptString.fromDisplayPath(\n                            snippet.uri\n                        )}:\\n\\n${contextPrompts.content}`\n                    )\n                }\n            }\n\n            const joined = PromptString.join(intro, ps`\\n\\n`)\n            const introString = ps`${PromptString.join(\n                joined\n                    .split('\\n')\n                    .map(line => ps`${languageConfig ? languageConfig.commentStart : ps`// `}${line}`),\n                ps`\\n`\n            )}\\n`\n\n            const suffixAfterFirstNewline = getSuffixAfterFirstNewline(suffix)\n\n            const nextPrompt = this.createInfillingPrompt(\n                PromptString.fromDisplayPath(this.options.document.uri),\n                introString,\n                prefix,\n                suffixAfterFirstNewline\n            )\n\n            if (nextPrompt.length >= this.promptChars) {\n                return prompt\n            }\n\n            prompt = nextPrompt\n        }\n\n        return prompt\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:45-76"",""content"":""} from './provider'\n\nexport const SINGLE_LINE_STOP_SEQUENCES = [\n    anthropic.HUMAN_PROMPT,\n    CLOSING_CODE_TAG.toString(),\n    MULTILINE_STOP_SEQUENCE,\n]\n\nexport const MULTI_LINE_STOP_SEQUENCES = [\n    anthropic.HUMAN_PROMPT,\n    CLOSING_CODE_TAG.toString(),\n    MULTILINE_STOP_SEQUENCE,\n]\n\nconst lineNumberDependentCompletionParams = getLineNumberDependentCompletionParams({\n    singlelineStopSequences: SINGLE_LINE_STOP_SEQUENCES,\n    multilineStopSequences: MULTI_LINE_STOP_SEQUENCES,\n})\n\nlet isOutdatedSourcegraphInstanceWithoutAnthropicAllowlist = false\n\nexport interface AnthropicOptions {\n    model?: string // The model identifier that is being used by the server's site config.\n    maxContextTokens?: number\n    client: Pick<CodeCompletionsClient, 'complete'>\n}\n\nclass AnthropicProvider extends Provider {\n    private promptChars: number\n    private client: Pick<CodeCompletionsClient, 'complete'>\n    private model: string | undefined\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:298-316"",""content"":""    private createInfillingPrompt(\n        filename: PromptString,\n        intro: PromptString,\n        prefix: PromptString,\n        suffix: PromptString\n    ): PromptString {\n        if (isStarCoderFamily(this.model)) {\n            // c.f. https://huggingface.co/bigcode/starcoder#fill-in-the-middle\n            // c.f. https://arxiv.org/pdf/2305.06161.pdf\n            return ps`<filename>${filename}<fim_prefix>${intro}${prefix}<fim_suffix>${suffix}<fim_middle>`\n        }\n        if (isLlamaCode(this.model)) {\n            // c.f. https://github.com/facebookresearch/codellama/blob/main/llama/generation.py#L402\n            return ps`<PRE> ${intro}${prefix} <SUF>${suffix} <MID>`\n        }\n\n        console.error('Could not generate infilling prompt for', this.model)\n        return ps`${intro}${prefix}`\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-mixin.ts:0-22"",""content"":""import type { ChatMessage } from '../chat/transcript/messages'\nimport { PromptString, ps } from './prompt-string'\n\nconst identity = ps`Reply as Cody, a coding assistant developed by Sourcegraph.`\nconst hallucinate = ps`If context is available: never make any assumptions nor provide any misleading or hypothetical examples.`\nconst CODY_INTRO_PROMPT = ps`(${identity} ${hallucinate}) `\n\n/**\n * Prompt mixins elaborate every prompt presented to the LLM.\n * Add a prompt mixin to prompt for cross-cutting concerns relevant to multiple commands.\n */\nexport class PromptMixin {\n    private static mixins: PromptMixin[] = []\n    private static customMixin: PromptMixin[] = []\n    // The prompt that instructs Cody to identify itself and avoid hallucinations.\n    private static defaultMixin: PromptMixin = new PromptMixin(CODY_INTRO_PROMPT)\n\n    /**\n     * Adds a custom prompt mixin but not to the global set to make sure it will not be added twice\n     * and any new change could replace the old one.\n     */\n    public static addCustom(mixin: PromptMixin): void {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.ts:100-126"",""content"":""        instruction: psDedent`\n            This is part of the file: {filePath}\n\n            The user has the following code in their selection:\n            <${PROMPT_TOPICS.SELECTED}>{selectedText}</${PROMPT_TOPICS.SELECTED}>\n\n            The user wants you to generate documentation for the selected code by following their instructions.\n            Provide your generated documentation using the following instructions:\n            <${PROMPT_TOPICS.INSTRUCTIONS}>\n            {instruction}\n            </${PROMPT_TOPICS.INSTRUCTIONS}>`,\n    },\n}\n\nexport const buildGenericPrompt = (\n    intent: EditIntent,\n    { instruction, selectedText, uri }: GetLLMInteractionOptions\n): LLMPrompt => {\n    switch (intent) {\n        case 'edit':\n            return {\n                system: GENERIC_PROMPTS.edit.system,\n                instruction: GENERIC_PROMPTS.edit.instruction\n                    .replaceAll('{instruction}', instruction)\n                    .replaceAll('{selectedText}', selectedText)\n                    .replaceAll('{filePath}', PromptString.fromDisplayPath(uri)),\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:97-142"",""content"":""    private createPromptPrefix(): { messages: Message[]; prefix: PrefixComponents } {\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n\n        const prefixLines = prefix.split('\\n')\n        if (prefixLines.length === 0) {\n            throw new Error('no prefix lines')\n        }\n\n        const { head, tail, overlap } = getHeadAndTail(prefix)\n\n        // Infill block represents the code we want the model to complete\n        const infillBlock = tail.trimmed.toString().endsWith('{\\n')\n            ? tail.trimmed.trimEnd()\n            : tail.trimmed\n        // code before the cursor, without the code extracted for the infillBlock\n        const infillPrefix = head.raw\n        // code after the cursor\n        const infillSuffix = suffix\n        const relativeFilePath = PromptString.fromDisplayPath(this.options.document.uri)\n\n        const prefixMessagesWithInfill: Message[] = [\n            {\n                speaker: 'human',\n                text: ps`You are a code completion AI designed to take the surrounding code and shared context into account in order to predict and suggest high-quality code to complete the code enclosed in ${OPENING_CODE_TAG} tags. You only respond with code that works and fits seamlessly with surrounding code if any or use best practice and nothing else.`,\n            },\n            {\n                speaker: 'assistant',\n                text: ps`I am a code completion AI with exceptional context-awareness designed to auto-complete nested code blocks with high-quality code that seamlessly integrates with surrounding code.`,\n            },\n            {\n                speaker: 'human',\n                text: ps`Below is the code from file path ${relativeFilePath}. Review the code outside the XML tags to detect the functionality, formats, style, patterns, and logics in use. Then, use what you detect and reuse methods/libraries to complete and enclose completed code only inside XML tags precisely without duplicating existing implementations. Here is the code: \\n\\`\\`\\`\\n${\n                    infillPrefix ? infillPrefix : ''\n                }${OPENING_CODE_TAG}${CLOSING_CODE_TAG}${infillSuffix}\\n\\`\\`\\``,\n            },\n            {\n                speaker: 'assistant',\n                text: ps`${OPENING_CODE_TAG}${infillBlock}`,\n            },\n        ]\n\n        return { messages: prefixMessagesWithInfill, prefix: { head, tail, overlap } }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/experimental-ollama.ts:204-215"",""content"":""\n            // For the same reason above, we want a very small suffix because otherwise Ollama needs to\n            // reevaluate more tokens in the prompt. This is because the prompt is (roughly) `prefix\n            // (cursor position) suffix`, so even typing a single character at the cursor position\n            // invalidates the LLM's cache of the suffix.\n            suffixChars: 100,\n        },\n        identifier: PROVIDER_IDENTIFIER,\n        model: ollamaOptions.model,\n    }\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:146-182"",""content"":""    protected createPrompt(snippets: AutocompleteContextSnippet[]): {\n        messages: Message[]\n        prefix: PrefixComponents\n    } {\n        const { messages: prefixMessages, prefix } = this.createPromptPrefix()\n\n        const referenceSnippetMessages: Message[] = []\n\n        let remainingChars = this.promptChars - this.emptyPromptLength()\n\n        for (const snippet of snippets) {\n            const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n            const snippetMessages: Message[] = [\n                {\n                    speaker: 'human',\n                    text: contextPrompts.symbol\n                        ? ps`Additional documentation for \\`${contextPrompts.symbol}\\`: ${OPENING_CODE_TAG}${contextPrompts.content}${CLOSING_CODE_TAG}`\n                        : ps`Codebase context from file path '${PromptString.fromDisplayPath(\n                              snippet.uri\n                          )}': ${OPENING_CODE_TAG}${contextPrompts.content}${CLOSING_CODE_TAG}`,\n                },\n                {\n                    speaker: 'assistant',\n                    text: ps`I will refer to this code to complete your next request.`,\n                },\n            ]\n            const numSnippetChars = messagesToText(snippetMessages).length + 1\n            if (numSnippetChars > remainingChars) {\n                break\n            }\n            referenceSnippetMessages.push(...snippetMessages)\n            remainingChars -= numSnippetChars\n        }\n\n        return { messages: [...referenceSnippetMessages, ...prefixMessages], prefix }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:121-131"",""content"":""     * LLMs that support that kind of message, but that `speaker` value is not currently supported\n     * by the `Message` type.)\n     */\n    speaker: 'human'\n\n    /**\n     * The context item that this message introduces into the conversation.\n     */\n    file: ContextItem\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/fireworks.ts:161-221"",""content"":""    private createPrompt(snippets: AutocompleteContextSnippet[]): PromptString {\n        const { prefix, suffix } = PromptString.fromAutocompleteDocumentContext(\n            this.options.docContext,\n            this.options.document.uri\n        )\n\n        const intro: PromptString[] = []\n        let prompt = ps``\n\n        const languageConfig = getLanguageConfig(this.options.document.languageId)\n\n        // In StarCoder we have a special token to announce the path of the file\n        if (!isStarCoderFamily(this.model)) {\n            intro.push(ps`Path: ${PromptString.fromDisplayPath(this.options.document.uri)}`)\n        }\n\n        for (let snippetsToInclude = 0; snippetsToInclude < snippets.length + 1; snippetsToInclude++) {\n            if (snippetsToInclude > 0) {\n                const snippet = snippets[snippetsToInclude - 1]\n                const contextPrompts = PromptString.fromAutocompleteContextSnippet(snippet)\n\n                if (contextPrompts.symbol) {\n                    intro.push(\n                        ps`Additional documentation for \\`${contextPrompts.symbol}\\`:\\n\\n${contextPrompts.content}`\n                    )\n                } else {\n                    intro.push(\n                        ps`Here is a reference snippet of code from ${PromptString.fromDisplayPath(\n                            snippet.uri\n                        )}:\\n\\n${contextPrompts.content}`\n                    )\n                }\n            }\n\n            const introString = ps`${PromptString.join(\n                PromptString.join(intro, ps`\\n\\n`)\n                    .split('\\n')\n                    .map(line => ps`${languageConfig ? languageConfig.commentStart : ps`// `}${line}`),\n                ps`\\n`\n            )}\\n`\n\n            // We want to remove the same line suffix from a completion request since both StarCoder and Llama\n            // code can't handle this correctly.\n            const suffixAfterFirstNewline = getSuffixAfterFirstNewline(suffix)\n\n            const nextPrompt = this.createInfillingPrompt(\n                PromptString.fromDisplayPath(this.options.document.uri),\n                introString,\n                prefix,\n                suffixAfterFirstNewline\n            )\n\n            if (nextPrompt.length >= this.promptChars) {\n                return prompt\n            }\n\n            prompt = nextPrompt\n        }\n\n        return prompt\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:128-159"",""content"":""\n    /**\n     * Sets the size of the context window used to generate the next token.\n     * (Default: 2048)\n     */\n    num_ctx?: number\n\n    /**\n     * The temperature of the model. Increasing the temperature will make the model answer more creatively.\n     * (Default: 0.8)\n     */\n    temperature?: number\n\n    /**\n     * Sets the stop sequences to use. When this pattern is encountered the LLM will stop generating text and return.\n     * Multiple stop patterns may be set by specifying multiple separate stop parameters in a modelfile.\n     */\n    stop?: string[]\n\n    /**\n     * Reduces the probability of generating nonsense. A higher value (e.g. 100) will give more diverse answers,\n     * while a lower value (e.g. 10) will be more conservative.\n     * (Default: 40)\n     */\n    top_k?: number\n\n    /**\n     * Works together with top-k. A higher value (e.g., 0.95) will lead to more diverse text,\n     * while a lower value (e.g., 0.5) will generate more focused and conservative text.\n     * (Default: 0.9)\n     */\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/type.ts:3-6"",""content"":""export interface LLMPrompt {\n    system?: PromptString\n    instruction: PromptString\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/provider.ts:97-109"",""content"":""\n    /** Called with the result from the LLM. */\n    result(data: CompletionProviderTracerResultData): void\n}\n\nexport interface CompletionProviderTracerResultData {\n    /** The post-processed completions that are returned by the provider. */\n    completions: InlineCompletionItemWithAnalytics[]\n\n    /** Free-form text with debugging or timing information. */\n    debugMessage?: string\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:314-316"",""content"":""    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:16-41"",""content"":""//\n// - Literal strings are considered \""safe\"". Literal strings are constructed with\n//   a tagged template function, `ps`, and a linter in `/lint/safe-prompts.ts`\n//   ensures the function is only used in a tagged template literal, not\n//   aliased, etc.\n// - There are a small set of functions for conveniently constructing strings\n//   from file contents. Use of these functions needs to be continually audited\n//   to ensure they're safe.\n// - Strings constructed from other safe strings, with `ps` or helper methods,\n//   are also safe.\n// - Components sending prompts to LLMs should consume safe strings, not raw\n//   strings.\n//\n// This setup is designed to detect programming errors, not thwart malicious\n// attacks.\n\n/**\n * A \""safe\"" string class for constructing prompts.\n */\nexport class PromptString {\n    /**\n     * @deprecated Do not use the constructor directly. Instead, use ps`...` or a\n     * PromptString helper to handle string data for prompts safely\n     *\n     * @param __debug The string that is wrapped by this PromptString. This is\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/llm-providers/google/utils.ts:15-22"",""content"":""export function constructGeminiChatMessages(messages: Message[]): GeminiChatMessage[] {\n    return messages\n        .map(msg => ({\n            role: msg.speaker === 'human' ? 'user' : 'model',\n            parts: [{ text: msg.text?.toString() ?? '' }],\n        }))\n        .filter((_, i, arr) => i !== arr.length - 1 || arr[i].role !== 'model')\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/provider.ts:57-97"",""content"":""\nexport interface ProviderOptions {\n    /**\n     * A unique and descriptive identifier for the provider.\n     */\n    id: string\n\n    position: Position\n    document: TextDocument\n    docContext: DocumentContext\n    multiline: boolean\n    /**\n     * Number of parallel LLM requests per completion.\n     */\n    n: number\n    /**\n     *  Timeout in milliseconds for the first completion to be yielded from the completions generator.\n     */\n    firstCompletionTimeout: number\n\n    // feature flags\n    hotStreak?: boolean\n}\n\nexport abstract class Provider {\n    constructor(public readonly options: Readonly<ProviderOptions>) {}\n\n    public abstract generateCompletions(\n        abortSignal: AbortSignal,\n        snippets: AutocompleteContextSnippet[],\n        tracer?: CompletionProviderTracer\n    ): AsyncGenerator<FetchCompletionResult[]>\n}\n\n/**\n * Tracer for {@link Provider}.\n */\nexport interface CompletionProviderTracer {\n    /** Called with the params passed to the LLM. */\n    params(params: CompletionParameters): void\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_027/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,The function `searchRemote` in `cody_test/vscode/src/chat/chat-view/context.ts` is responsible for calling remote searches. It utilizes the `RemoteSearch` instance to query for context based on the provided user text.,Where do we call remote searches?,"[{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:159-180"",""content"":""async function searchRemote(\n    remoteSearch: RemoteSearch | null,\n    userText: PromptString\n): Promise<ContextItem[]> {\n    return wrapInActiveSpan('chat.context.search.remote', async () => {\n        if (!remoteSearch) {\n            return []\n        }\n        return (await remoteSearch.query(userText)).map(result => {\n            return {\n                type: 'file',\n                content: result.content,\n                range: new vscode.Range(result.startLine, 0, result.endLine, 0),\n                uri: result.uri,\n                source: ContextItemSource.Unified,\n                repoName: result.repoName,\n                title: result.path,\n                revision: result.commit,\n            } satisfies ContextItem\n        })\n    })\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/search.html:0-20"",""content"":""<!DOCTYPE html>\n<html lang=\""en\"">\n\n<head>\n    <meta charset=\""UTF-8\"" />\n    <meta name=\""viewport\"" content=\""width=device-width, initial-scale=1.0\"" />\n    <!-- This content security policy also implicitly disables inline scripts and styles. -->\n    <meta http-equiv=\""Content-Security-Policy\""\n        content=\""default-src 'none'; img-src {cspSource} https:; script-src {cspSource}; style-src {cspSource}; font-src {cspSource};\"" />\n    <!-- DO NOT REMOVE: THIS FILE IS THE ENTRY FILE FOR CODY WEBVIEW -->\n    <title>Cody Search</title>\n</head>\n\n<body>\n    <div id=\""root\""></div>\n    <script type=\""module\"" src=\""search.tsx\""></script>\n</body>\n\n</html>\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/local-context/index.ts:21-24"",""content"":""export interface IRemoteSearch {\n    setWorkspaceUri(uri: URI): Promise<void>\n    search(query: PromptString): Promise<ContextItemFile[]>\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:60-87"",""content"":""    onShouldBuildSymfIndex: (provider: LocalSearchProvider) => void\n}\n\nfunction useEnhancedContextContext(): EnhancedContextContextT {\n    return React.useContext(EnhancedContextContext)\n}\n\nfunction useEnhancedContextEventHandlers(): EnhancedContextEventHandlersT {\n    return React.useContext(EnhancedContextEventHandlers)\n}\n\n// Shortens a repository name into a more succinct--but ambiguous--display name.\nfunction briefName(name: string): string {\n    return name.slice(name.lastIndexOf('/') + 1)\n}\n\nconst CompactGroupsComponent: React.FunctionComponent<{\n    groups: readonly ContextGroup[]\n    handleChoose: () => void\n    handleRemove: (id: string) => void\n}> = ({ groups, handleChoose, handleRemove }): React.ReactNode => {\n    // The compact groups component is only used for enterprise context, which\n    // uses homogeneous remote search providers. Lift the providers out of the\n    // groups.\n    const liftedProviders: [string, RemoteSearchProvider][] = []\n    for (const group of groups) {\n        const providers = group.providers.filter(\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.tsx:353-377"",""content"":""                // Checkbox click: `CodyVSCodeExtension:useEnhancedContextToggler:clicked`\n                // Button click: `CodyVSCodeExtension:useEnhancedContextTogglerBtn:clicked`\n                const eventName = source === 'btn' ? 'Btn' : ''\n                getVSCodeAPI().postMessage({\n                    command: 'event',\n                    eventName: `CodyVSCodeExtension:useEnhancedContextToggler${eventName}:clicked`,\n                    properties: { useEnhancedContext: shouldEnable },\n                })\n            }\n        },\n        [events, enabled]\n    )\n\n    // Handles removing a manually added remote search provider.\n    const handleRemoveRemoteSearchRepo = React.useCallback(\n        (id: string) => {\n            events.onRemoveRemoteSearchRepo(id)\n        },\n        [events]\n    )\n    const handleChooseRemoteSearchRepo = React.useCallback(\n        () => events.onChooseRemoteSearchRepo(),\n        [events]\n    )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/EnhancedContextSettings.story.tsx:211-235"",""content"":""                                    kind: 'search',\n                                    type: 'remote',\n                                    state: 'ready',\n                                    id: 'pqrxy',\n                                    inclusion: 'manual',\n                                },\n                            ],\n                        },\n                        {\n                            displayName: 'github.com/megacorp/bar',\n                            providers: [\n                                {\n                                    kind: 'search',\n                                    type: 'remote',\n                                    state: 'ready',\n                                    id: 'xgzwa',\n                                    inclusion: 'auto',\n                                },\n                            ],\n                        },\n                        {\n                            displayName: 'github.com/subsidiarycorp/handbook',\n                            providers: [\n                                {\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:1017-1043"",""content"":""\n    // #endregion\n    // =======================================================================\n    // #region session management\n    // =======================================================================\n\n    // A unique identifier for this SimpleChatPanelProvider instance used to identify\n    // it when a handle to this specific panel provider is needed.\n    public get sessionID(): string {\n        return this.chatModel.sessionID\n    }\n\n    // Sets the provider up for a new chat that is not being restored from a\n    // saved session.\n    public async newSession(): Promise<void> {\n        // Set the remote search's selected repos to the workspace repo list\n        // by default.\n        this.remoteSearch?.setRepos(\n            (await this.repoPicker?.getDefaultRepos()) || [],\n            RepoInclusion.Manual\n        )\n    }\n\n    // Attempts to restore the chat to the given sessionID, if it exists in\n    // history. If it does, then saves the current session and cancels the\n    // current in-progress completion. If the chat does not exist, then this\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/context.ts:0-32"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type ConfigurationUseContext,\n    type ContextItem,\n    ContextItemSource,\n    MAX_BYTES_PER_FILE,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    type PromptString,\n    type Result,\n    isFileURI,\n    truncateTextNearestLine,\n    uriBasename,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { RemoteSearch } from '../../context/remote-search'\nimport type { VSCodeEditor } from '../../editor/vscode-editor'\nimport type { ContextRankingController } from '../../local-context/context-ranking'\nimport type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug, logError } from '../../log'\n\ninterface GetEnhancedContextOptions {\n    strategy: ConfigurationUseContext\n    editor: VSCodeEditor\n    text: PromptString\n    providers: {\n        localEmbeddings: LocalEmbeddingsController | null\n        symf: SymfRunner | null\n        remoteSearch: RemoteSearch | null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/Components/FileLink.tsx:43-65"",""content"":""\n    let tooltip: string\n    let pathWithRange: string\n    let href: string\n    let target: string | undefined\n    if (source === 'unified') {\n        // Remote search result.\n        const repoShortName = repoName?.slice(repoName.lastIndexOf('/') + 1)\n        const pathToDisplay = `${repoShortName} ${title}`\n        pathWithRange = range ? `${pathToDisplay}:${displayLineRange(range)}` : pathToDisplay\n        tooltip = `${repoName} @${revision}\\nincluded via Enhanced Context (Enterprise Search)`\n        // We can skip encoding when the uri path already contains '@'.\n        href = uri.toString(uri.path.includes('@'))\n        target = '_blank'\n    } else {\n        const pathToDisplay = `${displayPath(uri)}`\n        pathWithRange = range ? `${pathToDisplay}:${displayLineRange(range)}` : pathToDisplay\n        const openURI = webviewOpenURIForContextItem({ uri, range })\n        tooltip = isTooLarge ? WARNING : pathWithRange\n        href = openURI.href\n        target = openURI.target\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/README.md:44-60"",""content"":""\n## Cody Natural Language Search (Beta)\n\nCody builds a Search index of your local files to make it easier to find what youre looking for. Use a natural language query like password hashing or \""connection retries\"" to quickly find and open the files that match your search.\n\n<img src=\""https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-natural-language.gif\"" width=\""480\"" alt=\""Natural Language Search\"">\n\n## Usage\n\nThis extension works for all Cody plans, including Cody Free, Cody Pro, and Cody Enterprise.\n\nYou can find detailed information about Cody's available plans [on our website](https://sourcegraph.com/pricing?utm_source=marketplace.visualstudio.com&utm_medium=referral).\n\n## Programming Languages\n\nCody works for any programming language because it uses LLMs trained on broad data. Cody works great with Python, Go, JavaScript, and TypeScript code.\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/repo-picker.ts:0-22"",""content"":""import * as vscode from 'vscode'\n\nimport { logDebug } from '../log'\nimport { RemoteSearch } from './remote-search'\nimport { type Repo, type RepoFetcher, RepoFetcherState } from './repo-fetcher'\nimport type { WorkspaceRepoMapper } from './workspace-repo-mapper'\n\n// A quickpick for choosing a set of repositories from a Sourcegraph instance.\nexport class RemoteRepoPicker implements vscode.Disposable {\n    private readonly maxSelectedRepoCount: number = RemoteSearch.MAX_REPO_COUNT - 1\n    private disposables: vscode.Disposable[] = []\n    private readonly quickpick: vscode.QuickPick<vscode.QuickPickItem & Repo>\n    private prefetchedRepos: Map<string, Repo> = new Map()\n\n    constructor(\n        private readonly fetcher: RepoFetcher,\n        private readonly workspaceRepoMapper: WorkspaceRepoMapper\n    ) {\n        this.fetcher.onRepoListChanged(() => this.handleRepoListChanged(), undefined, this.disposables)\n        this.fetcher.onStateChanged(\n            state => {\n                this.quickpick.busy = state === RepoFetcherState.Fetching\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/telemetry/index.ts:0-22"",""content"":""/**\n * A service to log telemetry data.\n */\nexport interface TelemetryService {\n    /**\n     * Log a telemetry event.\n     *\n     * PRIVACY: Do NOT include any potentially private information in `eventProperties`. These\n     * properties may get sent to analytics tools, so must not include private information, such as\n     * search queries or repository names.\n     * @param eventName The name of the event.\n     * @param properties Event properties. Do NOT include any private information, such as full URLs\n     * that may contain private repository names or search queries.\n     * @deprecated New callsites should use telemetryRecorder instead. Existing\n     * callsites should ALSO record an event using services/telemetry-v2\n     * as well and indicate this has happened, for example:\n     *\n     * logEvent(name, properties, { hasV2Event: true })\n     * telemetryRecorder.recordEvent(...)\n     *\n     * In the future, all usages of TelemetryService will be removed in\n     * favour of the new libraries. For more information, see:\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/protocol.md:488-509"",""content"":""<p>Notification sent from the server to the client.</p>\n\n\n```ts\n'progress/report': [ProgressReportParams]\n```\n<h2 id=\""progress_end\""><a href=\""#progress_end\"" name=\""progress_end\""><code>progress/end</code> (<img class=\""emoji\"" title=\"":arrow_right:\"" alt=\"":arrow_right:\"" src=\""https://github.githubassets.com/images/icons/emoji/unicode/27a1.png\"" height=\""20\"" width=\""20\"">)</a></h2>\n<p>Notification sent from the server to the client.</p>\n\n\n```ts\n'progress/end': [{ id: string; }]\n\n```ts\n'remoteRepo/*: ...'\n```\n\nMethods and notifications related to a remote list of repositories. Only for enterprise configurations. See [agent-protocol.ts].\n\n```\n<!-- PROTOCOL END -->\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:213-234"",""content"":""        )\n        this.disposables.push(this.contextStatusAggregator.addProvider(this.codebaseStatusProvider))\n\n        if (this.remoteSearch) {\n            this.disposables.push(\n                // Display enhanced context status from the remote search provider\n                this.contextStatusAggregator.addProvider(this.remoteSearch),\n\n                // When the codebase has a remote ID, include it automatically\n                this.codebaseStatusProvider.onDidChangeStatus(async () => {\n                    const codebase = await this.codebaseStatusProvider.currentCodebase()\n                    if (codebase?.remote && codebase.remoteRepoId) {\n                        this.remoteSearch?.setRepos(\n                            [\n                                {\n                                    name: codebase.remote,\n                                    id: codebase.remoteRepoId,\n                                },\n                            ],\n                            RepoInclusion.Automatic\n                        )\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/context-status.ts:28-62"",""content"":""\nexport interface LocalEmbeddingsProvider {\n    kind: 'embeddings'\n    state: 'indeterminate' | 'no-match' | 'unconsented' | 'indexing' | 'ready'\n    errorReason?: 'not-a-git-repo' | 'git-repo-has-no-remote'\n}\n\nexport type SearchProvider = LocalSearchProvider | RemoteSearchProvider\n\nexport interface LocalSearchProvider {\n    kind: 'search'\n    type: 'local'\n    state: 'unindexed' | 'indexing' | 'ready' | 'failed'\n}\n\nexport interface ContextGroup {\n    /** The directory that this context group represents. */\n    dir?: URI\n\n    /**\n     * Usually `basename(dir)`.\n     *\n     * TODO(sqs): when old remote embeddings code is removed, remove this field and compute it as\n     * late as possible for presentation only.\n     */\n    displayName: string\n\n    providers: ContextProvider[]\n}\n\n// TODO: rename to EnhancedContextStatusT\nexport interface EnhancedContextContextT {\n    groups: ContextGroup[]\n}\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/context/remote-search.ts:0-163"",""content"":""import * as vscode from 'vscode'\n\nimport {\n    type ContextGroup,\n    type ContextItem,\n    type ContextItemFile,\n    ContextItemSource,\n    type ContextSearchResult,\n    type ContextStatusProvider,\n    type Disposable,\n    type IRemoteSearch,\n    type PromptString,\n    graphqlClient,\n    isError,\n} from '@sourcegraph/cody-shared'\n\nimport type { URI } from 'vscode-uri'\nimport { getCodebaseFromWorkspaceUri } from '../repository/git-extension-api'\nimport type * as repofetcher from './repo-fetcher'\n\nexport enum RepoInclusion {\n    Automatic = 'auto',\n    Manual = 'manual',\n}\n\ninterface DisplayRepo {\n    displayName: string\n}\n\nexport class RemoteSearch implements ContextStatusProvider, IRemoteSearch {\n    public static readonly MAX_REPO_COUNT = 10\n\n    private statusChangedEmitter = new vscode.EventEmitter<ContextStatusProvider>()\n\n    // Repositories we are including automatically because of the workspace.\n    private reposAuto: Map<string, DisplayRepo> = new Map()\n\n    // Repositories the user has added manually.\n    private reposManual: Map<string, DisplayRepo> = new Map()\n\n    public dispose(): void {\n        this.statusChangedEmitter.dispose()\n    }\n\n    // #region ContextStatusProvider implementation.\n\n    public onDidChangeStatus(callback: (provider: ContextStatusProvider) => void): Disposable {\n        return this.statusChangedEmitter.event(callback)\n    }\n\n    public get status(): ContextGroup[] {\n        return [...this.getRepoIdSet()].map(id => {\n            const auto = this.reposAuto.get(id)\n            const manual = this.reposManual.get(id)\n            const displayName = auto?.displayName || manual?.displayName || '?'\n            return {\n                displayName,\n                providers: [\n                    {\n                        kind: 'search',\n                        type: 'remote',\n                        state: 'ready',\n                        id,\n                        inclusion: auto ? 'auto' : 'manual',\n                    },\n                ],\n            }\n        })\n    }\n\n    // #endregion\n\n    // Removes a manually included repository.\n    public removeRepo(repoId: string): void {\n        if (this.reposManual.delete(repoId)) {\n            this.statusChangedEmitter.fire(this)\n        }\n    }\n\n    // Sets the repos to search. RepoInclusion.Automatic is for repositories added\n    // automatically based on the workspace; these are presented differently\n    // and can't be removed by the user. RepoInclusion.Manual is for repositories\n    // added manually by the user.\n    public setRepos(repos: repofetcher.Repo[], inclusion: RepoInclusion): void {\n        const repoMap: Map<string, DisplayRepo> = new Map(\n            repos.map(repo => [repo.id, { displayName: repo.name }])\n        )\n        switch (inclusion) {\n            case RepoInclusion.Automatic: {\n                this.reposAuto = repoMap\n                break\n            }\n            case RepoInclusion.Manual: {\n                this.reposManual = repoMap\n                break\n            }\n        }\n        this.statusChangedEmitter.fire(this)\n    }\n\n    public getRepos(inclusion: RepoInclusion): repofetcher.Repo[] {\n        return [\n            ...(inclusion === RepoInclusion.Automatic ? this.reposAuto : this.reposManual).entries(),\n        ].map(([id, repo]) => ({ id, name: repo.displayName }))\n    }\n\n    // Gets the set of all repositories to search.\n    public getRepoIdSet(): Set<string> {\n        return new Set([...this.reposAuto.keys(), ...this.reposManual.keys()])\n    }\n\n    public async query(query: PromptString): Promise<ContextSearchResult[]> {\n        // Sending prompt strings to the Sourcegraph search backend is fine.\n        const result = await graphqlClient.contextSearch(this.getRepoIdSet(), query.toString())\n        if (result instanceof Error) {\n            throw result\n        }\n        return result || []\n    }\n\n    // IRemoteSearch implementation. This is only used for inline edit context.\n\n    public async setWorkspaceUri(uri: URI): Promise<void> {\n        const codebase = getCodebaseFromWorkspaceUri(uri)\n        if (!codebase) {\n            this.setRepos([], RepoInclusion.Automatic)\n            return\n        }\n        const repos = await graphqlClient.getRepoIds([codebase], 10)\n        if (isError(repos)) {\n            throw repos\n        }\n        this.setRepos(repos, RepoInclusion.Automatic)\n    }\n\n    public async search(query: PromptString): Promise<ContextItemFile[]> {\n        const results = await this.query(query)\n        if (isError(results)) {\n            throw results\n        }\n        return (results || []).map(\n            result =>\n                ({\n                    type: 'file',\n                    uri: result.uri,\n                    repoName: result.repoName,\n                    revision: result.commit,\n                    source: ContextItemSource.Unified,\n                    content: result.content,\n                    range: {\n                        start: {\n                            line: result.startLine,\n                            character: 0,\n                        },\n                        end: {\n                            line: result.endLine,\n                            character: 0,\n                        },\n                    },\n                }) satisfies ContextItem\n        )\n    }\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/SearchPanel.tsx:249-272"",""content"":""                <div className={styles.searchInputContainer}>\n                    <textarea\n                        placeholder=\""Search\""\n                        className={styles.searchInput}\n                        onChange={onInputChange}\n                        onKeyDown={onInputKeyDown}\n                        ref={queryInputRef}\n                    />\n                </div>\n            </form>\n            {!searching && query.trim().length === 0 && (\n                <p className={styles.instructions}>\n                    Search for code using a natural language query, such as password hashing,\n                    \""connection retries\"", a symbol name, or a topic.\n                </p>\n            )}\n            {!searching && results.length === 0 && query.trim().length !== 0 && (\n                <p className={styles.instructions}>No results found</p>\n            )}\n            <div className={styles.searchResultsContainer}>\n                {results.map((result, fileIndex) => (\n                    <>\n                        {/* File result */}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:175-202"",""content"":""        {\n            error: string | null\n            repoNames: string[]\n            limitHit: boolean\n        },\n    ]\n\n    // Gets whether the specific repo name is known on the remote.\n    'remoteRepo/has': [{ repoName: string }, { result: boolean }]\n\n    // Gets paginated list of repositories matching a fuzzy search query (or ''\n    // for all repositories.) Remote repositories are fetched concurrently, so\n    // subscribe to 'remoteRepo/didChange' to invalidate results.\n    //\n    // At the end of the list, returns an empty list of repositories.\n    // If `afterId` is specified, but not in the query result set,\n    // `startIndex` is -1.\n    //\n    // remoteRepo/list caches a single query result, making it efficient to page\n    // through a large list of results provided the query is the same.\n    'remoteRepo/list': [\n        {\n            // The user input to perform a fuzzy match with\n            query?: string\n            // The maximum number of results to retrieve\n            first: number\n            // The repository ID of the last result in the previous\n""}]",Find logic,,,1,,1,false,,,,,,,,,,,,,,,,
yaml,chat-context,gemini-1.5-pro-latest,chat,question_028/question.yaml,9cddf3856b5a55fc00e1ad07be3e6d6ad982b474,,,,0,0,0,0,,,,,,,,,,,"The code you provided doesn't seem to have a central place where ""completion types"" are explicitly checked in the traditional sense of a conditional statement or switch case. 

However, based on the context, it seems like ""completion types"" might refer to the different kinds of type information associated with code completion suggestions. 

Here's how the code you provided seems to handle different aspects of completion types:

- **`scip.ts`:** This file defines various TypeScript types like `SingleType`, `SuperType`, `AnnotatedType`, etc. These types likely represent different categories of code completion suggestions, such as suggesting a variable of a specific type, a superclass, or an annotated type.
- **`get-completion-params.ts`:** This file defines an interface `LineNumberDependentCompletionParamsByType` which suggests that completion parameters might vary depending on whether the code is on a single line or multiple lines. This could influence the types of completions offered.
- **`test-helpers.ts`:** This file defines a `completion` function that seems to extract completion suggestions from a template string. This suggests that completion types might be implicitly determined based on the context of the code and the template being used.
- **`types.ts`:** This file defines several interfaces related to completions, including `CompletionResponse`, `CompletionEvent`, `CompletionParameters`, and `CompletionCallbacks`. These interfaces likely define the structure of data related to code completion suggestions, and the different types of information that might be associated with a suggestion.

Therefore, instead of a single point of checking, the code likely determines and utilizes ""completion types"" throughout the completion suggestion process based on factors like:

- The specific type definitions in `scip.ts`.
- The context of the code being edited (e.g., single-line vs. multi-line).
- The templates used for generating completion suggestions.
- The data structures used to represent completions and their associated information. 

To get a more precise understanding of how ""completion types"" are used, you would need to analyze how these different components interact during the code completion process.",Where do we check for completion types?,"[{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/index.ts:0-2"",""content"":""export type { Message } from './completions/types'\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/types.ts:0-59"",""content"":""import type * as vscode from 'vscode'\n\nimport type { AutocompleteContextSnippet, DocumentContext } from '@sourcegraph/cody-shared'\nimport type { LastInlineCompletionCandidate } from './get-inline-completions'\n\n/**\n * @see vscode.InlineCompletionItem\n */\nexport interface InlineCompletionItem {\n    insertText: string\n    /**\n     * The range to replace.\n     * Must begin and end on the same line.\n     *\n     * Prefer replacements over insertions to provide a better experience when the user deletes typed text.\n     */\n    range?: vscode.Range\n}\n\nexport interface ContextRetrieverOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    hints: {\n        maxChars: number\n        maxMs: number\n    }\n    lastCandidate?: LastInlineCompletionCandidate\n    abortSignal?: AbortSignal\n}\n\n/**\n * Interface for a general purpose retrieval strategy. During the retrieval phase, all retrievers\n * that are outlined in the execution plan will be called concurrently.\n */\nexport interface ContextRetriever extends vscode.Disposable {\n    /**\n     * The identifier of the retriever. Used for logging purposes.\n     */\n    identifier: string\n\n    /**\n     * Start a retrieval processes. Implementers should observe the hints to return the best results\n     * in the available time.\n     *\n     * The client hints signalize _soft_ timeouts. When a hard timeout is reached, the retriever's\n     * results will not be taken into account anymore so it's suggested to return _something_ during\n     * the maxMs time.\n     *\n     * The abortSignal can be used to detect when the completion request becomes invalidated. When\n     * triggered, any further work is ignored so you can stop immediately.\n     */\n    retrieve(options: ContextRetrieverOptions): Promise<AutocompleteContextSnippet[]>\n\n    /**\n     * Return true if the retriever supports the given languageId.\n     */\n    isSupportedForLanguageId(languageId: string): boolean\n}\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2372-2394"",""content"":""                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: SuperType\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2478-2500"",""content"":""                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: AnnotatedType\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/text-processing/process-inline-completions.ts:123-127"",""content"":""interface GetNodeTypesInfoParams {\n    position: Position\n    parseTree?: Tree\n    multilineTriggerPosition: Position | null\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2350-2372"",""content"":""                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: ThisType\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/text-processing/process-inline-completions.ts:129-160"",""content"":""function getNodeTypesInfo(\n    params: GetNodeTypesInfoParams\n): InlineCompletionItemWithAnalytics['nodeTypes'] | undefined {\n    const { position, parseTree, multilineTriggerPosition } = params\n\n    const positionBeforeCursor = asPoint({\n        line: position.line,\n        character: Math.max(0, position.character - 1),\n    })\n\n    if (parseTree) {\n        const captures = getNodeAtCursorAndParents(parseTree.rootNode, positionBeforeCursor)\n\n        if (captures.length > 0) {\n            const [atCursor, ...parents] = captures\n            const lastAncestorOnTheSameLine = findLastAncestorOnTheSameRow(\n                parseTree.rootNode,\n                asPoint(multilineTriggerPosition || position)\n            )\n\n            return {\n                atCursor: atCursor.node.type,\n                parent: parents[0]?.node.type,\n                grandparent: parents[1]?.node.type,\n                greatGrandparent: parents[2]?.node.type,\n                lastAncestorOnTheSameLine: lastAncestorOnTheSameLine?.type,\n            }\n        }\n    }\n\n    return undefined\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2584-2605"",""content"":""                              repeated_type?: never\n                              match_type?: MatchType\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: LambdaType\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3655-3657"",""content"":""        set types(value: Type[]) {\n            pb_1.Message.setRepeatedWrapperField(this, 1, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2436-2457"",""content"":""                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: WithType\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3740-3742"",""content"":""        set types(value: Type[]) {\n            pb_1.Message.setRepeatedWrapperField(this, 1, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2457-2478"",""content"":""                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: StructuralType\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3825-3827"",""content"":""        set types(value: Type[]) {\n            pb_1.Message.setRepeatedWrapperField(this, 1, value)\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2500-2521"",""content"":""                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: ExistentialType\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/types.ts:39-43"",""content"":""export interface CompletionCallbacks {\n    onChange: (text: string) => void\n    onComplete: () => void\n    onError: (error: Error, statusCode?: number) => void\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2415-2436"",""content"":""                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: UnionType\n                              with_type?: never\n                              structural_type?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/types.ts:28-37"",""content"":""export interface CompletionParameters {\n    fast?: boolean\n    messages: Message[]\n    maxTokensToSample: number\n    temperature?: number\n    stopSequences?: string[]\n    topK?: number\n    topP?: number\n    model?: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2521-2542"",""content"":""                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: UniversalType\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/types.ts:6-8"",""content"":""interface CompletionEvent extends CompletionResponse {\n    type: 'completion'\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2329-2350"",""content"":""                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: SingleType\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/sourcegraph-api/completions/types.ts:23-26"",""content"":""export interface CompletionResponse {\n    completion: string\n    stopReason: string\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2563-2584"",""content"":""                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: RepeatedType\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/test-helpers.ts:17-31"",""content"":""export function completion(string: TemplateStringsArray, ...values: unknown[]): CompletionResponse {\n    const raw = dedent(string, ...values)\n    let completion = raw\n\n    const start = raw.indexOf('')\n    const end = raw.lastIndexOf('')\n    if (0 <= start && start <= end) {\n        completion = raw.slice(start + 1, end)\n    }\n\n    return {\n        completion,\n        stopReason: 'unknown',\n    }\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2855-2869"",""content"":""            super_type?: ReturnType<typeof SuperType.prototype.toObject>\n            constant_type?: ReturnType<typeof ConstantType.prototype.toObject>\n            intersection_type?: ReturnType<typeof IntersectionType.prototype.toObject>\n            union_type?: ReturnType<typeof UnionType.prototype.toObject>\n            with_type?: ReturnType<typeof WithType.prototype.toObject>\n            structural_type?: ReturnType<typeof StructuralType.prototype.toObject>\n            annotated_type?: ReturnType<typeof AnnotatedType.prototype.toObject>\n            existential_type?: ReturnType<typeof ExistentialType.prototype.toObject>\n            universal_type?: ReturnType<typeof UniversalType.prototype.toObject>\n            by_name_type?: ReturnType<typeof ByNameType.prototype.toObject>\n            repeated_type?: ReturnType<typeof RepeatedType.prototype.toObject>\n            match_type?: ReturnType<typeof MatchType.prototype.toObject>\n            lambda_type?: ReturnType<typeof LambdaType.prototype.toObject>\n        }): Type {\n""},{""source"":""search"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/get-completion-params.ts:10-13"",""content"":""interface LineNumberDependentCompletionParamsByType {\n    singlelineParams: LineNumberDependentCompletionParams\n    multilineParams: LineNumberDependentCompletionParams\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2542-2563"",""content"":""                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: ByNameType\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n""},{""source"":""embeddings"",""file"":""/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2394-2415"",""content"":""                              super_type?: never\n                              constant_type?: ConstantType\n                              intersection_type?: never\n                              union_type?: never\n                              with_type?: never\n                              structural_type?: never\n                              annotated_type?: never\n                              existential_type?: never\n                              universal_type?: never\n                              by_name_type?: never\n                              repeated_type?: never\n                              match_type?: never\n                              lambda_type?: never\n                          }\n                      | {\n                              type_ref?: never\n                              single_type?: never\n                              this_type?: never\n                              super_type?: never\n                              constant_type?: never\n                              intersection_type?: IntersectionType\n""}]",Find logic,,,1,,0,false,,,,,,,,,,,,,,,,
