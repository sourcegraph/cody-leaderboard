 question: Where do we choose the context items from different sources?
# CHAT
# CHAT_QUESTION Where do we choose the context items from different sources?

# CHAT_REPLY Based on the codebase context, the selection of context items from different sources seems to happen in the `context-mixer.ts` file, specifically in the `GetContextResult` interface and the `ContextMixer` class.
# CHAT_REPLY 
# CHAT_REPLY The `ContextMixer` is responsible for combining multiple context retrieval strategies into a single proposed context list. It does this by ranking the order of documents using reciprocal rank fusion and then combining the snippets from each retriever into a single list using top-k.
# CHAT_REPLY 
# CHAT_REPLY The `GetContextResult` interface defines the result of the context mixing process, which includes an array of `AutocompleteContextSnippet` objects representing the selected context, and a `ContextSummary` object containing information about the different retrievers that were used, such as the strategy, duration, and which positions in the result set each retriever contributed to.
# CHAT_REPLY 
# CHAT_REPLY The specific context retrieval strategies are defined in the `context-strategy.ts` file, where the `ContextStrategy` type lists the available strategies like `bfg`, `jaccard-similarity`, `bfg-mixed`, etc. Each strategy is implemented by a different `ContextRetriever` class, such as `BfgRetriever` or `JaccardSimilarityRetriever`.
# CHAT_REPLY 
# CHAT_REPLY So, in summary, the `ContextMixer` class orchestrates the selection of context items from different retrieval strategies (e.g., BFG, Jaccard similarity, local context, etc.), ranks and combines them into a single list, and provides information about the contribution of each strategy.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:168-197","content":"    public async rankContextItems(\n        query: PromptString,\n        contextItems: ContextItem[]\n    ): Promise<ContextItem[]> {\n        const repoUri = this.getRepoUri()\n        if (!repoUri || !this.endpointIsDotcom || !this.serviceStarted) {\n            return contextItems\n        }\n\n        try {\n            const service = await this.getService()\n            const rankItems = this.convertContextItemsToRankItems(repoUri.fsPath, contextItems)\n            const rankedItemsOrder = await service.request('context-ranking/rank-items', {\n                repoPath: repoUri.path,\n                contextItems: rankItems,\n                query: query.toString(),\n            })\n\n            if (rankedItemsOrder.prediction.length !== contextItems.length) {\n                return contextItems\n            }\n            const reRankedContextItems = this.orderContextItemsAsRankItems(\n                contextItems,\n                rankedItemsOrder.prediction\n            )\n            return reRankedContextItems\n        } catch (error) {\n            return contextItems\n        }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:26-66","content":"export type {\n    ChatError,\n    EventSource,\n    ChatHistory,\n    ChatMessage,\n    UserLocalHistory,\n    SerializedChatMessage,\n} from './chat/transcript/messages'\nexport {\n    CODY_PASSTHROUGH_VSCODE_OPEN_COMMAND_ID,\n    webviewOpenURIForContextItem,\n} from './chat/transcript/display-text'\nexport { Typewriter } from './chat/typewriter'\nexport { reformatBotMessageForChat } from './chat/viewHelpers'\nexport type {\n    ContextGroup,\n    ContextProvider,\n    ContextStatusProvider,\n    Disposable,\n    EnhancedContextContextT,\n    LocalEmbeddingsProvider,\n    LocalSearchProvider,\n    RemoteSearchProvider,\n    SearchProvider,\n} from './codebase-context/context-status'\nexport {\n    type ContextItem,\n    type ContextItemFile,\n    ContextItemSource,\n    type ContextItemWithContent,\n    type ContextItemSymbol,\n    type ContextFileType,\n    type ContextMessage,\n    type SymbolKind,\n} from './codebase-context/messages'\nexport type {\n    CodyCommand,\n    CodyCommandContext,\n    CodyCommandType,\n    TerminalOutputArguments,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:59-73","content":"function convertContextItemMentionElement(domNode: HTMLElement): DOMConversionOutput | null {\n    const data = domNode.getAttribute(DOM_DATA_ATTR)\n    if (data !== null) {\n        try {\n            const contextItem: SerializedContextItem = JSON.parse(data)\n            const node = $createContextItemMentionNode(contextItem)\n            return { node }\n        } catch (error) {\n            console.error(error)\n            return null\n        }\n    }\n\n    return null\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/chat/cells/contextCell/ContextCell.tsx:0-27","content":"import type { ContextItem } from '@sourcegraph/cody-shared'\nimport classNames from 'classnames'\nimport type React from 'react'\nimport { FileLink } from '../../../Components/FileLink'\nimport { SourcegraphLogo } from '../../../icons/SourcegraphLogo'\nimport { MENTION_CLASS_NAME } from '../../../promptEditor/nodes/ContextItemMentionNode'\nimport { getVSCodeAPI } from '../../../utils/VSCodeApi'\nimport { LoadingDots } from '../../components/LoadingDots'\nimport { Cell } from '../Cell'\nimport styles from './ContextCell.module.css'\n\n/**\n * A component displaying the context for a human message.\n */\nexport const ContextCell: React.FunctionComponent<{\n    contextFiles: ContextItem[] | undefined\n    disabled?: boolean\n    className?: string\n\n    /** For use in storybooks only. */\n    __storybook__initialOpen?: boolean\n}> = ({ contextFiles, disabled, className, __storybook__initialOpen }) => {\n    const usedContext = []\n    const excludedAtContext = []\n    if (contextFiles) {\n        for (const f of contextFiles) {\n            if (f.isTooLarge) {\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/execute/cody.json:16-24","content":"      \"context\": {\n        \"currentFile\": true\n      },\n      \"type\": \"default\"\n    },\n    \"test\": {\n      \"description\": \"Generate unit tests\",\n      \"prompt\": \"Review the shared context to identify the testing framework and libraries in use. Then, generate a suite of multiple unit tests for the selected function using the detected test framework and libraries. Be sure to import the function being tested. Use the same patterns, testing framework, conventions, and libraries as shown in the shared context. Only import modules, functions, dependencies, and mocks based on shared code. If a test suite for the selected code is in the shared context, focus on generating new tests for uncovered cases. If none are detected, import common unit test libraries for {languageName}. Focus on validating key functionality with simple and complete assertions. Before writing the tests, identify which testing libraries and frameworks to use and import. At the end, enclose the fully completed code for the new unit tests without any comments, fragments, or TODOs. The new tests should validate the expected functionality and cover edge cases for with all required imports, including the function being tested. Do not repeat tests from the shared context. Enclose only the complete runnable tests.\",\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:190-199","content":"export function $createContextItemMentionNode(\n    contextItem: ContextItem | SerializedContextItem\n): ContextItemMentionNode {\n    const node = new ContextItemMentionNode(contextItem)\n    node.setMode('token').toggleDirectionless()\n    contextItem.type === 'file' &&\n        contextItem.isTooLarge &&\n        node.setStyle('color: var(--vscode-list-errorForeground)')\n    return $applyNodeReplacement(node)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/index.ts:130-167","content":"} from './inferenceClient/misc'\nexport type {\n    ContextResult,\n    FilenameContextFetcher,\n    IndexedKeywordContextFetcher,\n    LocalEmbeddingsFetcher,\n    IRemoteSearch,\n    Result,\n    SearchPanelFile,\n    SearchPanelSnippet,\n} from './local-context'\nexport { logDebug, logError, setLogger } from './logger'\nexport {\n    createOllamaClient,\n    ollamaChatClient,\n    type OllamaGenerateParams,\n    OLLAMA_DEFAULT_URL,\n} from './llm-providers/ollama'\nexport {\n    MAX_BYTES_PER_FILE,\n    MAX_CURRENT_FILE_TOKENS,\n    ANSWER_TOKENS,\n    NUM_CODE_RESULTS,\n    NUM_TEXT_RESULTS,\n    SURROUNDING_LINES,\n} from './prompt/constants'\nexport { PromptMixin, newPromptMixin } from './prompt/prompt-mixin'\nexport * from './prompt/templates'\nexport {\n    truncateText,\n    truncateTextNearestLine,\n    truncatePromptStringStart,\n    truncatePromptString,\n} from './prompt/truncation'\nexport type { Message } from './sourcegraph-api'\nexport { SourcegraphBrowserCompletionsClient } from './sourcegraph-api/completions/browserClient'\nexport { SourcegraphCompletionsClient } from './sourcegraph-api/completions/client'\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:213-217","content":"export function $createContextItemTextNode(contextItem: ContextItem | SerializedContextItem): TextNode {\n    const atNode = new ContextItemMentionNode(contextItem)\n    const textNode = new TextNode(atNode.__text)\n    return $applyNodeReplacement(textNode)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.ts:418-421","content":"\n    return context.concat(currentFileNameComment, prompt.prefix)\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItem.kt:22-53","content":"\ndata class ContextItemFile(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: file\n) : ContextItem() {\n\n  enum class TypeEnum {\n    @SerializedName(\"file\") File,\n  }\n}\n\ndata class ContextItemSymbol(\n  val uri: Uri? = null,\n  val range: RangeData? = null,\n  val content: String? = null,\n  val repoName: String? = null,\n  val revision: String? = null,\n  val title: String? = null,\n  val source: ContextItemSource? = null, // Oneof: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n  val size: Int? = null,\n  val isTooLarge: Boolean? = null,\n  val type: TypeEnum? = null, // Oneof: symbol\n  val symbolName: String? = null,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:77-173","content":"export class ContextItemMentionNode extends TextNode {\n    static getType(): string {\n        return 'contextItemMention'\n    }\n\n    static clone(node: ContextItemMentionNode): ContextItemMentionNode {\n        return new ContextItemMentionNode(node.contextItem, node.__text, node.__key)\n    }\n    static importJSON(serializedNode: SerializedContextItemMentionNode): ContextItemMentionNode {\n        const node = $createContextItemMentionNode(serializedNode.contextItem)\n        node.setTextContent(serializedNode.text)\n        node.setFormat(serializedNode.format)\n        node.setDetail(serializedNode.detail)\n        node.setMode(serializedNode.mode)\n        node.setStyle(serializedNode.style)\n        return node\n    }\n\n    private contextItem: SerializedContextItem\n\n    constructor(\n        contextItemWithAllFields: ContextItem | SerializedContextItem,\n        text?: string,\n        key?: NodeKey\n    ) {\n        // Make sure we only bring over the fields on the context item that we need, or else we\n        // could accidentally include tons of data (including the entire contents of files).\n        const contextItem = serializeContextItem(contextItemWithAllFields)\n\n        super(text ?? contextItemMentionNodeDisplayText(contextItem), key)\n\n        this.contextItem = contextItem\n    }\n\n    exportJSON(): SerializedContextItemMentionNode {\n        return {\n            ...super.exportJSON(),\n            contextItem: this.contextItem,\n            type: ContextItemMentionNode.getType(),\n            version: 1,\n        }\n    }\n\n    private static CLASS_NAMES = `context-item-mention-node ${styles.contextItemMentionNode}`\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config)\n        element.className = ContextItemMentionNode.CLASS_NAMES\n        return element\n    }\n\n    exportDOM(): DOMExportOutput {\n        const element = document.createElement('span')\n        element.setAttribute(DOM_DATA_ATTR, JSON.stringify(this.contextItem))\n        element.className = ContextItemMentionNode.CLASS_NAMES\n\n        const link = document.createElement('a')\n        const { href, target } = webviewOpenURIForContextItem({\n            uri: URI.parse(this.contextItem.uri),\n            range: this.contextItem.range,\n        })\n        link.href = href\n        if (target) {\n            link.target = target\n        }\n        link.textContent = this.__text\n        element.appendChild(link)\n\n        return { element }\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            span: (domNode: HTMLElement) => {\n                if (!domNode.hasAttribute(DOM_DATA_ATTR)) {\n                    return null\n                }\n                return {\n                    conversion: convertContextItemMentionElement,\n                    priority: 1,\n                }\n            },\n        }\n    }\n\n    isTextEntity(): true {\n        return true\n    }\n\n    canInsertTextBefore(): boolean {\n        return false\n    }\n\n    canInsertTextAfter(): boolean {\n        return false\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-input.ts:396-419","content":"\n                const matchingContext = await getMatchingContext(mentionQuery)\n                if (matchingContext.length === 0) {\n                    // Attempted to match but found nothing\n                    input.items = [\n                        {\n                            alwaysShow: true,\n                            label:\n                                mentionQuery.type === 'symbol'\n                                    ? mentionQuery.text.length === 0\n                                        ? SYMBOL_HELP_LABEL\n                                        : NO_SYMBOL_MATCHES_LABEL\n                                    : mentionQuery.text.length === 0\n                                      ? FILE_HELP_LABEL\n                                      : NO_FILE_MATCHES_LABEL,\n                        },\n                    ]\n                    return\n                }\n\n                // Update stored context items so we can retrieve them later\n                for (const { key, item } of matchingContext) {\n                    contextItems.set(key, item)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:40-68","content":"export async function fetchContentForURLContextItem(\n    url: string,\n    signal?: AbortSignal\n): Promise<string | null> {\n    const resp = await fetch(url.toString(), { signal })\n    if (!resp.ok) {\n        return null\n    }\n    const body = await resp.text()\n\n    // HACK(sqs): Rudimentarily strip HTML tags, script, and other unneeded elements from body using\n    // regexp. This is NOT intending to be a general-purpose HTML parser and is NOT sanitizing the\n    // value for security.\n    const bodyWithoutTags = body\n        .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n        .replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '')\n        .replace(/<svg\\b[^<]*(?:(?!<\\/svg>)<[^<]*)*<\\/svg>/gi, '')\n        .replace(/<!--.*?-->/gs, '')\n        .replace(/\\s(?:class|style)=[\"'][^\"']*[\"']/gi, '')\n        .replace(/\\sdata-[\\w-]+(=[\"'][^\"']*[\"'])?/gi, '')\n\n    // TODO(sqs): Arbitrarily trim the response text to avoid overflowing the context window for the\n    // LLM. Ideally we would make the prompt builder prioritize this context item over other context\n    // because it is explicitly from the user.\n    const MAX_LENGTH = 14000\n    return bodyWithoutTags.length > MAX_LENGTH\n        ? `${bodyWithoutTags.slice(0, MAX_LENGTH)}... (web page content was truncated)`\n        : bodyWithoutTags\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.ts:294-320","content":"\n    public static fromContextItem(contextItem: ContextItem) {\n        const ref = [contextItem.uri]\n        return {\n            content: contextItem.content\n                ? internal_createPromptString(contextItem.content, ref)\n                : undefined,\n            repoName: contextItem.repoName\n                ? internal_createPromptString(contextItem.repoName, ref)\n                : undefined,\n        }\n    }\n\n    // ðŸš¨ Use this function only for user-generated queries.\n    // TODO: Can we detect if the user is pasting in content from a document?\n    public static unsafe_fromUserQuery(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // ðŸš¨ Use this function only for LLM responses queries.\n    public static unsafe_fromLLMResponse(string: string): PromptString {\n        return internal_createPromptString(string, [])\n    }\n\n    // ðŸš¨ We slam chats in and out of storage quite a bit, so it seems weird to\n    // have references on a chat transcript, but closing and opening the chat\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:35-48","content":"export function serializeContextItem(\n    contextItem: ContextItem | SerializedContextItem\n): SerializedContextItem {\n    // Make sure we only bring over the fields on the context item that we need, or else we\n    // could accidentally include tons of data (including the entire contents of files).\n    return {\n        ...contextItem,\n        uri: contextItem.uri.toString(),\n\n        // Don't include the `content` (if it's present) because it's quite large, and we don't need\n        // to serialize it here. It can be hydrated on demand.\n        content: undefined,\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:0-33","content":"import type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    isCodyIgnoredFile,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport type { LastInlineCompletionCandidate } from '../get-inline-completions'\nimport type { ContextStrategy, ContextStrategyFactory } from './context-strategy'\nimport { fuseResults } from './reciprocal-rank-fusion'\n\ninterface GetContextOptions {\n    document: vscode.TextDocument\n    position: vscode.Position\n    docContext: DocumentContext\n    abortSignal?: AbortSignal\n    maxChars: number\n    lastCandidate?: LastInlineCompletionCandidate\n}\n\nexport interface ContextSummary {\n    /** Name of the strategy being used */\n    strategy: ContextStrategy\n    /** Total duration of the context retrieval phase */\n    duration: number\n    /** Total characters of combined context snippets */\n    totalChars: number\n    /** Detailed information for each retriever that has run */\n    retrieverStats: {\n        [identifier: string]: {\n            /** Number of items that are ended up being suggested to be used by the context mixer */\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/nodes/ContextItemMentionNode.ts:50-52","content":"export function deserializeContextItem(contextItem: SerializedContextItem): ContextItem {\n    return { ...contextItem, uri: URI.parse(contextItem.uri) }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/input/get-matching-context.ts:0-31","content":"import type { ContextItem, MentionQuery } from '@sourcegraph/cody-shared'\nimport * as vscode from 'vscode'\n\nimport { getChatContextItemsForMention } from '../../chat/context/chatContext'\nimport { getLabelForContextItem } from './utils'\n\ninterface FixupMatchingContext {\n    /* Unique identifier for the context, shown in the input value but not necessarily in the quick pick selector */\n    key: string\n    /* If present, will override the key shown in the quick pick selector */\n    shortLabel?: string\n    item: ContextItem\n}\n\nexport async function getMatchingContext(mentionQuery: MentionQuery): Promise<FixupMatchingContext[]> {\n    const token = new vscode.CancellationTokenSource()?.token\n    const results = await getChatContextItemsForMention(mentionQuery, token)\n    return results.map(result => {\n        return {\n            key: getLabelForContextItem(result),\n            item: result,\n            shortLabel:\n                result.type === 'symbol'\n                    ? `${result.kind === 'class' ? '$(symbol-structure)' : '$(symbol-method)'} ${\n                          result.symbolName\n                      }`\n                    : undefined,\n        }\n    })\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:7-34","content":"export async function getURLContextItems(\n    urlInput: string,\n    signal?: AbortSignal\n): Promise<ContextItem[]> {\n    const url = tryParsePossiblyIncompleteURL(urlInput)\n    if (url === null) {\n        return []\n    }\n\n    try {\n        const content = await fetchContentForURLContextItem(url.toString(), signal)\n        if (content === null) {\n            return []\n        }\n        return [\n            {\n                type: 'file',\n                uri: url,\n                content,\n                title: tryGetHTMLDocumentTitle(content),\n                source: ContextItemSource.Uri,\n            },\n        ]\n    } catch (error) {\n        // Suppress errors because the user might be typing a URL that is not yet valid.\n        return []\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:0-25","content":"import * as vscode from 'vscode'\n\nimport type { ContextRetriever } from '../types'\n\nimport type { BfgRetriever } from './retrievers/bfg/bfg-retriever'\nimport { JaccardSimilarityRetriever } from './retrievers/jaccard-similarity/jaccard-similarity-retriever'\nimport { SectionHistoryRetriever } from './retrievers/section-history/section-history-retriever'\n\nexport type ContextStrategy =\n    | 'bfg'\n    | 'jaccard-similarity'\n    | 'new-jaccard-similarity'\n    | 'bfg-mixed'\n    | 'local-mixed'\n    | 'none'\n\nexport interface ContextStrategyFactory extends vscode.Disposable {\n    getStrategy(document: vscode.TextDocument): { name: ContextStrategy; retrievers: ContextRetriever[] }\n}\n\nexport class DefaultContextStrategyFactory implements ContextStrategyFactory {\n    private disposables: vscode.Disposable[] = []\n\n    private localRetriever: ContextRetriever | undefined\n    private graphRetriever: ContextRetriever | undefined\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/mentions/urlContextItems.ts:36-38","content":"export function isURLContextItem(item: Pick<ContextItem, 'uri'>): boolean {\n    return item.uri.scheme === 'http' || item.uri.scheme === 'https'\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-mixer.ts:33-61","content":"            suggestedItems: number\n            /** Number of total snippets */\n            retrievedItems: number\n            /** Duration of the individual retriever */\n            duration: number\n            /**\n             * A bitmap that indicates at which position in the result set an entry from the given\n             * retriever is included. It only includes information about the first 32 entries.\n             *\n             * The lowest bit indicates if the first entry is included, the second lowest bit\n             * indicates if the second entry is included, and so on.\n             */\n            positionBitmap: number\n        }\n    }\n}\n\nexport interface GetContextResult {\n    context: AutocompleteContextSnippet[]\n    logSummary: ContextSummary\n}\n\n/**\n * The context mixer is responsible for combining multiple context retrieval strategies into a\n * single proposed context list.\n *\n * This is done by ranking the order of documents using reciprocal rank fusion and then combining\n * the snippets from each retriever into a single list using top-k (so we will pick all returned\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:212-226","content":"    private orderContextItemsAsRankItems(\n        contextItems: ContextItem[],\n        rankedItemsOrder: RankerPrediction[]\n    ): ContextItem[] {\n        rankedItemsOrder.sort((a, b) => b.score - a.score)\n        const orderedContextItems: ContextItem[] = []\n        for (const item of rankedItemsOrder) {\n            const newIndex = item.document_id\n            if (newIndex < 0 || newIndex >= contextItems.length) {\n                return contextItems\n            }\n            orderedContextItems.push(contextItems[newIndex])\n        }\n        return orderedContextItems\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:38-88","content":"\n    /**\n     * The token count of the item's content.\n     */\n    size?: number\n\n    /**\n     * Whether the content of the item is too large to be included as context.\n     */\n    isTooLarge?: boolean\n}\n\n/**\n * The source of this context.\n */\nexport enum ContextItemSource {\n    /** From embeddings search */\n    Embeddings = 'embeddings',\n\n    /** Explicitly @-mentioned by the user in chat */\n    User = 'user',\n\n    /** From local keyword search */\n    Keyword = 'keyword',\n\n    /** From the current editor state and open tabs/documents */\n    Editor = 'editor',\n\n    Filename = 'filename',\n\n    /** From symf search */\n    Search = 'search',\n\n    /** Remote search */\n    Unified = 'unified',\n\n    /** Selected code from the current editor */\n    Selection = 'selection',\n\n    /** Output from the terminal */\n    Terminal = 'terminal',\n\n    /** From URI */\n    Uri = 'uri',\n}\n\n/**\n * An item (such as a file or symbol) that is included as context in a chat message.\n */\nexport type ContextItem = ContextItemFile | ContextItemSymbol\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/context-ranking.ts:199-210","content":"    private convertContextItemsToRankItems(\n        baseRepoPath: string,\n        contextItems: ContextItem[]\n    ): RankContextItem[] {\n        const rankContextItems = contextItems.map((item, index) => ({\n            documentId: index,\n            filePath: item.uri?.path ? path.relative(baseRepoPath, item.uri?.path) : '',\n            content: item.content ?? '',\n            source: item.source,\n        }))\n        return rankContextItems\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/completion-provider-config.ts:55-77","content":"        )\n    }\n\n    public get contextStrategy(): ContextStrategy {\n        const { config } = this\n\n        const bfgMixedContextFlag = this.getPrefetchedFlag(FeatureFlag.CodyAutocompleteContextBfgMixed)\n\n        const contextStrategy: ContextStrategy =\n            config.autocompleteExperimentalGraphContext === 'bfg'\n                ? 'bfg'\n                : config.autocompleteExperimentalGraphContext === 'bfg-mixed'\n                  ? 'bfg-mixed'\n                  : config.autocompleteExperimentalGraphContext === 'local-mixed'\n                      ? 'local-mixed'\n                      : config.autocompleteExperimentalGraphContext === 'jaccard-similarity'\n                          ? 'jaccard-similarity'\n                          : config.autocompleteExperimentalGraphContext === 'new-jaccard-similarity'\n                              ? 'new-jaccard-similarity'\n                              : bfgMixedContextFlag\n                                  ? 'bfg-mixed'\n                                  : 'jaccard-similarity'\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/bindings/kotlin/lib/src/main/kotlin/com/sourcegraph/cody/protocol_generated/ContextItemSource.kt:0-6","content":"@file:Suppress(\"FunctionName\", \"ClassName\", \"unused\", \"EnumEntryName\", \"UnusedImport\")\npackage com.sourcegraph.cody.protocol_generated\n\ntypealias ContextItemSource = String // One of: embeddings, user, keyword, editor, filename, search, unified, selection, terminal, uri\n\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/codebase-context/messages.ts:88-121","content":"\n/**\n * A file (or a subset of a file given by a range) that is included as context in a chat message.\n */\nexport interface ContextItemFile extends ContextItemCommon {\n    type: 'file'\n}\n\n/**\n * A symbol (which is a range within a file) that is included as context in a chat message.\n */\nexport interface ContextItemSymbol extends ContextItemCommon {\n    type: 'symbol'\n\n    /** The name of the symbol, used for presentation only (not semantically meaningful). */\n    symbolName: string\n\n    /** The kind of symbol, used for presentation only (not semantically meaningful). */\n    kind: SymbolKind\n}\n\n/** The valid kinds of a symbol. */\nexport type SymbolKind = 'class' | 'function' | 'method'\n\n/** {@link ContextItem} with the `content` field set to the content. */\nexport type ContextItemWithContent = ContextItem & Required<Pick<ContextItem, 'content'>>\n\n/**\n * A system chat message that adds a context item to the conversation.\n */\nexport interface ContextMessage extends Required<Message> {\n    /**\n     * Context messages are always \"from\" the human. (In the future, this could be from \"system\" for\n"}]

 class: Find logic
