 question: Where is the functionality for running symf?
# CHAT
# CHAT_QUESTION Where is the functionality for running symf?

# CHAT_REPLY The functionality for running `symf` is primarily encapsulated within the `SymfRunner` class, which is defined in the file `cody_test/vscode/src/local-context/symf.ts`. This class handles various operations related to `symf`, such as ensuring indexes, running queries, and managing index statuses. Here are some key methods within the `SymfRunner` class that are responsible for running `symf`:
# CHAT_REPLY 
# CHAT_REPLY 1. **`getResults`**: This method is used to get results from `symf` for a given user query and scope directories.
# CHAT_REPLY     ```typescript
# CHAT_REPLY     public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {
# CHAT_REPLY         const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)
# CHAT_REPLY         return Promise.resolve(
# CHAT_REPLY             scopeDirs
# CHAT_REPLY                 .filter(isFileURI)
# CHAT_REPLY                 .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))
# CHAT_REPLY         )
# CHAT_REPLY     }
# CHAT_REPLY     ```
# CHAT_REPLY 
# CHAT_REPLY 2. **`getResultsForScopeDir`**: This method gets the list of results from `symf` for a single directory scope.
# CHAT_REPLY     ```typescript
# CHAT_REPLY     private async getResultsForScopeDir(
# CHAT_REPLY         keywordQuery: Promise<string>,
# CHAT_REPLY         scopeDir: FileURI
# CHAT_REPLY     ): Promise<Result[]> {
# CHAT_REPLY         const maxRetries = 10
# CHAT_REPLY 
# CHAT_REPLY         for (let i = 0; i < maxRetries; i++) {
# CHAT_REPLY             await this.getIndexLock(scopeDir).withWrite(async () => {
# CHAT_REPLY                 await this.unsafeEnsureIndex(scopeDir, {
# CHAT_REPLY                     retryIfLastAttemptFailed: i === 0,
# CHAT_REPLY                     ignoreExisting: false,
# CHAT_REPLY                 })
# CHAT_REPLY             })
# CHAT_REPLY 
# CHAT_REPLY             let indexNotFound = false
# CHAT_REPLY             const stdout = await this.getIndexLock(scopeDir).withRead(async () => {
# CHAT_REPLY                 if (!(await this.unsafeIndexExists(scopeDir))) {
# CHAT_REPLY                     indexNotFound = true
# CHAT_REPLY                     return ''
# CHAT_REPLY                 }
# CHAT_REPLY                 return this.unsafeRunQuery(await keywordQuery, scopeDir)
# CHAT_REPLY             })
# CHAT_REPLY             if (indexNotFound) {
# CHAT_REPLY                 continue
# CHAT_REPLY             }
# CHAT_REPLY             const results = parseSymfStdout(stdout)
# CHAT_REPLY             return results
# CHAT_REPLY         }
# CHAT_REPLY         throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)
# CHAT_REPLY     }
# CHAT_REPLY     ```
# CHAT_REPLY 
# CHAT_REPLY 3. **`unsafeRunQuery`**: This method runs a query using `symf`.
# CHAT_REPLY     ```typescript
# CHAT_REPLY     private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {
# CHAT_REPLY         const { indexDir } = this.getIndexDir(scopeDir)
# CHAT_REPLY         const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()
# CHAT_REPLY         try {
# CHAT_REPLY             const { stdout } = await execFile(
# CHAT_REPLY                 symfPath,
# CHAT_REPLY                 [
# CHAT_REPLY                     '--index-root',
# CHAT_REPLY                     indexDir.fsPath,
# CHAT_REPLY                     'query',
# CHAT_REPLY                     '--scopes',
# CHAT_REPLY                     scopeDir.fsPath,
# CHAT_REPLY                     '--fmt',
# CHAT_REPLY                     'json',
# CHAT_REPLY                     keywordQuery,
# CHAT_REPLY                 ],
# CHAT_REPLY                 {
# CHAT_REPLY                     env: {
# CHAT_REPLY                         SOURCEGRAPH_TOKEN: accessToken,
# CHAT_REPLY                         SOURCEGRAPH_URL: serverEndpoint,
# CHAT_REPLY                         HOME: process.env.HOME,
# CHAT_REPLY                     },
# CHAT_REPLY                     maxBuffer: 1024 * 1024 * 1024,
# CHAT_REPLY                     timeout: 1000 * 30, // timeout in 30 seconds
# CHAT_REPLY                 }
# CHAT_REPLY             )
# CHAT_REPLY             return stdout
# CHAT_REPLY         } catch (error) {
# CHAT_REPLY             throw toSymfError(error)
# CHAT_REPLY         }
# CHAT_REPLY     }
# CHAT_REPLY     ```
# CHAT_REPLY 
# CHAT_REPLY Additionally, the `SymfRunner` class is instantiated and used in the `activateCommon` function in the file `cody_test/vscode/src/extension.node.ts`:
# CHAT_REPLY ```typescript
# CHAT_REPLY return activateCommon(context, {
# CHAT_REPLY     createSymfRunner: (...args) => new SymfRunner(...args),
# CHAT_REPLY     // other services
# CHAT_REPLY })
# CHAT_REPLY ```
# CHAT_REPLY 
# CHAT_REPLY The `getSymfPath` function in `cody_test/vscode/src/local-context/download-symf.ts` is responsible for determining the path to the `symf` binary, either by using a user-specified path or downloading it if necessary:
# CHAT_REPLY ```typescript
# CHAT_REPLY export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {
# CHAT_REPLY     const config = vscode.workspace.getConfiguration()
# CHAT_REPLY     const userSymfPath = config.get<string>('cody.experimental.symf.path')
# CHAT_REPLY     if (userSymfPath) {
# CHAT_REPLY         logDebug('symf', `using user symf: ${userSymfPath}`)
# CHAT_REPLY         return userSymfPath
# CHAT_REPLY     }
# CHAT_REPLY 
# CHAT_REPLY     const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')
# CHAT_REPLY     return await _getSymfPath(symfContainingDir)
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY 
# CHAT_REPLY In summary, the `SymfRunner` class in `cody_test/vscode/src/local-context/symf.ts` encapsulates the functionality for running `symf`, including methods for querying, indexing, and managing the `symf` binary.

# CONTEXT_ITEMS [{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/pnpm-lock.yaml:4554-4589","content":"      '@storybook/builder-manager': 8.0.5\n      '@storybook/channels': 8.0.5\n      '@storybook/core-common': 8.0.5\n      '@storybook/core-events': 8.0.5\n      '@storybook/csf': 0.1.2\n      '@storybook/csf-tools': 8.0.5\n      '@storybook/docs-mdx': 3.0.0\n      '@storybook/global': 5.0.0\n      '@storybook/manager': 8.0.5\n      '@storybook/manager-api': 8.0.5(react-dom@18.2.0)(react@18.2.0)\n      '@storybook/node-logger': 8.0.5\n      '@storybook/preview-api': 8.0.5\n      '@storybook/telemetry': 8.0.5\n      '@storybook/types': 8.0.5\n      '@types/detect-port': 1.3.5\n      '@types/node': 18.19.31\n      '@types/pretty-hrtime': 1.0.3\n      '@types/semver': 7.5.8\n      better-opn: 3.0.2\n      chalk: 4.1.2\n      cli-table3: 0.6.3\n      compression: 1.7.4\n      detect-port: 1.5.1\n      express: 4.18.3\n      fs-extra: 11.2.0\n      globby: 11.1.0\n      ip: 2.0.1\n      lodash: 4.17.21\n      open: 8.4.2\n      pretty-hrtime: 1.0.3\n      prompts: 2.4.2\n      read-pkg-up: 7.0.1\n      semver: 7.6.0\n      telejson: 7.2.0\n      tiny-invariant: 1.3.3\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:565-582","content":"\n### Changed\n\n- Settings: Relabel \"symf Context\" as \"Search Context\". [pull/2285](https://github.com/sourcegraph/cody/pull/2285)\n- Chat: Removed 'Chat Suggestions' setting. [pull/2284](https://github.com/sourcegraph/cody/pull/2284)\n- Edit: Completed edits are no longer scrolled back into view in the active file. [pull/2297](https://github.com/sourcegraph/cody/pull/2297)\n- Chat: Update welcome message. [pull/2298](https://github.com/sourcegraph/cody/pull/2298)\n- Edit: Decorations are no longer shown once an edit has been applied. [pull/2304](https://github.com/sourcegraph/cody/pull/2304)\n\n## [0.18.4]\n\n### Added\n\n### Fixed\n\n- Fixes an issue where the sidebar would not properly load when not signed in. [pull/2267](https://github.com/sourcegraph/cody/pull/2267)\n- Fixes an issue where telemetry events were not properly logged with the new chat experience. [pull/2291](https://github.com/sourcegraph/cody/pull/2291)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:19-30","content":"export async function getSymfPath(context: vscode.ExtensionContext): Promise<string | null> {\n    // If user-specified symf path is set, use that\n    const config = vscode.workspace.getConfiguration()\n    const userSymfPath = config.get<string>('cody.experimental.symf.path')\n    if (userSymfPath) {\n        logDebug('symf', `using user symf: ${userSymfPath}`)\n        return userSymfPath\n    }\n\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:62-67","content":"\n        onConfigurationChange: setCustomAgent,\n        extensionClient,\n    })\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/isRunningInsideAgent.ts:2-4","content":"export function isRunningInsideAgent(): boolean {\n    return vscode.workspace.getConfiguration().get<boolean>('cody.advanced.agent.running', false)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.test.ts:48-70","content":"                        return true\n                    case 'cody.experimental.symf.path':\n                        return '/usr/local/bin/symf'\n                    case 'cody.experimental.simpleChatContext':\n                        return true\n                    case 'cody.experimental.symfContext':\n                        return true\n                    case 'cody.experimental.tracing':\n                        return true\n                    case 'cody.debug.verbose':\n                        return true\n                    case 'cody.debug.filter':\n                        return /.*/\n                    case 'cody.telemetry.level':\n                        return 'off'\n                    case 'cody.chat.preInstruction':\n                        return 'My name is Jeff.'\n                    case 'cody.edit.preInstruction':\n                        return 'My name is not Jeff.'\n                    case 'cody.autocomplete.advanced.provider':\n                        return 'unstable-openai'\n                    case 'cody.autocomplete.advanced.model':\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:55-80","content":"\n    const symfFilename = `symf-${symfVersion}-${arch}-${platform}`\n    const symfUnzippedFilename = `symf-${arch}-${zigPlatform}` // the filename inside the zip\n    const symfPath = path.join(symfContainingDir, symfFilename)\n    if (await fileExists(symfPath)) {\n        logDebug('symf', `using downloaded symf \"${symfPath}\"`)\n        return symfPath\n    }\n\n    const symfURL = `https://github.com/sourcegraph/symf/releases/download/${symfVersion}/symf-${arch}-${zigPlatform}.zip`\n\n    // Download symf binary with vscode progress api\n    try {\n        await downloadLock.acquire()\n        // Re-check if it has been downloaded\n        if (await fileExists(symfPath)) {\n            logDebug('symf', 'symf already downloaded, reusing')\n            return symfPath\n        }\n\n        await actualDownloadSymf({ symfPath, symfURL, symfFilename, symfUnzippedFilename })\n        void removeOldSymfBinaries(symfContainingDir, symfFilename)\n    } catch (error) {\n        captureException(error)\n        void vscode.window.showErrorMessage(`Failed to download symf: ${error}`)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:543-580","content":"function parseSymfStdout(stdout: string): Result[] {\n    interface RawSymfResult extends Omit<Result, 'file'> {\n        file: string\n    }\n    const results = JSON.parse(stdout) as RawSymfResult[]\n    return results.map(result => {\n        const { fqname, name, type, doc, exported, lang, file: fsPath, range, summary } = result\n\n        const { row: startRow, col: startColumn } = range.startPoint\n        const { row: endRow, col: endColumn } = range.endPoint\n\n        const startByte = range.startByte\n        const endByte = range.endByte\n\n        return {\n            fqname,\n            name,\n            type,\n            doc,\n            exported,\n            lang,\n            file: vscode.Uri.file(fsPath),\n            summary,\n            range: {\n                startByte,\n                endByte,\n                startPoint: {\n                    row: startRow,\n                    col: startColumn,\n                },\n                endPoint: {\n                    row: endRow,\n                    col: endColumn,\n                },\n            },\n        } satisfies Result\n    })\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/SimpleChatPanelProvider.ts:36-59","content":"import type { LocalEmbeddingsController } from '../../local-context/local-embeddings'\nimport type { SymfRunner } from '../../local-context/symf'\nimport { logDebug } from '../../log'\nimport type { AuthProvider } from '../../services/AuthProvider'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport type { TreeViewProvider } from '../../services/tree-views/TreeViewProvider'\nimport {\n    handleCodeFromInsertAtCursor,\n    handleCodeFromSaveToNewFile,\n    handleCopiedCode,\n} from '../../services/utils/codeblock-action-tracker'\nimport { openExternalLinks, openLocalFileWithRange } from '../../services/utils/workspace-action'\nimport { TestSupport } from '../../test-support'\nimport { countGeneratedCode } from '../utils'\n\nimport type { Span } from '@opentelemetry/api'\nimport { captureException } from '@sentry/core'\nimport type {\n    ContextItemFile,\n    ContextItemWithContent,\n} from '@sourcegraph/cody-shared/src/codebase-context/messages'\nimport { ModelUsage } from '@sourcegraph/cody-shared/src/models/types'\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:14-14","content":"const symfVersion = 'v0.0.9'\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/main.ts:261-285","content":"    }\n\n    // Register tree views\n    disposables.push(\n        chatManager,\n        vscode.window.registerWebviewViewProvider('cody.chat', chatManager.sidebarViewController, {\n            webviewOptions: { retainContextWhenHidden: true },\n        }),\n        // Update external services when configurationChangeEvent is fired by chatProvider\n        contextProvider.configurationChangeEvent.event(async () => {\n            const newConfig = await getFullConfig()\n            await onConfigurationChange(newConfig)\n        })\n    )\n\n    const statusBar = createStatusBar()\n\n    // Important to respect `config.experimentalSymfContext`. The agent\n    // currently crashes with a cryptic error when running with symf enabled so\n    // we need a way to reliably disable symf until we fix the root problem.\n    if (symfRunner && config.experimentalSymfContext) {\n        const searchViewProvider = new SearchViewProvider(context.extensionUri, symfRunner)\n        disposables.push(searchViewProvider)\n        searchViewProvider.initialize()\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:154-162","content":"async function unzipSymf(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/extension.node.ts:46-62","content":"\n    return activateCommon(context, {\n        createLocalEmbeddingsController: isLocalEmbeddingsDisabled\n            ? undefined\n            : (config: LocalEmbeddingsConfig): LocalEmbeddingsController =>\n                  createLocalEmbeddingsController(context, config),\n        createContextRankingController: (config: ContextRankerConfig) =>\n            createContextRankingController(context, config),\n        createCompletionsClient: (...args) => new SourcegraphNodeCompletionsClient(...args),\n        createCommandsProvider: () => new CommandsProvider(),\n        createSymfRunner: (...args) => new SymfRunner(...args),\n        createBfgRetriever: () => new BfgRetriever(context),\n        createSentryService: (...args) => new NodeSentryService(...args),\n        createOpenTelemetryService: (...args) => new OpenTelemetryService(...args),\n        getRemoteUrlGetters: () => [gitRemoteUrlFromGitCli],\n        startTokenReceiver: (...args) => startTokenReceiver(...args),\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:88-125","content":"async function downloadSymf({\n    symfPath,\n    symfFilename,\n    symfUnzippedFilename,\n    symfURL,\n}: {\n    symfPath: string\n    symfFilename: string\n    symfUnzippedFilename: string\n    symfURL: string\n}): Promise<void> {\n    logDebug('symf', `downloading symf from ${symfURL}`)\n\n    await vscode.window.withProgress(\n        {\n            location: vscode.ProgressLocation.Notification,\n            title: 'Downloading Cody search engine (symf)',\n            cancellable: false,\n        },\n        async progress => {\n            const symfTmpDir = `${symfPath}.tmp`\n            progress.report({ message: 'Downloading symf and extracting symf' })\n\n            await fspromises.mkdir(symfTmpDir, { recursive: true })\n            const symfZipFile = path.join(symfTmpDir, `${symfFilename}.zip`)\n            await downloadFile(symfURL, symfZipFile)\n            await unzipSymf(symfZipFile, symfTmpDir)\n            logDebug('symf', `downloaded symf to ${symfTmpDir}`)\n\n            const tmpFile = path.join(symfTmpDir, symfUnzippedFilename)\n            await fspromises.chmod(tmpFile, 0o755)\n            await fspromises.rename(tmpFile, symfPath)\n            await fspromises.rm(symfTmpDir, { recursive: true })\n\n            logDebug('symf', `extracted symf to ${symfPath}`)\n        }\n    )\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/package.json:29-63","content":"    \"update-symf-recordings\": \"rm -rf recordings && CODY_RECORD_IF_MISSING=true vitest vscode/src/local-context/symf.test.ts\"\n  },\n  \"devDependencies\": {\n    \"@biomejs/biome\": \"1.5.2\",\n    \"@sourcegraph/tsconfig\": \"^4.0.1\",\n    \"@storybook/addon-essentials\": \"^8.0.5\",\n    \"@storybook/react\": \"^8.0.5\",\n    \"@storybook/react-vite\": \"^8.0.5\",\n    \"@testing-library/jest-dom\": \"^6.4.2\",\n    \"@testing-library/react\": \"^14.2.2\",\n    \"@types/node\": \"20.12.7\",\n    \"@types/react\": \"18.2.79\",\n    \"@types/react-dom\": \"18.2.25\",\n    \"@vitejs/plugin-react\": \"^4.2.1\",\n    \"esbuild\": \"^0.18.20\",\n    \"happy-dom\": \"^14.3.10\",\n    \"jsdom\": \"^22.1.0\",\n    \"knip\": \"^3.13.2\",\n    \"storybook\": \"^8.0.5\",\n    \"stylelint\": \"^15.11.0\",\n    \"stylelint-config-standard\": \"^34.0.0\",\n    \"ts-node\": \"^10.9.2\",\n    \"typescript\": \"^5.4.2\",\n    \"vite\": \"^5.2.9\",\n    \"vitest\": \"^1.5.0\"\n  },\n  \"dependencies\": {\n    \"ignore\": \"^5.3.1\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"packageManager\": \"pnpm@8.6.7\",\n  \"resolutions\": {\n    \"tslib\": \"2.1.0\"\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1531-1567","content":"            Module = 29,\n            Namespace = 30,\n            Null = 31,\n            Number = 32,\n            Object = 33,\n            Operator = 34,\n            Package = 35,\n            PackageObject = 36,\n            Parameter = 37,\n            ParameterLabel = 38,\n            Pattern = 39,\n            Predicate = 40,\n            Property = 41,\n            Protocol = 42,\n            ProtocolMethod = 68,\n            PureVirtualMethod = 69,\n            Quasiquoter = 43,\n            SelfParameter = 44,\n            Setter = 45,\n            Signature = 46,\n            SingletonClass = 75,\n            SingletonMethod = 76,\n            StaticDataMember = 77,\n            StaticEvent = 78,\n            StaticField = 79,\n            StaticMethod = 80,\n            StaticProperty = 81,\n            StaticVariable = 82,\n            String = 48,\n            Struct = 49,\n            Subscript = 47,\n            Tactic = 50,\n            Theorem = 51,\n            ThisParameter = 52,\n            Trait = 53,\n            TraitMethod = 70,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:49-486","content":"export class SymfRunner implements IndexedKeywordContextFetcher, vscode.Disposable {\n    // The root of all symf index directories\n    private indexRoot: FileURI\n    private indexLocks: Map<string, RWLock> = new Map()\n\n    private status: IndexStatus = new IndexStatus()\n\n    constructor(\n        private context: vscode.ExtensionContext,\n        private sourcegraphServerEndpoint: string | null,\n        private authToken: string | null,\n        private completionsClient: SourcegraphCompletionsClient\n    ) {\n        const indexRoot = vscode.Uri.joinPath(context.globalStorageUri, 'symf', 'indexroot').with(\n            // On VS Code Desktop, this is a `vscode-userdata:` URI that actually just refers to\n            // file system paths.\n            vscode.env.uiKind === vscode.UIKind.Desktop ? { scheme: 'file' } : {}\n        )\n\n        if (!isFileURI(indexRoot)) {\n            throw new Error('symf only supports running on the file system')\n        }\n        this.indexRoot = indexRoot\n    }\n\n    public dispose(): void {\n        this.status.dispose()\n    }\n\n    public onIndexStart(cb: (e: IndexStartEvent) => void): vscode.Disposable {\n        return this.status.onDidStart(cb)\n    }\n\n    public onIndexEnd(cb: (e: IndexEndEvent) => void): vscode.Disposable {\n        return this.status.onDidEnd(cb)\n    }\n\n    public setSourcegraphAuth(endpoint: string | null, authToken: string | null): void {\n        this.sourcegraphServerEndpoint = endpoint\n        this.authToken = authToken\n    }\n\n    private async getSymfInfo(): Promise<{\n        symfPath: string\n        serverEndpoint: string\n        accessToken: string\n    }> {\n        const accessToken = this.authToken\n        if (!accessToken) {\n            throw new Error('SymfRunner.getResults: No access token')\n        }\n        const serverEndpoint = this.sourcegraphServerEndpoint\n        if (!serverEndpoint) {\n            throw new Error('SymfRunner.getResults: No Sourcegraph server endpoint')\n        }\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            throw new Error('No symf executable')\n        }\n        return { accessToken, serverEndpoint, symfPath }\n    }\n\n    public getResults(userQuery: PromptString, scopeDirs: vscode.Uri[]): Promise<Promise<Result[]>[]> {\n        const expandedQuery = symfExpandQuery(this.completionsClient, userQuery)\n        return Promise.resolve(\n            scopeDirs\n                .filter(isFileURI)\n                .map(scopeDir => this.getResultsForScopeDir(expandedQuery, scopeDir))\n        )\n    }\n\n    /**\n     * Returns the list of results from symf for a single directory scope.\n     * @param keywordQuery is a promise, because query expansion might be an expensive\n     * operation that is best done concurrently with querying and (re)building the index.\n     */\n    private async getResultsForScopeDir(\n        keywordQuery: Promise<string>,\n        scopeDir: FileURI\n    ): Promise<Result[]> {\n        const maxRetries = 10\n\n        // Run in a loop in case the index is deleted before we can query it\n        for (let i = 0; i < maxRetries; i++) {\n            await this.getIndexLock(scopeDir).withWrite(async () => {\n                await this.unsafeEnsureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: i === 0,\n                    ignoreExisting: false,\n                })\n            })\n\n            let indexNotFound = false\n            const stdout = await this.getIndexLock(scopeDir).withRead(async () => {\n                // Check again if index exists after we have the read lock\n                if (!(await this.unsafeIndexExists(scopeDir))) {\n                    indexNotFound = true\n                    return ''\n                }\n                return this.unsafeRunQuery(await keywordQuery, scopeDir)\n            })\n            if (indexNotFound) {\n                continue\n            }\n            const results = parseSymfStdout(stdout)\n            return results\n        }\n        throw new Error(`failed to find index after ${maxRetries} tries for directory ${scopeDir}`)\n    }\n\n    public async deleteIndex(scopeDir: FileURI): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeDeleteIndex(scopeDir)\n        })\n    }\n\n    public async getIndexStatus(\n        scopeDir: FileURI\n    ): Promise<'unindexed' | 'indexing' | 'ready' | 'failed'> {\n        if (this.status.isInProgress(scopeDir)) {\n            // Check this before waiting on the lock\n            return 'indexing'\n        }\n        const hasIndex = await this.getIndexLock(scopeDir).withRead(async () => {\n            return this.unsafeIndexExists(scopeDir)\n        })\n        if (hasIndex) {\n            return 'ready'\n        }\n        if (await this.didIndexFail(scopeDir)) {\n            return 'failed'\n        }\n        return 'unindexed'\n    }\n\n    /**\n     * Check index freshness and reindex if needed. Currently reindexes daily if changes\n     * have been detected.\n     */\n    public async reindexIfStale(scopeDir: FileURI): Promise<void> {\n        logDebug('SymfRunner', 'reindexIfStale', scopeDir.fsPath)\n        try {\n            const diff = await this.statIndex(scopeDir)\n            if (!diff) {\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: false,\n                })\n                return\n            }\n            if (\n                (diff.millisElapsed === undefined || diff.millisElapsed > oneDayMillis) &&\n                (diff.maybeChangedFiles || (diff.changedFiles && diff.changedFiles.length > 0))\n            ) {\n                // reindex targeting a temporary directory\n                // atomically replace index\n                await this.ensureIndex(scopeDir, {\n                    retryIfLastAttemptFailed: false,\n                    ignoreExisting: true,\n                })\n            }\n        } catch (error) {\n            logDebug('SymfRunner', `Error checking freshness of index at ${scopeDir.fsPath}`, error)\n        }\n    }\n\n    private async statIndex(scopeDir: FileURI): Promise<CorpusDiff | null> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { symfPath } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(symfPath, [\n                '--index-root',\n                indexDir.fsPath,\n                'status',\n                scopeDir.fsPath,\n            ])\n            return parseJSONToCorpusDiff(stdout)\n        } catch (error) {\n            logDebug('SymfRunner', 'symf status error', error)\n            return null\n        }\n    }\n\n    /**\n     * Triggers indexing for a scopeDir.\n     *\n     * Options:\n     * - retryIfLastAttemptFailed: if the last indexing run ended in failure, we don't retry\n     *   unless this value is true.\n     * - ignoreExisting: if an index already exists, we don't reindex unless this value is true.\n     *   This should be set to true when we want to update an index because files have changed.\n     */\n    public async ensureIndex(\n        scopeDir: FileURI,\n        options: IndexOptions = { retryIfLastAttemptFailed: false, ignoreExisting: false }\n    ): Promise<void> {\n        await this.getIndexLock(scopeDir).withWrite(async () => {\n            await this.unsafeEnsureIndex(scopeDir, options)\n        })\n    }\n\n    private getIndexLock(scopeDir: FileURI): RWLock {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        let lock = this.indexLocks.get(indexDir.toString())\n        if (lock) {\n            return lock\n        }\n        lock = new RWLock()\n        this.indexLocks.set(indexDir.toString(), lock)\n        return lock\n    }\n\n    private async unsafeRunQuery(keywordQuery: string, scopeDir: FileURI): Promise<string> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        const { accessToken, symfPath, serverEndpoint } = await this.getSymfInfo()\n        try {\n            const { stdout } = await execFile(\n                symfPath,\n                [\n                    '--index-root',\n                    indexDir.fsPath,\n                    'query',\n                    '--scopes',\n                    scopeDir.fsPath,\n                    '--fmt',\n                    'json',\n                    keywordQuery,\n                ],\n                {\n                    env: {\n                        SOURCEGRAPH_TOKEN: accessToken,\n                        SOURCEGRAPH_URL: serverEndpoint,\n                        HOME: process.env.HOME,\n                    },\n                    maxBuffer: 1024 * 1024 * 1024,\n                    timeout: 1000 * 30, // timeout in 30 seconds\n                }\n            )\n            return stdout\n        } catch (error) {\n            throw toSymfError(error)\n        }\n    }\n\n    private async unsafeDeleteIndex(scopeDir: FileURI): Promise<void> {\n        const trashRootDir = vscode.Uri.joinPath(this.indexRoot, '.trash')\n        await mkdirp(trashRootDir.fsPath)\n        const { indexDir } = this.getIndexDir(scopeDir)\n\n        if (!(await fileExists(indexDir))) {\n            // index directory no longer exists, nothing to do\n            return\n        }\n\n        // Unique name for trash directory\n        const trashDir = vscode.Uri.joinPath(trashRootDir, `${uriBasename(indexDir)}-${Date.now()}`)\n        if (await fileExists(trashDir)) {\n            // if trashDir already exists, error\n            throw new Error(\n                `could not delete index ${indexDir}: target trash directory ${trashDir} already exists`\n            )\n        }\n\n        await rename(indexDir.fsPath, trashDir.fsPath)\n        void rm(trashDir.fsPath, { recursive: true, force: true }) // delete in background\n    }\n\n    private async unsafeIndexExists(scopeDir: FileURI): Promise<boolean> {\n        const { indexDir } = this.getIndexDir(scopeDir)\n        return fileExists(vscode.Uri.joinPath(indexDir, 'index.json'))\n    }\n\n    private async unsafeEnsureIndex(scopeDir: FileURI, options: IndexOptions): Promise<void> {\n        logDebug('SymfRunner', 'unsafeEnsureIndex', scopeDir.toString(), { verbose: { options } })\n        if (!options.ignoreExisting) {\n            const indexExists = await this.unsafeIndexExists(scopeDir)\n            if (indexExists) {\n                return\n            }\n        }\n\n        if (!options.retryIfLastAttemptFailed && (await this.didIndexFail(scopeDir))) {\n            // Index build previous failed, so don't try to rebuild\n            logDebug(\n                'symf',\n                'index build previously failed and retryIfLastAttemptFailed=false, not rebuilding'\n            )\n                //return\n        }\n\n        const { indexDir, tmpDir } = this.getIndexDir(scopeDir)\n        try {\n            await this.unsafeUpsertIndex(indexDir, tmpDir, scopeDir)\n        } catch (error) {\n            logDebug('symf', 'symf index creation failed', error)\n            await this.markIndexFailed(scopeDir)\n            throw error\n        }\n        await this.clearIndexFailure(scopeDir)\n    }\n\n    private getIndexDir(scopeDir: FileURI): { indexDir: FileURI; tmpDir: FileURI } {\n        let indexSubdir = scopeDir.path\n\n        // On Windows, we can't use an absolute path with a drive letter inside another path\n        // so we remove the colon, so `/c:/foo/` becomes `/c/foo` and `/c%3A/foo` becomes `/c/foo`.\n        if (isWindows()) {\n            if (indexSubdir[2] === ':') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(3)\n            } else if (indexSubdir.slice(2, 5) === '%3A') {\n                indexSubdir = indexSubdir.slice(0, 2) + indexSubdir.slice(5)\n            }\n        }\n\n        return {\n            indexDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, indexSubdir)),\n            tmpDir: assertFileURI(vscode.Uri.joinPath(this.indexRoot, '.tmp', indexSubdir)),\n        }\n    }\n\n    private unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI\n    ): Promise<void> {\n        const cancellation = new vscode.CancellationTokenSource()\n        const upsert = this._unsafeUpsertIndex(indexDir, tmpIndexDir, scopeDir, cancellation.token)\n        this.status.didStart({ scopeDir, done: upsert, cancel: () => cancellation.cancel() })\n        void upsert.finally(() => {\n            this.status.didEnd({ scopeDir })\n            cancellation.dispose()\n        })\n        return upsert\n    }\n\n    private async _unsafeUpsertIndex(\n        indexDir: FileURI,\n        tmpIndexDir: FileURI,\n        scopeDir: FileURI,\n        cancellationToken: vscode.CancellationToken\n    ): Promise<void> {\n        const symfPath = await getSymfPath(this.context)\n        if (!symfPath) {\n            return\n        }\n        await rm(tmpIndexDir.fsPath, { recursive: true }).catch(() => undefined)\n\n        logDebug('symf', 'creating index', indexDir)\n        let maxCPUs = 1\n        if (os.cpus().length > 4) {\n            maxCPUs = 2\n        }\n\n        const disposeOnFinish: vscode.Disposable[] = []\n        if (cancellationToken.isCancellationRequested) {\n            throw new vscode.CancellationError()\n        }\n\n        let wasCancelled = false\n        let onExit: (() => void) | undefined\n        try {\n            const proc = spawn(symfPath, ['--index-root', tmpIndexDir.fsPath, 'add', scopeDir.fsPath], {\n                env: {\n                    ...process.env,\n                    GOMAXPROCS: `${maxCPUs}`, // use at most one cpu for indexing\n                },\n                stdio: ['ignore', 'ignore', 'ignore'],\n                timeout: 1000 * 60 * 10, // timeout in 10 minutes\n            })\n            onExit = () => {\n                proc.kill('SIGKILL')\n            }\n            process.on('exit', onExit)\n\n            if (cancellationToken.isCancellationRequested) {\n                wasCancelled = true\n                proc.kill('SIGKILL')\n            } else {\n                disposeOnFinish.push(\n                    cancellationToken.onCancellationRequested(() => {\n                        wasCancelled = true\n                        proc.kill('SIGKILL')\n                    })\n                )\n            }\n\n            // wait for proc to finish\n            await new Promise<void>((resolve, reject) => {\n                proc.on('error', reject)\n                proc.on('exit', code => {\n                    if (code === 0) {\n                        resolve()\n                    } else {\n                        reject(new Error(`symf exited with code ${code}`))\n                    }\n                })\n            })\n\n            // move just-built index to index path\n            await rm(indexDir.fsPath, { recursive: true }).catch(() => undefined)\n            await mkdirp(uriDirname(indexDir).fsPath)\n            await rename(tmpIndexDir.fsPath, indexDir.fsPath)\n        } catch (error) {\n            if (wasCancelled) {\n                throw new vscode.CancellationError()\n            }\n            throw toSymfError(error)\n        } finally {\n            if (onExit) {\n                process.removeListener('exit', onExit)\n            }\n            vscode.Disposable.from(...disposeOnFinish).dispose()\n            await rm(tmpIndexDir.fsPath, { recursive: true, force: true })\n        }\n    }\n\n    /**\n     * Helpers for tracking index failure\n     */\n\n    private async markIndexFailed(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        await mkdirp(failureRoot.fsPath)\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await writeFile(failureSentinelFile.fsPath, '')\n    }\n\n    private async didIndexFail(scopeDir: FileURI): Promise<boolean> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        return fileExists(failureSentinelFile)\n    }\n\n    private async clearIndexFailure(scopeDir: FileURI): Promise<void> {\n        const failureRoot = vscode.Uri.joinPath(this.indexRoot, '.failed')\n        const failureSentinelFile = vscode.Uri.joinPath(failureRoot, scopeDir.path.replaceAll('/', '__'))\n        await rm(failureSentinelFile.fsPath, { force: true })\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/download-symf.ts:27-55","content":"\n    const symfContainingDir = path.join(context.globalStorageUri.fsPath, 'symf')\n    return await _getSymfPath(symfContainingDir)\n}\n\nconst downloadLock = new Mutex()\n\nexport async function _getSymfPath(\n    symfContainingDir: string,\n    actualDownloadSymf: (op: {\n        symfPath: string\n        symfFilename: string\n        symfUnzippedFilename: string\n        symfURL: string\n    }) => Promise<void> = downloadSymf\n): Promise<string | null> {\n    const { platform, arch } = getOSArch()\n    if (!platform || !arch) {\n        // show vs code error message\n        void vscode.window.showErrorMessage(\n            `No symf binary available for ${os.platform()}/${os.machine()}`\n        )\n        return null\n    }\n    // Releases (eg at https://github.com/sourcegraph/symf/releases) are named with the Zig platform\n    // identifier (linux-musl, windows-gnu, macos).\n    const zigPlatform =\n        platform === 'linux' ? 'linux-musl' : platform === 'windows' ? 'windows-gnu' : platform\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/local-context/symf.ts:630-642","content":"function toSymfError(error: unknown): Error {\n    const errorString = `${error}`\n    let errorMessage: string\n    if (errorString.includes('ENOENT')) {\n        errorMessage =\n            'symf binary not found. Do you have \"cody.experimental.symf.path\" set and is it valid?'\n    } else if (errorString.includes('401')) {\n        errorMessage = `symf: Unauthorized. Is Cody signed in? ${error}`\n    } else {\n        errorMessage = `symf index creation failed: ${error}`\n    }\n    return new EvalError(errorMessage)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/external-services.ts:27-61","content":"    symfRunner: SymfRunner | undefined\n\n    /** Update configuration for all of the services in this interface. */\n    onConfigurationChange: (newConfig: ExternalServicesConfiguration) => void\n}\n\ntype ExternalServicesConfiguration = Pick<\n    ConfigurationWithAccessToken,\n    | 'serverEndpoint'\n    | 'codebase'\n    | 'useContext'\n    | 'customHeaders'\n    | 'accessToken'\n    | 'debugVerbose'\n    | 'experimentalTracing'\n> &\n    LocalEmbeddingsConfig &\n    ContextRankerConfig\n\nexport async function configureExternalServices(\n    context: vscode.ExtensionContext,\n    initialConfig: ExternalServicesConfiguration,\n    platform: Pick<\n        PlatformContext,\n        | 'createLocalEmbeddingsController'\n        | 'createCompletionsClient'\n        | 'createSentryService'\n        | 'createOpenTelemetryService'\n        | 'createSymfRunner'\n        | 'createContextRankingController'\n    >,\n    authProvider: AuthProvider\n): Promise<ExternalServices> {\n    const sentryService = platform.createSentryService?.(initialConfig)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/CodebaseStatusProvider.ts:179-183","content":"        this.symfIndexStatus = newSymfStatus\n        return didSymfStatusChange\n    }\n}\n"}]

 class: Find logic
