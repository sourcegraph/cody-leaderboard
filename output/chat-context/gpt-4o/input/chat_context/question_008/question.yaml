 question: Where is the functionality for preventing prompt injection?
# CHAT
# CHAT_QUESTION Where is the functionality for preventing prompt injection?

# CHAT_REPLY The functionality for preventing prompt injection is implemented in the `PromptString` class and its associated functions in the file `cody_test/lib/shared/src/prompt/prompt-string.ts`. Here's a summary of how it works:
# CHAT_REPLY 
# CHAT_REPLY 1. **Safe String Handling**: The `PromptString` class is designed to handle strings safely by ensuring that only certain types of strings can be used to construct prompts. Literal strings are considered safe, and dynamic strings must be constructed using helper functions.
# CHAT_REPLY 
# CHAT_REPLY 2. **Tagged Template Literals**: The `ps` function is a tagged template literal function that ensures strings are constructed safely. It throws an error if used incorrectly, such as with dynamic strings that are not allowed.
# CHAT_REPLY 
# CHAT_REPLY 3. **Internal Handling**: The `PromptString` class uses internal methods and a WeakMap to store the actual string values and their references. This prevents direct manipulation of the string content and ensures that only safe operations are performed.
# CHAT_REPLY 
# CHAT_REPLY 4. **Validation**: The `isValidPromptString` function checks if an input is indeed a `PromptString` and not just typecast to it. This helps in validating that only safe strings are used.
# CHAT_REPLY 
# CHAT_REPLY 5. **Testing**: The file `cody_test/lib/shared/src/prompt/prompt-string.test.ts` contains tests that verify the behavior of the `PromptString` class and its methods, ensuring that unsafe strings cannot be used.
# CHAT_REPLY 
# CHAT_REPLY Here are some key excerpts from the code:
# CHAT_REPLY 
# CHAT_REPLY - **Tagged Template Literal Function**:
# CHAT_REPLY   ```typescript
# CHAT_REPLY   export function ps(format: TemplateStringsArray, ...args: TemplateArgs): PromptString {
# CHAT_REPLY       if (!(Array.isArray(format) && Object.isFrozen(format) && format.length > 0)) {
# CHAT_REPLY           throw new Error('ps is only intended to be used in tagged template literals.');
# CHAT_REPLY       }
# CHAT_REPLY 
# CHAT_REPLY       const buffer: string[] = []
# CHAT_REPLY       const references: Set<StringReference> = new Set()
# CHAT_REPLY       for (let i = 0; i < format.length; i++) {
# CHAT_REPLY           buffer.push(format[i])
# CHAT_REPLY           if (i < args.length) {
# CHAT_REPLY               const arg = args[i]
# CHAT_REPLY 
# CHAT_REPLY               if (typeof arg === 'number') {
# CHAT_REPLY                   buffer.push(Number.prototype.toString.call(arg))
# CHAT_REPLY               } else if (arg === '') {
# CHAT_REPLY                   // Allow empty strings
# CHAT_REPLY               } else if (arg instanceof PromptString) {
# CHAT_REPLY                   buffer.push(internal_toString(arg))
# CHAT_REPLY                   for (const ref of internal_toReferences(arg)) {
# CHAT_REPLY                       references.add(ref)
# CHAT_REPLY                   }
# CHAT_REPLY               } else {
# CHAT_REPLY                   throw new Error(
# CHAT_REPLY                       'Use ps`...` or a PromptString helper to handle string data for prompts safely.'
# CHAT_REPLY                   )
# CHAT_REPLY               }
# CHAT_REPLY           }
# CHAT_REPLY       }
# CHAT_REPLY 
# CHAT_REPLY       return internal_createPromptString(buffer.join(''), [...references])
# CHAT_REPLY   }
# CHAT_REPLY   ```
# CHAT_REPLY 
# CHAT_REPLY - **Validation Function**:
# CHAT_REPLY   ```typescript
# CHAT_REPLY   export function isValidPromptString(promptString: PromptString) {
# CHAT_REPLY       return pocket.has(promptString)
# CHAT_REPLY   }
# CHAT_REPLY   ```
# CHAT_REPLY 
# CHAT_REPLY - **Tests**:
# CHAT_REPLY   ```typescript
# CHAT_REPLY   describe('PromptString', () => {
# CHAT_REPLY       it('can not be generated dynamically unless it consists of allowed sources', () => {
# CHAT_REPLY           expect(ps`foo`).toBeInstanceOf(PromptString)
# CHAT_REPLY           expect(ps`foo${ps`bar`}`).toBeInstanceOf(PromptString)
# CHAT_REPLY           expect(ps`foo${1234}`).toBeInstanceOf(PromptString)
# CHAT_REPLY 
# CHAT_REPLY           // @ts-expect-error: Can't inline a string
# CHAT_REPLY           expect(() => ps`foo${'ho ho'}bar`).toThrowError()
# CHAT_REPLY 
# CHAT_REPLY           const evil = 'ha-ha!'
# CHAT_REPLY           // @ts-expect-error: Evil is a string and can not be appended like this
# CHAT_REPLY           expect(() => ps`foo${evil}bar`).toThrowError()
# CHAT_REPLY 
# CHAT_REPLY           const evil2 = {
# CHAT_REPLY               toString: () => 'hehe!',
# CHAT_REPLY           }
# CHAT_REPLY           // @ts-expect-error: Can't hack around the limitation
# CHAT_REPLY           expect(() => ps`foo${evil2}bar`).toThrowError()
# CHAT_REPLY 
# CHAT_REPLY           class FakePromptString extends PromptString {
# CHAT_REPLY               toString() {
# CHAT_REPLY                   return 'ðŸ˜ˆ'
# CHAT_REPLY               }
# CHAT_REPLY           }
# CHAT_REPLY           const fake = new FakePromptString('')
# CHAT_REPLY           expect(() => ps`${fake}`).toThrowError()
# CHAT_REPLY       })
# CHAT_REPLY   })
# CHAT_REPLY   ```
# CHAT_REPLY 
# CHAT_REPLY These mechanisms collectively ensure that prompt injection is prevented by controlling how strings are constructed and used within the codebase.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsxL197-204"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsxL47-138"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.test.tsL0-181"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/openaicompatible.tsL372-380"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-mixin.tsL0-56"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/prompt/prompt-string.tsL0-437"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/supercompletions/prompt.tsL43-50"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/commands/types.tsL32-60"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.tsL116-133"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.tsL126-149"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lints/safe-prompts.tsL0-22"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.tsL41-51"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/chat/chat-view/prompt.tsL80-98"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/webviews/promptEditor/PromptEditor.tsxL25-62"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/edit/prompt/models/generic.tsL51-62"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/menus/index.tsL152-179"}]

 class: Find logic
