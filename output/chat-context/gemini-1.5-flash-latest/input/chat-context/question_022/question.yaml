 question: Where is the code that interacts with bfg binary?
# CHAT
# CHAT_QUESTION Where is the code that interacts with bfg binary?

# CHAT_REPLY The code that interacts with the bfg binary is primarily located in these files:
# CHAT_REPLY 
# CHAT_REPLY * **`cody_test/vscode/src/graph/bfg/download-bfg.ts`:** This file handles downloading the bfg binary from GitHub, unzipping it, and storing it in the VS Code extension's global storage. It also manages deleting older versions of the bfg binary.
# CHAT_REPLY * **`cody_test/vscode/src/graph/bfg/spawn-bfg.ts`:** This file spawns the bfg process as a child process, sets up communication channels (stdin, stdout, stderr) between the VS Code extension and the bfg process, and handles error handling and process termination.
# CHAT_REPLY * **`cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts`:** This file uses the `spawnBfg` function to initialize a connection to the bfg process and sends requests to it to retrieve context information for code completions. It also handles indexing the workspace and Git repositories to keep the bfg process up-to-date with the codebase.
# CHAT_REPLY 
# CHAT_REPLY In addition to these files, the `bfg-protocol.ts` file defines the JSON-RPC protocol used to communicate between the VS Code extension and the bfg process.
# CHAT_REPLY 
# CHAT_REPLY Overall, the interaction with the bfg binary is managed through a combination of downloading, spawning, communication, and indexing, all of which are handled by the code in these files.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/spawn-bfg.ts:9-44","content":"export async function spawnBfg(\n    context: vscode.ExtensionContext,\n    reject: (reason?: any) => void\n): Promise<MessageHandler> {\n    const bfg = new MessageHandler()\n    const codyrpc = await downloadBfg(context)\n    if (!codyrpc) {\n        throw new Error(\n            'Failed to download BFG binary. To fix this problem, set the \"cody.experimental.cody-engine.path\" configuration to the path of your BFG binary'\n        )\n    }\n    const isVerboseDebug = vscode.workspace.getConfiguration().get<boolean>('cody.debug.verbose', false)\n    const child = child_process.spawn(codyrpc, {\n        stdio: 'pipe',\n        env: {\n            VERBOSE_DEBUG: `${isVerboseDebug}`,\n            RUST_BACKTRACE: isVerboseDebug ? '1' : '0',\n            // See bfg issue 138\n            RUST_LIB_BACKTRACE: '0',\n        },\n    })\n    child.stderr.on('data', chunk => {\n        logDebug('CodyEngine', 'spawnBfg:stderr', { verbose: chunk.toString() })\n    })\n    child.on('disconnect', () => reject())\n    child.on('close', () => reject())\n    child.on('error', error => reject(error))\n    child.on('exit', code => {\n        bfg.exit()\n        reject(code)\n    })\n    child.stderr.pipe(process.stderr)\n    child.stdout.pipe(bfg.messageDecoder)\n    bfg.messageEncoder.pipe(child.stdin)\n    return bfg\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5905-5936","content":"        }\n        set value(value: number) {\n            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): DoubleConstant {\n            const message = new DoubleConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeDouble(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DoubleConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:111-119","content":"async function unzipBfg(zipFile: string, destinationDir: string): Promise<void> {\n    const zip = fs.createReadStream(zipFile).pipe(unzipper.Parse({ forceStream: true }))\n    for await (const entry of zip) {\n        if (entry.path.endsWith('/')) {\n            continue\n        }\n        entry.pipe(fs.createWriteStream(path.join(destinationDir, entry.path)))\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:933-953","content":"        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.scheme.length) writer.writeString(1, this.scheme)\n            if (this.has_package)\n                writer.writeMessage(2, this.package, () => this.package.serialize(writer))\n            if (this.descriptors.length)\n                writer.writeRepeatedMessage(3, this.descriptors, (item: Descriptor) =>\n                    item.serialize(writer)\n                )\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Symbol {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Symbol()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.scheme = reader.readString()\n                        break\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:20-109","content":"export async function downloadBfg(context: vscode.ExtensionContext): Promise<string | null> {\n    // First, wait for any in-progress downloads.\n    await serializeBfgDownload\n\n    // Now we are the in-progress download.\n    serializeBfgDownload = (async () => {\n        const config = vscode.workspace.getConfiguration()\n        const userBfgPath = config.get<string>('cody.experimental.cody-engine.path')\n        if (userBfgPath) {\n            const bfgStat = await fspromises.stat(userBfgPath)\n            if (!bfgStat.isFile()) {\n                throw new Error(`not a file: ${userBfgPath}`)\n            }\n            logDebug('CodyEngine', `using user-provided path: ${userBfgPath} ${bfgStat.isFile()}`)\n            return userBfgPath\n        }\n\n        const osArch = getOSArch()\n        if (!osArch) {\n            logDebug('CodyEngine', 'getOSArch returned nothing')\n            return null\n        }\n        const { platform, arch } = osArch\n\n        if (!arch) {\n            logDebug('CodyEngine', 'getOSArch returned undefined arch')\n            return null\n        }\n\n        if (!platform) {\n            logDebug('CodyEngine', 'getOSArch returned undefined platform')\n            return null\n        }\n        // Rename returned architecture to match RFC 795 conventions\n        // https://docs.google.com/document/d/11cw-7dAp93JmasITNSNCtx31xrQsNB1L2OoxVE6zrTc/edit\n        const archRenames = new Map([\n            ['aarch64', 'arm64'],\n            ['x86_64', 'x64'],\n        ])\n        let rfc795Arch = archRenames.get(arch ?? '') ?? arch\n        if (rfc795Arch === 'arm64' && platform === 'win') {\n            // On Windows Arm PCs, we rely on emulation and use the x64 binary.\n            // See https://learn.microsoft.com/en-us/windows/arm/apps-on-arm-x86-emulation\n            rfc795Arch = 'x64'\n        }\n\n        const bfgContainingDir = path.join(context.globalStorageUri.fsPath, 'cody-engine')\n        const bfgVersion = config.get<string>('cody.experimental.cody-engine.version', defaultBfgVersion)\n        await fspromises.mkdir(bfgContainingDir, { recursive: true })\n        const bfgFilename = `cody-engine-${bfgVersion}-${platform}-${rfc795Arch}`\n        const bfgPath = path.join(bfgContainingDir, bfgFilename)\n        const isAlreadyDownloaded = await fileExists(bfgPath)\n        if (isAlreadyDownloaded) {\n            logDebug('CodyEngine', `using downloaded path \"${bfgPath}\"`)\n            return bfgPath\n        }\n\n        const bfgURL = `https://github.com/sourcegraph/bfg/releases/download/v${bfgVersion}/bfg-${platform}-${rfc795Arch}.zip`\n        try {\n            await vscode.window.withProgress(\n                {\n                    location: vscode.ProgressLocation.Window,\n                    title: 'Downloading cody-engine',\n                    cancellable: false,\n                },\n                async progress => {\n                    progress.report({ message: 'Downloading cody-engine' })\n                    const bfgZip = path.join(bfgContainingDir, 'bfg.zip')\n                    await downloadBfgBinary(bfgURL, bfgZip)\n                    await unzipBfg(bfgZip, bfgContainingDir)\n                    logDebug('CodyEngine', bfgPath)\n                    // The zip file contains a binary named `bfg` or `bfg.exe`. We unzip it with that name first and then rename into\n                    // a version-specific binary so that we can delete old versions of bfg.\n                    const unzipPath = platform === 'windows' ? 'bfg.exe' : 'bfg'\n                    await fspromises.rename(path.join(bfgContainingDir, unzipPath), bfgPath)\n                    await fspromises.chmod(bfgPath, 0o755)\n                    await fspromises.rm(bfgZip)\n                    logDebug('CodyEngine', `downloaded cody-engine to ${bfgPath}`)\n                }\n            )\n            void removeOldBfgBinaries(bfgContainingDir, bfgFilename)\n        } catch (error) {\n            captureException(error)\n            void vscode.window.showErrorMessage(`Failed to download bfg from URL ${bfgURL}: ${error}`)\n            return null\n        }\n        return bfgPath\n    })()\n    return serializeBfgDownload\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5636-5662","content":"            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CharConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new CharConstant()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.value = reader.readInt32()\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:25-38","content":"    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:123-144","content":"\n### Code Actions\n\n#### Fixing code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action (in VSC) lightbulb icon in the project file\n- [ ] Select `Ask Cody to Fix`.\n- [ ] Verify that there is a notification that \"Cody is working...\" while edits are being applied.\n- [ ] Verify that Cody automatically applies a code fix to the selected code.\n- [ ] Verify that you can see a diff view of the fix in a new tab by clicking `Show diff`.\n- [ ] Verify that you can prompt Cody to retry the command by clicking `Retry` and entering new instructions.\n- [ ] Verify that you can undo the fix by clicking `Undo`.\n- [ ] Verify that the ghost text disappears by clicking `Accept`.\n\n#### Explaining code\n\n- [ ] Deliberately break a line or section of code to trigger the IDE’s red squiggly error warning.\n- [ ] Click the Code Action lightbulb icon in the project file\n- [ ] Select `Ask Cody to Explain`.\n- [ ] Verify that Cody provides an explanation of the error in a new chat window.\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:3411-3438","content":"                message.symbol = data.symbol\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                symbol?: string\n            } = {}\n            if (this.symbol != null) {\n                data.symbol = this.symbol\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.symbol.length) writer.writeString(1, this.symbol)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ThisType {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new ThisType()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/SidebarCommands.ts:57-78","content":"        }),\n        vscode.commands.registerCommand('cody.sidebar.keyboardShortcuts', () => {\n            logSidebarClick('keyboardShortcuts')\n            void vscode.commands.executeCommand(\n                'workbench.action.openGlobalKeybindings',\n                '@ext:sourcegraph.cody-ai'\n            )\n        }),\n        vscode.commands.registerCommand('cody.sidebar.releaseNotes', () => {\n            logSidebarClick('releaseNotes')\n            void vscode.commands.executeCommand('vscode.open', releaseNotesURL(version))\n        }),\n        vscode.commands.registerCommand('cody.sidebar.documentation', () => {\n            logSidebarClick('documentation')\n            void vscode.commands.executeCommand('vscode.open', CODY_DOC_URL.href)\n        }),\n        vscode.commands.registerCommand('cody.sidebar.support', () => {\n            logSidebarClick('support')\n            void vscode.commands.executeCommand('vscode.open', CODY_SUPPORT_URL.href)\n        }),\n        vscode.commands.registerCommand('cody.sidebar.feedback', () => {\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57","content":"import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5695-5726","content":"        }\n        set value(value: number) {\n            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): IntConstant {\n            const message = new IntConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73","content":"import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\"presentation\"] div[class*=\"squiggly-error\"]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5487-5516","content":"            pb_1.Message.setField(this, 1, value)\n        }\n        static fromObject(data: {\n            value?: number\n        }): ByteConstant {\n            const message = new ByteConstant({})\n            if (data.value != null) {\n                message.value = data.value\n            }\n            return message\n        }\n        toObject() {\n            const data: {\n                value?: number\n            } = {}\n            if (this.value != null) {\n                data.value = this.value\n            }\n            return data\n        }\n        serialize(): Uint8Array\n        serialize(w: pb_1.BinaryWriter): void\n        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {\n            const writer = w || new pb_1.BinaryWriter()\n            if (this.value != 0) writer.writeInt32(1, this.value)\n            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ByteConstant {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203","content":"import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/commands.md:0-13","content":"## Cody Commands\n\n<img src=\"https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-explain.gif\">\n\nCody has a range of commands for explaining code, generating unit tests, adding documentation, and more.\n\nTo get started: select code in your editor, right click, and choose a command from the \"Cody\" menu.\n\nYou can also use the [Cody: Commands Menu](command:cody.menu.commands) which has the default keyboard shortcut of `Option` `C` on macOS and `Alt` `C` on Windows & Linux.\n\n**✨ Pro-tips for using Cody commands**\n<br>• You can build your own [Custom Commands (Beta)](https://sourcegraph.com/docs/cody/custom-commands) with custom prompts, output into chat or perform code edits, and more.\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21","content":"export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:1700-1723","content":"            if (!w) return writer.getResultBuffer()\n        }\n        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Relationship {\n            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Relationship()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        message.symbol = reader.readString()\n                        break\n                    case 2:\n                        message.is_reference = reader.readBool()\n                        break\n                    case 3:\n                        message.is_implementation = reader.readBool()\n                        break\n                    case 4:\n                        message.is_type_definition = reader.readBool()\n                        break\n                    case 5:\n                        message.is_definition = reader.readBool()\n                        break\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/bfg-protocol.ts:0-39","content":"/**\n * This file declares the protocol for communicating between Cody and BFG (Blazingly Fast Graph), a Rust implementation\n * of the \"Graph Context\" feature flag.\n */\nimport type { Position } from './agent-protocol'\n\ninterface BFGFileContextSnippet {\n    fileName: string\n    content: string\n}\n\ninterface BFGSymbolContextSnippet extends BFGFileContextSnippet {\n    symbol: string\n}\n\nexport type Requests = {\n    'bfg/initialize': [{ clientName: string }, { serverVersion: string }]\n    'bfg/contextAtPosition': [\n        { uri: string; content: string; position: Position; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[]; files?: BFGFileContextSnippet[] },\n    ]\n    'bfg/contextForIdentifiers': [\n        { uri: string; identifiers: string[]; maxSnippets: number; maxDepth: number },\n        { symbols?: BFGSymbolContextSnippet[] },\n    ]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/gitRevision/didChange': [{ gitDirectoryUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/workspace/didChange': [{ workspaceUri: string }, void]\n    // biome-ignore lint/suspicious/noConfusingVoidType: this models a function returning void\n    'bfg/shutdown': [null, void]\n\n    'embeddings/hello': [null, string]\n}\n\nexport type Notifications = {\n    'bfg/placeholderNotification': [null]\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012","content":"        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/context-strategy.ts:25-50","content":"\n    constructor(\n        private contextStrategy: ContextStrategy,\n        createBfgRetriever?: () => BfgRetriever\n    ) {\n        switch (contextStrategy) {\n            case 'none':\n                break\n            case 'bfg-mixed':\n            case 'bfg':\n                // The bfg strategy uses jaccard similarity as a fallback if no results are found or\n                // the language is not supported by BFG\n                this.localRetriever = new JaccardSimilarityRetriever()\n                this.disposables.push(this.localRetriever)\n                if (createBfgRetriever) {\n                    this.graphRetriever = createBfgRetriever()\n                    this.disposables.push(this.graphRetriever)\n                }\n                break\n            case 'jaccard-similarity':\n                this.localRetriever = new JaccardSimilarityRetriever()\n                this.disposables.push(this.localRetriever)\n                break\n            case 'local-mixed':\n                this.localRetriever = new JaccardSimilarityRetriever()\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/context/retrievers/bfg/bfg-retriever.ts:0-303","content":"import * as vscode from 'vscode'\n\nimport { spawnBfg } from '../../../../graph/bfg/spawn-bfg'\nimport type { MessageHandler } from '../../../../jsonrpc/jsonrpc'\nimport { logDebug } from '../../../../log'\nimport type { Repository } from '../../../../repository/builtinGitExtension'\nimport { gitAPI } from '../../../../repository/git-extension-api'\nimport { captureException } from '../../../../services/sentry/sentry'\nimport type { ContextRetriever, ContextRetrieverOptions } from '../../../types'\n\nimport type { AutocompleteContextSnippet } from '@sourcegraph/cody-shared'\nimport {\n    getLastNGraphContextIdentifiersFromDocument,\n    getLastNGraphContextIdentifiersFromString,\n} from '../graph/identifiers'\nimport { type SimpleRepository, inferGitRepository } from './simple-git'\n\nexport class BfgRetriever implements ContextRetriever {\n    public identifier = 'bfg'\n    private loadedBFG: Promise<MessageHandler>\n    private bfgIndexingPromise = Promise.resolve<void>(undefined)\n    private awaitIndexing: boolean\n    private didFailLoading = false\n    // Keys are repository URIs, values are revisions (commit hashes).\n    private indexedRepositoryRevisions = new Map<string, string>()\n    constructor(private context: vscode.ExtensionContext) {\n        this.awaitIndexing = vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.await-indexing', false)\n        this.loadedBFG = this.loadBFG()\n\n        this.loadedBFG.then(\n            () => {},\n            error => {\n                captureException(error)\n                this.didFailLoading = true\n                logDebug('CodyEngine', 'failed to initialize', error)\n            }\n        )\n\n        this.bfgIndexingPromise = this.indexWorkspace()\n    }\n\n    private async indexWorkspace(): Promise<void> {\n        await this.indexGitRepositories()\n        await this.indexRemainingWorkspaceFolders()\n    }\n    private isWorkspaceIndexed(folder: vscode.Uri): boolean {\n        const uri = folder.toString()\n        logDebug('CodyEngine', 'Checking if folder is indexed', uri)\n        for (const key of this.indexedRepositoryRevisions.keys()) {\n            if (uri.startsWith(key)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private async indexRemainingWorkspaceFolders(): Promise<void> {\n        logDebug(\n            'CodyEngine',\n            'workspaceFolders',\n            vscode.workspace.workspaceFolders?.map(folder => folder.uri.toString()) ?? []\n        )\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.isWorkspaceIndexed(folder.uri)) {\n                continue\n            }\n            await this.indexEntry({ workspace: folder.uri })\n        }\n    }\n    private async indexGitRepositories(): Promise<void> {\n        const git = gitAPI()\n        if (!git) {\n            return\n        }\n        for (const repository of git.repositories) {\n            await this.didChangeGitExtensionRepository(repository)\n        }\n        this.context.subscriptions.push(\n            git.onDidOpenRepository(repository => this.didChangeGitExtensionRepository(repository))\n        )\n        this.context.subscriptions.push(\n            vscode.workspace.onDidChangeWorkspaceFolders(() => this.indexInferredGitRepositories())\n        )\n        // TODO: handle closed repositories\n\n        await this.indexInferredGitRepositories()\n    }\n\n    private shouldInferGitRepositories(): boolean {\n        // Some users may not want to allow Cody to index code outside the VS\n        // Code workspace folder so we support an escape hatch to disable this\n        // functionality. This setting is hidden because all the other\n        // BFG-related settings are hidden.\n        return vscode.workspace\n            .getConfiguration()\n            .get<boolean>('cody.experimental.cody-engine.index-parent-git-folder', false)\n    }\n\n    // Infers what git repositories that are relevant but may not be \"open\" by\n    // the git extension.  For example, by default, the git extension doesn't\n    // open git repositories when the workspace root is a subfolder. There's a\n    // setting to automatically open parent git repositories but the setting is\n    // disabled by default.\n    private async indexInferredGitRepositories(): Promise<void> {\n        if (!this.shouldInferGitRepositories()) {\n            return\n        }\n        for (const folder of vscode.workspace.workspaceFolders ?? []) {\n            if (this.indexedRepositoryRevisions.has(folder.uri.toString())) {\n                continue\n            }\n            const repo = await inferGitRepository(folder.uri)\n            if (repo) {\n                await this.didChangeSimpleRepository(repo)\n            }\n        }\n    }\n\n    private async didChangeGitExtensionRepository(repository: Repository): Promise<void> {\n        const commit = repository?.state?.HEAD?.commit\n        if (!commit) {\n            return\n        }\n        await this.didChangeSimpleRepository({ uri: repository.rootUri, commit })\n    }\n\n    private async didChangeSimpleRepository(repository: SimpleRepository): Promise<void> {\n        const uri = repository.uri.toString()\n        if (repository.commit !== this.indexedRepositoryRevisions.get(uri)) {\n            this.indexedRepositoryRevisions.set(uri, repository.commit ?? '')\n            await this.indexEntry({ repository })\n        }\n    }\n\n    private async indexEntry(params: {\n        repository?: SimpleRepository\n        workspace?: vscode.Uri\n    }): Promise<void> {\n        const { repository, workspace } = params\n        if (!repository && !workspace) {\n            return\n        }\n        const bfg = await this.loadedBFG\n        const indexingStartTime = Date.now()\n        // TODO: include commit?\n        try {\n            if (repository) {\n                await bfg.request('bfg/gitRevision/didChange', {\n                    gitDirectoryUri: repository.uri.toString(),\n                })\n            }\n            if (workspace) {\n                await bfg.request('bfg/workspace/didChange', { workspaceUri: workspace.toString() })\n            }\n            const elapsed = Date.now() - indexingStartTime\n            const label = repository\n                ? `${repository.uri.fsPath}:${repository.commit}`\n                : workspace\n                  ? workspace.fsPath\n                  : ''\n            if (label) {\n                logDebug('CodyEngine', `gitRevision/didChange ${label} indexing time ${elapsed}ms`)\n            }\n        } catch (error) {\n            logDebug('CodyEngine', `indexing error ${error}`)\n        }\n    }\n\n    public async retrieve({\n        document,\n        position,\n        docContext,\n        hints,\n        lastCandidate,\n    }: ContextRetrieverOptions): Promise<AutocompleteContextSnippet[]> {\n        try {\n            if (this.didFailLoading) {\n                return []\n            }\n            const bfg = await this.loadedBFG\n            if (!bfg.isAlive()) {\n                logDebug('CodyEngine', 'not alive')\n                return []\n            }\n\n            if (this.awaitIndexing) {\n                await this.bfgIndexingPromise\n            }\n\n            const lastCandidateCurrentLine =\n                (lastCandidate?.lastTriggerDocContext.currentLinePrefix || '') +\n                lastCandidate?.result.items[0].insertText\n\n            const bfgRequestStart = performance.now()\n            const inputIdentifiers = Array.from(\n                new Set([\n                    // Get last 10 identifiers from the last candidate insert text\n                    // in hopes that LLM partially guessed the right completion.\n                    ...getLastNGraphContextIdentifiersFromString({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                        source: lastCandidateCurrentLine,\n                    }),\n                    // Get last 10 identifiers from the current document prefix.\n                    ...getLastNGraphContextIdentifiersFromDocument({\n                        n: 10,\n                        document,\n                        position,\n                        currentLinePrefix: docContext.currentLinePrefix,\n                    }),\n                ])\n            )\n\n            const response = await bfg.request('bfg/contextForIdentifiers', {\n                uri: document.uri.toString(),\n                identifiers: inputIdentifiers,\n                maxSnippets: 20,\n                maxDepth: 4,\n            })\n\n            // Just in case, handle non-object results\n            if (typeof response !== 'object') {\n                return []\n            }\n\n            // Convert BFG snippets to match the format expected on the client.\n            const symbols = (response.symbols || []).map(contextSnippet => ({\n                ...contextSnippet,\n                uri: vscode.Uri.from({ scheme: 'file', path: contextSnippet.fileName }),\n            })) satisfies Omit<AutocompleteContextSnippet, 'startLine' | 'endLine'>[]\n\n            logDebug('CodyEngine', 'bfg/contextForIdentifiers', {\n                verbose: {\n                    inputIdentifiers,\n                    duration: `${performance.now() - bfgRequestStart}ms`,\n                    symbols: symbols.map(s => `${s.symbol} ${s.content}`),\n                },\n            })\n\n            // TODO: add `startLine` and `endLine` to `responses` or explicitly add\n            // another context snippet type to the client.\n            // @ts-ignore\n            return symbols\n        } catch (error) {\n            logDebug('CodyEngine:error', `${error}`)\n            return []\n        }\n    }\n\n    public isSupportedForLanguageId(languageId: string): boolean {\n        switch (languageId) {\n            case 'typescript':\n            case 'typescriptreact':\n            case 'javascript':\n            case 'javascriptreact':\n            case 'java':\n            case 'go':\n            case 'dart':\n            case 'python':\n            case 'zig':\n                return true\n            default:\n                return false\n        }\n    }\n\n    public dispose(): void {\n        if (this.didFailLoading) {\n            return\n        }\n        this.loadedBFG.then(\n            bfg => bfg.request('bfg/shutdown', null),\n            () => {}\n        )\n    }\n\n    // We lazily load BFG to allow the Cody extension to finish activation as\n    // quickly as possible.\n    private loadBFG(): Promise<MessageHandler> {\n        // This is implemented as a custom promise instead of async/await so that we can reject\n        // the promise in the 'exit' handler if we fail to start the bfg process for some reason.\n        return new Promise<MessageHandler>((resolve, reject) => {\n            logDebug('CodyEngine', 'loading bfg')\n            this.doLoadBFG(reject).then(\n                bfg => resolve(bfg),\n                error => {\n                    captureException(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    private async doLoadBFG(reject: (reason?: any) => void): Promise<MessageHandler> {\n        const bfg = await spawnBfg(this.context, reject)\n        await bfg.request('bfg/initialize', { clientName: 'vscode' })\n        return bfg\n    }\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:5271-5292","content":"            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),\n                message = new Constant()\n            while (reader.nextField()) {\n                if (reader.isEndGroup()) break\n                switch (reader.getFieldNumber()) {\n                    case 1:\n                        reader.readMessage(\n                            message.unit_constant,\n                            () => (message.unit_constant = UnitConstant.deserialize(reader))\n                        )\n                        break\n                    case 2:\n                        reader.readMessage(\n                            message.boolean_constant,\n                            () => (message.boolean_constant = BooleanConstant.deserialize(reader))\n                        )\n                        break\n                    case 3:\n                        reader.readMessage(\n                            message.byte_constant,\n                            () => (message.byte_constant = ByteConstant.deserialize(reader))\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:139-145","content":"async function removeOldBfgBinaries(containingDir: string, currentBfgPath: string): Promise<void> {\n    const bfgDirContents = await fspromises.readdir(containingDir)\n    const oldBfgBinaries = bfgDirContents.filter(f => f.startsWith('bfg') && f !== currentBfgPath)\n    for (const oldBfgBinary of oldBfgBinaries) {\n        await fspromises.rm(path.join(containingDir, oldBfgBinary))\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/evaluate-autocomplete.ts:208-243","content":"        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-language <glob>',\n        'A glob pattern to determine what language paths to exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-fixture <glob>',\n        'A glob pattern to determine what fixtures to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-fixture <glob>',\n        'A glob pattern to determine what fixtures exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--include-filepath <glob>',\n        'A glob pattern to determine what files to include in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .option(\n        '--exclude-filepath <glob>',\n        'A glob pattern to determine what files exclude in the evaluation',\n        arrayOption as any,\n        []\n    )\n    .addOption(\n        new commander.Option('--bfg-binary <path>', 'Optional path to a BFG binary').env('BFG_BINARY')\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/graph/bfg/download-bfg.ts:121-137","content":"async function downloadBfgBinary(url: string, destination: string): Promise<void> {\n    logDebug('CodyEngine', `downloading from URL ${url}`)\n    const response = await axios({\n        url,\n        method: 'GET',\n        responseType: 'stream',\n        maxRedirects: 10,\n    })\n\n    const stream = fs.createWriteStream(destination)\n    response.data.pipe(stream)\n\n    await new Promise((resolve, reject) => {\n        stream.on('finish', resolve)\n        stream.on('error', reject)\n    })\n"}]

 class: Find logic
