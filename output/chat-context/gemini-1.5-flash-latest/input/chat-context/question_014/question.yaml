 question: Where is the code for inserting autocompletions?
# CHAT
# CHAT_QUESTION Where is the code for inserting autocompletions?

# CHAT_REPLY The code for inserting autocompletions is spread across several files, but the core logic is in `cody_test/vscode/src/completions/inline-completion-item-provider.ts`. 
# CHAT_REPLY 
# CHAT_REPLY Here's a breakdown:
# CHAT_REPLY 
# CHAT_REPLY 1. **`updateInsertRangeForVSCode` function:** This function, located in `cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts`, is responsible for adjusting the `insertText` and `range` properties of autocomplete items to be compatible with VS Code's inline completion API.
# CHAT_REPLY 
# CHAT_REPLY 2. **`CodyCompletionItemProvider` class:** This class, in `cody_test/vscode/src/completions/inline-completion-item-provider.ts`, handles the entire process of providing inline completions. It fetches suggestions from various providers, filters them, and then uses the `updateInsertRangeForVSCode` function to prepare them for insertion.
# CHAT_REPLY 
# CHAT_REPLY 3. **`handleCodeFromInsertAtCursor` function:** This function, in `cody_test/vscode/src/services/utils/codeblock-action-tracker.ts`, is responsible for inserting the code from the "Insert at Cursor" button. It uses VS Code's `WorkspaceEdit` API to insert the text at the current cursor position.
# CHAT_REPLY 
# CHAT_REPLY 4. **`acceptCompletion` function:** This function, also in `cody_test/vscode/src/completions/inline-completion-item-provider.ts`, is called when the user accepts a completion. It triggers the insertion of the selected completion using VS Code's `InlineCompletionItemProvider.resolveInlineCompletionItem` method.
# CHAT_REPLY 
# CHAT_REPLY In summary, the insertion of autocompletions is a collaborative effort between these components:
# CHAT_REPLY 
# CHAT_REPLY - **`updateInsertRangeForVSCode`:** Prepares the completion item for VS Code.
# CHAT_REPLY - **`CodyCompletionItemProvider`:** Fetches, filters, and prepares completions.
# CHAT_REPLY - **`handleCodeFromInsertAtCursor`:** Inserts code from the "Insert at Cursor" button.
# CHAT_REPLY - **`acceptCompletion`:** Triggers the insertion of the selected completion.
# CHAT_REPLY 
# CHAT_REPLY This process ensures that the autocompletions are correctly inserted into the editor, respecting the user's selection and the context of the code.

# CONTEXT_ITEMS [{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/evaluate-autocomplete.ts:13-50","content":"export interface EvaluateAutocompleteOptions {\n    workspace: string\n    worktree?: string\n    treeSitterGrammars: string\n    queriesDirectory: string\n    testCount: number\n    maxFileTestCount: number\n    includeFixture: string[]\n    excludeFixture: string[]\n    includeWorkspace: string[]\n    excludeWorkspace: string[]\n    includeFilepath?: string[]\n    excludeFilepath?: string[]\n    includeLanguage?: string[]\n    excludeLanguage?: string[]\n    includeMatchKind?: string[]\n    excludeMatchKind?: string[]\n    testTypecheck?: boolean\n    testParse?: boolean\n    srcAccessToken: string\n    srcEndpoint: string\n\n    codyAgentBinary?: string\n\n    matchMinimumSize?: number\n    matchSkipSingleline?: number\n    matchEveryN?: number\n    matchKindDistribution?: number\n\n    evaluationConfig: string\n    snapshotDirectory: string\n    csvPath?: string\n    bfgBinary?: string\n    installCommand?: string\n    testCommand?: string\n    gitLogFilter?: string\n    fixture: EvaluationFixture\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:345-367","content":"\n### Language ignore list\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion for file in the X programming language.\n- [ ] Open VS Code settings, find the language ignore list, and add this language to the list\n- [ ] Verify that completions are no longer generated for this language.\n\n### LLM selection\n\n- [ ] Log in to the VS Code extension as a Free user.\n- [ ] Generate completion using the LLM selected by default.\n- [ ] Open VS Code settings and find Cody autocomplete mode settings.\n  - Combinations to test:\n    - [ ] Provider: fireworks; Model: starcoder-16 and starcoder-7b\n    - [ ] Provider: anthropic; Model: null\n- [ ] Verify that autocomplete works as expected after the settings change.\n\n### Multi-line completions\n\n- [ ] Open a TypeScript file. Paste in something like this: `function bubbleSort(`.\n- [ ] Expect more than one line of code being completed for you.\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/tracer/traceView.ts:0-24","content":"import * as vscode from 'vscode'\n\nimport { displayPath, displayRange, isDefined, renderMarkdown } from '@sourcegraph/cody-shared'\n\nimport {\n    SectionHistoryRetriever,\n    registerDebugListener as registerSectionObserverDebugListener,\n} from '../context/retrievers/section-history/section-history-retriever'\nimport { InlineCompletionsResultSource } from '../get-inline-completions'\nimport type { InlineCompletionItemProvider } from '../inline-completion-item-provider'\nimport * as statistics from '../statistics'\nimport type { InlineCompletionItem } from '../types'\n\nimport type { ProvideInlineCompletionsItemTraceData } from '.'\n\n/**\n * Registers a command `Cody: Open Autocomplete Trace View` that shows the context and prompt used\n * for autocomplete.\n */\nexport function registerAutocompleteTraceView(\n    provider: InlineCompletionItemProvider\n): vscode.Disposable {\n    let panel: vscode.WebviewPanel | null = null\n    let latestInvocationSequence = 0\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:14-20","content":"interface AutocompleteMatch {\n    kind: AutocompleteMatchKind\n    newText: string\n    removedText: string\n    removedRange: vscode.Range\n    requestPosition: vscode.Position\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:33-66","content":"\n    /**\n     * Autocomplete\n     */\n    autocomplete: boolean\n    autocompleteLanguages: Record<string, boolean>\n    autocompleteAdvancedProvider:\n        | 'anthropic'\n        | 'fireworks'\n        | 'unstable-openai'\n        | 'experimental-openaicompatible'\n        | 'experimental-ollama'\n        | null\n    autocompleteAdvancedModel: string | null\n    autocompleteCompleteSuggestWidgetSelection?: boolean\n    autocompleteFormatOnAccept?: boolean\n    autocompleteDisableInsideComments: boolean\n\n    /**\n     * Experimental\n     */\n    experimentalGuardrails: boolean\n    experimentalSymfContext: boolean\n    experimentalTracing: boolean\n    experimentalSimpleChatContext: boolean\n    experimentalChatContextRanker: boolean | undefined\n    experimentalOllamaChat: boolean\n    experimentalSupercompletions: boolean\n\n    /**\n     * Unstable Features for internal testing only\n     */\n    internalUnstable: boolean\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:17-31","content":"export interface AutocompleteParameters {\n    parser?: WrappedParser\n    originalTree?: Tree\n    originalTreeIsErrorFree?: boolean\n    client: MessageHandler\n    document: EvaluationDocument\n\n    options: EvaluateAutocompleteOptions\n\n    range: vscode.Range\n    autocompleteKind?: AutocompleteMatchKind\n    modifiedContent: string\n    removedContent: string\n    position: vscode.Position\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/TESTING.md:0-32","content":"## Checklist\n\n- Commands\n  - [ ] [Explain](#explain)\n  - [ ] [Edit](#edit)\n  - [ ] [Test](#test)\n  - [ ] [Document](#document)\n  - [ ] [Smell](#smell)\n  - [ ] [Code Actions](#code-actions)\n  - [ ] [Custom Commands](#custom-commands)\n- Chat\n  - [ ] [Chat UX](#chat-ux)\n  - [ ] [Chats lefthand panel](#chats-lefthand-panel)\n  - [ ] [Enhanced Context](#enhanced-context)\n  - [ ] [LLM Selection](#llm-selection)\n- [Search](#search)\n- Autocomplete\n  - [ ] [Manual trigger key binding](#manual-trigger-key-binding)\n  - [ ] [Language ignore list](#language-ignore-list)\n  - [ ] [LLM selection](#llm-selection)\n  - [ ] [Multi-line completions](#multi-line-completions)\n  - [ ] [Telemetry and analytics](#telemetry-and-analytics)\n\n## Commands\n\n### Explain\n\n- [ ] Verify that the option to run the `Explain Code` command is available in the following locations:\n  - [ ] Sidebar `Explain Code`\n  - [ ] Context (right-click) menu `Cody > Explain Code`\n  - [ ] Command palette (MetaKey+Shift+p) `Cody Command: Explain Code`\n  - [ ] Cody Command Menu (option+c, `Explain Code`)\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/AutocompleteMatcher.ts:21-172","content":"export class AutocompleteMatcher {\n    public parser: WrappedParser | undefined\n    public originalTree: Tree | undefined\n    public originalTreeIsFreeOfErrrors: boolean | undefined\n    constructor(\n        public readonly params: EvaluationDocumentParams,\n        public readonly queries: Queries,\n        public readonly grammarDirectory: string\n    ) {}\n    private ifSyntax(language: SupportedLanguage): string {\n        switch (language) {\n            case SupportedLanguage.go:\n                return 'if  '\n            default:\n                return 'if ()'\n        }\n    }\n    public async matches(text: string): Promise<AutocompleteMatch[] | undefined> {\n        const { languageid: language } = this.params\n\n        if (!isSupportedLanguage(language)) {\n            return undefined\n        }\n        this.parser = await createParser({ language, grammarDirectory: this.grammarDirectory })\n        if (!this.parser) {\n            return undefined\n        }\n        const query = await this.queries.loadQuery(this.parser, language, 'context')\n        if (!query) {\n            return\n        }\n        this.originalTree = this.parser.parse(text)\n        this.originalTreeIsFreeOfErrrors = !this.originalTree.rootNode.hasError()\n        const result: AutocompleteMatch[] = []\n        const document = new EvaluationDocument(this.params, text, vscode.Uri.file(this.params.filepath))\n        for (const queryMatch of query.matches(this.originalTree.rootNode)) {\n            for (const capture of queryMatch.captures) {\n                if (capture.name === 'if_statement') {\n                    const ifSyntax = this.ifSyntax(language)\n\n                    const newText = [\n                        text.slice(0, capture.node.startIndex),\n                        ifSyntax,\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'if_statement',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            capture.node.startIndex + ifSyntax.length - 1\n                        ),\n                    })\n                } else if (capture.name === 'function_declaration') {\n                    const openParen = queryMatch.captures.find(c => c.name === 'opening_paren')?.node\n                    if (!openParen) {\n                        throw new Error('Missing capture group @opening_paren for @function_declaration')\n                    }\n                    const newText = [\n                        text.slice(0, openParen.startIndex),\n                        '()',\n                        text.slice(capture.node.endIndex),\n                    ]\n                    result.push({\n                        kind: 'function_declaration',\n                        newText: newText.join(''),\n                        removedText: capture.node.text,\n                        removedRange: new vscode.Range(\n                            document.textDocument.positionAt(capture.node.startIndex),\n                            document.textDocument.positionAt(capture.node.endIndex)\n                        ),\n                        requestPosition: document.textDocument.positionAt(\n                            openParen.startIndex + '('.length\n                        ),\n                    })\n                } else if (capture.name === 'call_expression') {\n                    const openParenPosition = queryMatch.captures.find(c => c.name === 'opening_paren')\n                        ?.node.startIndex\n                    const closeParenPosition = queryMatch.captures.find(c => c.name === 'closing_paren')\n                        ?.node.endIndex\n                    if (openParenPosition && closeParenPosition) {\n                        const openParenSyntax = text.charAt(openParenPosition) ?? '('\n                        const closeParenSyntax = text.charAt(closeParenPosition - 1) ?? ')'\n                        if (\n                            closeParenSyntax !== ')' &&\n                            closeParenSyntax !== '}' &&\n                            closeParenSyntax !== ']' &&\n                            closeParenSyntax !== '>'\n                        ) {\n                            throw new Error(\n                                `Invalid close paren syntax. ${JSON.stringify({\n                                    params: this.params,\n                                    closeParenSyntax,\n                                })}`\n                            )\n                        }\n                        const newText = [\n                            text.slice(0, openParenPosition),\n                            openParenSyntax,\n                            closeParenSyntax,\n                            text.slice(closeParenPosition),\n                        ]\n                        result.push({\n                            kind: 'call_expression',\n                            newText: newText.join(''),\n                            removedText: text.slice(openParenPosition, closeParenPosition),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(openParenPosition),\n                                document.textDocument.positionAt(closeParenPosition)\n                            ),\n                            requestPosition: document.textDocument.positionAt(\n                                openParenPosition + openParenSyntax.length\n                            ),\n                        })\n                    } else {\n                        throw new Error(\n                            `Missing @opening_paren and/or @closing_parent captures for node: ${capture.node.text}`\n                        )\n                    }\n                } else if (capture.name === 'assignment_statement') {\n                    const equalSign = queryMatch.captures.find(c => c.name === 'equal_sign')?.node\n                    if (equalSign) {\n                        const startIndex = equalSign.startIndex\n                        const endIndex =\n                            text.at(capture.node.endIndex) === ';'\n                                ? capture.node.endIndex + 1\n                                : capture.node.endIndex\n                        const newText = [text.slice(0, startIndex), text.slice(endIndex)]\n                        result.push({\n                            kind: 'assignment_statement',\n                            newText: newText.join(''),\n                            removedText: text.slice(startIndex, endIndex),\n                            removedRange: new vscode.Range(\n                                document.textDocument.positionAt(startIndex),\n                                document.textDocument.positionAt(endIndex)\n                            ),\n                            requestPosition: document.textDocument.positionAt(startIndex - 1),\n                        })\n                    } else {\n                        throw new Error(`Missing @equal_sign capture for node: ${capture.node.text}`)\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/jsonrpc/agent-protocol.ts:342-378","content":"\ninterface CompletionItemParams {\n    completionID: string\n}\n\ninterface AutocompleteParams {\n    uri: string\n    filePath?: string\n    position: Position\n    // Defaults to 'Automatic' for autocompletions which were not explicitly\n    // triggered.\n    triggerKind?: 'Automatic' | 'Invoke'\n    selectedCompletionInfo?: SelectedCompletionInfo\n}\n\ninterface SelectedCompletionInfo {\n    readonly range: Range\n    readonly text: string\n}\n\nexport interface ChatExportResult {\n    chatID: string\n    transcript: SerializedChatTranscript\n}\nexport interface AutocompleteResult {\n    items: AutocompleteItem[]\n\n    /** completionEvent is not deprecated because it's used by non-editor clients like evaluate-autocomplete that need access to book-keeping data to evaluate results. */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\nexport interface AutocompleteItem {\n    id: string\n    insertText: string\n    range: Range\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/evaluate-autocomplete/triggerAutocomplete.ts:33-162","content":"export async function triggerAutocomplete(parameters: AutocompleteParameters): Promise<void> {\n    const { range, client, document, modifiedContent, autocompleteKind, removedContent, position } =\n        parameters\n    client.notify('textDocument/didChange', {\n        uri: document.uri.toString(),\n        filePath: document.uri.fsPath,\n        content: modifiedContent,\n    })\n    let result: AutocompleteResult\n    try {\n        result = await client.request('autocomplete/execute', {\n            uri: document.uri.toString(),\n            filePath: document.uri.fsPath,\n            position,\n            // We don't use the \"automatic\" trigger to avoid certain code paths like\n            // synthetic latency when acceptance rate is low.\n            triggerKind: 'Invoke',\n        })\n    } catch (error) {\n        const resultError = error instanceof Error ? error.message : String(error)\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultError,\n        })\n        return\n    }\n\n    const didNotSendNetworkRequest =\n        result.items.length === 0 && result.completionEvent?.networkRequestStartedAt === null\n    if (didNotSendNetworkRequest) {\n        return\n    }\n\n    const textDocument = new AgentTextDocument(\n        ProtocolTextDocumentWithUri.from(document.uri, { content: modifiedContent })\n    )\n    for (const [index, item] of result.items.entries()) {\n        const info = result.completionEvent?.items?.[index]\n        const original = textDocument.getText(\n            new vscode.Range(\n                item.range.start.line,\n                item.range.start.character,\n                item.range.end.line,\n                item.range.end.character\n            )\n        )\n        const start = new vscode.Position(item.range.start.line, item.range.start.character)\n        const end = new vscode.Position(item.range.end.line, item.range.end.character)\n        const modifiedDocument = new AgentTextDocument(\n            ProtocolTextDocumentWithUri.from(document.uri, { content: parameters.modifiedContent })\n        )\n        const newText = [\n            modifiedDocument.getText(new vscode.Range(new vscode.Position(0, 0), start)),\n            item.insertText,\n            modifiedDocument.getText(\n                new vscode.Range(end, new vscode.Position(modifiedDocument.lineCount, 0))\n            ),\n        ].join('')\n        const testParameters: TestParameters = { ...parameters, item, newText }\n        let resultParses: boolean | undefined\n        if (parameters.originalTreeIsErrorFree && parameters.parser && parameters.options.testParse) {\n            resultParses = testParses(newText, parameters.parser)\n        }\n\n        const resultTypechecks = await testTypecheck(testParameters)\n        const patches: string[] = []\n        let hasNonInsertPatch = false\n        for (const [sx, ex, text] of calcPatch(original, item.insertText)) {\n            if (sx !== ex) {\n                hasNonInsertPatch = true\n                continue\n            }\n            patches.push(text)\n        }\n        if (hasNonInsertPatch) {\n            document.pushItem({\n                resultText: item.insertText,\n                autocompleteKind,\n                range,\n                resultTypechecks,\n                resultParses,\n                resultNonInsertPatch: true,\n                event: result.completionEvent,\n                info,\n            })\n        } else if (patches.length > 0) {\n            const text = patches.join('')\n            if (text === removedContent) {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultExact: true,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            } else {\n                document.pushItem({\n                    autocompleteKind,\n                    info,\n                    range,\n                    resultText: text,\n                    resultParses,\n                    event: result.completionEvent,\n                    resultTypechecks,\n                })\n            }\n        } else {\n            document.pushItem({\n                autocompleteKind,\n                info,\n                range,\n                resultEmpty: true,\n                event: result.completionEvent,\n                resultParses,\n            })\n        }\n    }\n    if (result.items.length === 0) {\n        const expectedEmptyMatch = removedContent === ''\n        document.pushItem({\n            autocompleteKind,\n            range,\n            resultExact: expectedEmptyMatch,\n            resultEmpty: !expectedEmptyMatch,\n        })\n    }\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/logger.ts:62-92","content":"\n    /** Wether the completion is a singleline or multiline one. */\n    multiline: boolean\n\n    /**\n     * `null` means singleline, `block` means multiline.\n     * @deprecated Use `multiline` instead.\n     */\n    multilineMode: null | 'block'\n\n    /** Describes how the autocomplete request was triggered by the user. */\n    triggerKind: TriggerKind\n\n    /** Information about what provider is used. e.g. `anthropic` or `fireworks`. */\n    providerIdentifier: string\n\n    /** Information about which model was used. e.g. `starcoder-7b` or `claude-instant`. */\n    providerModel: string\n\n    /** Language of the document being completed. */\n    languageId: string\n\n    /** If we're inside a test file */\n    testFile: boolean\n\n    /**\n     * Information about the context retrieval process that lead to this autocomplete request. Refer\n     * to the documentation of {@link ContextSummary}\n     */\n    contextSummary?: ContextSummary\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/code-actions/CodeActionProvider.ts:25-38","content":"    private registerCodeActions(config: Omit<Config, 'codebase'>): void {\n        vscode.Disposable.from(...this.actionProviders).dispose()\n        this.actionProviders = []\n\n        if (!config.codeActions) {\n            return\n        }\n\n        this.addActionProvider(TestCodeAction)\n        this.addActionProvider(DocumentCodeAction)\n        this.addActionProvider(EditCodeAction)\n        this.addActionProvider(ExplainCodeAction)\n        this.addActionProvider(FixupCodeAction)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/unstable-openai.ts:0-36","content":"import {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport { forkSignal, generatorWithTimeout, zipGenerators } from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n} from './provider'\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.test.ts:0-57","content":"import { describe, expect, it } from 'vitest'\n\nimport { countCode, matchCodeSnippets } from './code-count'\n\ndescribe('countCode', () => {\n    it('counts lines correctly', () => {\n        const code = `line1\n  line2\n  line3`\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('counts characters correctly', () => {\n        const code = 'foo bar'\n        const result = countCode(code)\n        expect(result.charCount).toBe(7)\n    })\n\n    it('handles windows line endings', () => {\n        const code = 'line1\\r\\nline2\\r\\nline3'\n        const result = countCode(code)\n        expect(result.lineCount).toBe(3)\n    })\n\n    it('handles empty string', () => {\n        const code = ''\n        const result = countCode(code)\n        expect(result.lineCount).toBe(1)\n        expect(result.charCount).toBe(0)\n    })\n})\n\ndescribe('matchCodeSnippets', () => {\n    it('returns false if either input is empty', () => {\n        expect(matchCodeSnippets('', 'foo')).toBe(false)\n        expect(matchCodeSnippets('foo', '')).toBe(false)\n    })\n\n    it('returns true if inputs match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobar'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n\n    it('returns false if inputs do not match without whitespace', () => {\n        const copied = 'foo\\nbar'\n        const changed = 'foobaz'\n        expect(matchCodeSnippets(copied, changed)).toBe(false)\n    })\n\n    it('handles trailing whitespace correctly', () => {\n        const copied = 'foo '\n        const changed = 'foo'\n        expect(matchCodeSnippets(copied, changed)).toBe(true)\n    })\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/providers/anthropic.ts:0-45","content":"import * as anthropic from '@anthropic-ai/sdk'\n\nimport {\n    type AutocompleteContextSnippet,\n    type CodeCompletionsClient,\n    type CodeCompletionsParams,\n    type Message,\n    PromptString,\n    ps,\n    tokensToChars,\n} from '@sourcegraph/cody-shared'\n\nimport {\n    CLOSING_CODE_TAG,\n    MULTILINE_STOP_SEQUENCE,\n    OPENING_CODE_TAG,\n    type PrefixComponents,\n    extractFromCodeBlock,\n    fixBadCompletionStart,\n    getHeadAndTail,\n    trimLeadingWhitespaceUntilNewline,\n} from '../text-processing'\nimport {\n    forkSignal,\n    generatorWithErrorObserver,\n    generatorWithTimeout,\n    messagesToText,\n    zipGenerators,\n} from '../utils'\n\nimport {\n    type FetchCompletionResult,\n    fetchAndProcessDynamicMultilineCompletions,\n} from './fetch-and-process-completions'\nimport {\n    MAX_RESPONSE_TOKENS,\n    getCompletionParams,\n    getLineNumberDependentCompletionParams,\n} from './get-completion-params'\nimport {\n    type CompletionProviderTracer,\n    Provider,\n    type ProviderConfig,\n    type ProviderOptions,\n    standardContextSizeHints,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/code-count.ts:0-21","content":"export function countCode(code: string): { lineCount: number; charCount: number } {\n    const lineCount = code.split(/\\r\\n|\\r|\\n/).length\n    const charCount = code.length\n    return { lineCount, charCount }\n}\n\n/**\n * Handle edge cases for code snippets where code is not pasted correctly\n * or code is multiline and the formatting is changed on paste\n */\nexport function matchCodeSnippets(copiedText: string, text: string): boolean {\n    if (!text || !copiedText) {\n        return false\n    }\n    // Code can be multiline, so we need to remove all new lines and spaces\n    // from the copied code and changed text as formatting on paste may change the spacing\n    const copiedTextNoSpace = copiedText.replaceAll(/\\s/g, '')\n    const textNoSpace = text?.replace(/\\s/g, '')\n    // check if the copied code is the same as the changed text without spaces\n    return copiedTextNoSpace === textNoSpace\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:47-82","content":"} from './suggested-autocomplete-items-cache'\nimport type { ProvideInlineCompletionItemsTracer, ProvideInlineCompletionsItemTraceData } from './tracer'\n\ninterface AutocompleteResult extends vscode.InlineCompletionList {\n    logId: CompletionLogID\n    items: AutocompleteItem[]\n    /** @deprecated */\n    completionEvent?: CompletionBookkeepingEvent\n}\n\ninterface CodyCompletionItemProviderConfig {\n    providerConfig: ProviderConfig\n    statusBar: CodyStatusBar\n    tracer?: ProvideInlineCompletionItemsTracer | null\n    triggerNotice: ((notice: { key: string }) => void) | null\n    isRunningInsideAgent?: boolean\n\n    authStatus: AuthStatus\n    isDotComUser?: boolean\n\n    createBfgRetriever?: () => BfgRetriever\n\n    // Settings\n    formatOnAccept?: boolean\n    disableInsideComments?: boolean\n\n    // Feature flags\n    completeSuggestWidgetSelection?: boolean\n}\n\ninterface CompletionRequest {\n    document: vscode.TextDocument\n    position: vscode.Position\n    context: vscode.InlineCompletionContext\n}\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/test/e2e/code-actions.test.ts:0-73","content":"import * as mockServer from '../fixtures/mock-server'\n\nimport { sidebarExplorer, sidebarSignin } from './common'\nimport { type DotcomUrlOverride, type ExpectedEvents, test as baseTest } from './helpers'\n\nconst test = baseTest.extend<DotcomUrlOverride>({ dotcomUrl: mockServer.SERVER_URL })\n\nconst ERROR_DECORATION_SELECTOR = 'div.view-overlays[role=\"presentation\"] div[class*=\"squiggly-error\"]'\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:chat-question:submitted',\n        'CodyVSCodeExtension:chat-question:executed',\n    ],\n})('code action: explain', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Explain')\n    await page.keyboard.press('Enter')\n})\n\ntest.extend<ExpectedEvents>({\n    // list of events we expect this test to log, add to this list as needed\n    expectedEvents: [\n        'CodyVSCodeExtension:command:fix:executed',\n        'CodyVSCodeExtension:fixupResponse:hasCode',\n        'CodyVSCodeExtension:fixup:applied',\n    ],\n})('code action: fix', async ({ page, sidebar }) => {\n    // Sign into Cody\n    await sidebarSignin(page, sidebar)\n\n    // Open the Explorer view from the sidebar\n    await sidebarExplorer(page).click()\n    // Open the error.ts file from the tree view\n    await page.getByRole('treeitem', { name: 'error.ts' }).locator('a').click()\n    // Wait for error.ts to fully open\n    await page.getByRole('tab', { name: 'error.ts' }).hover()\n\n    // Remove the comment that suppresses the type error\n    await page.getByText('// @ts-nocheck').click({ clickCount: 3 })\n    await page.keyboard.press('Backspace')\n\n    // Activate the code action on the erred text\n    const erredText = page.getByText('logNumber').nth(1)\n    await page.waitForSelector(ERROR_DECORATION_SELECTOR)\n    await erredText.click()\n    await erredText.hover()\n    await page.getByRole('button', { name: /Quick Fix/ }).click()\n    // Get by text takes a very long time, it's faster to type and let the quick fix item be focused\n    await page.keyboard.type('Fix')\n    await page.keyboard.press('Enter')\n})\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/configuration.ts:95-112","content":"        debugFilter: debugRegex,\n        telemetryLevel: config.get<'all' | 'off'>(CONFIG_KEY.telemetryLevel, 'all'),\n        autocomplete: config.get(CONFIG_KEY.autocompleteEnabled, true),\n        autocompleteLanguages: config.get(CONFIG_KEY.autocompleteLanguages, {\n            '*': true,\n        }),\n        chatPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.chatPreInstruction, ps``),\n        editPreInstruction: PromptString.fromConfig(config, CONFIG_KEY.editPreInstruction, ps``),\n        commandCodeLenses: config.get(CONFIG_KEY.commandCodeLenses, false),\n        autocompleteAdvancedProvider,\n        autocompleteAdvancedModel: config.get<string | null>(CONFIG_KEY.autocompleteAdvancedModel, null),\n        autocompleteCompleteSuggestWidgetSelection: config.get(\n            CONFIG_KEY.autocompleteCompleteSuggestWidgetSelection,\n            true\n        ),\n        autocompleteFormatOnAccept: config.get(CONFIG_KEY.autocompleteFormatOnAccept, true),\n        autocompleteDisableInsideComments: config.get(\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/commands/services/code-lenses.ts:0-203","content":"import * as vscode from 'vscode'\nimport { getEditor } from '../../editor/active-editor'\nimport { getDocumentSections } from '../../editor/utils/document-sections'\nimport { telemetryService } from '../../services/telemetry'\nimport { telemetryRecorder } from '../../services/telemetry-v2'\nimport { isValidTestFile } from '../utils/test-commands'\n\ninterface EditorCodeLens {\n    name: string\n    selection: vscode.Selection\n}\n\n/**\n * Adds Code lenses for triggering Command Menu\n */\nexport class CommandCodeLenses implements vscode.CodeLensProvider {\n    private isEnabled = false\n    private addTestEnabled = false\n\n    private _disposables: vscode.Disposable[] = []\n    private _onDidChangeCodeLenses: vscode.EventEmitter<void> = new vscode.EventEmitter<void>()\n    public readonly onDidChangeCodeLenses: vscode.Event<void> = this._onDidChangeCodeLenses.event\n    constructor() {\n        this.provideCodeLenses = this.provideCodeLenses.bind(this)\n        this.updateConfig()\n\n        vscode.workspace.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('cody')) {\n                this.updateConfig()\n            }\n        })\n    }\n\n    /**\n     * init\n     */\n    private init(): void {\n        if (!this.isEnabled) {\n            return\n        }\n        this._disposables.push(vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this))\n        this._disposables.push(\n            vscode.commands.registerCommand('cody.editor.codelens.click', async lens => {\n                telemetryService.log('CodyVSCodeExtension:command:codelens:clicked')\n                telemetryRecorder.recordEvent('cody.command.codelens', 'clicked')\n                const clickedLens = lens as EditorCodeLens\n                await this.onCodeLensClick(clickedLens)\n            })\n        )\n        // on change events for toggling\n        this._disposables.push(\n            vscode.window.onDidChangeVisibleTextEditors(() => this.fire()),\n            vscode.window.onDidChangeActiveTextEditor(() => this.fire())\n        )\n    }\n\n    /**\n     * Update the configurations\n     */\n    private updateConfig(): void {\n        const config = vscode.workspace.getConfiguration('cody')\n        this.isEnabled = config.get('commandCodeLenses') as boolean\n        this.addTestEnabled = config.get('internal.unstable') as boolean\n\n        if (this.isEnabled && !this._disposables.length) {\n            this.init()\n        }\n        this.fire()\n    }\n\n    /**\n     * Gets the code lenses for the specified document.\n     */\n    public async provideCodeLenses(\n        document: vscode.TextDocument,\n        token: vscode.CancellationToken\n    ): Promise<vscode.CodeLens[]> {\n        if (!this.isEnabled) {\n            return []\n        }\n\n        token.onCancellationRequested(() => [])\n        const editor = getEditor()?.active\n        if (editor?.document !== document || document.languageId === 'json') {\n            return []\n        }\n\n        // For test files, adds code lenses for each symbol\n        if (this.addTestEnabled && isValidTestFile(document.uri)) {\n            return await this.provideCodeLensesForSymbols(document.uri)\n        }\n\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        const smartRanges = await getDocumentSections(document)\n        for (const range of smartRanges) {\n            if (linesWithLenses.has(range.start)) {\n                continue\n            }\n            const selection = new vscode.Selection(range.start, range.end)\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.cody,\n                    arguments: [{ name: 'cody.menu.commands', selection }],\n                })\n            )\n\n            linesWithLenses.add(range.start.line)\n        }\n\n        return codeLenses\n    }\n\n    private async provideCodeLensesForSymbols(doc: vscode.Uri): Promise<vscode.CodeLens[]> {\n        const codeLenses = []\n        const linesWithLenses = new Set()\n\n        // Get a list of symbols from the document, filter out symbols that are not functions / classes / methods\n        const allSymbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(\n            'vscode.executeDocumentSymbolProvider',\n            doc\n        )\n        const symbols =\n            allSymbols?.filter(\n                symbol =>\n                    symbol.kind === vscode.SymbolKind.Function ||\n                    symbol.kind === vscode.SymbolKind.Class ||\n                    symbol.kind === vscode.SymbolKind.Method ||\n                    symbol.kind === vscode.SymbolKind.Constructor\n            ) ?? []\n\n        for (const symbol of symbols) {\n            const range = symbol.location.range\n            const startLine = range.start.line\n            if (linesWithLenses.has(startLine)) {\n                continue\n            }\n\n            const selection = new vscode.Selection(startLine, 0, range.end.line + 1, 0)\n\n            codeLenses.push(\n                new vscode.CodeLens(range, {\n                    ...commandLenses.test,\n                    arguments: [{ name: 'cody.command.tests-cases', selection }],\n                })\n            )\n\n            linesWithLenses.add(startLine)\n        }\n\n        return codeLenses\n    }\n\n    /**\n     * Handle the code lens click event\n     */\n    private async onCodeLensClick(lens: EditorCodeLens): Promise<void> {\n        // Update selection in active editor to the selection of the clicked code lens\n        const activeEditor = getEditor().active\n        if (activeEditor) {\n            activeEditor.selection = lens.selection\n        }\n        await vscode.commands.executeCommand(lens.name, 'codeLens')\n    }\n\n    /**\n     * Fire an event to notify VS Code that the code lenses have changed.\n     */\n    public fire(): void {\n        if (!this.isEnabled) {\n            this.dispose()\n            return\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n\n    /**\n     * Dispose the disposables\n     */\n    public dispose(): void {\n        if (this._disposables.length) {\n            for (const disposable of this._disposables) {\n                disposable.dispose()\n            }\n            this._disposables = []\n        }\n        this._onDidChangeCodeLenses.fire()\n    }\n}\n\nconst commandLenses = {\n    cody: {\n        title: '$(cody-logo) Cody',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Open command menu',\n    },\n    test: {\n        title: '$(cody-logo) Add More Tests',\n        command: 'cody.editor.codelens.click',\n        tooltip: 'Generate new test cases',\n    },\n}\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/request-manager.ts:0-28","content":"import { partition } from 'lodash'\nimport { LRUCache } from 'lru-cache'\nimport type * as vscode from 'vscode'\n\nimport {\n    type AutocompleteContextSnippet,\n    type DocumentContext,\n    FeatureFlag,\n    isDefined,\n    wrapInActiveSpan,\n} from '@sourcegraph/cody-shared'\n\nimport { addAutocompleteDebugEvent } from '../services/open-telemetry/debug-utils'\n\nimport { logDebug } from '../log'\nimport { completionProviderConfig } from './completion-provider-config'\nimport {\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n} from './get-inline-completions'\nimport { type CompletionLogID, logCompletionBookkeepingEvent } from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport { STOP_REASON_HOT_STREAK } from './providers/hot-streak'\nimport type { CompletionProviderTracer, Provider } from './providers/provider'\nimport { reuseLastCandidate } from './reuse-last-candidate'\nimport { lines, removeIndentation } from './text-processing'\nimport {\n    type InlineCompletionItemWithAnalytics,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/services/utils/codeblock-action-tracker.ts:77-94","content":"export async function handleCodeFromInsertAtCursor(text: string): Promise<void> {\n    const editor = getEditor()\n    const activeEditor = editor.active\n    const selectionRange = activeEditor?.selection\n    if (!activeEditor || !selectionRange) {\n        throw new Error('No editor or selection found to insert text')\n    }\n\n    const edit = new vscode.WorkspaceEdit()\n    // trimEnd() to remove new line added by Cody\n    edit.insert(activeEditor.document.uri, selectionRange.start, `${text}\\n`)\n    await vscode.workspace.applyEdit(edit)\n\n    // Log insert event\n    const op = 'insert'\n    const eventName = `${op}Button`\n    setLastStoredCode(text, eventName)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/package.json:1033-1050","content":"          \"default\": null,\n          \"enum\": [null, \"starcoder-16b\", \"starcoder-7b\", \"llama-code-13b\"],\n          \"markdownDescription\": \"Overwrite the  model used for code autocompletion inference. This is only supported with the `fireworks` provider\"\n        },\n        \"cody.autocomplete.completeSuggestWidgetSelection\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"markdownDescription\": \"Autocomplete based on the currently selection in the suggest widget. Requires the VS Code user setting `editor.inlineSuggest.suppressSuggestions` set to true and will change it to true in user settings if it is not true.\"\n        },\n        \"cody.autocomplete.formatOnAccept\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"markdownDescription\": \"Format completions on accept using [the default document formatter](https://code.visualstudio.com/docs/editor/codebasics#_formatting).\"\n        },\n        \"cody.autocomplete.disableInsideComments\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/agent/src/cli/scip-codegen/scip.ts:2010-2012","content":"        set code(value: string) {\n            pb_1.Message.setField(this, 2, value)\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/walkthroughs/autocomplete.md:0-11","content":"## Code Autocomplete\n\n<img src=\"https://storage.googleapis.com/sourcegraph-assets/blog/vs-code-onboarding-walkthrough-dec-2023-cody-autocomplete-tsx.gif\">\n\nStart writing code and Cody will complete the line (or the entire function) for you. Hit tab to accept the suggestion.\n\n**✨ Pro-tips for using Cody autocomplete**\n<br>• Autocomplete uses the surrounding code and context to inform the suggestions, so if you need to guide it you can add a comment above the line you're editing.\n<br>• You can hover over the grey suggestion to see a toolbar of alternative suggestions, as well as other options such as accepting a single word at a time.\n<br>• You can use the \"Trigger Autocomplete at Cursor\" command to trigger a code suggestion at any time, using the default keyboard shortcut of `Option` `\\` on macOS and `Alt` `\\` on Windows & Linux.\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/suggested-autocomplete-items-cache.ts:171-194","content":"export function updateInsertRangeForVSCode(items: AutocompleteItem[]): AutocompleteItem[] {\n    return items.map(item => {\n        const {\n            insertText,\n            range,\n            requestParams: { position, document },\n        } = item\n\n        const currentLine = document.lineAt(position)\n        const currentLinePrefix = document.getText(currentLine.range.with({ end: position }))\n\n        const start = currentLine.range.start\n        // If the completion does not have a range set it will always exclude the same line suffix,\n        // so it has to overwrite the current same line suffix and reach to the end of the line.\n        const end = range?.end || currentLine.range.end\n\n        const vscodeInsertRange = new vscode.Range(start, end)\n\n        item.range = vscodeInsertRange\n        item.insertText = currentLinePrefix + (insertText as string)\n\n        return item\n    })\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/src/completions/inline-completion-item-provider.ts:24-47","content":"import { formatCompletion } from './format-completion'\nimport { getCurrentDocContext } from './get-current-doc-context'\nimport {\n    type InlineCompletionsParams,\n    InlineCompletionsResultSource,\n    type LastInlineCompletionCandidate,\n    TriggerKind,\n    getInlineCompletions,\n} from './get-inline-completions'\nimport { isCompletionVisible } from './is-completion-visible'\nimport type { CompletionBookkeepingEvent, CompletionItemID, CompletionLogID } from './logger'\nimport * as CompletionLogger from './logger'\nimport { isLocalCompletionsProvider } from './providers/experimental-ollama'\nimport type { ProviderConfig } from './providers/provider'\nimport { RequestManager, type RequestParams } from './request-manager'\nimport { getRequestParamsFromLastCandidate } from './reuse-last-candidate'\nimport { SmartThrottleService } from './smart-throttle'\nimport {\n    type AutocompleteInlineAcceptedCommandArgs,\n    type AutocompleteItem,\n    analyticsItemToAutocompleteItem,\n    suggestedAutocompleteItemsCache,\n    updateInsertRangeForVSCode,\n"},{"source":"search","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/vscode/CHANGELOG.md:998-1015","content":"### Added\n\n- Add a UI indicator when you're not signed in. [pull/970](https://github.com/sourcegraph/cody/pull/970)\n- Added a completion statistics summary to the autocomplete trace view. [pull/973](https://github.com/sourcegraph/cody/pull/973)\n- Add experimental option `claude-instant-infill` to the `cody.autocomplete.advanced.model` config option that enables users using the Claude Instant model to get suggestions with context awareness (infill). [pull/974](https://github.com/sourcegraph/cody/pull/974)\n- New `cody.chat.preInstruction` configuration option for adding custom message at the start of all chat messages sent to Cody. Extension reload required. [pull/963](https://github.com/sourcegraph/cody/pull/963)\n- Add a simplified sign-in. 50% of people will see these new sign-in buttons. [pull/1036](https://github.com/sourcegraph/cody/pull/1036)\n- Now removes completions from cache when the initial suggestion prefix is deleted by users after a suggestion was displayed. This avoids unhelpful/stale suggestions from persisting. [pull/1105](https://github.com/sourcegraph/cody/pull/1105)\n- VScode can now share a dotcom access token with future versions of Cody App. [pull/1090](https://github.com/sourcegraph/cody/pull/1090)\n\n### Fixed\n\n- Fix a potential race condition for autocomplete requests that happen when a completion is stored as the last shown candidate when it will not be shown. [pull/1059](https://github.com/sourcegraph/cody/pull/1059)\n- Use `insert` instead of `replace` for `Insert at Cursor` button for inserting code to current cursor position. [pull/1118](https://github.com/sourcegraph/cody/pull/1118)\n- Autocomplete: Fix support for working with CRLF line endings. [pull/1124](https://github.com/sourcegraph/cody/pull/1124)\n- Fix issue that caused the custom commands menu to unable to execute commands. [pull/1123](https://github.com/sourcegraph/cody/pull/1123)\n\n"},{"source":"embeddings","file":"/Users/jan/repos/cody-leaderboard/input/chat-context/cody_test/lib/shared/src/configuration.ts:66-98","content":"\n    /**\n     * Experimental autocomplete\n     */\n    autocompleteExperimentalHotStreak?: boolean\n    autocompleteExperimentalGraphContext: 'bfg' | 'bfg-mixed' | null\n    autocompleteExperimentalOllamaOptions: OllamaOptions\n    autocompleteExperimentalFireworksOptions?: FireworksOptions\n    autocompleteExperimentalSmartThrottle?: boolean\n\n    /**\n     * Hidden settings\n     */\n    isRunningInsideAgent?: boolean\n    agentIDE?: 'VSCode' | 'JetBrains' | 'Neovim' | 'Emacs'\n    autocompleteTimeouts: AutocompleteTimeouts\n\n    testingLocalEmbeddingsModel: string | undefined\n    testingLocalEmbeddingsEndpoint: string | undefined\n    testingLocalEmbeddingsIndexLibraryPath: string | undefined\n}\n\nexport interface AutocompleteTimeouts {\n    multiline?: number\n    singleline?: number\n}\n\nexport interface ConfigurationWithAccessToken extends Configuration {\n    serverEndpoint: string\n    /** The access token, which is stored in the secret storage (not configuration). */\n    accessToken: string | null\n}\n"}]

 class: Find logic
