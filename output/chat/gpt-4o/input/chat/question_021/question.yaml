 question: how do goroutines work?
# CHAT
# CHAT_QUESTION how do goroutines work?

# CHAT_REPLY Goroutines are a fundamental feature of the Go programming language that allow you to run functions concurrently. They are lightweight threads managed by the Go runtime. Here's a basic overview of how goroutines work:
# CHAT_REPLY 
# CHAT_REPLY 1. **Creating a Goroutine**: You can create a goroutine by prefixing a function call with the `go` keyword. This will run the function concurrently with the calling function.
# CHAT_REPLY 
# CHAT_REPLY 2. **Concurrency**: Goroutines run in the same address space, so access to shared memory must be synchronized. Go provides various synchronization primitives like channels, mutexes, and wait groups to manage this.
# CHAT_REPLY 
# CHAT_REPLY 3. **Scheduling**: The Go runtime scheduler manages the execution of goroutines. It multiplexes thousands of goroutines onto a small number of OS threads.
# CHAT_REPLY 
# CHAT_REPLY 4. **Communication**: Goroutines can communicate with each other using channels, which provide a way to send and receive values between goroutines safely.
# CHAT_REPLY 
# CHAT_REPLY Here's an example to illustrate how goroutines work:
# CHAT_REPLY 
# CHAT_REPLY ```go:main.go
# CHAT_REPLY package main
# CHAT_REPLY 
# CHAT_REPLY import (
# CHAT_REPLY 	"fmt"
# CHAT_REPLY 	"time"
# CHAT_REPLY )
# CHAT_REPLY 
# CHAT_REPLY func printNumbers() {
# CHAT_REPLY 	for i := 1; i <= 5; i++ {
# CHAT_REPLY 		fmt.Println(i)
# CHAT_REPLY 		time.Sleep(100 * time.Millisecond)
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func printLetters() {
# CHAT_REPLY 	for i := 'a'; i <= 'e'; i++ {
# CHAT_REPLY 		fmt.Printf("%c\n", i)
# CHAT_REPLY 		time.Sleep(150 * time.Millisecond)
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func main() {
# CHAT_REPLY 	go printNumbers() // Run printNumbers concurrently
# CHAT_REPLY 	go printLetters() // Run printLetters concurrently
# CHAT_REPLY 
# CHAT_REPLY 	// Sleep to allow goroutines to finish
# CHAT_REPLY 	time.Sleep(1 * time.Second)
# CHAT_REPLY 	fmt.Println("Done")
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY 
# CHAT_REPLY In this example:
# CHAT_REPLY 
# CHAT_REPLY - The `printNumbers` and `printLetters` functions are run as goroutines.
# CHAT_REPLY - The `main` function sleeps for 1 second to allow the goroutines to complete their execution. In a real-world application, you would use synchronization primitives like `sync.WaitGroup` instead of `time.Sleep`.
# CHAT_REPLY 
# CHAT_REPLY ### Synchronization Example
# CHAT_REPLY 
# CHAT_REPLY Here's an example using `sync.WaitGroup` to wait for goroutines to finish:
# CHAT_REPLY 
# CHAT_REPLY ```go:main.go
# CHAT_REPLY package main
# CHAT_REPLY 
# CHAT_REPLY import (
# CHAT_REPLY 	"fmt"
# CHAT_REPLY 	"sync"
# CHAT_REPLY 	"time"
# CHAT_REPLY )
# CHAT_REPLY 
# CHAT_REPLY func printNumbers(wg *sync.WaitGroup) {
# CHAT_REPLY 	defer wg.Done()
# CHAT_REPLY 	for i := 1; i <= 5; i++ {
# CHAT_REPLY 		fmt.Println(i)
# CHAT_REPLY 		time.Sleep(100 * time.Millisecond)
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func printLetters(wg *sync.WaitGroup) {
# CHAT_REPLY 	defer wg.Done()
# CHAT_REPLY 	for i := 'a'; i <= 'e'; i++ {
# CHAT_REPLY 		fmt.Printf("%c\n", i)
# CHAT_REPLY 		time.Sleep(150 * time.Millisecond)
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func main() {
# CHAT_REPLY 	var wg sync.WaitGroup
# CHAT_REPLY 
# CHAT_REPLY 	wg.Add(2) // We have two goroutines to wait for
# CHAT_REPLY 
# CHAT_REPLY 	go printNumbers(&wg)
# CHAT_REPLY 	go printLetters(&wg)
# CHAT_REPLY 
# CHAT_REPLY 	wg.Wait() // Wait for both goroutines to finish
# CHAT_REPLY 	fmt.Println("Done")
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY 
# CHAT_REPLY In this example, we use a `sync.WaitGroup` to wait for both goroutines to complete before printing "Done". This is a more robust way to handle synchronization compared to using `time.Sleep`.

# CONTEXT_ITEMS []

 class: general coding
