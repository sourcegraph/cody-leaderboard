 question: Mind taking a second look at the file? @limit.go
# CHAT
# CHAT_QUESTION Mind taking a second look at the file? @limit.go

# CHAT_REPLY Sure, let's take a closer look at the `limit.go` file. Here's a breakdown of its contents:
# CHAT_REPLY 
# CHAT_REPLY ### Package Declaration
# CHAT_REPLY ```go
# CHAT_REPLY package zoekt
# CHAT_REPLY ```
# CHAT_REPLY The file is part of the `zoekt` package.
# CHAT_REPLY 
# CHAT_REPLY ### Imports
# CHAT_REPLY ```go
# CHAT_REPLY import "log"
# CHAT_REPLY ```
# CHAT_REPLY The file imports the `log` package for logging purposes.
# CHAT_REPLY 
# CHAT_REPLY ### Function: SortAndTruncateFiles
# CHAT_REPLY ```go
# CHAT_REPLY // SortAndTruncateFiles is a convenience around SortFiles and
# CHAT_REPLY // DisplayTruncator. Given an aggregated files it will sort and then truncate
# CHAT_REPLY // based on the search options.
# CHAT_REPLY func SortAndTruncateFiles(files []FileMatch, opts *SearchOptions) []FileMatch {
# CHAT_REPLY 	SortFiles(files)
# CHAT_REPLY 	truncator, _ := NewDisplayTruncator(opts)
# CHAT_REPLY 	files, _ = truncator(files)
# CHAT_REPLY 	return files
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY This function sorts and truncates a list of `FileMatch` objects based on the provided `SearchOptions`.
# CHAT_REPLY 
# CHAT_REPLY ### Type: DisplayTruncator
# CHAT_REPLY ```go
# CHAT_REPLY // DisplayTruncator is a stateful function which enforces Document and Match
# CHAT_REPLY // display limits by truncating and mutating before. hasMore is true until the
# CHAT_REPLY // limits are exhausted. Once hasMore is false each subsequent call will
# CHAT_REPLY // return an empty after and hasMore false.
# CHAT_REPLY type DisplayTruncator func(before []FileMatch) (after []FileMatch, hasMore bool)
# CHAT_REPLY ```
# CHAT_REPLY `DisplayTruncator` is a function type that enforces document and match display limits.
# CHAT_REPLY 
# CHAT_REPLY ### Function: NewDisplayTruncator
# CHAT_REPLY ```go
# CHAT_REPLY // NewDisplayTruncator will return a DisplayTruncator which enforces the limits in
# CHAT_REPLY // opts. If there are no limits to enforce, hasLimits is false and there is no
# CHAT_REPLY // need to call DisplayTruncator.
# CHAT_REPLY func NewDisplayTruncator(opts *SearchOptions) (_ DisplayTruncator, hasLimits bool) {
# CHAT_REPLY 	docLimit := opts.MaxDocDisplayCount
# CHAT_REPLY 	docLimited := docLimit > 0
# CHAT_REPLY 
# CHAT_REPLY 	matchLimit := opts.MaxMatchDisplayCount
# CHAT_REPLY 	matchLimited := matchLimit > 0
# CHAT_REPLY 
# CHAT_REPLY 	done := false
# CHAT_REPLY 
# CHAT_REPLY 	if !docLimited && !matchLimited {
# CHAT_REPLY 		return func(fm []FileMatch) ([]FileMatch, bool) {
# CHAT_REPLY 			return fm, true
# CHAT_REPLY 		}, false
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return func(fm []FileMatch) ([]FileMatch, bool) {
# CHAT_REPLY 		if done {
# CHAT_REPLY 			return nil, false
# CHAT_REPLY 		}
# CHAT_REPLY 
# CHAT_REPLY 		if docLimited {
# CHAT_REPLY 			if len(fm) >= docLimit {
# CHAT_REPLY 				done = true
# CHAT_REPLY 				fm = fm[:docLimit]
# CHAT_REPLY 			}
# CHAT_REPLY 			docLimit -= len(fm)
# CHAT_REPLY 		}
# CHAT_REPLY 
# CHAT_REPLY 		if matchLimited {
# CHAT_REPLY 			fm, matchLimit = limitMatches(fm, matchLimit, opts.ChunkMatches)
# CHAT_REPLY 			if matchLimit <= 0 {
# CHAT_REPLY 				done = true
# CHAT_REPLY 			}
# CHAT_REPLY 		}
# CHAT_REPLY 
# CHAT_REPLY 		return fm, !done
# CHAT_REPLY 	}, true
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY This function returns a `DisplayTruncator` that enforces the limits specified in `SearchOptions`. If there are no limits, it returns a no-op truncator.
# CHAT_REPLY 
# CHAT_REPLY ### Function: limitMatches
# CHAT_REPLY ```go
# CHAT_REPLY func limitMatches(files []FileMatch, limit int, chunkMatches bool) ([]FileMatch, int) {
# CHAT_REPLY 	var limiter func(file *FileMatch, limit int) int
# CHAT_REPLY 	if chunkMatches {
# CHAT_REPLY 		limiter = limitChunkMatches
# CHAT_REPLY 	} else {
# CHAT_REPLY 		limiter = limitLineMatches
# CHAT_REPLY 	}
# CHAT_REPLY 	for i := range files {
# CHAT_REPLY 		limit = limiter(&files[i], limit)
# CHAT_REPLY 		if limit <= 0 {
# CHAT_REPLY 			return files[:i+1], 0
# CHAT_REPLY 		}
# CHAT_REPLY 	}
# CHAT_REPLY 	return files, limit
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY This function limits the number of matches in each `FileMatch` based on the provided limit and whether chunk matches are used.
# CHAT_REPLY 
# CHAT_REPLY ### Function: limitChunkMatches
# CHAT_REPLY ```go
# CHAT_REPLY // Limit the number of ChunkMatches in the given FileMatch, returning the
# CHAT_REPLY // remaining limit, if any.
# CHAT_REPLY func limitChunkMatches(file *FileMatch, limit int) int {
# CHAT_REPLY 	for i := range file.ChunkMatches {
# CHAT_REPLY 		cm := &file.ChunkMatches[i]
# CHAT_REPLY 		if len(cm.Ranges) > limit {
# CHAT_REPLY 			// We potentially need to effect the limit upon 3 different fields:
# CHAT_REPLY 			// Ranges, SymbolInfo, and Content.
# CHAT_REPLY 
# CHAT_REPLY 			// Content is the most complicated: we need to remove the last N
# CHAT_REPLY 			// lines from it, where N is the difference between the line number
# CHAT_REPLY 			// of the end of the old last Range and that of the new last Range.
# CHAT_REPLY 			// This calculation is correct in the presence of both context lines
# CHAT_REPLY 			// and multiline Ranges, taking into account that Content never has
# CHAT_REPLY 			// a trailing newline.
# CHAT_REPLY 			n := cm.Ranges[len(cm.Ranges)-1].End.LineNumber - cm.Ranges[limit-1].End.LineNumber
# CHAT_REPLY 			if n > 0 {
# CHAT_REPLY 				for b := len(cm.Content) - 1; b >= 0; b-- {
# CHAT_REPLY 					if cm.Content[b] == '/n' {
# CHAT_REPLY 						n -= 1
# CHAT_REPLY 					}
# CHAT_REPLY 					if n == 0 {
# CHAT_REPLY 						cm.Content = cm.Content[:b]
# CHAT_REPLY 						break
# CHAT_REPLY 					}
# CHAT_REPLY 				}
# CHAT_REPLY 				if n > 0 {
# CHAT_REPLY 					// Should be impossible.
# CHAT_REPLY 					log.Panicf("Failed to find enough newlines when truncating Content, %d left over, %d ranges", n, len(cm.Ranges))
# CHAT_REPLY 				}
# CHAT_REPLY 			}
# CHAT_REPLY 
# CHAT_REPLY 			cm.Ranges = cm.Ranges[:limit]
# CHAT_REPLY 			if cm.SymbolInfo != nil {
# CHAT_REPLY 				// When non-nil, SymbolInfo is specified to have the same length
# CHAT_REPLY 				// as Ranges.
# CHAT_REPLY 				cm.SymbolInfo = cm.SymbolInfo[:limit]
# CHAT_REPLY 			}
# CHAT_REPLY 		}
# CHAT_REPLY 		if len(cm.Ranges) == limit {
# CHAT_REPLY 			file.ChunkMatches = file.ChunkMatches[:i+1]
# CHAT_REPLY 			limit = 0
# CHAT_REPLY 			break
# CHAT_REPLY 		}
# CHAT_REPLY 		limit -= len(cm.Ranges)
# CHAT_REPLY 	}
# CHAT_REPLY 	return limit
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY This function limits the number of `ChunkMatches` in a `FileMatch` and adjusts the content accordingly.
# CHAT_REPLY 
# CHAT_REPLY ### Function: limitLineMatches
# CHAT_REPLY ```go
# CHAT_REPLY // Limit the number of LineMatches in the given FileMatch, returning the
# CHAT_REPLY // remaining limit, if any.
# CHAT_REPLY func limitLineMatches(file *FileMatch, limit int) int {
# CHAT_REPLY 	for i := range file.LineMatches {
# CHAT_REPLY 		lm := &file.LineMatches[i]
# CHAT_REPLY 		if len(lm.LineFragments) > limit {
# CHAT_REPLY 			lm.LineFragments = lm.LineFragments[:limit]
# CHAT_REPLY 		}
# CHAT_REPLY 		if len(lm.LineFragments) == limit {
# CHAT_REPLY 			file.LineMatches = file.LineMatches[:i+1]
# CHAT_REPLY 			limit = 0
# CHAT_REPLY 			break
# CHAT_REPLY 		}
# CHAT_REPLY 		limit -= len(lm.LineFragments)
# CHAT_REPLY 	}
# CHAT_REPLY 	return limit
# CHAT_REPLY }
# CHAT_REPLY ```
# CHAT_REPLY This function limits the number of `LineMatches` in a `FileMatch`.
# CHAT_REPLY 
# CHAT_REPLY ### Summary
# CHAT_REPLY The `limit.go` file provides functionality to sort and truncate search results based on document and match limits specified in `SearchOptions`. It includes functions to handle both chunk matches and line matches, ensuring that the results do not exceed the specified limits.

 files:
   - ../mocked/codebase_context/README.md
   - ../mocked/codebase_context/limit.go
   - ../mocked/codebase_context/eval.go
   - ../mocked/codebase_context/vscode/src/external-services.ts
 
