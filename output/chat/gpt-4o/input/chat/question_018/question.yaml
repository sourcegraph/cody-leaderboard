 question: See zoekt repo find location of tensor function
# CHAT
# CHAT_QUESTION See zoekt repo find location of tensor function

# CHAT_REPLY To find the location of the `tensor` function in the `zoekt` repository, you can use the following steps:
# CHAT_REPLY 
# CHAT_REPLY 1. **Clone the Repository**: If you haven't already, clone the repository to your local machine.
# CHAT_REPLY     ```sh
# CHAT_REPLY     git clone https://github.com/sourcegraph/zoekt.git
# CHAT_REPLY     cd zoekt
# CHAT_REPLY     ```
# CHAT_REPLY 
# CHAT_REPLY 2. **Search for the Function**: Use a tool like `grep` to search for the definition of the `tensor` function within the repository.
# CHAT_REPLY     ```sh
# CHAT_REPLY     grep -r "func tensor" .
# CHAT_REPLY     ```
# CHAT_REPLY 
# CHAT_REPLY 3. **Using Sourcegraph**: If you have Sourcegraph set up, you can use it to search for the function directly in the web interface.
# CHAT_REPLY 
# CHAT_REPLY Here's an example of how you might use `grep` to find the function:
# CHAT_REPLY 
# CHAT_REPLY ```sh
# CHAT_REPLY $ grep -r "func tensor" .
# CHAT_REPLY ```
# CHAT_REPLY 
# CHAT_REPLY This command will recursively search through the repository files and print out the locations where the `tensor` function is defined.
# CHAT_REPLY 
# CHAT_REPLY If you have Sourcegraph set up, you can also use its powerful search capabilities to find the function. Simply go to your Sourcegraph instance, navigate to the zoekt repository, and use the search bar to look for `func tensor`.
# CHAT_REPLY 
# CHAT_REPLY If you need further assistance or a more specific search, please let me know!

# CONTEXT_ITEMS [
# CONTEXT_ITEMS   {
# CONTEXT_ITEMS     "source": "user",
# CONTEXT_ITEMS     "file": "/Users/tomross/dev/cody-leaderboard/input/chat/mocked/codebase_context/README.md:undefined-undefined",
# CONTEXT_ITEMS     "content": "\n    \"Zoekt, en gij zult spinazie eten\" - Jan Eertink\n\n    (\"seek, and ye shall eat spinach\" - My primary school teacher)\n\nThis is a fast text search engine, intended for use with source\ncode. (Pronunciation: roughly as you would pronounce \"zooked\" in English)\n\n**Note:** This is a [Sourcegraph](https://github.com/sourcegraph/zoekt) fork\nof [github.com/google/zoekt](https://github.com/google/zoekt). It is now the\nmain maintained source of Zoekt.\n\n# INSTRUCTIONS\n\n## Downloading\n\n    go get github.com/sourcegraph/zoekt/\n\n## Indexing\n\n### Directory\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-index\n    $GOPATH/bin/zoekt-index .\n\n### Git repository\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-git-index\n    $GOPATH/bin/zoekt-git-index -branches master,stable-1.4 -prefix origin/ .\n\n### Repo repositories\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-{repo-index,mirror-gitiles}\n    zoekt-mirror-gitiles -dest ~/repos/ https://gfiber.googlesource.com\n    zoekt-repo-index \\\n        -name gfiber \\\n        -base_url https://gfiber.googlesource.com/ \\\n        -manifest_repo ~/repos/gfiber.googlesource.com/manifests.git \\\n        -repo_cache ~/repos \\\n        -manifest_rev_prefix=refs/heads/ --rev_prefix= \\\n        master:default_unrestricted.xml\n\n## Searching\n\n### Web interface\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-webserver\n    $GOPATH/bin/zoekt-webserver -listen :6070\n\n### JSON API\n\nYou can retrieve search results as JSON by sending a GET request to zoekt-webserver.\n\n    curl --get \\\n        --url \"http://localhost:6070/search\" \\\n        --data-urlencode \"q=ngram f:READ\" \\\n        --data-urlencode \"num=50\" \\\n        --data-urlencode \"format=json\"\n\nThe response data is a JSON object. You can refer to [web.ApiSearchResult](https://sourcegraph.com/github.com/sourcegraph/zoekt@6b1df4f8a3d7b34f13ba0cafd8e1a9b3fc728cf0/-/blob/web/api.go?L23:6&subtree=true) to learn about the structure of the object.\n\n### CLI\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt\n    $GOPATH/bin/zoekt 'ngram f:READ'\n\n## Installation\nA more organized installation on a Linux server should use a systemd unit file,\neg.\n\n    [Unit]\n    Description=zoekt webserver\n\n    [Service]\n    ExecStart=/zoekt/bin/zoekt-webserver -index /zoekt/index -listen :443  --ssl_cert /zoekt/etc/cert.pem   --ssl_key /zoekt/etc/key.pem\n    Restart=always\n\n    [Install]\n    WantedBy=default.target\n\n\n# SEARCH SERVICE\n\nZoekt comes with a small service management program:\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-indexserver\n\n    cat << EOF > config.json\n    [{\"GithubUser\": \"username\"},\n     {\"GithubOrg\": \"org\"},\n     {\"GitilesURL\": \"https://gerrit.googlesource.com\", \"Name\": \"zoekt\" }\n    ]\n    EOF\n\n    $GOPATH/bin/zoekt-indexserver -mirror_config config.json\n\nThis will mirror all repos under 'github.com/username', 'github.com/org', as\nwell as the 'zoekt' repository. It will index the repositories.\n\nIt takes care of fetching and indexing new data and cleaning up logfiles.\n\nThe webserver can be started from a standard service management framework, such\nas systemd.\n\n\n# SYMBOL SEARCH\n\nIt is recommended to install [Universal\nctags](https://github.com/universal-ctags/ctags) to improve\nranking. See [here](doc/ctags.md) for more information.\n\n\n# ACKNOWLEDGEMENTS\n\nThanks to Han-Wen Nienhuys for creating Zoekt. Thanks to Alexander Neubeck for\ncoming up with this idea, and helping Han-Wen Nienhuys flesh it out.\n\n\n# FORK DETAILS\n\nOriginally this fork contained some changes that do not make sense to upstream\nand or have not yet been upstreamed. However, this is now the defacto source\nfor Zoekt. This section will remain for historical reasons and contains\noutdated information. It can be removed once the dust settles on moving from\ngoogle/zoekt to sourcegraph/zoekt. Differences:\n\n- [zoekt-sourcegraph-indexserver](cmd/zoekt-sourcegraph-indexserver/main.go)\n  is a Sourcegraph specific command which indexes all enabled repositories on\n  Sourcegraph, as well as keeping the indexes up to date.\n- We have exposed the API via\n  [keegancsmith/rpc](https://github.com/keegancsmith/rpc) (a fork of `net/rpc`\n  which supports cancellation).\n- Query primitive `BranchesRepos` to efficiently specify a set of repositories to\n  search.\n- Allow empty shard directories on startup. Needed when starting a fresh\n  instance which hasn't indexed anything yet.\n- We can return symbol/ctag data in results. Additionally we can run symbol regex queries.\n- We search shards in order of repo name and ignore shard ranking.\n- Other minor changes.\n\nAssuming you have the gerrit upstream configured, a useful way to see what we\nchanged is:\n\n``` shellsession\n$ git diff gerrit/master -- ':(exclude)vendor/' ':(exclude)Gopkg*'\n```\n\n# DISCLAIMER\n\nThis is not an official Google product\n"
# CONTEXT_ITEMS   },
# CONTEXT_ITEMS   {
# CONTEXT_ITEMS     "source": "user",
# CONTEXT_ITEMS     "file": "/Users/tomross/dev/cody-leaderboard/input/chat/mocked/codebase_context/limit.go:undefined-undefined",
# CONTEXT_ITEMS     "content": "package zoekt\n\nimport \"log\"\n\n// SortAndTruncateFiles is a convenience around SortFiles and\n// DisplayTruncator. Given an aggregated files it will sort and then truncate\n// based on the search options.\nfunc SortAndTruncateFiles(files []FileMatch, opts *SearchOptions) []FileMatch {\n\tSortFiles(files)\n\ttruncator, _ := NewDisplayTruncator(opts)\n\tfiles, _ = truncator(files)\n\treturn files\n}\n\n// DisplayTruncator is a stateful function which enforces Document and Match\n// display limits by truncating and mutating before. hasMore is true until the\n// limits are exhausted. Once hasMore is false each subsequent call will\n// return an empty after and hasMore false.\ntype DisplayTruncator func(before []FileMatch) (after []FileMatch, hasMore bool)\n\n// NewDisplayTruncator will return a DisplayTruncator which enforces the limits in\n// opts. If there are no limits to enforce, hasLimits is false and there is no\n// need to call DisplayTruncator.\nfunc NewDisplayTruncator(opts *SearchOptions) (_ DisplayTruncator, hasLimits bool) {\n\tdocLimit := opts.MaxDocDisplayCount\n\tdocLimited := docLimit > 0\n\n\tmatchLimit := opts.MaxMatchDisplayCount\n\tmatchLimited := matchLimit > 0\n\n\tdone := false\n\n\tif !docLimited && !matchLimited {\n\t\treturn func(fm []FileMatch) ([]FileMatch, bool) {\n\t\t\treturn fm, true\n\t\t}, false\n\t}\n\n\treturn func(fm []FileMatch) ([]FileMatch, bool) {\n\t\tif done {\n\t\t\treturn nil, false\n\t\t}\n\n\t\tif docLimited {\n\t\t\tif len(fm) >= docLimit {\n\t\t\t\tdone = true\n\t\t\t\tfm = fm[:docLimit]\n\t\t\t}\n\t\t\tdocLimit -= len(fm)\n\t\t}\n\n\t\tif matchLimited {\n\t\t\tfm, matchLimit = limitMatches(fm, matchLimit, opts.ChunkMatches)\n\t\t\tif matchLimit <= 0 {\n\t\t\t\tdone = true\n\t\t\t}\n\t\t}\n\n\t\treturn fm, !done\n\t}, true\n}\n\nfunc limitMatches(files []FileMatch, limit int, chunkMatches bool) ([]FileMatch, int) {\n\tvar limiter func(file *FileMatch, limit int) int\n\tif chunkMatches {\n\t\tlimiter = limitChunkMatches\n\t} else {\n\t\tlimiter = limitLineMatches\n\t}\n\tfor i := range files {\n\t\tlimit = limiter(&files[i], limit)\n\t\tif limit <= 0 {\n\t\t\treturn files[:i+1], 0\n\t\t}\n\t}\n\treturn files, limit\n}\n\n// Limit the number of ChunkMatches in the given FileMatch, returning the\n// remaining limit, if any.\nfunc limitChunkMatches(file *FileMatch, limit int) int {\n\tfor i := range file.ChunkMatches {\n\t\tcm := &file.ChunkMatches[i]\n\t\tif len(cm.Ranges) > limit {\n\t\t\t// We potentially need to effect the limit upon 3 different fields:\n\t\t\t// Ranges, SymbolInfo, and Content.\n\n\t\t\t// Content is the most complicated: we need to remove the last N\n\t\t\t// lines from it, where N is the difference between the line number\n\t\t\t// of the end of the old last Range and that of the new last Range.\n\t\t\t// This calculation is correct in the presence of both context lines\n\t\t\t// and multiline Ranges, taking into account that Content never has\n\t\t\t// a trailing newline.\n\t\t\tn := cm.Ranges[len(cm.Ranges)-1].End.LineNumber - cm.Ranges[limit-1].End.LineNumber\n\t\t\tif n > 0 {\n\t\t\t\tfor b := len(cm.Content) - 1; b >= 0; b-- {\n\t\t\t\t\tif cm.Content[b] == '\\n' {\n\t\t\t\t\t\tn -= 1\n\t\t\t\t\t}\n\t\t\t\t\tif n == 0 {\n\t\t\t\t\t\tcm.Content = cm.Content[:b]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\t// Should be impossible.\n\t\t\t\t\tlog.Panicf(\"Failed to find enough newlines when truncating Content, %d left over, %d ranges\", n, len(cm.Ranges))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcm.Ranges = cm.Ranges[:limit]\n\t\t\tif cm.SymbolInfo != nil {\n\t\t\t\t// When non-nil, SymbolInfo is specified to have the same length\n\t\t\t\t// as Ranges.\n\t\t\t\tcm.SymbolInfo = cm.SymbolInfo[:limit]\n\t\t\t}\n\t\t}\n\t\tif len(cm.Ranges) == limit {\n\t\t\tfile.ChunkMatches = file.ChunkMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(cm.Ranges)\n\t}\n\treturn limit\n}\n\n// Limit the number of LineMatches in the given FileMatch, returning the\n// remaining limit, if any.\nfunc limitLineMatches(file *FileMatch, limit int) int {\n\tfor i := range file.LineMatches {\n\t\tlm := &file.LineMatches[i]\n\t\tif len(lm.LineFragments) > limit {\n\t\t\tlm.LineFragments = lm.LineFragments[:limit]\n\t\t}\n\t\tif len(lm.LineFragments) == limit {\n\t\t\tfile.LineMatches = file.LineMatches[:i+1]\n\t\t\tlimit = 0\n\t\t\tbreak\n\t\t}\n\t\tlimit -= len(lm.LineFragments)\n\t}\n\treturn limit\n}\n"
# CONTEXT_ITEMS   },
# CONTEXT_ITEMS   {
# CONTEXT_ITEMS     "source": "user",
# CONTEXT_ITEMS     "file": "/Users/tomross/dev/cody-leaderboard/input/chat/mocked/codebase_context/eval.go:undefined-undefined",
# CONTEXT_ITEMS     "content": "// Copyright 2016 Google Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage zoekt\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"regexp/syntax\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\tenry_data \"github.com/go-enry/go-enry/v2/data\"\n\t\"github.com/grafana/regexp\"\n\n\t\"github.com/sourcegraph/zoekt/query\"\n)\n\n// simplifyMultiRepo takes a query and a predicate. It returns Const(true) if all\n// repository names fulfill the predicate, Const(false) if none of them do, and q\n// otherwise.\nfunc (d *indexData) simplifyMultiRepo(q query.Q, predicate func(*Repository) bool) query.Q {\n\tcount := 0\n\talive := len(d.repoMetaData)\n\tfor i := range d.repoMetaData {\n\t\tif d.repoMetaData[i].Tombstone {\n\t\t\talive--\n\t\t} else if predicate(&d.repoMetaData[i]) {\n\t\t\tcount++\n\t\t}\n\t}\n\tif count == alive {\n\t\treturn &query.Const{Value: true}\n\t}\n\tif count > 0 {\n\t\treturn q\n\t}\n\treturn &query.Const{Value: false}\n}\n\nfunc (d *indexData) simplify(in query.Q) query.Q {\n\teval := query.Map(in, func(q query.Q) query.Q {\n\t\tswitch r := q.(type) {\n\t\tcase *query.Repo:\n\t\t\treturn d.simplifyMultiRepo(q, func(repo *Repository) bool {\n\t\t\t\treturn r.Regexp.MatchString(repo.Name)\n\t\t\t})\n\t\tcase *query.RepoRegexp:\n\t\t\treturn d.simplifyMultiRepo(q, func(repo *Repository) bool {\n\t\t\t\treturn r.Regexp.MatchString(repo.Name)\n\t\t\t})\n\t\tcase *query.BranchesRepos:\n\t\t\tfor i := range d.repoMetaData {\n\t\t\t\tfor _, br := range r.List {\n\t\t\t\t\tif br.Repos.Contains(d.repoMetaData[i].ID) {\n\t\t\t\t\t\treturn q\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &query.Const{Value: false}\n\t\tcase *query.RepoSet:\n\t\t\treturn d.simplifyMultiRepo(q, func(repo *Repository) bool {\n\t\t\t\treturn r.Set[repo.Name]\n\t\t\t})\n\t\tcase *query.RepoIDs:\n\t\t\treturn d.simplifyMultiRepo(q, func(repo *Repository) bool {\n\t\t\t\treturn r.Repos.Contains(repo.ID)\n\t\t\t})\n\t\tcase *query.Language:\n\t\t\t_, has := d.metaData.LanguageMap[r.Language]\n\t\t\tif !has && d.metaData.IndexFeatureVersion < 12 {\n\t\t\t\t// For index files that haven't been re-indexed by go-enry,\n\t\t\t\t// fall back to file-based matching and continue even if this\n\t\t\t\t// repo doesn't have the specific language present.\n\t\t\t\textsForLang := enry_data.ExtensionsByLanguage[r.Language]\n\t\t\t\tif extsForLang != nil {\n\t\t\t\t\textFrags := make([]string, 0, len(extsForLang))\n\t\t\t\t\tfor _, ext := range extsForLang {\n\t\t\t\t\t\textFrags = append(extFrags, regexp.QuoteMeta(ext))\n\t\t\t\t\t}\n\t\t\t\t\tif len(extFrags) > 0 {\n\t\t\t\t\t\tpattern := fmt.Sprintf(\"(?i)(%s)$\", strings.Join(extFrags, \"|\"))\n\t\t\t\t\t\t// inlined copy of query.regexpQuery\n\t\t\t\t\t\tre, err := syntax.Parse(pattern, syntax.Perl)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn &query.Const{Value: false}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif re.Op == syntax.OpLiteral {\n\t\t\t\t\t\t\treturn &query.Substring{\n\t\t\t\t\t\t\t\tPattern:  string(re.Rune),\n\t\t\t\t\t\t\t\tFileName: true,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &query.Regexp{\n\t\t\t\t\t\t\tRegexp:   re,\n\t\t\t\t\t\t\tFileName: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !has {\n\t\t\t\treturn &query.Const{Value: false}\n\t\t\t}\n\t\t}\n\t\treturn q\n\t})\n\treturn query.Simplify(eval)\n}\n\nfunc (o *SearchOptions) SetDefaults() {\n\tif o.ShardMaxMatchCount == 0 {\n\t\t// We cap the total number of matches, so overly broad\n\t\t// searches don't crash the machine.\n\t\to.ShardMaxMatchCount = 100000\n\t}\n\tif o.TotalMaxMatchCount == 0 {\n\t\to.TotalMaxMatchCount = 10 * o.ShardMaxMatchCount\n\t}\n}\n\nfunc (d *indexData) Search(ctx context.Context, q query.Q, opts *SearchOptions) (sr *SearchResult, err error) {\n\ttimer := newTimer()\n\n\tcopyOpts := *opts\n\topts = &copyOpts\n\topts.SetDefaults()\n\n\tvar res SearchResult\n\tif len(d.fileNameIndex) == 0 {\n\t\treturn &res, nil\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tres.Stats.ShardsSkipped++\n\t\treturn &res, nil\n\tdefault:\n\t}\n\n\tq = d.simplify(q)\n\tif c, ok := q.(*query.Const); ok && !c.Value {\n\t\treturn &res, nil\n\t}\n\n\tif opts.EstimateDocCount {\n\t\tres.Stats.ShardFilesConsidered = len(d.fileBranchMasks)\n\t\treturn &res, nil\n\t}\n\n\tq = query.Map(q, query.ExpandFileContent)\n\n\tmt, err := d.newMatchTree(q, matchTreeOpt{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Capture the costs of construction before pruning\n\tupdateMatchTreeStats(mt, &res.Stats)\n\n\tmt, err = pruneMatchTree(mt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres.Stats.MatchTreeConstruction = timer.Elapsed()\n\tif mt == nil {\n\t\tres.Stats.ShardsSkippedFilter++\n\t\treturn &res, nil\n\t}\n\n\tres.Stats.ShardsScanned++\n\n\tcp := &contentProvider{\n\t\tid:    d,\n\t\tstats: &res.Stats,\n\t}\n\n\t// Track the number of documents found in a repository for\n\t// ShardRepoMaxMatchCount\n\tvar (\n\t\tlastRepoID     uint16\n\t\trepoMatchCount int\n\t)\n\n\tdocCount := uint32(len(d.fileBranchMasks))\n\tlastDoc := int(-1)\n\nnextFileMatch:\n\tfor {\n\t\tcanceled := false\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tcanceled = true\n\t\tdefault:\n\t\t}\n\n\t\tnextDoc := mt.nextDoc()\n\t\tif int(nextDoc) <= lastDoc {\n\t\t\tnextDoc = uint32(lastDoc + 1)\n\t\t}\n\n\t\tfor ; nextDoc < docCount; nextDoc++ {\n\t\t\trepoID := d.repos[nextDoc]\n\t\t\trepoMetadata := &d.repoMetaData[repoID]\n\n\t\t\t// Skip tombstoned repositories\n\t\t\tif repoMetadata.Tombstone {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Skip documents that are tombstoned\n\t\t\tif len(repoMetadata.FileTombstones) > 0 {\n\t\t\t\tif _, tombstoned := repoMetadata.FileTombstones[string(d.fileName(nextDoc))]; tombstoned {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip documents over ShardRepoMaxMatchCount if specified.\n\t\t\tif opts.ShardRepoMaxMatchCount > 0 {\n\t\t\t\tif repoMatchCount >= opts.ShardRepoMaxMatchCount && repoID == lastRepoID {\n\t\t\t\t\tres.Stats.FilesSkipped++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tif nextDoc >= docCount {\n\t\t\tbreak\n\t\t}\n\n\t\tlastDoc = int(nextDoc)\n\n\t\t// We track lastRepoID for ShardRepoMaxMatchCount\n\t\tif lastRepoID != d.repos[nextDoc] {\n\t\t\tlastRepoID = d.repos[nextDoc]\n\t\t\trepoMatchCount = 0\n\t\t}\n\n\t\tif canceled || (res.Stats.MatchCount >= opts.ShardMaxMatchCount && opts.ShardMaxMatchCount > 0) {\n\t\t\tres.Stats.FilesSkipped += int(docCount - nextDoc)\n\t\t\tbreak\n\t\t}\n\n\t\tres.Stats.FilesConsidered++\n\t\tmt.prepare(nextDoc)\n\n\t\tcp.setDocument(nextDoc)\n\n\t\tknown := make(map[matchTree]bool)\n\t\tmd := d.repoMetaData[d.repos[nextDoc]]\n\n\t\tfor cost := costMin; cost <= costMax; cost++ {\n\t\t\tswitch evalMatchTree(cp, cost, known, mt) {\n\t\t\tcase matchesRequiresHigherCost:\n\t\t\t\tif cost == costMax {\n\t\t\t\t\tlog.Panicf(\"did not decide. Repo %s, doc %d, known %v\",\n\t\t\t\t\t\tmd.Name, nextDoc, known)\n\t\t\t\t}\n\t\t\tcase matchesFound:\n\t\t\t\t// could short-circuit now, but we want to run higher costs to\n\t\t\t\t// potentially find higher ranked matches.\n\t\t\tcase matchesNone:\n\t\t\t\tcontinue nextFileMatch\n\t\t\t}\n\t\t}\n\n\t\tfileMatch := FileMatch{\n\t\t\tRepository:         md.Name,\n\t\t\tRepositoryID:       md.ID,\n\t\t\tRepositoryPriority: md.priority,\n\t\t\tFileName:           string(d.fileName(nextDoc)),\n\t\t\tChecksum:           d.getChecksum(nextDoc),\n\t\t\tLanguage:           d.languageMap[d.getLanguage(nextDoc)],\n\t\t}\n\n\t\tif s := d.subRepos[nextDoc]; s > 0 {\n\t\t\tif s >= uint32(len(d.subRepoPaths[d.repos[nextDoc]])) {\n\t\t\t\tlog.Panicf(\"corrupt index: subrepo %d beyond %v\", s, d.subRepoPaths)\n\t\t\t}\n\t\t\tpath := d.subRepoPaths[d.repos[nextDoc]][s]\n\t\t\tfileMatch.SubRepositoryPath = path\n\t\t\tsr := md.SubRepoMap[path]\n\t\t\tfileMatch.SubRepositoryName = sr.Name\n\t\t\tif idx := d.branchIndex(nextDoc); idx >= 0 {\n\t\t\t\tfileMatch.Version = sr.Branches[idx].Version\n\t\t\t}\n\t\t} else {\n\t\t\tidx := d.branchIndex(nextDoc)\n\t\t\tif idx >= 0 {\n\t\t\t\tfileMatch.Version = md.Branches[idx].Version\n\t\t\t}\n\t\t}\n\n\t\t// Important invariant for performance: finalCands is sorted by offset and\n\t\t// non-overlapping. gatherMatches respects this invariant and all later\n\t\t// transformations respect this.\n\t\tshouldMergeMatches := !opts.ChunkMatches\n\t\tfinalCands := d.gatherMatches(nextDoc, mt, known, shouldMergeMatches)\n\n\t\tif opts.ChunkMatches {\n\t\t\tfileMatch.ChunkMatches = cp.fillChunkMatches(finalCands, opts.NumContextLines, fileMatch.Language, opts.DebugScore)\n\t\t} else {\n\t\t\tfileMatch.LineMatches = cp.fillMatches(finalCands, opts.NumContextLines, fileMatch.Language, opts.DebugScore)\n\t\t}\n\n\t\tif opts.UseBM25Scoring {\n\t\t\td.scoreFileUsingBM25(&fileMatch, nextDoc, finalCands, opts)\n\t\t} else {\n\t\t\t// Use the standard, non-experimental scoring method by default\n\t\t\td.scoreFile(&fileMatch, nextDoc, mt, known, opts)\n\t\t}\n\n\t\tfileMatch.Branches = d.gatherBranches(nextDoc, mt, known)\n\t\tsortMatchesByScore(fileMatch.LineMatches)\n\t\tsortChunkMatchesByScore(fileMatch.ChunkMatches)\n\t\tif opts.Whole {\n\t\t\tfileMatch.Content = cp.data(false)\n\t\t}\n\n\t\tmatchedChunkRanges := 0\n\t\tfor _, cm := range fileMatch.ChunkMatches {\n\t\t\tmatchedChunkRanges += len(cm.Ranges)\n\t\t}\n\n\t\trepoMatchCount += len(fileMatch.LineMatches)\n\t\trepoMatchCount += matchedChunkRanges\n\n\t\tif opts.DebugScore {\n\t\t\tfileMatch.Debug = fmt.Sprintf(\"score:%.2f <- %s\", fileMatch.Score, fileMatch.Debug)\n\t\t}\n\n\t\tres.Files = append(res.Files, fileMatch)\n\t\tres.Stats.MatchCount += len(fileMatch.LineMatches)\n\t\tres.Stats.MatchCount += matchedChunkRanges\n\t\tres.Stats.FileCount++\n\t}\n\n\tfor _, md := range d.repoMetaData {\n\t\tr := md\n\t\taddRepo(&res, &r)\n\t\tfor _, v := range r.SubRepoMap {\n\t\t\taddRepo(&res, v)\n\t\t}\n\t}\n\n\t// Update stats based on work done during document search.\n\tupdateMatchTreeStats(mt, &res.Stats)\n\n\t// If document ranking is enabled, then we can rank and truncate the files to save memory.\n\tif opts.UseDocumentRanks {\n\t\tres.Files = SortAndTruncateFiles(res.Files, opts)\n\t}\n\n\tres.Stats.MatchTreeSearch = timer.Elapsed()\n\n\treturn &res, nil\n}\n\nfunc addRepo(res *SearchResult, repo *Repository) {\n\tif res.RepoURLs == nil {\n\t\tres.RepoURLs = map[string]string{}\n\t}\n\tres.RepoURLs[repo.Name] = repo.FileURLTemplate\n\n\tif res.LineFragments == nil {\n\t\tres.LineFragments = map[string]string{}\n\t}\n\tres.LineFragments[repo.Name] = repo.LineFragmentTemplate\n}\n\n// Gather matches from this document. The matches are returned in document\n// order and are non-overlapping. All filename and content matches are\n// returned, with filename matches first.\n//\n// If `merge` is set, overlapping and adjacent matches will be merged\n// into a single match. Otherwise, overlapping matches will be removed,\n// but adjacent matches will remain.\nfunc (d *indexData) gatherMatches(nextDoc uint32, mt matchTree, known map[matchTree]bool, merge bool) []*candidateMatch {\n\tvar cands []*candidateMatch\n\tvisitMatches(mt, known, 1, func(mt matchTree, scoreWeight float64) {\n\t\tif smt, ok := mt.(*substrMatchTree); ok {\n\t\t\tcands = append(cands, setScoreWeight(scoreWeight, smt.current)...)\n\t\t}\n\t\tif rmt, ok := mt.(*regexpMatchTree); ok {\n\t\t\tcands = append(cands, setScoreWeight(scoreWeight, rmt.found)...)\n\t\t}\n\t\tif rmt, ok := mt.(*wordMatchTree); ok {\n\t\t\tcands = append(cands, setScoreWeight(scoreWeight, rmt.found)...)\n\t\t}\n\t\tif smt, ok := mt.(*symbolRegexpMatchTree); ok {\n\t\t\tcands = append(cands, setScoreWeight(scoreWeight, smt.found)...)\n\t\t}\n\t})\n\n\t// If we found no candidate matches at all, assume there must have been a match on filename.\n\tif len(cands) == 0 {\n\t\tnm := d.fileName(nextDoc)\n\t\treturn []*candidateMatch{{\n\t\t\tcaseSensitive: false,\n\t\t\tfileName:      true,\n\t\t\tsubstrBytes:   nm,\n\t\t\tsubstrLowered: nm,\n\t\t\tfile:          nextDoc,\n\t\t\truneOffset:    0,\n\t\t\tbyteOffset:    0,\n\t\t\tbyteMatchSz:   uint32(len(nm)),\n\t\t}}\n\t}\n\n\tsort.Sort((sortByOffsetSlice)(cands))\n\tres := cands[:0]\n\tmergeRun := 1\n\tfor i, c := range cands {\n\t\tif i == 0 {\n\t\t\tres = append(res, c)\n\t\t\tcontinue\n\t\t}\n\n\t\tlast := res[len(res)-1]\n\n\t\t// Never compare filename and content matches\n\t\tif last.fileName != c.fileName {\n\t\t\tres = append(res, c)\n\t\t\tcontinue\n\t\t}\n\n\t\tif merge {\n\t\t\t// Merge adjacent candidates. This guarantees that the matches\n\t\t\t// are non-overlapping.\n\t\t\tlastEnd := last.byteOffset + last.byteMatchSz\n\t\t\tend := c.byteOffset + c.byteMatchSz\n\t\t\tif lastEnd >= c.byteOffset {\n\t\t\t\tmergeRun++\n\t\t\t\t// Average out the score across the merged candidates. Only do it if\n\t\t\t\t// we are boosting to avoid floating point funkiness in the normal\n\t\t\t\t// case.\n\t\t\t\tif !(epsilonEqualsOne(last.scoreWeight) && epsilonEqualsOne(c.scoreWeight)) {\n\t\t\t\t\tlast.scoreWeight = ((last.scoreWeight * float64(mergeRun-1)) + c.scoreWeight) / float64(mergeRun)\n\t\t\t\t}\n\n\t\t\t\t// latest candidate goes further, update our end\n\t\t\t\tif end > lastEnd {\n\t\t\t\t\tlast.byteMatchSz = end - last.byteOffset\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tmergeRun = 1\n\t\t\t}\n\t\t} else {\n\t\t\t// Remove overlapping candidates. This guarantees that the matches\n\t\t\t// are non-overlapping, but also preserves expected match counts.\n\t\t\tlastEnd := last.byteOffset + last.byteMatchSz\n\t\t\tif lastEnd > c.byteOffset {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tres = append(res, c)\n\t}\n\treturn res\n}\n\ntype sortByOffsetSlice []*candidateMatch\n\nfunc (m sortByOffsetSlice) Len() int      { return len(m) }\nfunc (m sortByOffsetSlice) Swap(i, j int) { m[i], m[j] = m[j], m[i] }\nfunc (m sortByOffsetSlice) Less(i, j int) bool {\n\t// Sort all filename matches to the start\n\tif m[i].fileName != m[j].fileName {\n\t\treturn m[i].fileName\n\t}\n\n\tif m[i].byteOffset == m[j].byteOffset { // tie break if same offset\n\t\t// Prefer longer candidates if starting at same position\n\t\treturn m[i].byteMatchSz > m[j].byteMatchSz\n\t}\n\treturn m[i].byteOffset < m[j].byteOffset\n}\n\n// setScoreWeight is a helper used by gatherMatches to set the weight based on\n// the score weight of the matchTree.\nfunc setScoreWeight(scoreWeight float64, cm []*candidateMatch) []*candidateMatch {\n\tfor _, m := range cm {\n\t\tm.scoreWeight = scoreWeight\n\t}\n\treturn cm\n}\n\nfunc (d *indexData) branchIndex(docID uint32) int {\n\tmask := d.fileBranchMasks[docID]\n\tidx := 0\n\tfor mask != 0 {\n\t\tif mask&0x1 != 0 {\n\t\t\treturn idx\n\t\t}\n\t\tidx++\n\t\tmask >>= 1\n\t}\n\treturn -1\n}\n\n// gatherBranches returns a list of branch names taking into account any branch\n// filters in the query. If the query contains a branch filter, it returns all\n// branches containing the docID and matching the branch filter. Otherwise, it\n// returns all branches containing docID.\nfunc (d *indexData) gatherBranches(docID uint32, mt matchTree, known map[matchTree]bool) []string {\n\tvar mask uint64\n\tvisitMatchAtoms(mt, known, func(mt matchTree) {\n\t\tbq, ok := mt.(*branchQueryMatchTree)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\tmask = mask | bq.branchMask()\n\t})\n\n\tif mask == 0 {\n\t\tmask = d.fileBranchMasks[docID]\n\t}\n\n\tvar branches []string\n\tid := uint32(1)\n\tbranchNames := d.branchNames[d.repos[docID]]\n\tfor mask != 0 {\n\t\tif mask&0x1 != 0 {\n\t\t\tbranches = append(branches, branchNames[uint(id)])\n\t\t}\n\t\tid <<= 1\n\t\tmask >>= 1\n\t}\n\n\treturn branches\n}\n\nfunc (d *indexData) List(ctx context.Context, q query.Q, opts *ListOptions) (rl *RepoList, err error) {\n\tvar include func(rle *RepoListEntry) bool\n\n\tq = d.simplify(q)\n\tif c, ok := q.(*query.Const); ok {\n\t\tif !c.Value {\n\t\t\treturn &RepoList{}, nil\n\t\t}\n\t\tinclude = func(rle *RepoListEntry) bool {\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tsr, err := d.Search(ctx, q, &SearchOptions{\n\t\t\tShardRepoMaxMatchCount: 1,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfoundRepos := make(map[string]struct{}, len(sr.Files))\n\t\tfor _, file := range sr.Files {\n\t\t\tfoundRepos[file.Repository] = struct{}{}\n\t\t}\n\n\t\tinclude = func(rle *RepoListEntry) bool {\n\t\t\t_, ok := foundRepos[rle.Repository.Name]\n\t\t\treturn ok\n\t\t}\n\t}\n\n\tvar l RepoList\n\n\tfield, err := opts.GetField()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch field {\n\tcase RepoListFieldRepos:\n\t\tl.Repos = make([]*RepoListEntry, 0, len(d.repoListEntry))\n\tcase RepoListFieldReposMap:\n\t\tl.ReposMap = make(ReposMap, len(d.repoListEntry))\n\t}\n\n\tfor i := range d.repoListEntry {\n\t\tif d.repoMetaData[i].Tombstone {\n\t\t\tcontinue\n\t\t}\n\t\trle := &d.repoListEntry[i]\n\t\tif !include(rle) {\n\t\t\tcontinue\n\t\t}\n\n\t\tl.Stats.Add(&rle.Stats)\n\n\t\t// Backwards compat for when ID is missing\n\t\tif rle.Repository.ID == 0 {\n\t\t\tl.Repos = append(l.Repos, rle)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch field {\n\t\tcase RepoListFieldRepos:\n\t\t\tl.Repos = append(l.Repos, rle)\n\t\tcase RepoListFieldReposMap:\n\t\t\tl.ReposMap[rle.Repository.ID] = MinimalRepoListEntry{\n\t\t\t\tHasSymbols:    rle.Repository.HasSymbols,\n\t\t\t\tBranches:      rle.Repository.Branches,\n\t\t\t\tIndexTimeUnix: rle.IndexMetadata.IndexTime.Unix(),\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Only one of these fields is populated and in all cases the size of that\n\t// field is the number of Repos in this shard.\n\tl.Stats.Repos = len(l.Repos) + len(l.ReposMap)\n\n\treturn &l, nil\n}\n\n// regexpToMatchTreeRecursive converts a regular expression to a matchTree mt. If\n// mt is equivalent to the input r, isEqual = true and the matchTree can be used\n// in place of the regex r. If singleLine = true, then the matchTree and all\n// its children only match terms on the same line. singleLine is used during\n// recursion to decide whether to return an andLineMatchTree (singleLine = true)\n// or a andMatchTree (singleLine = false).\nfunc (d *indexData) regexpToMatchTreeRecursive(r *syntax.Regexp, minTextSize int, fileName bool, caseSensitive bool) (mt matchTree, isEqual bool, singleLine bool, err error) {\n\t// TODO - we could perhaps transform Begin/EndText in '\\n'?\n\t// TODO - we could perhaps transform CharClass in (OrQuery )\n\t// if there are just a few runes, and part of a OpConcat?\n\tswitch r.Op {\n\tcase syntax.OpLiteral:\n\t\ts := string(r.Rune)\n\t\tif len(s) >= minTextSize {\n\t\t\tignoreCase := syntax.FoldCase == (r.Flags & syntax.FoldCase)\n\t\t\tmt, err := d.newSubstringMatchTree(&query.Substring{Pattern: s, FileName: fileName, CaseSensitive: !ignoreCase && caseSensitive})\n\t\t\treturn mt, true, !strings.Contains(s, \"\\n\"), err\n\t\t}\n\tcase syntax.OpCapture:\n\t\treturn d.regexpToMatchTreeRecursive(r.Sub[0], minTextSize, fileName, caseSensitive)\n\n\tcase syntax.OpPlus:\n\t\treturn d.regexpToMatchTreeRecursive(r.Sub[0], minTextSize, fileName, caseSensitive)\n\n\tcase syntax.OpRepeat:\n\t\tif r.Min == 1 {\n\t\t\treturn d.regexpToMatchTreeRecursive(r.Sub[0], minTextSize, fileName, caseSensitive)\n\t\t} else if r.Min > 1 {\n\t\t\t// (x){2,} can't be expressed precisely by the matchTree\n\t\t\tmt, _, singleLine, err := d.regexpToMatchTreeRecursive(r.Sub[0], minTextSize, fileName, caseSensitive)\n\t\t\treturn mt, false, singleLine, err\n\t\t}\n\tcase syntax.OpConcat, syntax.OpAlternate:\n\t\tvar qs []matchTree\n\t\tisEq := true\n\t\tsingleLine = true\n\t\tfor _, sr := range r.Sub {\n\t\t\tif sq, subIsEq, subSingleLine, err := d.regexpToMatchTreeRecursive(sr, minTextSize, fileName, caseSensitive); sq != nil {\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, false, false, err\n\t\t\t\t}\n\t\t\t\tisEq = isEq && subIsEq\n\t\t\t\tsingleLine = singleLine && subSingleLine\n\t\t\t\tqs = append(qs, sq)\n\t\t\t}\n\t\t}\n\t\tif r.Op == syntax.OpConcat {\n\t\t\tif len(qs) > 1 {\n\t\t\t\tisEq = false\n\t\t\t}\n\t\t\tnewQs := make([]matchTree, 0, len(qs))\n\t\t\tfor _, q := range qs {\n\t\t\t\tif _, ok := q.(*bruteForceMatchTree); ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tnewQs = append(newQs, q)\n\t\t\t}\n\t\t\tif len(newQs) == 1 {\n\t\t\t\treturn newQs[0], isEq, singleLine, nil\n\t\t\t}\n\t\t\tif len(newQs) == 0 {\n\t\t\t\treturn &bruteForceMatchTree{}, isEq, singleLine, nil\n\t\t\t}\n\t\t\tif singleLine {\n\t\t\t\treturn &andLineMatchTree{andMatchTree{children: newQs}}, isEq, singleLine, nil\n\t\t\t}\n\t\t\treturn &andMatchTree{newQs}, isEq, singleLine, nil\n\t\t}\n\t\tfor _, q := range qs {\n\t\t\tif _, ok := q.(*bruteForceMatchTree); ok {\n\t\t\t\treturn q, isEq, false, nil\n\t\t\t}\n\t\t}\n\t\tif len(qs) == 0 {\n\t\t\treturn &noMatchTree{Why: \"const\"}, isEq, false, nil\n\t\t}\n\t\treturn &orMatchTree{qs}, isEq, false, nil\n\tcase syntax.OpStar:\n\t\tif r.Sub[0].Op == syntax.OpAnyCharNotNL {\n\t\t\treturn &bruteForceMatchTree{}, false, true, nil\n\t\t}\n\t}\n\treturn &bruteForceMatchTree{}, false, false, nil\n}\n\ntype timer struct {\n\tlast time.Time\n}\n\nfunc newTimer() *timer {\n\treturn &timer{\n\t\tlast: time.Now(),\n\t}\n}\n\nfunc (t *timer) Elapsed() time.Duration {\n\tnow := time.Now()\n\td := now.Sub(t.last)\n\tt.last = now\n\treturn d\n}\n"
# CONTEXT_ITEMS   }
# CONTEXT_ITEMS ]

 class: insufficient context
 files:
   - ../mocked/codebase_context/README.md
   - ../mocked/codebase_context/limit.go
   - ../mocked/codebase_context/eval.go
 
