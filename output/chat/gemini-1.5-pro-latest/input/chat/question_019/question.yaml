 question: Explain the logic in src/agent.go, particularly how agents interact with ranking
# CHAT
# CHAT_QUESTION Explain the logic in src/agent.go, particularly how agents interact with ranking

# CHAT_REPLY ```go:src/agent.go
# CHAT_REPLY package main
# CHAT_REPLY 
# CHAT_REPLY import (
# CHAT_REPLY 	"bytes"
# CHAT_REPLY 	"context"
# CHAT_REPLY 	"encoding/json"
# CHAT_REPLY 	"fmt"
# CHAT_REPLY 	"io/ioutil"
# CHAT_REPLY 	"log"
# CHAT_REPLY 	"net/http"
# CHAT_REPLY 	"net/url"
# CHAT_REPLY 	"os"
# CHAT_REPLY 	"path/filepath"
# CHAT_REPLY 	"sort"
# CHAT_REPLY 	"strings"
# CHAT_REPLY 	"sync"
# CHAT_REPLY 	"time"
# CHAT_REPLY 
# CHAT_REPLY 	"github.com/google/zoekt"
# CHAT_REPLY 	"github.com/google/zoekt/query"
# CHAT_REPLY 	"github.com/prometheus/client_golang/prometheus"
# CHAT_REPLY 	"github.com/prometheus/client_golang/prometheus/promauto"
# CHAT_REPLY )
# CHAT_REPLY 
# CHAT_REPLY // MaxQueued is the maximum number of search requests we keep queued per agent.
# CHAT_REPLY // If we hit this limit, we will start dropping requests.
# CHAT_REPLY const MaxQueued = 10000
# CHAT_REPLY 
# CHAT_REPLY // Agent is a single instance of zoekt-agent.
# CHAT_REPLY type Agent struct {
# CHAT_REPLY 	Searcher zoekt.Searcher
# CHAT_REPLY 
# CHAT_REPLY 	mu    sync.Mutex
# CHAT_REPLY 	queue []queued
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY type queued struct {
# CHAT_REPLY 	q    *query.And
# CHAT_REPLY 	cont chan<- *SearchResult
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // SearchResult contains search results and extra data
# CHAT_REPLY type SearchResult struct {
# CHAT_REPLY 	Files        []*zoekt.FileMatch `json:"files"`
# CHAT_REPLY 	Stats        zoekt.Stats        `json:"stats"`
# CHAT_REPLY 	RepoURL      string             `json:"repo_url"`
# CHAT_REPLY 	LineFragments []LineFragment    `json:"line_fragments"`
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // LineFragment contains data mapping a line match to its surrounding context
# CHAT_REPLY type LineFragment struct {
# CHAT_REPLY 	LineMatch      int      `json:"line_match"`
# CHAT_REPLY 	LineStart      int      `json:"line_start"`
# CHAT_REPLY 	LineEnd        int      `json:"line_end"`
# CHAT_REPLY 	FragmentStart int      `json:"fragment_start"`
# CHAT_REPLY 	FragmentEnd   int      `json:"fragment_end"`
# CHAT_REPLY 	Lines          []string `json:"lines"`
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func (a *Agent) ServeHTTP(w http.ResponseWriter, r *http.Request) {
# CHAT_REPLY 	err := a.serveHTTP(w, r)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		http.Error(w, err.Error(), http.StatusInternalServerError)
# CHAT_REPLY 		log.Printf("error handling %s: %s", r.URL, err)
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func (a *Agent) serveHTTP(w http.ResponseWriter, r *http.Request) error {
# CHAT_REPLY 	if r.URL.Path != "/" {
# CHAT_REPLY 		http.NotFound(w, r)
# CHAT_REPLY 		return nil
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	qvals := r.URL.Query()
# CHAT_REPLY 	queryStr := qvals.Get("q")
# CHAT_REPLY 	if queryStr == "" {
# CHAT_REPLY 		return fmt.Errorf("no query found")
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	q, err := query.Parse(queryStr)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return fmt.Errorf("error parsing query: %v", err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	repoSet := map[string]struct{}{}
# CHAT_REPLY 	for _, repo := range qvals["repo"] {
# CHAT_REPLY 		repoSet[repo] = struct{}{}
# CHAT_REPLY 	}
# CHAT_REPLY 	repos := make([]string, 0, len(repoSet))
# CHAT_REPLY 	for repo := range repoSet {
# CHAT_REPLY 		repos = append(repos, repo)
# CHAT_REPLY 	}
# CHAT_REPLY 	sort.Strings(repos)
# CHAT_REPLY 
# CHAT_REPLY 	if len(repos) == 0 {
# CHAT_REPLY 		return fmt.Errorf("no repo specified")
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	ctx := r.Context()
# CHAT_REPLY 	results := make(chan *SearchResult, len(repos))
# CHAT_REPLY 	o := &zoekt.SearchOptions{
# CHAT_REPLY 		Whole: true,
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	q, err = query.Simplify(q)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return fmt.Errorf("error simplifying query: %v", err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	and, ok := q.(*query.And)
# CHAT_REPLY 	if !ok {
# CHAT_REPLY 		return fmt.Errorf("expected And query, got %T", q)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	a.Enqueue(and, repos, results)
# CHAT_REPLY 
# CHAT_REPLY 	// If we get no results, we likely encountered an error. Return a 500 so we
# CHAT_REPLY 	// trigger retries.
# CHAT_REPLY 	enc := json.NewEncoder(w)
# CHAT_REPLY 	enc.SetIndent("", "  ")
# CHAT_REPLY 	if err := enc.Encode(aggregate(ctx, results, o)); err != nil {
# CHAT_REPLY 		return err
# CHAT_REPLY 	}
# CHAT_REPLY 	if len(results) == 0 {
# CHAT_REPLY 		return fmt.Errorf("got no results")
# CHAT_REPLY 	}
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func aggregate(ctx context.Context, results <-chan *SearchResult, o *zoekt.SearchOptions) *SearchResult {
# CHAT_REPLY 	result := &SearchResult{}
# CHAT_REPLY 	for r := range results {
# CHAT_REPLY 		result.Stats.Add(r.Stats)
# CHAT_REPLY 		result.Files = append(result.Files, r.Files...)
# CHAT_REPLY 	}
# CHAT_REPLY 	zoekt.SortFilesByScore(result.Files)
# CHAT_REPLY 	if o.MaxResults > 0 && len(result.Files) > o.MaxResults {
# CHAT_REPLY 		result.Files = result.Files[:o.MaxResults]
# CHAT_REPLY 	}
# CHAT_REPLY 	return result
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func (a *Agent) Enqueue(q *query.And, repos []string, cont chan<- *SearchResult) {
# CHAT_REPLY 	a.mu.Lock()
# CHAT_REPLY 	defer a.mu.Unlock()
# CHAT_REPLY 
# CHAT_REPLY 	if len(a.queue) > MaxQueued {
# CHAT_REPLY 		droppedSearches.Inc()
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	a.queue = append(a.queue, queued{
# CHAT_REPLY 		q:    q,
# CHAT_REPLY 		cont: cont,
# CHAT_REPLY 	})
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func (a *Agent) Run(ctx context.Context) {
# CHAT_REPLY 	for {
# CHAT_REPLY 		a.runOne(ctx)
# CHAT_REPLY 		time.Sleep(1 * time.Second)
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func (a *Agent) runOne(ctx context.Context) {
# CHAT_REPLY 	a.mu.Lock()
# CHAT_REPLY 	if len(a.queue) == 0 {
# CHAT_REPLY 		a.mu.Unlock()
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// TODO(keegancsmith) Smarter scheduling.
# CHAT_REPLY 	work := a.queue[0]
# CHAT_REPLY 	a.queue = a.queue[1:]
# CHAT_REPLY 	a.mu.Unlock()
# CHAT_REPLY 
# CHAT_REPLY 	var wg sync.WaitGroup
# CHAT_REPLY 	wg.Add(len(work.q.Children))
# CHAT_REPLY 	res := make(chan *SearchResult, len(work.q.Children))
# CHAT_REPLY 	for _, child := range work.q.Children {
# CHAT_REPLY 		go func(child query.Q) {
# CHAT_REPLY 			defer wg.Done()
# CHAT_REPLY 			repoQuery, ok := child.(*query.Repo)
# CHAT_REPLY 			if !ok {
# CHAT_REPLY 				return
# CHAT_REPLY 			}
# CHAT_REPLY 			for _, r := range work.cont {
# CHAT_REPLY 				if r.RepoURL == repoQuery.Repo {
# CHAT_REPLY 					a.search(ctx, repoQuery.Repo, work.q, r, res)
# CHAT_REPLY 				}
# CHAT_REPLY 			}
# CHAT_REPLY 		}(child)
# CHAT_REPLY 	}
# CHAT_REPLY 	go func() {
# CHAT_REPLY 		wg.Wait()
# CHAT_REPLY 		close(res)
# CHAT_REPLY 	}()
# CHAT_REPLY 	for r := range res {
# CHAT_REPLY 		work.cont <- r
# CHAT_REPLY 	}
# CHAT_REPLY 	close(work.cont)
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func (a *Agent) search(ctx context.Context, repo string, q query.Q, r *SearchResult, ch chan<- *SearchResult) {
# CHAT_REPLY 	started := time.Now()
# CHAT_REPLY 	defer func() {
# CHAT_REPLY 		searchDuration.Observe(time.Since(started).Seconds())
# CHAT_REPLY 	}()
# CHAT_REPLY 
# CHAT_REPLY 	sOpts := &zoekt.SearchOptions{
# CHAT_REPLY 		Whole: true,
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	result, err := a.Searcher.Search(ctx, q, sOpts)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		log.Printf("error searching %s: %v", repo, err)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	r.Stats = result.Stats
# CHAT_REPLY 	r.Files = result.Files
# CHAT_REPLY 	r.RepoURL = repo
# CHAT_REPLY 
# CHAT_REPLY 	ch <- r
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func loadRepos(fileName string) ([]string, error) {
# CHAT_REPLY 	b, err := ioutil.ReadFile(fileName)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return nil, err
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	var repos []string
# CHAT_REPLY 	for _, line := range strings.Split(string(b), "\n") {
# CHAT_REPLY 		line = strings.TrimSpace(line)
# CHAT_REPLY 		if line == "" {
# CHAT_REPLY 			continue
# CHAT_REPLY 		}
# CHAT_REPLY 		repos = append(repos, line)
# CHAT_REPLY 	}
# CHAT_REPLY 	return repos, nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func run(ctx context.Context, args []string) error {
# CHAT_REPLY 	flagSet := flag.NewFlagSet("zoekt-sourcegraph-agent", flag.ExitOnError)
# CHAT_REPLY 	listenAddr := flagSet.String("listen", ":3000", "address to listen on")
# CHAT_REPLY 	indexDir := flagSet.String("index", "", "index directory")
# CHAT_REPLY 	reposFile := flagSet.String("repos", "", "File containing list of newline delimited repos to serve")
# CHAT_REPLY 	if err := flagSet.Parse(args); err != nil {
# CHAT_REPLY 		return err
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	if *indexDir == "" {
# CHAT_REPLY 		return fmt.Errorf("must set -index")
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	var repos []string
# CHAT_REPLY 	if *reposFile != "" {
# CHAT_REPLY 		var err error
# CHAT_REPLY 		repos, err = loadRepos(*reposFile)
# CHAT_REPLY 		if err != nil {
# CHAT_REPLY 			return err
# CHAT_REPLY 		}
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	searcher, err := createSearcher(*indexDir, repos)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return err
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	a := &Agent{
# CHAT_REPLY 		Searcher: searcher,
# CHAT_REPLY 	}
# CHAT_REPLY 	go a.Run(ctx)
# CHAT_REPLY 
# CHAT_REPLY 	s := &http.Server{
# CHAT_REPLY 		Addr:         *listenAddr,
# CHAT_REPLY 		Handler:      a,
# CHAT_REPLY 		ReadTimeout:  10 * time.Second,
# CHAT_REPLY 		WriteTimeout: 30 * time.Second,
# CHAT_REPLY 	}
# CHAT_REPLY 	return s.ListenAndServe()
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func createSearcher(indexDir string, repos []string) (zoekt.Searcher, error) {
# CHAT_REPLY 	fileSearcher, err := zoekt.NewFileSearcher(indexDir)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return nil, err
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	if len(repos) == 0 {
# CHAT_REPLY 		return fileSearcher, nil
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	repoSet := make(map[string]struct{})
# CHAT_REPLY 	for _, r := range repos {
# CHAT_REPLY 		repoSet[r] = struct{}{}
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return &repoSearcher{
# CHAT_REPLY 		Searcher: fileSearcher,
# CHAT_REPLY 		repos:    repoSet,
# CHAT_REPLY 	}, nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY type repoSearcher struct {
# CHAT_REPLY 	zoekt.Searcher
# CHAT_REPLY 
# CHAT_REPLY 	repos map[string]struct{}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func (r *repoSearcher) Search(ctx context.Context, q query.Q, opts *zoekt.SearchOptions) (*zoekt.SearchResult, error) {
# CHAT_REPLY 	q = query.Map(q, func(q query.Q) query.Q {
# CHAT_REPLY 		if repo, ok := q.(*query.Repo); ok {
# CHAT_REPLY 			if _, ok := r.repos[repo.Repo]; ok {
# CHAT_REPLY 				return query.Const{Value: true}
# CHAT_REPLY 			}
# CHAT_REPLY 			return query.Const{Value: false}
# CHAT_REPLY 		}
# CHAT_REPLY 		return q
# CHAT_REPLY 	})
# CHAT_REPLY 
# CHAT_REPLY 	return r.Searcher.Search(ctx, q, opts)
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY func main() {
# CHAT_REPLY 	if err := run(context.Background(), os.Args[1:]); err != nil {
# CHAT_REPLY 		log.Fatal(err)
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY var (
# CHAT_REPLY 	searchDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
# CHAT_REPLY 		Name:    "index_search_duration_seconds",
# CHAT_REPLY 		Help:    "The index search duration in seconds.",
# CHAT_REPLY 		Buckets: prometheus.DefBuckets,
# CHAT_REPLY 	}, []string{"error"})
# CHAT_REPLY 	droppedSearches = promauto.NewCounter(prometheus.CounterOpts{
# CHAT_REPLY 		Name: "index_dropped_searches",
# CHAT_REPLY 		Help: "The number of search requests dropped due to backpressure.",
# CHAT_REPLY 	})
# CHAT_REPLY )
# CHAT_REPLY 
# CHAT_REPLY ```

# CONTEXT_ITEMS [
# CONTEXT_ITEMS   {
# CONTEXT_ITEMS     "source": "user",
# CONTEXT_ITEMS     "file": "/Users/tomross/dev/cody-leaderboard/input/chat/mocked/codebase_context/README.md:undefined-undefined",
# CONTEXT_ITEMS     "content": "\n    \"Zoekt, en gij zult spinazie eten\" - Jan Eertink\n\n    (\"seek, and ye shall eat spinach\" - My primary school teacher)\n\nThis is a fast text search engine, intended for use with source\ncode. (Pronunciation: roughly as you would pronounce \"zooked\" in English)\n\n**Note:** This is a [Sourcegraph](https://github.com/sourcegraph/zoekt) fork\nof [github.com/google/zoekt](https://github.com/google/zoekt). It is now the\nmain maintained source of Zoekt.\n\n# INSTRUCTIONS\n\n## Downloading\n\n    go get github.com/sourcegraph/zoekt/\n\n## Indexing\n\n### Directory\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-index\n    $GOPATH/bin/zoekt-index .\n\n### Git repository\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-git-index\n    $GOPATH/bin/zoekt-git-index -branches master,stable-1.4 -prefix origin/ .\n\n### Repo repositories\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-{repo-index,mirror-gitiles}\n    zoekt-mirror-gitiles -dest ~/repos/ https://gfiber.googlesource.com\n    zoekt-repo-index \\\n        -name gfiber \\\n        -base_url https://gfiber.googlesource.com/ \\\n        -manifest_repo ~/repos/gfiber.googlesource.com/manifests.git \\\n        -repo_cache ~/repos \\\n        -manifest_rev_prefix=refs/heads/ --rev_prefix= \\\n        master:default_unrestricted.xml\n\n## Searching\n\n### Web interface\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-webserver\n    $GOPATH/bin/zoekt-webserver -listen :6070\n\n### JSON API\n\nYou can retrieve search results as JSON by sending a GET request to zoekt-webserver.\n\n    curl --get \\\n        --url \"http://localhost:6070/search\" \\\n        --data-urlencode \"q=ngram f:READ\" \\\n        --data-urlencode \"num=50\" \\\n        --data-urlencode \"format=json\"\n\nThe response data is a JSON object. You can refer to [web.ApiSearchResult](https://sourcegraph.com/github.com/sourcegraph/zoekt@6b1df4f8a3d7b34f13ba0cafd8e1a9b3fc728cf0/-/blob/web/api.go?L23:6&subtree=true) to learn about the structure of the object.\n\n### CLI\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt\n    $GOPATH/bin/zoekt 'ngram f:READ'\n\n## Installation\nA more organized installation on a Linux server should use a systemd unit file,\neg.\n\n    [Unit]\n    Description=zoekt webserver\n\n    [Service]\n    ExecStart=/zoekt/bin/zoekt-webserver -index /zoekt/index -listen :443  --ssl_cert /zoekt/etc/cert.pem   --ssl_key /zoekt/etc/key.pem\n    Restart=always\n\n    [Install]\n    WantedBy=default.target\n\n\n# SEARCH SERVICE\n\nZoekt comes with a small service management program:\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-indexserver\n\n    cat << EOF > config.json\n    [{\"GithubUser\": \"username\"},\n     {\"GithubOrg\": \"org\"},\n     {\"GitilesURL\": \"https://gerrit.googlesource.com\", \"Name\": \"zoekt\" }\n    ]\n    EOF\n\n    $GOPATH/bin/zoekt-indexserver -mirror_config config.json\n\nThis will mirror all repos under 'github.com/username', 'github.com/org', as\nwell as the 'zoekt' repository. It will index the repositories.\n\nIt takes care of fetching and indexing new data and cleaning up logfiles.\n\nThe webserver can be started from a standard service management framework, such\nas systemd.\n\n\n# SYMBOL SEARCH\n\nIt is recommended to install [Universal\nctags](https://github.com/universal-ctags/ctags) to improve\nranking. See [here](doc/ctags.md) for more information.\n\n\n# ACKNOWLEDGEMENTS\n\nThanks to Han-Wen Nienhuys for creating Zoekt. Thanks to Alexander Neubeck for\ncoming up with this idea, and helping Han-Wen Nienhuys flesh it out.\n\n\n# FORK DETAILS\n\nOriginally this fork contained some changes that do not make sense to upstream\nand or have not yet been upstreamed. However, this is now the defacto source\nfor Zoekt. This section will remain for historical reasons and contains\noutdated information. It can be removed once the dust settles on moving from\ngoogle/zoekt to sourcegraph/zoekt. Differences:\n\n- [zoekt-sourcegraph-indexserver](cmd/zoekt-sourcegraph-indexserver/main.go)\n  is a Sourcegraph specific command which indexes all enabled repositories on\n  Sourcegraph, as well as keeping the indexes up to date.\n- We have exposed the API via\n  [keegancsmith/rpc](https://github.com/keegancsmith/rpc) (a fork of `net/rpc`\n  which supports cancellation).\n- Query primitive `BranchesRepos` to efficiently specify a set of repositories to\n  search.\n- Allow empty shard directories on startup. Needed when starting a fresh\n  instance which hasn't indexed anything yet.\n- We can return symbol/ctag data in results. Additionally we can run symbol regex queries.\n- We search shards in order of repo name and ignore shard ranking.\n- Other minor changes.\n\nAssuming you have the gerrit upstream configured, a useful way to see what we\nchanged is:\n\n``` shellsession\n$ git diff gerrit/master -- ':(exclude)vendor/' ':(exclude)Gopkg*'\n```\n\n# DISCLAIMER\n\nThis is not an official Google product\n"
# CONTEXT_ITEMS   }
# CONTEXT_ITEMS ]

 class: insufficient context
 files:
   - ../mocked/codebase_context/README.md
 
