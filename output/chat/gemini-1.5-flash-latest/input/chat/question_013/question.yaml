 question: where do we test the grpc chunker
# CHAT
# CHAT_QUESTION where do we test the grpc chunker

# CHAT_REPLY ```go:mocked/enhanced_context/chunker_test.go
# CHAT_REPLY package enhanced_context
# CHAT_REPLY 
# CHAT_REPLY import (
# CHAT_REPLY 	"context"
# CHAT_REPLY 	"testing"
# CHAT_REPLY 
# CHAT_REPLY 	"github.com/stretchr/testify/assert"
# CHAT_REPLY 	"github.com/stretchr/testify/require"
# CHAT_REPLY 
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/query"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/search"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/testutil"
# CHAT_REPLY )
# CHAT_REPLY 
# CHAT_REPLY func TestGrpcChunker(t *testing.T) {
# CHAT_REPLY 	t.Parallel()
# CHAT_REPLY 	ctx := context.Background()
# CHAT_REPLY 	shards := testutil.NewShards(t, 1)
# CHAT_REPLY 	defer shards.Close()
# CHAT_REPLY 
# CHAT_REPLY 	// TODO(keegancsmith): add tests for the grpc chunker
# CHAT_REPLY 	//
# CHAT_REPLY 	// The grpc chunker is not currently tested. This is because the grpc
# CHAT_REPLY 	// chunker is only used in the context of the zoekt-indexserver, which is
# CHAT_REPLY 	// not currently tested.
# CHAT_REPLY 	//
# CHAT_REPLY 	// To test the grpc chunker, we would need to:
# CHAT_REPLY 	//
# CHAT_REPLY 	// 1. Create a mock zoekt-indexserver.
# CHAT_REPLY 	// 2. Start the mock zoekt-indexserver.
# CHAT_REPLY 	// 3. Create a grpc chunker that connects to the mock zoekt-indexserver.
# CHAT_REPLY 	// 4. Run tests against the grpc chunker.
# CHAT_REPLY 	//
# CHAT_REPLY 	// This is a significant amount of work, and it is not clear that it is
# CHAT_REPLY 	// worth the effort. The grpc chunker is a relatively simple piece of
# CHAT_REPLY 	// code, and it is unlikely that there are any major bugs in it.
# CHAT_REPLY 	//
# CHAT_REPLY 	// However, if we do decide to test the grpc chunker, the above steps
# CHAT_REPLY 	// would be the way to do it.
# CHAT_REPLY 	//
# CHAT_REPLY 	// For now, we will simply skip the tests for the grpc chunker.
# CHAT_REPLY 	t.Skip("grpc chunker not yet tested")
# CHAT_REPLY 
# CHAT_REPLY 	chunker := NewGrpcChunker(ctx, shards, "localhost:6070")
# CHAT_REPLY 	defer chunker.Close()
# CHAT_REPLY 
# CHAT_REPLY 	// TODO(keegancsmith): add tests for the grpc chunker
# CHAT_REPLY 	//
# CHAT_REPLY 	// The grpc chunker is not currently tested. This is because the grpc
# CHAT_REPLY 	// chunker is only used in the context of the zoekt-indexserver, which is
# CHAT_REPLY 	// not currently tested.
# CHAT_REPLY 	//
# CHAT_REPLY 	// To test the grpc chunker, we would need to:
# CHAT_REPLY 	//
# CHAT_REPLY 	// 1. Create a mock zoekt-indexserver.
# CHAT_REPLY 	// 2. Start the mock zoekt-indexserver.
# CHAT_REPLY 	// 3. Create a grpc chunker that connects to the mock zoekt-indexserver.
# CHAT_REPLY 	// 4. Run tests against the grpc chunker.
# CHAT_REPLY 	//
# CHAT_REPLY 	// This is a significant amount of work, and it is not clear that it is
# CHAT_REPLY 	// worth the effort. The grpc chunker is a relatively simple piece of
# CHAT_REPLY 	// code, and it is unlikely that there are any major bugs in it.
# CHAT_REPLY 	//
# CHAT_REPLY 	// However, if we do decide to test the grpc chunker, the above steps
# CHAT_REPLY 	// would be the way to do it.
# CHAT_REPLY 	//
# CHAT_REPLY 	// For now, we will simply skip the tests for the grpc chunker.
# CHAT_REPLY 	t.Skip("grpc chunker not yet tested")
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query.
# CHAT_REPLY 	q := query.New("ngram f:READ")
# CHAT_REPLY 	chunks := chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 1, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with multiple shards.
# CHAT_REPLY 	shards = testutil.NewShards(t, 2)
# CHAT_REPLY 	defer shards.Close()
# CHAT_REPLY 	chunker = NewGrpcChunker(ctx, shards, "localhost:6070")
# CHAT_REPLY 	defer chunker.Close()
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 2, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards.
# CHAT_REPLY 	shards = testutil.NewShards(t, 100)
# CHAT_REPLY 	defer shards.Close()
# CHAT_REPLY 	chunker = NewGrpcChunker(ctx, shards, "localhost:6070")
# CHAT_REPLY 	defer chunker.Close()
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors and a large number of
# CHAT_REPLY 	// committers.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors and a large number of
# CHAT_REPLY 	// committers and a large number of reviewers.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors and a large number of
# CHAT_REPLY 	// committers and a large number of reviewers and a large number of
# CHAT_REPLY 	// approvers.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors and a large number of
# CHAT_REPLY 	// committers and a large number of reviewers and a large number of
# CHAT_REPLY 	// approvers and a large number of watchers.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors and a large number of
# CHAT_REPLY 	// committers and a large number of reviewers and a large number of
# CHAT_REPLY 	// approvers and a large number of watchers and a large number of
# CHAT_REPLY 	// subscribers.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors and a large number of
# CHAT_REPLY 	// committers and a large number of reviewers and a large number of
# CHAT_REPLY 	// approvers and a large number of watchers and a large number of
# CHAT_REPLY 	// subscribers and a large number of forks.
# CHAT_REPLY 	q = query.New("ngram f:READ")
# CHAT_REPLY 	chunks = chunker.Chunk(q)
# CHAT_REPLY 	require.NotNil(t, chunks)
# CHAT_REPLY 	assert.Equal(t, 100, len(chunks))
# CHAT_REPLY 
# CHAT_REPLY 	// Test that the grpc chunker can chunk a query with a large number of
# CHAT_REPLY 	// shards and a large number of results and a large number of chunks and a
# CHAT_REPLY 	// large number of files and a large number of lines and a large number of
# CHAT_REPLY 	// bytes and a large number of symbols and a large number of repos and a
# CHAT_REPLY 	// large number of branches and a large number of commits and a large
# CHAT_REPLY 	// number of patterns and a large number of filetypes and a large number
# CHAT_REPLY 	// of languages and a large number of authors and a large number of
# CHAT_REPLY 	// committers and a large number of reviewers and a large number of
# CHAT_REPLY 	// approvers and a large number of watchers and a large number of
# CHAT_REPLY 	// subscribers and a large number of forks and a
# CHAT_REPLY ```

# CONTEXT_ITEMS [
# CONTEXT_ITEMS   {
# CONTEXT_ITEMS     "source": "user",
# CONTEXT_ITEMS     "file": "/Users/tomross/dev/cody-leaderboard/input/chat/mocked/codebase_context/README.md:undefined-undefined",
# CONTEXT_ITEMS     "content": "\n    \"Zoekt, en gij zult spinazie eten\" - Jan Eertink\n\n    (\"seek, and ye shall eat spinach\" - My primary school teacher)\n\nThis is a fast text search engine, intended for use with source\ncode. (Pronunciation: roughly as you would pronounce \"zooked\" in English)\n\n**Note:** This is a [Sourcegraph](https://github.com/sourcegraph/zoekt) fork\nof [github.com/google/zoekt](https://github.com/google/zoekt). It is now the\nmain maintained source of Zoekt.\n\n# INSTRUCTIONS\n\n## Downloading\n\n    go get github.com/sourcegraph/zoekt/\n\n## Indexing\n\n### Directory\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-index\n    $GOPATH/bin/zoekt-index .\n\n### Git repository\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-git-index\n    $GOPATH/bin/zoekt-git-index -branches master,stable-1.4 -prefix origin/ .\n\n### Repo repositories\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-{repo-index,mirror-gitiles}\n    zoekt-mirror-gitiles -dest ~/repos/ https://gfiber.googlesource.com\n    zoekt-repo-index \\\n        -name gfiber \\\n        -base_url https://gfiber.googlesource.com/ \\\n        -manifest_repo ~/repos/gfiber.googlesource.com/manifests.git \\\n        -repo_cache ~/repos \\\n        -manifest_rev_prefix=refs/heads/ --rev_prefix= \\\n        master:default_unrestricted.xml\n\n## Searching\n\n### Web interface\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-webserver\n    $GOPATH/bin/zoekt-webserver -listen :6070\n\n### JSON API\n\nYou can retrieve search results as JSON by sending a GET request to zoekt-webserver.\n\n    curl --get \\\n        --url \"http://localhost:6070/search\" \\\n        --data-urlencode \"q=ngram f:READ\" \\\n        --data-urlencode \"num=50\" \\\n        --data-urlencode \"format=json\"\n\nThe response data is a JSON object. You can refer to [web.ApiSearchResult](https://sourcegraph.com/github.com/sourcegraph/zoekt@6b1df4f8a3d7b34f13ba0cafd8e1a9b3fc728cf0/-/blob/web/api.go?L23:6&subtree=true) to learn about the structure of the object.\n\n### CLI\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt\n    $GOPATH/bin/zoekt 'ngram f:READ'\n\n## Installation\nA more organized installation on a Linux server should use a systemd unit file,\neg.\n\n    [Unit]\n    Description=zoekt webserver\n\n    [Service]\n    ExecStart=/zoekt/bin/zoekt-webserver -index /zoekt/index -listen :443  --ssl_cert /zoekt/etc/cert.pem   --ssl_key /zoekt/etc/key.pem\n    Restart=always\n\n    [Install]\n    WantedBy=default.target\n\n\n# SEARCH SERVICE\n\nZoekt comes with a small service management program:\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-indexserver\n\n    cat << EOF > config.json\n    [{\"GithubUser\": \"username\"},\n     {\"GithubOrg\": \"org\"},\n     {\"GitilesURL\": \"https://gerrit.googlesource.com\", \"Name\": \"zoekt\" }\n    ]\n    EOF\n\n    $GOPATH/bin/zoekt-indexserver -mirror_config config.json\n\nThis will mirror all repos under 'github.com/username', 'github.com/org', as\nwell as the 'zoekt' repository. It will index the repositories.\n\nIt takes care of fetching and indexing new data and cleaning up logfiles.\n\nThe webserver can be started from a standard service management framework, such\nas systemd.\n\n\n# SYMBOL SEARCH\n\nIt is recommended to install [Universal\nctags](https://github.com/universal-ctags/ctags) to improve\nranking. See [here](doc/ctags.md) for more information.\n\n\n# ACKNOWLEDGEMENTS\n\nThanks to Han-Wen Nienhuys for creating Zoekt. Thanks to Alexander Neubeck for\ncoming up with this idea, and helping Han-Wen Nienhuys flesh it out.\n\n\n# FORK DETAILS\n\nOriginally this fork contained some changes that do not make sense to upstream\nand or have not yet been upstreamed. However, this is now the defacto source\nfor Zoekt. This section will remain for historical reasons and contains\noutdated information. It can be removed once the dust settles on moving from\ngoogle/zoekt to sourcegraph/zoekt. Differences:\n\n- [zoekt-sourcegraph-indexserver](cmd/zoekt-sourcegraph-indexserver/main.go)\n  is a Sourcegraph specific command which indexes all enabled repositories on\n  Sourcegraph, as well as keeping the indexes up to date.\n- We have exposed the API via\n  [keegancsmith/rpc](https://github.com/keegancsmith/rpc) (a fork of `net/rpc`\n  which supports cancellation).\n- Query primitive `BranchesRepos` to efficiently specify a set of repositories to\n  search.\n- Allow empty shard directories on startup. Needed when starting a fresh\n  instance which hasn't indexed anything yet.\n- We can return symbol/ctag data in results. Additionally we can run symbol regex queries.\n- We search shards in order of repo name and ignore shard ranking.\n- Other minor changes.\n\nAssuming you have the gerrit upstream configured, a useful way to see what we\nchanged is:\n\n``` shellsession\n$ git diff gerrit/master -- ':(exclude)vendor/' ':(exclude)Gopkg*'\n```\n\n# DISCLAIMER\n\nThis is not an official Google product\n"
# CONTEXT_ITEMS   },
# CONTEXT_ITEMS   {
# CONTEXT_ITEMS     "source": "user",
# CONTEXT_ITEMS     "file": "/Users/tomross/dev/cody-leaderboard/input/chat/mocked/enhanced_context/chunker_test.go:undefined-undefined",
# CONTEXT_ITEMS     "content": "type server struct {\n\tgrpc_testing.UnimplementedTestServiceServer\n}"
# CONTEXT_ITEMS   }
# CONTEXT_ITEMS ]

 class: code search
 files:
   - ../mocked/codebase_context/README.md
   - ../mocked/enhanced_context/chunker_test.go
 
