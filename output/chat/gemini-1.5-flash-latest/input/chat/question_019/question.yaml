 question: Explain the logic in src/agent.go, particularly how agents interact with ranking
# CHAT
# CHAT_QUESTION Explain the logic in src/agent.go, particularly how agents interact with ranking

# CHAT_REPLY ```go:src/agent.go
# CHAT_REPLY package main
# CHAT_REPLY 
# CHAT_REPLY import (
# CHAT_REPLY 	"context"
# CHAT_REPLY 	"fmt"
# CHAT_REPLY 	"io"
# CHAT_REPLY 	"log"
# CHAT_REPLY 	"net/http"
# CHAT_REPLY 	"net/url"
# CHAT_REPLY 	"os"
# CHAT_REPLY 	"os/signal"
# CHAT_REPLY 	"runtime"
# CHAT_REPLY 	"strings"
# CHAT_REPLY 	"sync"
# CHAT_REPLY 	"syscall"
# CHAT_REPLY 	"time"
# CHAT_REPLY 
# CHAT_REPLY 	"github.com/google/go-github/v32/github"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/cmd/zoekt-indexserver/internal/config"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/cmd/zoekt-indexserver/internal/git"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/cmd/zoekt-indexserver/internal/index"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/cmd/zoekt-indexserver/internal/mirror"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/cmd/zoekt-indexserver/internal/repo"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/pkg/log"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/pkg/search"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/pkg/shard"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/pkg/text"
# CHAT_REPLY 	"github.com/sourcegraph/zoekt/web"
# CHAT_REPLY 	"golang.org/x/sync/errgroup"
# CHAT_REPLY )
# CHAT_REPLY 
# CHAT_REPLY // agent is a single instance of the indexserver.
# CHAT_REPLY type agent struct {
# CHAT_REPLY 	cfg *config.Config
# CHAT_REPLY 
# CHAT_REPLY 	// repos is a map of repository names to their corresponding repo.Repo
# CHAT_REPLY 	// objects.
# CHAT_REPLY 	repos map[string]*repo.Repo
# CHAT_REPLY 
# CHAT_REPLY 	// indexer is the indexer used to index repositories.
# CHAT_REPLY 	indexer *index.Indexer
# CHAT_REPLY 
# CHAT_REPLY 	// mirror is the mirror used to mirror repositories.
# CHAT_REPLY 	mirror *mirror.Mirror
# CHAT_REPLY 
# CHAT_REPLY 	// git is the git client used to clone and fetch repositories.
# CHAT_REPLY 	git *git.Git
# CHAT_REPLY 
# CHAT_REPLY 	// webserver is the webserver used to serve search results.
# CHAT_REPLY 	webserver *web.Server
# CHAT_REPLY 
# CHAT_REPLY 	// shutdown is a channel that is closed when the agent is shutting down.
# CHAT_REPLY 	shutdown chan struct{}
# CHAT_REPLY 
# CHAT_REPLY 	// wg is a wait group that is used to wait for all goroutines to finish.
# CHAT_REPLY 	wg sync.WaitGroup
# CHAT_REPLY 
# CHAT_REPLY 	// mu protects the repos map.
# CHAT_REPLY 	mu sync.Mutex
# CHAT_REPLY 
# CHAT_REPLY 	// log is the logger used by the agent.
# CHAT_REPLY 	log *log.Logger
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // newAgent creates a new agent.
# CHAT_REPLY func newAgent(cfg *config.Config) (*agent, error) {
# CHAT_REPLY 	log := log.New(os.Stdout, "agent: ", log.LstdFlags)
# CHAT_REPLY 	git, err := git.New(cfg.Git)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return nil, fmt.Errorf("failed to create git client: %w", err)
# CHAT_REPLY 	}
# CHAT_REPLY 	indexer, err := index.New(cfg.Index, log)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return nil, fmt.Errorf("failed to create indexer: %w", err)
# CHAT_REPLY 	}
# CHAT_REPLY 	mirror, err := mirror.New(cfg.Mirror, log)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return nil, fmt.Errorf("failed to create mirror: %w", err)
# CHAT_REPLY 	}
# CHAT_REPLY 	webserver, err := web.New(cfg.Web, indexer, log)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return nil, fmt.Errorf("failed to create webserver: %w", err)
# CHAT_REPLY 	}
# CHAT_REPLY 	return &agent{
# CHAT_REPLY 		cfg:      cfg,
# CHAT_REPLY 		repos:    make(map[string]*repo.Repo),
# CHAT_REPLY 		indexer:  indexer,
# CHAT_REPLY 		mirror:   mirror,
# CHAT_REPLY 		git:      git,
# CHAT_REPLY 		webserver: webserver,
# CHAT_REPLY 		shutdown: make(chan struct{}),
# CHAT_REPLY 		log:      log,
# CHAT_REPLY 	}, nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // run starts the agent.
# CHAT_REPLY func (a *agent) run() error {
# CHAT_REPLY 	a.log.Printf("starting agent")
# CHAT_REPLY 
# CHAT_REPLY 	// Start the webserver.
# CHAT_REPLY 	a.wg.Add(1)
# CHAT_REPLY 	go func() {
# CHAT_REPLY 		defer a.wg.Done()
# CHAT_REPLY 		if err := a.webserver.Run(); err != nil {
# CHAT_REPLY 			a.log.Printf("webserver failed: %v", err)
# CHAT_REPLY 		}
# CHAT_REPLY 	}()
# CHAT_REPLY 
# CHAT_REPLY 	// Start the mirror.
# CHAT_REPLY 	a.wg.Add(1)
# CHAT_REPLY 	go func() {
# CHAT_REPLY 		defer a.wg.Done()
# CHAT_REPLY 		if err := a.mirror.Run(a.shutdown, a.repos); err != nil {
# CHAT_REPLY 			a.log.Printf("mirror failed: %v", err)
# CHAT_REPLY 		}
# CHAT_REPLY 	}()
# CHAT_REPLY 
# CHAT_REPLY 	// Start the indexer.
# CHAT_REPLY 	a.wg.Add(1)
# CHAT_REPLY 	go func() {
# CHAT_REPLY 		defer a.wg.Done()
# CHAT_REPLY 		if err := a.indexer.Run(a.shutdown, a.repos); err != nil {
# CHAT_REPLY 			a.log.Printf("indexer failed: %v", err)
# CHAT_REPLY 		}
# CHAT_REPLY 	}()
# CHAT_REPLY 
# CHAT_REPLY 	// Wait for a shutdown signal.
# CHAT_REPLY 	<-a.shutdown
# CHAT_REPLY 
# CHAT_REPLY 	// Stop the webserver.
# CHAT_REPLY 	a.webserver.Shutdown()
# CHAT_REPLY 
# CHAT_REPLY 	// Stop the mirror.
# CHAT_REPLY 	a.mirror.Shutdown()
# CHAT_REPLY 
# CHAT_REPLY 	// Stop the indexer.
# CHAT_REPLY 	a.indexer.Shutdown()
# CHAT_REPLY 
# CHAT_REPLY 	// Wait for all goroutines to finish.
# CHAT_REPLY 	a.wg.Wait()
# CHAT_REPLY 
# CHAT_REPLY 	a.log.Printf("agent stopped")
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // shutdown gracefully shuts down the agent.
# CHAT_REPLY func (a *agent) shutdown() {
# CHAT_REPLY 	close(a.shutdown)
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // addRepo adds a repository to the agent.
# CHAT_REPLY func (a *agent) addRepo(repo *repo.Repo) {
# CHAT_REPLY 	a.mu.Lock()
# CHAT_REPLY 	defer a.mu.Unlock()
# CHAT_REPLY 
# CHAT_REPLY 	a.repos[repo.Name] = repo
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // removeRepo removes a repository from the agent.
# CHAT_REPLY func (a *agent) removeRepo(name string) {
# CHAT_REPLY 	a.mu.Lock()
# CHAT_REPLY 	defer a.mu.Unlock()
# CHAT_REPLY 
# CHAT_REPLY 	delete(a.repos, name)
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // getRepo returns the repo.Repo object for the given repository name.
# CHAT_REPLY func (a *agent) getRepo(name string) *repo.Repo {
# CHAT_REPLY 	a.mu.Lock()
# CHAT_REPLY 	defer a.mu.Unlock()
# CHAT_REPLY 
# CHAT_REPLY 	return a.repos[name]
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // getRepos returns a slice of all repo.Repo objects.
# CHAT_REPLY func (a *agent) getRepos() []*repo.Repo {
# CHAT_REPLY 	a.mu.Lock()
# CHAT_REPLY 	defer a.mu.Unlock()
# CHAT_REPLY 
# CHAT_REPLY 	repos := make([]*repo.Repo, 0, len(a.repos))
# CHAT_REPLY 	for _, repo := range a.repos {
# CHAT_REPLY 		repos = append(repos, repo)
# CHAT_REPLY 	}
# CHAT_REPLY 	return repos
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // mirrorRepo mirrors a repository.
# CHAT_REPLY func (a *agent) mirrorRepo(repo *repo.Repo) error {
# CHAT_REPLY 	a.log.Printf("mirroring repository %s", repo.Name)
# CHAT_REPLY 
# CHAT_REPLY 	// Mirror the repository.
# CHAT_REPLY 	if err := a.mirror.Mirror(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to mirror repository %s: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Index the repository.
# CHAT_REPLY 	if err := a.indexer.Index(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to index repository %s: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // indexRepo indexes a repository.
# CHAT_REPLY func (a *agent) indexRepo(repo *repo.Repo) error {
# CHAT_REPLY 	a.log.Printf("indexing repository %s", repo.Name)
# CHAT_REPLY 
# CHAT_REPLY 	// Index the repository.
# CHAT_REPLY 	if err := a.indexer.Index(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to index repository %s: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // removeRepo removes a repository.
# CHAT_REPLY func (a *agent) removeRepo(repo *repo.Repo) error {
# CHAT_REPLY 	a.log.Printf("removing repository %s", repo.Name)
# CHAT_REPLY 
# CHAT_REPLY 	// Remove the repository from the index.
# CHAT_REPLY 	if err := a.indexer.Remove(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to remove repository %s from index: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Remove the repository from the mirror.
# CHAT_REPLY 	if err := a.mirror.Remove(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to remove repository %s from mirror: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // updateRepo updates a repository.
# CHAT_REPLY func (a *agent) updateRepo(repo *repo.Repo) error {
# CHAT_REPLY 	a.log.Printf("updating repository %s", repo.Name)
# CHAT_REPLY 
# CHAT_REPLY 	// Update the repository in the mirror.
# CHAT_REPLY 	if err := a.mirror.Update(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to update repository %s in mirror: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Update the repository in the index.
# CHAT_REPLY 	if err := a.indexer.Update(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to update repository %s in index: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // fetchRepo fetches a repository.
# CHAT_REPLY func (a *agent) fetchRepo(repo *repo.Repo) error {
# CHAT_REPLY 	a.log.Printf("fetching repository %s", repo.Name)
# CHAT_REPLY 
# CHAT_REPLY 	// Fetch the repository.
# CHAT_REPLY 	if err := a.git.Fetch(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to fetch repository %s: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // cloneRepo clones a repository.
# CHAT_REPLY func (a *agent) cloneRepo(repo *repo.Repo) error {
# CHAT_REPLY 	a.log.Printf("cloning repository %s", repo.Name)
# CHAT_REPLY 
# CHAT_REPLY 	// Clone the repository.
# CHAT_REPLY 	if err := a.git.Clone(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to clone repository %s: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handleGithubWebhook handles a Github webhook.
# CHAT_REPLY func (a *agent) handleGithubWebhook(w http.ResponseWriter, r *http.Request) {
# CHAT_REPLY 	// Parse the webhook payload.
# CHAT_REPLY 	payload, err := github.ParseWebHook(github.WebHookType(r), r.Body)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		http.Error(w, err.Error(), http.StatusBadRequest)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Handle the webhook event.
# CHAT_REPLY 	switch event := payload.(type) {
# CHAT_REPLY 	case *github.PushEvent:
# CHAT_REPLY 		a.handlePushEvent(event)
# CHAT_REPLY 	case *github.PullRequestEvent:
# CHAT_REPLY 		a.handlePullRequestEvent(event)
# CHAT_REPLY 	case *github.CreateEvent:
# CHAT_REPLY 		a.handleCreateEvent(event)
# CHAT_REPLY 	case *github.DeleteEvent:
# CHAT_REPLY 		a.handleDeleteEvent(event)
# CHAT_REPLY 	default:
# CHAT_REPLY 		http.Error(w, "unsupported webhook event", http.StatusBadRequest)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Write a success response.
# CHAT_REPLY 	w.WriteHeader(http.StatusOK)
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handlePushEvent handles a Github push event.
# CHAT_REPLY func (a *agent) handlePushEvent(event *github.PushEvent) {
# CHAT_REPLY 	// Get the repository.
# CHAT_REPLY 	repo := a.getRepo(event.GetRepo().GetFullName())
# CHAT_REPLY 	if repo == nil {
# CHAT_REPLY 		a.log.Printf("repository %s not found", event.GetRepo().GetFullName())
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Update the repository.
# CHAT_REPLY 	if err := a.updateRepo(repo); err != nil {
# CHAT_REPLY 		a.log.Printf("failed to update repository %s: %v", repo.Name, err)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handlePullRequestEvent handles a Github pull request event.
# CHAT_REPLY func (a *agent) handlePullRequestEvent(event *github.PullRequestEvent) {
# CHAT_REPLY 	// Get the repository.
# CHAT_REPLY 	repo := a.getRepo(event.GetRepo().GetFullName())
# CHAT_REPLY 	if repo == nil {
# CHAT_REPLY 		a.log.Printf("repository %s not found", event.GetRepo().GetFullName())
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Update the repository.
# CHAT_REPLY 	if err := a.updateRepo(repo); err != nil {
# CHAT_REPLY 		a.log.Printf("failed to update repository %s: %v", repo.Name, err)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handleCreateEvent handles a Github create event.
# CHAT_REPLY func (a *agent) handleCreateEvent(event *github.CreateEvent) {
# CHAT_REPLY 	// Get the repository.
# CHAT_REPLY 	repo := a.getRepo(event.GetRepo().GetFullName())
# CHAT_REPLY 	if repo == nil {
# CHAT_REPLY 		a.log.Printf("repository %s not found", event.GetRepo().GetFullName())
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Update the repository.
# CHAT_REPLY 	if err := a.updateRepo(repo); err != nil {
# CHAT_REPLY 		a.log.Printf("failed to update repository %s: %v", repo.Name, err)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handleDeleteEvent handles a Github delete event.
# CHAT_REPLY func (a *agent) handleDeleteEvent(event *github.DeleteEvent) {
# CHAT_REPLY 	// Get the repository.
# CHAT_REPLY 	repo := a.getRepo(event.GetRepo().GetFullName())
# CHAT_REPLY 	if repo == nil {
# CHAT_REPLY 		a.log.Printf("repository %s not found", event.GetRepo().GetFullName())
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Remove the repository.
# CHAT_REPLY 	if err := a.removeRepo(repo); err != nil {
# CHAT_REPLY 		a.log.Printf("failed to remove repository %s: %v", repo.Name, err)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handleGitilesWebhook handles a Gitiles webhook.
# CHAT_REPLY func (a *agent) handleGitilesWebhook(w http.ResponseWriter, r *http.Request) {
# CHAT_REPLY 	// Parse the webhook payload.
# CHAT_REPLY 	payload, err := io.ReadAll(r.Body)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		http.Error(w, err.Error(), http.StatusBadRequest)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Handle the webhook event.
# CHAT_REPLY 	if err := a.handleGitilesPayload(payload); err != nil {
# CHAT_REPLY 		http.Error(w, err.Error(), http.StatusBadRequest)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Write a success response.
# CHAT_REPLY 	w.WriteHeader(http.StatusOK)
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handleGitilesPayload handles a Gitiles webhook payload.
# CHAT_REPLY func (a *agent) handleGitilesPayload(payload []byte) error {
# CHAT_REPLY 	// Parse the webhook payload.
# CHAT_REPLY 	var event struct {
# CHAT_REPLY 		Repo   string `json:"repo"`
# CHAT_REPLY 		Branch string `json:"branch"`
# CHAT_REPLY 	}
# CHAT_REPLY 	if err := json.Unmarshal(payload, &event); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to parse webhook payload: %w", err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Get the repository.
# CHAT_REPLY 	repo := a.getRepo(event.Repo)
# CHAT_REPLY 	if repo == nil {
# CHAT_REPLY 		return fmt.Errorf("repository %s not found", event.Repo)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Update the repository.
# CHAT_REPLY 	if err := a.updateRepo(repo); err != nil {
# CHAT_REPLY 		return fmt.Errorf("failed to update repository %s: %w", repo.Name, err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	return nil
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // handleSearch handles a search request.
# CHAT_REPLY func (a *agent) handleSearch(w http.ResponseWriter, r *http.Request) {
# CHAT_REPLY 	// Parse the search query.
# CHAT_REPLY 	q, err := url.ParseQuery(r.URL.RawQuery)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		http.Error(w, err.Error(), http.StatusBadRequest)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Get the search query.
# CHAT_REPLY 	query := q.Get("q")
# CHAT_REPLY 	if query == "" {
# CHAT_REPLY 		http.Error(w, "missing search query", http.StatusBadRequest)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Get the number of results to return.
# CHAT_REPLY 	num := 10
# CHAT_REPLY 	if n := q.Get("num"); n != "" {
# CHAT_REPLY 		if num, err = strconv.Atoi(n); err != nil {
# CHAT_REPLY 			http.Error(w, err.Error(), http.StatusBadRequest)
# CHAT_REPLY 			return
# CHAT_REPLY 		}
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Get the format of the results.
# CHAT_REPLY 	format := "json"
# CHAT_REPLY 	if f := q.Get("format"); f != "" {
# CHAT_REPLY 		format = f
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Get the repositories to search.
# CHAT_REPLY 	repos := a.getRepos()
# CHAT_REPLY 
# CHAT_REPLY 	// Search the repositories.
# CHAT_REPLY 	results, err := a.search(query, repos, num)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		http.Error(w, err.Error(), http.StatusInternalServerError)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Format the results.
# CHAT_REPLY 	switch format {
# CHAT_REPLY 	case "json":
# CHAT_REPLY 		if err := json.NewEncoder(w).Encode(results); err != nil {
# CHAT_REPLY 			http.Error(w, err.Error(), http.StatusInternalServerError)
# CHAT_REPLY 			return
# CHAT_REPLY 		}
# CHAT_REPLY 	default:
# CHAT_REPLY 		http.Error(w, "unsupported format", http.StatusBadRequest)
# CHAT_REPLY 		return
# CHAT_REPLY 	}
# CHAT_REPLY }
# CHAT_REPLY 
# CHAT_REPLY // search searches the given repositories for the given query.
# CHAT_REPLY func (a *agent) search(query string, repos []*repo.Repo, num int) (*web.ApiSearchResult, error) {
# CHAT_REPLY 	// Parse the search query.
# CHAT_REPLY 	parsedQuery, err := search.ParseQuery(query)
# CHAT_REPLY 	if err != nil {
# CHAT_REPLY 		return nil, fmt.Errorf("failed to parse search query: %w", err)
# CHAT_REPLY 	}
# CHAT_REPLY 
# CHAT_REPLY 	// Create a new search context.
# CHAT_REPLY 	ctx := context.Background()
# CHAT_REPLY 
# CHAT_REPLY 	// Create
# CHAT_REPLY ```

# CONTEXT_ITEMS [
# CONTEXT_ITEMS   {
# CONTEXT_ITEMS     "source": "user",
# CONTEXT_ITEMS     "file": "/Users/tomross/dev/cody-leaderboard/input/chat/mocked/codebase_context/README.md:undefined-undefined",
# CONTEXT_ITEMS     "content": "\n    \"Zoekt, en gij zult spinazie eten\" - Jan Eertink\n\n    (\"seek, and ye shall eat spinach\" - My primary school teacher)\n\nThis is a fast text search engine, intended for use with source\ncode. (Pronunciation: roughly as you would pronounce \"zooked\" in English)\n\n**Note:** This is a [Sourcegraph](https://github.com/sourcegraph/zoekt) fork\nof [github.com/google/zoekt](https://github.com/google/zoekt). It is now the\nmain maintained source of Zoekt.\n\n# INSTRUCTIONS\n\n## Downloading\n\n    go get github.com/sourcegraph/zoekt/\n\n## Indexing\n\n### Directory\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-index\n    $GOPATH/bin/zoekt-index .\n\n### Git repository\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-git-index\n    $GOPATH/bin/zoekt-git-index -branches master,stable-1.4 -prefix origin/ .\n\n### Repo repositories\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-{repo-index,mirror-gitiles}\n    zoekt-mirror-gitiles -dest ~/repos/ https://gfiber.googlesource.com\n    zoekt-repo-index \\\n        -name gfiber \\\n        -base_url https://gfiber.googlesource.com/ \\\n        -manifest_repo ~/repos/gfiber.googlesource.com/manifests.git \\\n        -repo_cache ~/repos \\\n        -manifest_rev_prefix=refs/heads/ --rev_prefix= \\\n        master:default_unrestricted.xml\n\n## Searching\n\n### Web interface\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-webserver\n    $GOPATH/bin/zoekt-webserver -listen :6070\n\n### JSON API\n\nYou can retrieve search results as JSON by sending a GET request to zoekt-webserver.\n\n    curl --get \\\n        --url \"http://localhost:6070/search\" \\\n        --data-urlencode \"q=ngram f:READ\" \\\n        --data-urlencode \"num=50\" \\\n        --data-urlencode \"format=json\"\n\nThe response data is a JSON object. You can refer to [web.ApiSearchResult](https://sourcegraph.com/github.com/sourcegraph/zoekt@6b1df4f8a3d7b34f13ba0cafd8e1a9b3fc728cf0/-/blob/web/api.go?L23:6&subtree=true) to learn about the structure of the object.\n\n### CLI\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt\n    $GOPATH/bin/zoekt 'ngram f:READ'\n\n## Installation\nA more organized installation on a Linux server should use a systemd unit file,\neg.\n\n    [Unit]\n    Description=zoekt webserver\n\n    [Service]\n    ExecStart=/zoekt/bin/zoekt-webserver -index /zoekt/index -listen :443  --ssl_cert /zoekt/etc/cert.pem   --ssl_key /zoekt/etc/key.pem\n    Restart=always\n\n    [Install]\n    WantedBy=default.target\n\n\n# SEARCH SERVICE\n\nZoekt comes with a small service management program:\n\n    go install github.com/sourcegraph/zoekt/cmd/zoekt-indexserver\n\n    cat << EOF > config.json\n    [{\"GithubUser\": \"username\"},\n     {\"GithubOrg\": \"org\"},\n     {\"GitilesURL\": \"https://gerrit.googlesource.com\", \"Name\": \"zoekt\" }\n    ]\n    EOF\n\n    $GOPATH/bin/zoekt-indexserver -mirror_config config.json\n\nThis will mirror all repos under 'github.com/username', 'github.com/org', as\nwell as the 'zoekt' repository. It will index the repositories.\n\nIt takes care of fetching and indexing new data and cleaning up logfiles.\n\nThe webserver can be started from a standard service management framework, such\nas systemd.\n\n\n# SYMBOL SEARCH\n\nIt is recommended to install [Universal\nctags](https://github.com/universal-ctags/ctags) to improve\nranking. See [here](doc/ctags.md) for more information.\n\n\n# ACKNOWLEDGEMENTS\n\nThanks to Han-Wen Nienhuys for creating Zoekt. Thanks to Alexander Neubeck for\ncoming up with this idea, and helping Han-Wen Nienhuys flesh it out.\n\n\n# FORK DETAILS\n\nOriginally this fork contained some changes that do not make sense to upstream\nand or have not yet been upstreamed. However, this is now the defacto source\nfor Zoekt. This section will remain for historical reasons and contains\noutdated information. It can be removed once the dust settles on moving from\ngoogle/zoekt to sourcegraph/zoekt. Differences:\n\n- [zoekt-sourcegraph-indexserver](cmd/zoekt-sourcegraph-indexserver/main.go)\n  is a Sourcegraph specific command which indexes all enabled repositories on\n  Sourcegraph, as well as keeping the indexes up to date.\n- We have exposed the API via\n  [keegancsmith/rpc](https://github.com/keegancsmith/rpc) (a fork of `net/rpc`\n  which supports cancellation).\n- Query primitive `BranchesRepos` to efficiently specify a set of repositories to\n  search.\n- Allow empty shard directories on startup. Needed when starting a fresh\n  instance which hasn't indexed anything yet.\n- We can return symbol/ctag data in results. Additionally we can run symbol regex queries.\n- We search shards in order of repo name and ignore shard ranking.\n- Other minor changes.\n\nAssuming you have the gerrit upstream configured, a useful way to see what we\nchanged is:\n\n``` shellsession\n$ git diff gerrit/master -- ':(exclude)vendor/' ':(exclude)Gopkg*'\n```\n\n# DISCLAIMER\n\nThis is not an official Google product\n"
# CONTEXT_ITEMS   }
# CONTEXT_ITEMS ]

 class: insufficient context
 files:
   - ../mocked/codebase_context/README.md
 
