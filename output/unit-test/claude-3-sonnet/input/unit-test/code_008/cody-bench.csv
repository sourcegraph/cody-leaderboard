LANGUAGEID,WORKSPACE,FIXTURE,STRATEGY,FILEPATH,REVISION,MULTILINE,COMPLETION_INTENT,AUTOCOMPLETE_KIND,RANGE_START_LINE,RANGE_START_CHARACTER,RANGE_END_LINE,RANGE_END_CHARACTER,RESULT_TIMEOUT,RESULT_ERROR,RESULT_EMPTY,RESULT_EXACT,RESULT_TYPECHECKS,RESULT_PARSES,RESULT_TEXT,RESULT_CHAR_COUNT,RESULT_NON_INSERT_PATCH,EDIT_DIFF,CHAT_REPLY,CHAT_QUESTION,FIX_AFTER_DIAGNOSTIC,FIX_BEFORE_DIAGNOSTIC,LLM_JUDGE_SCORE,LLM_JUDGE_REASONING,CONCISENESS_SCORE,HEDGES,PROVIDER_IDENTIFIER,PROVIDER_MODEL,STOP_REASON,CONTEXT_BFG_RETRIEVED_COUNT,CONTEXT_BFG_SUGGESTED_COUNT,CONTEXT_BFG_DURATION_MS,EVENT,TEST_FILE,TEST_EXPECTED_FILE,TEST_GENERATED,TEST_MATCHES_EXPECTED_TEST_FILE,TEST_HAS_TYPESCRIPT_ERRORS,TEST_USED_EXPECTED_TEST_FRAMEWORK,TEST_USED_CORRECT_APPEND_OPERATION,TEST_INPUT_FILE,TEST_LANGUAGE,TEST_NAME,TEST_DIAGNOSTICS
yaml,code_008,claude-3-sonnet,unit-test,test.yaml,0805200539a0bcd3fc369a5b67afaa11fdf4742e,,,,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,src/rockskip/search_test.go,src/rockskip/search_test.go,"import (
	""context""
	""testing""
	""time""

	""github.com/stretchr/testify/require""

	""github.com/sourcegraph/sourcegraph/cmd/symbols/fetcher""
	""github.com/sourcegraph/sourcegraph/internal/api""
	""github.com/sourcegraph/sourcegraph/internal/database/dbtest""
	""github.com/sourcegraph/sourcegraph/internal/gitserver""
	""github.com/sourcegraph/sourcegraph/internal/observation""
	""github.com/sourcegraph/sourcegraph/internal/search""
)

func TestSearch(t *testing.T) {
	t.Parallel()

	ctx := context.Background()
	db := dbtest.NewDB(t)
	git := &mockGit{}
	repoFetcher := newMockRepositoryFetcher(git)
	createParser := func() (ctags.Parser, error) { return mockParser{}, nil }

	service, err := NewService(
		&observation.TestContext,
		db,
		git,
		repoFetcher,
		createParser,
		1, 1, false, 1, 1, 1, false,
	)
	require.NoError(t, err)

	repo := api.RepoName(""github.com/test/repo"")
	commitID := api.CommitID(""deadbeef"")

	// Test case: Repo not found
	_, err = service.Search(ctx, search.SymbolsParameters{
		Repo:     repo,
		CommitID: commitID,
	})
	require.Error(t, err)

	// Test case: Commit not found
	_, err = updateLastAccessedAt(ctx, db, string(repo))
	require.NoError(t, err)
	_, err = service.Search(ctx, search.SymbolsParameters{
		Repo:     repo,
		CommitID: commitID,
	})
	require.Error(t, err)

	// Test case: Successful search
	git.addCommit(repo, commitID)
	symbols, err := service.Search(ctx, search.SymbolsParameters{
		Repo:     repo,
		CommitID: commitID,
	})
	require.NoError(t, err)
	require.NotEmpty(t, symbols)

	// Test case: Timeout
	ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
	defer cancel()
	_, err = service.Search(ctx, search.SymbolsParameters{
		Repo:     repo,
		CommitID: commitID,
		Timeout:  50 * time.Millisecond,
	})
	require.Error(t, err)
}

type mockGit struct {
	commits map[api.RepoName]map[api.CommitID]struct{}
}

func (m *mockGit) addCommit(repo api.RepoName, commit api.CommitID) {
	if m.commits == nil {
		m.commits = make(map[api.RepoName]map[api.CommitID]struct{})
	}
	if _, ok := m.commits[repo]; !ok {
		m.commits[repo] = make(map[api.CommitID]struct{})
	}
	m.commits[repo][commit] = struct{}{}
}

func (m *mockGit) RevList(ctx context.Context, repo string, commit string, onCommit func(commit string) (shouldContinue bool, err error)) (returnError error) {
	repoName := api.RepoName(repo)
	commitID := api.CommitID(commit)
	if _, ok := m.commits[repoName]; !ok {
		return nil
	}
	if _, ok := m.commits[repoName][commitID]; !ok {
		return nil
	}
	return onCommit(string(commitID))
}

type mockRepositoryFetcher struct {
	git *mockGit
}

func newMockRepositoryFetcher(git *mockGit) fetcher.RepositoryFetcher {
	return &mockRepositoryFetcher{git: git}
}

func (f *mockRepositoryFetcher) FetchRepositoryArchive(ctx context.Context, repo api.RepoName, commit api.CommitID, paths []string) <-chan fetcher.ParseRequestOrError {
	ch := make(chan fetcher.ParseRequestOrError)
	go func() {
		defer close(ch)
		if _, ok := f.git.commits[repo]; !ok {
			return
		}
		if _, ok := f.git.commits[repo][commit]; !ok {
			return
		}
		for _, p := range paths {
			ch <- fetcher.ParseRequestOrError{
				ParseRequest: fetcher.ParseRequest{
					Path: p,
					Data: []byte(""mock data""),
				},
			}
		}
	}()
	return ch
}
",true,false,true,,src/rockskip/search.go,go,Rockskip search,
