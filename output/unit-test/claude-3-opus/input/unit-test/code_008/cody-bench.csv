LANGUAGEID,WORKSPACE,FIXTURE,STRATEGY,FILEPATH,REVISION,MULTILINE,COMPLETION_INTENT,AUTOCOMPLETE_KIND,RANGE_START_LINE,RANGE_START_CHARACTER,RANGE_END_LINE,RANGE_END_CHARACTER,RESULT_TIMEOUT,RESULT_ERROR,RESULT_EMPTY,RESULT_EXACT,RESULT_TYPECHECKS,RESULT_PARSES,RESULT_TEXT,RESULT_CHAR_COUNT,RESULT_NON_INSERT_PATCH,EDIT_DIFF,CHAT_REPLY,CHAT_QUESTION,FIX_AFTER_DIAGNOSTIC,FIX_BEFORE_DIAGNOSTIC,LLM_JUDGE_SCORE,LLM_JUDGE_REASONING,CONCISENESS_SCORE,HEDGES,PROVIDER_IDENTIFIER,PROVIDER_MODEL,STOP_REASON,CONTEXT_BFG_RETRIEVED_COUNT,CONTEXT_BFG_SUGGESTED_COUNT,CONTEXT_BFG_DURATION_MS,EVENT,TEST_FILE,TEST_EXPECTED_FILE,TEST_GENERATED,TEST_MATCHES_EXPECTED_TEST_FILE,TEST_HAS_TYPESCRIPT_ERRORS,TEST_USED_EXPECTED_TEST_FRAMEWORK,TEST_USED_CORRECT_APPEND_OPERATION,TEST_INPUT_FILE,TEST_LANGUAGE,TEST_NAME,TEST_DIAGNOSTICS
yaml,code_008,claude-3-opus,unit-test,test.yaml,ef92e73fc6fdce716391f62b6097405545dd8a1f,,,,0,0,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,src/rockskip/search_test.go,src/rockskip/search_test.go,"func TestSearch_Timeout(t *testing.T) {
	repo, repoDir := gitserver.MakeGitRepositoryAndReturnDir(t)
	gitRun(t, repoDir, ""config"", ""user.email"", ""test@sourcegraph.com"")

	git, err := newSubprocessGit(t, repoDir)
	require.NoError(t, err)
	defer git.Close()

	db, s := mockService(t, git)
	defer db.Close()

	state := map[string][]string{}
	gitAdd(t, repoDir, state, ""a.txt"", ""sym1a/n"")

	out, err := gitserver.CreateGitCommand(repoDir, ""git"", ""rev-parse"", ""HEAD"").CombinedOutput()
	require.NoError(t, err, string(out))
	commit := string(bytes.TrimSpace(out))

	ctx := context.Background()
	params := search.SymbolsParameters{
		Repo:     repo,
		CommitID: api.CommitID(commit),
		Query:    ""sym"",
		Timeout:  1 * time.Millisecond,
	}

	_, err = s.Search(ctx, params)
	require.Error(t, err)
	require.Contains(t, err.Error(), ""Processing symbols is taking a while"")
}

func TestSearch_ConcurrentDeletion(t *testing.T) {
	repo, repoDir := gitserver.MakeGitRepositoryAndReturnDir(t)
	gitRun(t, repoDir, ""config"", ""user.email"", ""test@sourcegraph.com"")

	git, err := newSubprocessGit(t, repoDir)
	require.NoError(t, err)
	defer git.Close()

	db, s := mockService(t, git)
	defer db.Close()

	state := map[string][]string{}
	gitAdd(t, repoDir, state, ""a.txt"", ""sym1a/n"")

	out, err := gitserver.CreateGitCommand(repoDir, ""git"", ""rev-parse"", ""HEAD"").CombinedOutput()
	require.NoError(t, err, string(out))
	commit := string(bytes.TrimSpace(out))

	ctx := context.Background()
	params := search.SymbolsParameters{
		Repo:     repo,
		CommitID: api.CommitID(commit),
		Query:    ""sym"",
	}

	// Simulate a concurrent deletion by acquiring a write lock
	_, err = db.ExecContext(ctx, ""INSERT INTO rockskip_locks (repo, write_lock) VALUES ($1, true) ON CONFLICT (repo) DO UPDATE SET write_lock = true"", repo)
	require.NoError(t, err)

	_, err = s.Search(ctx, params)
	require.Error(t, err)
	require.Contains(t, err.Error(), ""deletion in progress"")
}

func TestSearch_IndexingInProgress(t *testing.T) {
	repo, repoDir := gitserver.MakeGitRepositoryAndReturnDir(t)
	gitRun(t, repoDir, ""config"", ""user.email"", ""test@sourcegraph.com"")

	git, err := newSubprocessGit(t, repoDir)
	require.NoError(t, err)
	defer git.Close()

	db, s := mockService(t, git)
	defer db.Close()

	state := map[string][]string{}
	gitAdd(t, repoDir, state, ""a.txt"", ""sym1a/n"")

	out, err := gitserver.CreateGitCommand(repoDir, ""git"", ""rev-parse"", ""HEAD"").CombinedOutput()
	require.NoError(t, err, string(out))
	commit := string(bytes.TrimSpace(out))

	ctx := context.Background()
	params := search.SymbolsParameters{
		Repo:     repo,
		CommitID: api.CommitID(commit),
		Query:    ""sym"",
	}

	// Simulate indexing in progress
	s.status.threadIdToThreadStatus[""test""] = &ThreadStatus{
		Name:      fmt.Sprintf(""indexing %s"", repo),
		StartTime: time.Now().Add(-5 * time.Minute),
	}

	_, err = s.Search(ctx, params)
	require.Error(t, err)
	require.Contains(t, err.Error(), ""Still processing symbols"")
}

func TestSearch_LastIndexedCommit(t *testing.T) {
	repo, repoDir := gitserver.MakeGitRepositoryAndReturnDir(t)
	gitRun(t, repoDir, ""config"", ""user.email"", ""test@sourcegraph.com"")

	git, err := newSubprocessGit(t, repoDir)
	require.NoError(t, err)
	defer git.Close()

	db, s := mockService(t, git)
	defer db.Close()

	state := map[string][]string{}
	gitAdd(t, repoDir, state, ""a.txt"", ""sym1a/n"")
	gitAdd(t, repoDir, state, ""b.txt"", ""sym1b/n"")

	out, err := gitserver.CreateGitCommand(repoDir, ""git"", ""rev-parse"", ""HEAD"").CombinedOutput()
	require.NoError(t, err, string(out))
	latestCommit := string(bytes.TrimSpace(out))

	out, err = gitserver.CreateGitCommand(repoDir, ""git"", ""rev-parse"", ""HEAD~1"").CombinedOutput()
	require.NoError(t, err, string(out))
	previousCommit := string(bytes.TrimSpace(out))

	ctx := context.Background()
	s.searchLastIndexedCommit = true

	// Index the previous commit
	_, err = updateLastAccessedAt(ctx, db, string(repo))
	require.NoError(t, err)
	_, err = db.ExecContext(ctx, ""INSERT INTO rockskip_commits (repo_id, hash) VALUES ((SELECT id FROM rockskip_repos WHERE name = $1), $2)"", repo, previousCommit)
	require.NoError(t, err)

	params := search.SymbolsParameters{
		Repo:     repo,
		CommitID: api.CommitID(latestCommit),
		Query:    ""sym"",
	}

	symbols, err := s.Search(ctx, params)
	require.NoError(t, err)
	require.Len(t, symbols, 1)
	require.Equal(t, ""sym1a"", symbols[0].Name)
}

func TestSearch_EmptyResult(t *testing.T) {
	repo, repoDir := gitserver.MakeGitRepositoryAndReturnDir(t)
	gitRun(t, repoDir, ""config"", ""user.email"", ""test@sourcegraph.com"")

	git, err := newSubprocessGit(t, repoDir)
	require.NoError(t, err)
	defer git.Close()

	db, s := mockService(t, git)
	defer db.Close()

	state := map[string][]string{}
	gitAdd(t, repoDir, state, ""a.txt"", ""content without symbols"")

	out, err := gitserver.CreateGitCommand(repoDir, ""git"", ""rev-parse"", ""HEAD"").CombinedOutput()
	require.NoError(t, err, string(out))
	commit := string(bytes.TrimSpace(out))

	ctx := context.Background()
	params := search.SymbolsParameters{
		Repo:     repo,
		CommitID: api.CommitID(commit),
		Query:    ""nonexistent"",
	}

	symbols, err := s.Search(ctx, params)
	require.NoError(t, err)
	require.Empty(t, symbols)
}
",true,false,true,true,src/rockskip/search.go,go,Rockskip search,
